(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to2, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // vendor/topbar.js
  var require_topbar = __commonJS({
    "vendor/topbar.js"(exports, module) {
      (function(window2, document2) {
        "use strict";
        (function() {
          var lastTime = 0;
          var vendors = ["ms", "moz", "webkit", "o"];
          for (var x = 0; x < vendors.length && !window2.requestAnimationFrame; ++x) {
            window2.requestAnimationFrame = window2[vendors[x] + "RequestAnimationFrame"];
            window2.cancelAnimationFrame = window2[vendors[x] + "CancelAnimationFrame"] || window2[vendors[x] + "CancelRequestAnimationFrame"];
          }
          if (!window2.requestAnimationFrame)
            window2.requestAnimationFrame = function(callback2, element) {
              var currTime = (/* @__PURE__ */ new Date()).getTime();
              var timeToCall = Math.max(0, 16 - (currTime - lastTime));
              var id = window2.setTimeout(function() {
                callback2(currTime + timeToCall);
              }, timeToCall);
              lastTime = currTime + timeToCall;
              return id;
            };
          if (!window2.cancelAnimationFrame)
            window2.cancelAnimationFrame = function(id) {
              clearTimeout(id);
            };
        })();
        var canvas, currentProgress, showing, progressTimerId = null, fadeTimerId = null, delayTimerId = null, addEvent = function(elem, type, handler) {
          if (elem.addEventListener)
            elem.addEventListener(type, handler, false);
          else if (elem.attachEvent)
            elem.attachEvent("on" + type, handler);
          else
            elem["on" + type] = handler;
        }, options = {
          autoRun: true,
          barThickness: 3,
          barColors: {
            0: "rgba(26,  188, 156, .9)",
            ".25": "rgba(52,  152, 219, .9)",
            ".50": "rgba(241, 196, 15,  .9)",
            ".75": "rgba(230, 126, 34,  .9)",
            "1.0": "rgba(211, 84,  0,   .9)"
          },
          shadowBlur: 10,
          shadowColor: "rgba(0,   0,   0,   .6)",
          className: null
        }, repaint2 = function() {
          canvas.width = window2.innerWidth;
          canvas.height = options.barThickness * 5;
          var ctx = canvas.getContext("2d");
          ctx.shadowBlur = options.shadowBlur;
          ctx.shadowColor = options.shadowColor;
          var lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          for (var stop in options.barColors)
            lineGradient.addColorStop(stop, options.barColors[stop]);
          ctx.lineWidth = options.barThickness;
          ctx.beginPath();
          ctx.moveTo(0, options.barThickness / 2);
          ctx.lineTo(
            Math.ceil(currentProgress * canvas.width),
            options.barThickness / 2
          );
          ctx.strokeStyle = lineGradient;
          ctx.stroke();
        }, createCanvas = function() {
          canvas = document2.createElement("canvas");
          var style = canvas.style;
          style.position = "fixed";
          style.top = style.left = style.right = style.margin = style.padding = 0;
          style.zIndex = 100001;
          style.display = "none";
          if (options.className)
            canvas.classList.add(options.className);
          document2.body.appendChild(canvas);
          addEvent(window2, "resize", repaint2);
        }, topbar2 = {
          config: function(opts) {
            for (var key in opts)
              if (options.hasOwnProperty(key))
                options[key] = opts[key];
          },
          show: function(delay) {
            if (showing)
              return;
            if (delay) {
              if (delayTimerId)
                return;
              delayTimerId = setTimeout(() => topbar2.show(), delay);
            } else {
              showing = true;
              if (fadeTimerId !== null)
                window2.cancelAnimationFrame(fadeTimerId);
              if (!canvas)
                createCanvas();
              canvas.style.opacity = 1;
              canvas.style.display = "block";
              topbar2.progress(0);
              if (options.autoRun) {
                (function loop() {
                  progressTimerId = window2.requestAnimationFrame(loop);
                  topbar2.progress(
                    "+" + 0.05 * Math.pow(1 - Math.sqrt(currentProgress), 2)
                  );
                })();
              }
            }
          },
          progress: function(to2) {
            if (typeof to2 === "undefined")
              return currentProgress;
            if (typeof to2 === "string") {
              to2 = (to2.indexOf("+") >= 0 || to2.indexOf("-") >= 0 ? currentProgress : 0) + parseFloat(to2);
            }
            currentProgress = to2 > 1 ? 1 : to2;
            repaint2();
            return currentProgress;
          },
          hide: function() {
            clearTimeout(delayTimerId);
            delayTimerId = null;
            if (!showing)
              return;
            showing = false;
            if (progressTimerId != null) {
              window2.cancelAnimationFrame(progressTimerId);
              progressTimerId = null;
            }
            (function loop() {
              if (topbar2.progress("+.1") >= 1) {
                canvas.style.opacity -= 0.05;
                if (canvas.style.opacity <= 0.05) {
                  canvas.style.display = "none";
                  fadeTimerId = null;
                  return;
                }
              }
              fadeTimerId = window2.requestAnimationFrame(loop);
            })();
          }
        };
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = topbar2;
        } else if (typeof define === "function" && define.amd) {
          define(function() {
            return topbar2;
          });
        } else {
          this.topbar = topbar2;
        }
      }).call(exports, window, document);
    }
  });

  // ../deps/phoenix_html/priv/static/phoenix_html.js
  (function() {
    var PolyfillEvent = eventConstructor();
    function eventConstructor() {
      if (typeof window.CustomEvent === "function")
        return window.CustomEvent;
      function CustomEvent2(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: void 0 };
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      }
      CustomEvent2.prototype = window.Event.prototype;
      return CustomEvent2;
    }
    function buildHiddenInput(name, value) {
      var input = document.createElement("input");
      input.type = "hidden";
      input.name = name;
      input.value = value;
      return input;
    }
    function handleClick(element, targetModifierKey) {
      var to2 = element.getAttribute("data-to"), method = buildHiddenInput("_method", element.getAttribute("data-method")), csrf = buildHiddenInput("_csrf_token", element.getAttribute("data-csrf")), form = document.createElement("form"), submit = document.createElement("input"), target = element.getAttribute("target");
      form.method = element.getAttribute("data-method") === "get" ? "get" : "post";
      form.action = to2;
      form.style.display = "none";
      if (target)
        form.target = target;
      else if (targetModifierKey)
        form.target = "_blank";
      form.appendChild(csrf);
      form.appendChild(method);
      document.body.appendChild(form);
      submit.type = "submit";
      form.appendChild(submit);
      submit.click();
    }
    window.addEventListener("click", function(e) {
      var element = e.target;
      if (e.defaultPrevented)
        return;
      while (element && element.getAttribute) {
        var phoenixLinkEvent = new PolyfillEvent("phoenix.link.click", {
          "bubbles": true,
          "cancelable": true
        });
        if (!element.dispatchEvent(phoenixLinkEvent)) {
          e.preventDefault();
          e.stopImmediatePropagation();
          return false;
        }
        if (element.getAttribute("data-method") && element.getAttribute("data-to")) {
          handleClick(element, e.metaKey || e.shiftKey);
          e.preventDefault();
          return false;
        } else {
          element = element.parentNode;
        }
      }
    }, false);
    window.addEventListener("phoenix.link.click", function(e) {
      var message = e.target.getAttribute("data-confirm");
      if (message && !window.confirm(message)) {
        e.preventDefault();
      }
    }, false);
  })();

  // ../deps/phoenix/priv/static/phoenix.mjs
  var closure = (value) => {
    if (typeof value === "function") {
      return value;
    } else {
      let closure22 = function() {
        return value;
      };
      return closure22;
    }
  };
  var globalSelf = typeof self !== "undefined" ? self : null;
  var phxWindow = typeof window !== "undefined" ? window : null;
  var global = globalSelf || phxWindow || global;
  var DEFAULT_VSN = "2.0.0";
  var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
  var DEFAULT_TIMEOUT = 1e4;
  var WS_CLOSE_NORMAL = 1e3;
  var CHANNEL_STATES = {
    closed: "closed",
    errored: "errored",
    joined: "joined",
    joining: "joining",
    leaving: "leaving"
  };
  var CHANNEL_EVENTS = {
    close: "phx_close",
    error: "phx_error",
    join: "phx_join",
    reply: "phx_reply",
    leave: "phx_leave"
  };
  var TRANSPORTS = {
    longpoll: "longpoll",
    websocket: "websocket"
  };
  var XHR_STATES = {
    complete: 4
  };
  var Push = class {
    constructor(channel, event, payload, timeout) {
      this.channel = channel;
      this.event = event;
      this.payload = payload || function() {
        return {};
      };
      this.receivedResp = null;
      this.timeout = timeout;
      this.timeoutTimer = null;
      this.recHooks = [];
      this.sent = false;
    }
    /**
     *
     * @param {number} timeout
     */
    resend(timeout) {
      this.timeout = timeout;
      this.reset();
      this.send();
    }
    /**
     *
     */
    send() {
      if (this.hasReceived("timeout")) {
        return;
      }
      this.startTimeout();
      this.sent = true;
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload(),
        ref: this.ref,
        join_ref: this.channel.joinRef()
      });
    }
    /**
     *
     * @param {*} status
     * @param {*} callback
     */
    receive(status, callback2) {
      if (this.hasReceived(status)) {
        callback2(this.receivedResp.response);
      }
      this.recHooks.push({ status, callback: callback2 });
      return this;
    }
    /**
     * @private
     */
    reset() {
      this.cancelRefEvent();
      this.ref = null;
      this.refEvent = null;
      this.receivedResp = null;
      this.sent = false;
    }
    /**
     * @private
     */
    matchReceive({ status, response, _ref }) {
      this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
    }
    /**
     * @private
     */
    cancelRefEvent() {
      if (!this.refEvent) {
        return;
      }
      this.channel.off(this.refEvent);
    }
    /**
     * @private
     */
    cancelTimeout() {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
    /**
     * @private
     */
    startTimeout() {
      if (this.timeoutTimer) {
        this.cancelTimeout();
      }
      this.ref = this.channel.socket.makeRef();
      this.refEvent = this.channel.replyEventName(this.ref);
      this.channel.on(this.refEvent, (payload) => {
        this.cancelRefEvent();
        this.cancelTimeout();
        this.receivedResp = payload;
        this.matchReceive(payload);
      });
      this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout);
    }
    /**
     * @private
     */
    hasReceived(status) {
      return this.receivedResp && this.receivedResp.status === status;
    }
    /**
     * @private
     */
    trigger(status, response) {
      this.channel.trigger(this.refEvent, { status, response });
    }
  };
  var Timer = class {
    constructor(callback2, timerCalc) {
      this.callback = callback2;
      this.timerCalc = timerCalc;
      this.timer = null;
      this.tries = 0;
    }
    reset() {
      this.tries = 0;
      clearTimeout(this.timer);
    }
    /**
     * Cancels any previous scheduleTimeout and schedules callback
     */
    scheduleTimeout() {
      clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.tries = this.tries + 1;
        this.callback();
      }, this.timerCalc(this.tries + 1));
    }
  };
  var Channel = class {
    constructor(topic, params, socket) {
      this.state = CHANNEL_STATES.closed;
      this.topic = topic;
      this.params = closure(params || {});
      this.socket = socket;
      this.bindings = [];
      this.bindingRef = 0;
      this.timeout = this.socket.timeout;
      this.joinedOnce = false;
      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
      this.pushBuffer = [];
      this.stateChangeRefs = [];
      this.rejoinTimer = new Timer(() => {
        if (this.socket.isConnected()) {
          this.rejoin();
        }
      }, this.socket.rejoinAfterMs);
      this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
      this.stateChangeRefs.push(
        this.socket.onOpen(() => {
          this.rejoinTimer.reset();
          if (this.isErrored()) {
            this.rejoin();
          }
        })
      );
      this.joinPush.receive("ok", () => {
        this.state = CHANNEL_STATES.joined;
        this.rejoinTimer.reset();
        this.pushBuffer.forEach((pushEvent) => pushEvent.send());
        this.pushBuffer = [];
      });
      this.joinPush.receive("error", () => {
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.onClose(() => {
        this.rejoinTimer.reset();
        if (this.socket.hasLogger())
          this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
        this.state = CHANNEL_STATES.closed;
        this.socket.remove(this);
      });
      this.onError((reason) => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `error ${this.topic}`, reason);
        if (this.isJoining()) {
          this.joinPush.reset();
        }
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.joinPush.receive("timeout", () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
        leavePush.send();
        this.state = CHANNEL_STATES.errored;
        this.joinPush.reset();
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
        this.trigger(this.replyEventName(ref), payload);
      });
    }
    /**
     * Join the channel
     * @param {integer} timeout
     * @returns {Push}
     */
    join(timeout = this.timeout) {
      if (this.joinedOnce) {
        throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
      } else {
        this.timeout = timeout;
        this.joinedOnce = true;
        this.rejoin();
        return this.joinPush;
      }
    }
    /**
     * Hook into channel close
     * @param {Function} callback
     */
    onClose(callback2) {
      this.on(CHANNEL_EVENTS.close, callback2);
    }
    /**
     * Hook into channel errors
     * @param {Function} callback
     */
    onError(callback2) {
      return this.on(CHANNEL_EVENTS.error, (reason) => callback2(reason));
    }
    /**
     * Subscribes on channel events
     *
     * Subscription returns a ref counter, which can be used later to
     * unsubscribe the exact event listener
     *
     * @example
     * const ref1 = channel.on("event", do_stuff)
     * const ref2 = channel.on("event", do_other_stuff)
     * channel.off("event", ref1)
     * // Since unsubscription, do_stuff won't fire,
     * // while do_other_stuff will keep firing on the "event"
     *
     * @param {string} event
     * @param {Function} callback
     * @returns {integer} ref
     */
    on(event, callback2) {
      let ref = this.bindingRef++;
      this.bindings.push({ event, ref, callback: callback2 });
      return ref;
    }
    /**
     * Unsubscribes off of channel events
     *
     * Use the ref returned from a channel.on() to unsubscribe one
     * handler, or pass nothing for the ref to unsubscribe all
     * handlers for the given event.
     *
     * @example
     * // Unsubscribe the do_stuff handler
     * const ref1 = channel.on("event", do_stuff)
     * channel.off("event", ref1)
     *
     * // Unsubscribe all handlers from event
     * channel.off("event")
     *
     * @param {string} event
     * @param {integer} ref
     */
    off(event, ref) {
      this.bindings = this.bindings.filter((bind) => {
        return !(bind.event === event && (typeof ref === "undefined" || ref === bind.ref));
      });
    }
    /**
     * @private
     */
    canPush() {
      return this.socket.isConnected() && this.isJoined();
    }
    /**
     * Sends a message `event` to phoenix with the payload `payload`.
     * Phoenix receives this in the `handle_in(event, payload, socket)`
     * function. if phoenix replies or it times out (default 10000ms),
     * then optionally the reply can be received.
     *
     * @example
     * channel.push("event")
     *   .receive("ok", payload => console.log("phoenix replied:", payload))
     *   .receive("error", err => console.log("phoenix errored", err))
     *   .receive("timeout", () => console.log("timed out pushing"))
     * @param {string} event
     * @param {Object} payload
     * @param {number} [timeout]
     * @returns {Push}
     */
    push(event, payload, timeout = this.timeout) {
      payload = payload || {};
      if (!this.joinedOnce) {
        throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
      }
      let pushEvent = new Push(this, event, function() {
        return payload;
      }, timeout);
      if (this.canPush()) {
        pushEvent.send();
      } else {
        pushEvent.startTimeout();
        this.pushBuffer.push(pushEvent);
      }
      return pushEvent;
    }
    /** Leaves the channel
     *
     * Unsubscribes from server events, and
     * instructs channel to terminate on server
     *
     * Triggers onClose() hooks
     *
     * To receive leave acknowledgements, use the `receive`
     * hook to bind to the server ack, ie:
     *
     * @example
     * channel.leave().receive("ok", () => alert("left!") )
     *
     * @param {integer} timeout
     * @returns {Push}
     */
    leave(timeout = this.timeout) {
      this.rejoinTimer.reset();
      this.joinPush.cancelTimeout();
      this.state = CHANNEL_STATES.leaving;
      let onClose = () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `leave ${this.topic}`);
        this.trigger(CHANNEL_EVENTS.close, "leave");
      };
      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
      leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
      leavePush.send();
      if (!this.canPush()) {
        leavePush.trigger("ok", {});
      }
      return leavePush;
    }
    /**
     * Overridable message hook
     *
     * Receives all events for specialized message handling
     * before dispatching to the channel callbacks.
     *
     * Must return the payload, modified or unmodified
     * @param {string} event
     * @param {Object} payload
     * @param {integer} ref
     * @returns {Object}
     */
    onMessage(_event, payload, _ref) {
      return payload;
    }
    /**
     * @private
     */
    isMember(topic, event, payload, joinRef) {
      if (this.topic !== topic) {
        return false;
      }
      if (joinRef && joinRef !== this.joinRef()) {
        if (this.socket.hasLogger())
          this.socket.log("channel", "dropping outdated message", { topic, event, payload, joinRef });
        return false;
      } else {
        return true;
      }
    }
    /**
     * @private
     */
    joinRef() {
      return this.joinPush.ref;
    }
    /**
     * @private
     */
    rejoin(timeout = this.timeout) {
      if (this.isLeaving()) {
        return;
      }
      this.socket.leaveOpenTopic(this.topic);
      this.state = CHANNEL_STATES.joining;
      this.joinPush.resend(timeout);
    }
    /**
     * @private
     */
    trigger(event, payload, ref, joinRef) {
      let handledPayload = this.onMessage(event, payload, ref, joinRef);
      if (payload && !handledPayload) {
        throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
      }
      let eventBindings = this.bindings.filter((bind) => bind.event === event);
      for (let i = 0; i < eventBindings.length; i++) {
        let bind = eventBindings[i];
        bind.callback(handledPayload, ref, joinRef || this.joinRef());
      }
    }
    /**
     * @private
     */
    replyEventName(ref) {
      return `chan_reply_${ref}`;
    }
    /**
     * @private
     */
    isClosed() {
      return this.state === CHANNEL_STATES.closed;
    }
    /**
     * @private
     */
    isErrored() {
      return this.state === CHANNEL_STATES.errored;
    }
    /**
     * @private
     */
    isJoined() {
      return this.state === CHANNEL_STATES.joined;
    }
    /**
     * @private
     */
    isJoining() {
      return this.state === CHANNEL_STATES.joining;
    }
    /**
     * @private
     */
    isLeaving() {
      return this.state === CHANNEL_STATES.leaving;
    }
  };
  var Ajax = class {
    static request(method, endPoint, accept, body, timeout, ontimeout, callback2) {
      if (global.XDomainRequest) {
        let req = new global.XDomainRequest();
        return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback2);
      } else {
        let req = new global.XMLHttpRequest();
        return this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback2);
      }
    }
    static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback2) {
      req.timeout = timeout;
      req.open(method, endPoint);
      req.onload = () => {
        let response = this.parseJSON(req.responseText);
        callback2 && callback2(response);
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.onprogress = () => {
      };
      req.send(body);
      return req;
    }
    static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback2) {
      req.open(method, endPoint, true);
      req.timeout = timeout;
      req.setRequestHeader("Content-Type", accept);
      req.onerror = () => callback2 && callback2(null);
      req.onreadystatechange = () => {
        if (req.readyState === XHR_STATES.complete && callback2) {
          let response = this.parseJSON(req.responseText);
          callback2(response);
        }
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.send(body);
      return req;
    }
    static parseJSON(resp) {
      if (!resp || resp === "") {
        return null;
      }
      try {
        return JSON.parse(resp);
      } catch (e) {
        console && console.log("failed to parse JSON response", resp);
        return null;
      }
    }
    static serialize(obj, parentKey) {
      let queryStr = [];
      for (var key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
          continue;
        }
        let paramKey = parentKey ? `${parentKey}[${key}]` : key;
        let paramVal = obj[key];
        if (typeof paramVal === "object") {
          queryStr.push(this.serialize(paramVal, paramKey));
        } else {
          queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
        }
      }
      return queryStr.join("&");
    }
    static appendParams(url, params) {
      if (Object.keys(params).length === 0) {
        return url;
      }
      let prefix = url.match(/\?/) ? "&" : "?";
      return `${url}${prefix}${this.serialize(params)}`;
    }
  };
  var arrayBufferToBase64 = (buffer) => {
    let binary = "";
    let bytes = new Uint8Array(buffer);
    let len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  };
  var LongPoll = class {
    constructor(endPoint) {
      this.endPoint = null;
      this.token = null;
      this.skipHeartbeat = true;
      this.reqs = /* @__PURE__ */ new Set();
      this.awaitingBatchAck = false;
      this.currentBatch = null;
      this.currentBatchTimer = null;
      this.batchBuffer = [];
      this.onopen = function() {
      };
      this.onerror = function() {
      };
      this.onmessage = function() {
      };
      this.onclose = function() {
      };
      this.pollEndpoint = this.normalizeEndpoint(endPoint);
      this.readyState = SOCKET_STATES.connecting;
      setTimeout(() => this.poll(), 0);
    }
    normalizeEndpoint(endPoint) {
      return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
    }
    endpointURL() {
      return Ajax.appendParams(this.pollEndpoint, { token: this.token });
    }
    closeAndRetry(code, reason, wasClean) {
      this.close(code, reason, wasClean);
      this.readyState = SOCKET_STATES.connecting;
    }
    ontimeout() {
      this.onerror("timeout");
      this.closeAndRetry(1005, "timeout", false);
    }
    isActive() {
      return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;
    }
    poll() {
      this.ajax("GET", "application/json", null, () => this.ontimeout(), (resp) => {
        if (resp) {
          var { status, token, messages } = resp;
          this.token = token;
        } else {
          status = 0;
        }
        switch (status) {
          case 200:
            messages.forEach((msg) => {
              setTimeout(() => this.onmessage({ data: msg }), 0);
            });
            this.poll();
            break;
          case 204:
            this.poll();
            break;
          case 410:
            this.readyState = SOCKET_STATES.open;
            this.onopen({});
            this.poll();
            break;
          case 403:
            this.onerror(403);
            this.close(1008, "forbidden", false);
            break;
          case 0:
          case 500:
            this.onerror(500);
            this.closeAndRetry(1011, "internal server error", 500);
            break;
          default:
            throw new Error(`unhandled poll status ${status}`);
        }
      });
    }
    // we collect all pushes within the current event loop by
    // setTimeout 0, which optimizes back-to-back procedural
    // pushes against an empty buffer
    send(body) {
      if (typeof body !== "string") {
        body = arrayBufferToBase64(body);
      }
      if (this.currentBatch) {
        this.currentBatch.push(body);
      } else if (this.awaitingBatchAck) {
        this.batchBuffer.push(body);
      } else {
        this.currentBatch = [body];
        this.currentBatchTimer = setTimeout(() => {
          this.batchSend(this.currentBatch);
          this.currentBatch = null;
        }, 0);
      }
    }
    batchSend(messages) {
      this.awaitingBatchAck = true;
      this.ajax("POST", "application/x-ndjson", messages.join("\n"), () => this.onerror("timeout"), (resp) => {
        this.awaitingBatchAck = false;
        if (!resp || resp.status !== 200) {
          this.onerror(resp && resp.status);
          this.closeAndRetry(1011, "internal server error", false);
        } else if (this.batchBuffer.length > 0) {
          this.batchSend(this.batchBuffer);
          this.batchBuffer = [];
        }
      });
    }
    close(code, reason, wasClean) {
      for (let req of this.reqs) {
        req.abort();
      }
      this.readyState = SOCKET_STATES.closed;
      let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });
      this.batchBuffer = [];
      clearTimeout(this.currentBatchTimer);
      this.currentBatchTimer = null;
      if (typeof CloseEvent !== "undefined") {
        this.onclose(new CloseEvent("close", opts));
      } else {
        this.onclose(opts);
      }
    }
    ajax(method, contentType, body, onCallerTimeout, callback2) {
      let req;
      let ontimeout = () => {
        this.reqs.delete(req);
        onCallerTimeout();
      };
      req = Ajax.request(method, this.endpointURL(), contentType, body, this.timeout, ontimeout, (resp) => {
        this.reqs.delete(req);
        if (this.isActive()) {
          callback2(resp);
        }
      });
      this.reqs.add(req);
    }
  };
  var serializer_default = {
    HEADER_LENGTH: 1,
    META_LENGTH: 4,
    KINDS: { push: 0, reply: 1, broadcast: 2 },
    encode(msg, callback2) {
      if (msg.payload.constructor === ArrayBuffer) {
        return callback2(this.binaryEncode(msg));
      } else {
        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
        return callback2(JSON.stringify(payload));
      }
    },
    decode(rawPayload, callback2) {
      if (rawPayload.constructor === ArrayBuffer) {
        return callback2(this.binaryDecode(rawPayload));
      } else {
        let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);
        return callback2({ join_ref, ref, topic, event, payload });
      }
    },
    // private
    binaryEncode(message) {
      let { join_ref, ref, event, topic, payload } = message;
      let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;
      let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
      let view = new DataView(header);
      let offset2 = 0;
      view.setUint8(offset2++, this.KINDS.push);
      view.setUint8(offset2++, join_ref.length);
      view.setUint8(offset2++, ref.length);
      view.setUint8(offset2++, topic.length);
      view.setUint8(offset2++, event.length);
      Array.from(join_ref, (char) => view.setUint8(offset2++, char.charCodeAt(0)));
      Array.from(ref, (char) => view.setUint8(offset2++, char.charCodeAt(0)));
      Array.from(topic, (char) => view.setUint8(offset2++, char.charCodeAt(0)));
      Array.from(event, (char) => view.setUint8(offset2++, char.charCodeAt(0)));
      var combined = new Uint8Array(header.byteLength + payload.byteLength);
      combined.set(new Uint8Array(header), 0);
      combined.set(new Uint8Array(payload), header.byteLength);
      return combined.buffer;
    },
    binaryDecode(buffer) {
      let view = new DataView(buffer);
      let kind = view.getUint8(0);
      let decoder = new TextDecoder();
      switch (kind) {
        case this.KINDS.push:
          return this.decodePush(buffer, view, decoder);
        case this.KINDS.reply:
          return this.decodeReply(buffer, view, decoder);
        case this.KINDS.broadcast:
          return this.decodeBroadcast(buffer, view, decoder);
      }
    },
    decodePush(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let topicSize = view.getUint8(2);
      let eventSize = view.getUint8(3);
      let offset2 = this.HEADER_LENGTH + this.META_LENGTH - 1;
      let joinRef = decoder.decode(buffer.slice(offset2, offset2 + joinRefSize));
      offset2 = offset2 + joinRefSize;
      let topic = decoder.decode(buffer.slice(offset2, offset2 + topicSize));
      offset2 = offset2 + topicSize;
      let event = decoder.decode(buffer.slice(offset2, offset2 + eventSize));
      offset2 = offset2 + eventSize;
      let data = buffer.slice(offset2, buffer.byteLength);
      return { join_ref: joinRef, ref: null, topic, event, payload: data };
    },
    decodeReply(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let refSize = view.getUint8(2);
      let topicSize = view.getUint8(3);
      let eventSize = view.getUint8(4);
      let offset2 = this.HEADER_LENGTH + this.META_LENGTH;
      let joinRef = decoder.decode(buffer.slice(offset2, offset2 + joinRefSize));
      offset2 = offset2 + joinRefSize;
      let ref = decoder.decode(buffer.slice(offset2, offset2 + refSize));
      offset2 = offset2 + refSize;
      let topic = decoder.decode(buffer.slice(offset2, offset2 + topicSize));
      offset2 = offset2 + topicSize;
      let event = decoder.decode(buffer.slice(offset2, offset2 + eventSize));
      offset2 = offset2 + eventSize;
      let data = buffer.slice(offset2, buffer.byteLength);
      let payload = { status: event, response: data };
      return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
    },
    decodeBroadcast(buffer, view, decoder) {
      let topicSize = view.getUint8(1);
      let eventSize = view.getUint8(2);
      let offset2 = this.HEADER_LENGTH + 2;
      let topic = decoder.decode(buffer.slice(offset2, offset2 + topicSize));
      offset2 = offset2 + topicSize;
      let event = decoder.decode(buffer.slice(offset2, offset2 + eventSize));
      offset2 = offset2 + eventSize;
      let data = buffer.slice(offset2, buffer.byteLength);
      return { join_ref: null, ref: null, topic, event, payload: data };
    }
  };
  var Socket = class {
    constructor(endPoint, opts = {}) {
      this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
      this.channels = [];
      this.sendBuffer = [];
      this.ref = 0;
      this.timeout = opts.timeout || DEFAULT_TIMEOUT;
      this.transport = opts.transport || global.WebSocket || LongPoll;
      this.primaryPassedHealthCheck = false;
      this.longPollFallbackMs = opts.longPollFallbackMs;
      this.fallbackTimer = null;
      this.sessionStore = opts.sessionStorage || global && global.sessionStorage;
      this.establishedConnections = 0;
      this.defaultEncoder = serializer_default.encode.bind(serializer_default);
      this.defaultDecoder = serializer_default.decode.bind(serializer_default);
      this.closeWasClean = false;
      this.binaryType = opts.binaryType || "arraybuffer";
      this.connectClock = 1;
      if (this.transport !== LongPoll) {
        this.encode = opts.encode || this.defaultEncoder;
        this.decode = opts.decode || this.defaultDecoder;
      } else {
        this.encode = this.defaultEncoder;
        this.decode = this.defaultDecoder;
      }
      let awaitingConnectionOnPageShow = null;
      if (phxWindow && phxWindow.addEventListener) {
        phxWindow.addEventListener("pagehide", (_e) => {
          if (this.conn) {
            this.disconnect();
            awaitingConnectionOnPageShow = this.connectClock;
          }
        });
        phxWindow.addEventListener("pageshow", (_e) => {
          if (awaitingConnectionOnPageShow === this.connectClock) {
            awaitingConnectionOnPageShow = null;
            this.connect();
          }
        });
      }
      this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
      this.rejoinAfterMs = (tries) => {
        if (opts.rejoinAfterMs) {
          return opts.rejoinAfterMs(tries);
        } else {
          return [1e3, 2e3, 5e3][tries - 1] || 1e4;
        }
      };
      this.reconnectAfterMs = (tries) => {
        if (opts.reconnectAfterMs) {
          return opts.reconnectAfterMs(tries);
        } else {
          return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
        }
      };
      this.logger = opts.logger || null;
      if (!this.logger && opts.debug) {
        this.logger = (kind, msg, data) => {
          console.log(`${kind}: ${msg}`, data);
        };
      }
      this.longpollerTimeout = opts.longpollerTimeout || 2e4;
      this.params = closure(opts.params || {});
      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
      this.vsn = opts.vsn || DEFAULT_VSN;
      this.heartbeatTimeoutTimer = null;
      this.heartbeatTimer = null;
      this.pendingHeartbeatRef = null;
      this.reconnectTimer = new Timer(() => {
        this.teardown(() => this.connect());
      }, this.reconnectAfterMs);
    }
    /**
     * Returns the LongPoll transport reference
     */
    getLongPollTransport() {
      return LongPoll;
    }
    /**
     * Disconnects and replaces the active transport
     *
     * @param {Function} newTransport - The new transport class to instantiate
     *
     */
    replaceTransport(newTransport) {
      this.connectClock++;
      this.closeWasClean = true;
      clearTimeout(this.fallbackTimer);
      this.reconnectTimer.reset();
      if (this.conn) {
        this.conn.close();
        this.conn = null;
      }
      this.transport = newTransport;
    }
    /**
     * Returns the socket protocol
     *
     * @returns {string}
     */
    protocol() {
      return location.protocol.match(/^https/) ? "wss" : "ws";
    }
    /**
     * The fully qualified socket url
     *
     * @returns {string}
     */
    endPointURL() {
      let uri = Ajax.appendParams(
        Ajax.appendParams(this.endPoint, this.params()),
        { vsn: this.vsn }
      );
      if (uri.charAt(0) !== "/") {
        return uri;
      }
      if (uri.charAt(1) === "/") {
        return `${this.protocol()}:${uri}`;
      }
      return `${this.protocol()}://${location.host}${uri}`;
    }
    /**
     * Disconnects the socket
     *
     * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.
     *
     * @param {Function} callback - Optional callback which is called after socket is disconnected.
     * @param {integer} code - A status code for disconnection (Optional).
     * @param {string} reason - A textual description of the reason to disconnect. (Optional)
     */
    disconnect(callback2, code, reason) {
      this.connectClock++;
      this.closeWasClean = true;
      clearTimeout(this.fallbackTimer);
      this.reconnectTimer.reset();
      this.teardown(callback2, code, reason);
    }
    /**
     *
     * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`
     *
     * Passing params to connect is deprecated; pass them in the Socket constructor instead:
     * `new Socket("/socket", {params: {user_id: userToken}})`.
     */
    connect(params) {
      if (params) {
        console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
        this.params = closure(params);
      }
      if (this.conn) {
        return;
      }
      if (this.longPollFallbackMs && this.transport !== LongPoll) {
        this.connectWithFallback(LongPoll, this.longPollFallbackMs);
      } else {
        this.transportConnect();
      }
    }
    /**
     * Logs the message. Override `this.logger` for specialized logging. noops by default
     * @param {string} kind
     * @param {string} msg
     * @param {Object} data
     */
    log(kind, msg, data) {
      this.logger && this.logger(kind, msg, data);
    }
    /**
     * Returns true if a logger has been set on this socket.
     */
    hasLogger() {
      return this.logger !== null;
    }
    /**
     * Registers callbacks for connection open events
     *
     * @example socket.onOpen(function(){ console.info("the socket was opened") })
     *
     * @param {Function} callback
     */
    onOpen(callback2) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.open.push([ref, callback2]);
      return ref;
    }
    /**
     * Registers callbacks for connection close events
     * @param {Function} callback
     */
    onClose(callback2) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.close.push([ref, callback2]);
      return ref;
    }
    /**
     * Registers callbacks for connection error events
     *
     * @example socket.onError(function(error){ alert("An error occurred") })
     *
     * @param {Function} callback
     */
    onError(callback2) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.error.push([ref, callback2]);
      return ref;
    }
    /**
     * Registers callbacks for connection message events
     * @param {Function} callback
     */
    onMessage(callback2) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.message.push([ref, callback2]);
      return ref;
    }
    /**
     * Pings the server and invokes the callback with the RTT in milliseconds
     * @param {Function} callback
     *
     * Returns true if the ping was pushed or false if unable to be pushed.
     */
    ping(callback2) {
      if (!this.isConnected()) {
        return false;
      }
      let ref = this.makeRef();
      let startTime = Date.now();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref });
      let onMsgRef = this.onMessage((msg) => {
        if (msg.ref === ref) {
          this.off([onMsgRef]);
          callback2(Date.now() - startTime);
        }
      });
      return true;
    }
    /**
     * @private
     */
    transportConnect() {
      this.connectClock++;
      this.closeWasClean = false;
      this.conn = new this.transport(this.endPointURL());
      this.conn.binaryType = this.binaryType;
      this.conn.timeout = this.longpollerTimeout;
      this.conn.onopen = () => this.onConnOpen();
      this.conn.onerror = (error) => this.onConnError(error);
      this.conn.onmessage = (event) => this.onConnMessage(event);
      this.conn.onclose = (event) => this.onConnClose(event);
    }
    getSession(key) {
      return this.sessionStore && this.sessionStore.getItem(key);
    }
    storeSession(key, val) {
      this.sessionStore && this.sessionStore.setItem(key, val);
    }
    connectWithFallback(fallbackTransport, fallbackThreshold = 2500) {
      clearTimeout(this.fallbackTimer);
      let established = false;
      let primaryTransport = true;
      let openRef, errorRef;
      let fallback = (reason) => {
        this.log("transport", `falling back to ${fallbackTransport.name}...`, reason);
        this.off([openRef, errorRef]);
        primaryTransport = false;
        this.replaceTransport(fallbackTransport);
        this.transportConnect();
      };
      if (this.getSession(`phx:fallback:${fallbackTransport.name}`)) {
        return fallback("memorized");
      }
      this.fallbackTimer = setTimeout(fallback, fallbackThreshold);
      errorRef = this.onError((reason) => {
        this.log("transport", "error", reason);
        if (primaryTransport && !established) {
          clearTimeout(this.fallbackTimer);
          fallback(reason);
        }
      });
      this.onOpen(() => {
        established = true;
        if (!primaryTransport) {
          if (!this.primaryPassedHealthCheck) {
            this.storeSession(`phx:fallback:${fallbackTransport.name}`, "true");
          }
          return this.log("transport", `established ${fallbackTransport.name} fallback`);
        }
        clearTimeout(this.fallbackTimer);
        this.fallbackTimer = setTimeout(fallback, fallbackThreshold);
        this.ping((rtt) => {
          this.log("transport", "connected to primary after", rtt);
          this.primaryPassedHealthCheck = true;
          clearTimeout(this.fallbackTimer);
        });
      });
      this.transportConnect();
    }
    clearHeartbeats() {
      clearTimeout(this.heartbeatTimer);
      clearTimeout(this.heartbeatTimeoutTimer);
    }
    onConnOpen() {
      if (this.hasLogger())
        this.log("transport", `${this.transport.name} connected to ${this.endPointURL()}`);
      this.closeWasClean = false;
      this.establishedConnections++;
      this.flushSendBuffer();
      this.reconnectTimer.reset();
      this.resetHeartbeat();
      this.stateChangeCallbacks.open.forEach(([, callback2]) => callback2());
    }
    /**
     * @private
     */
    heartbeatTimeout() {
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        if (this.hasLogger()) {
          this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
        }
        this.triggerChanError();
        this.closeWasClean = false;
        this.teardown(() => this.reconnectTimer.scheduleTimeout(), WS_CLOSE_NORMAL, "heartbeat timeout");
      }
    }
    resetHeartbeat() {
      if (this.conn && this.conn.skipHeartbeat) {
        return;
      }
      this.pendingHeartbeatRef = null;
      this.clearHeartbeats();
      this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    }
    teardown(callback2, code, reason) {
      if (!this.conn) {
        return callback2 && callback2();
      }
      this.waitForBufferDone(() => {
        if (this.conn) {
          if (code) {
            this.conn.close(code, reason || "");
          } else {
            this.conn.close();
          }
        }
        this.waitForSocketClosed(() => {
          if (this.conn) {
            this.conn.onopen = function() {
            };
            this.conn.onerror = function() {
            };
            this.conn.onmessage = function() {
            };
            this.conn.onclose = function() {
            };
            this.conn = null;
          }
          callback2 && callback2();
        });
      });
    }
    waitForBufferDone(callback2, tries = 1) {
      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
        callback2();
        return;
      }
      setTimeout(() => {
        this.waitForBufferDone(callback2, tries + 1);
      }, 150 * tries);
    }
    waitForSocketClosed(callback2, tries = 1) {
      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
        callback2();
        return;
      }
      setTimeout(() => {
        this.waitForSocketClosed(callback2, tries + 1);
      }, 150 * tries);
    }
    onConnClose(event) {
      let closeCode = event && event.code;
      if (this.hasLogger())
        this.log("transport", "close", event);
      this.triggerChanError();
      this.clearHeartbeats();
      if (!this.closeWasClean && closeCode !== 1e3) {
        this.reconnectTimer.scheduleTimeout();
      }
      this.stateChangeCallbacks.close.forEach(([, callback2]) => callback2(event));
    }
    /**
     * @private
     */
    onConnError(error) {
      if (this.hasLogger())
        this.log("transport", error);
      let transportBefore = this.transport;
      let establishedBefore = this.establishedConnections;
      this.stateChangeCallbacks.error.forEach(([, callback2]) => {
        callback2(error, transportBefore, establishedBefore);
      });
      if (transportBefore === this.transport || establishedBefore > 0) {
        this.triggerChanError();
      }
    }
    /**
     * @private
     */
    triggerChanError() {
      this.channels.forEach((channel) => {
        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
          channel.trigger(CHANNEL_EVENTS.error);
        }
      });
    }
    /**
     * @returns {string}
     */
    connectionState() {
      switch (this.conn && this.conn.readyState) {
        case SOCKET_STATES.connecting:
          return "connecting";
        case SOCKET_STATES.open:
          return "open";
        case SOCKET_STATES.closing:
          return "closing";
        default:
          return "closed";
      }
    }
    /**
     * @returns {boolean}
     */
    isConnected() {
      return this.connectionState() === "open";
    }
    /**
     * @private
     *
     * @param {Channel}
     */
    remove(channel) {
      this.off(channel.stateChangeRefs);
      this.channels = this.channels.filter((c) => c !== channel);
    }
    /**
     * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.
     *
     * @param {refs} - list of refs returned by calls to
     *                 `onOpen`, `onClose`, `onError,` and `onMessage`
     */
    off(refs) {
      for (let key in this.stateChangeCallbacks) {
        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {
          return refs.indexOf(ref) === -1;
        });
      }
    }
    /**
     * Initiates a new channel for the given topic
     *
     * @param {string} topic
     * @param {Object} chanParams - Parameters for the channel
     * @returns {Channel}
     */
    channel(topic, chanParams = {}) {
      let chan = new Channel(topic, chanParams, this);
      this.channels.push(chan);
      return chan;
    }
    /**
     * @param {Object} data
     */
    push(data) {
      if (this.hasLogger()) {
        let { topic, event, payload, ref, join_ref } = data;
        this.log("push", `${topic} ${event} (${join_ref}, ${ref})`, payload);
      }
      if (this.isConnected()) {
        this.encode(data, (result) => this.conn.send(result));
      } else {
        this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));
      }
    }
    /**
     * Return the next message ref, accounting for overflows
     * @returns {string}
     */
    makeRef() {
      let newRef = this.ref + 1;
      if (newRef === this.ref) {
        this.ref = 0;
      } else {
        this.ref = newRef;
      }
      return this.ref.toString();
    }
    sendHeartbeat() {
      if (this.pendingHeartbeatRef && !this.isConnected()) {
        return;
      }
      this.pendingHeartbeatRef = this.makeRef();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
      this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
    }
    flushSendBuffer() {
      if (this.isConnected() && this.sendBuffer.length > 0) {
        this.sendBuffer.forEach((callback2) => callback2());
        this.sendBuffer = [];
      }
    }
    onConnMessage(rawMessage) {
      this.decode(rawMessage.data, (msg) => {
        let { topic, event, payload, ref, join_ref } = msg;
        if (ref && ref === this.pendingHeartbeatRef) {
          this.clearHeartbeats();
          this.pendingHeartbeatRef = null;
          this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
        }
        if (this.hasLogger())
          this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
        for (let i = 0; i < this.channels.length; i++) {
          const channel = this.channels[i];
          if (!channel.isMember(topic, event, payload, join_ref)) {
            continue;
          }
          channel.trigger(event, payload, ref, join_ref);
        }
        for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {
          let [, callback2] = this.stateChangeCallbacks.message[i];
          callback2(msg);
        }
      });
    }
    leaveOpenTopic(topic) {
      let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));
      if (dupChannel) {
        if (this.hasLogger())
          this.log("transport", `leaving duplicate topic "${topic}"`);
        dupChannel.leave();
      }
    }
  };

  // ../deps/phoenix_live_view/priv/static/phoenix_live_view.esm.js
  var CONSECUTIVE_RELOADS = "consecutive-reloads";
  var MAX_RELOADS = 10;
  var RELOAD_JITTER_MIN = 5e3;
  var RELOAD_JITTER_MAX = 1e4;
  var FAILSAFE_JITTER = 3e4;
  var PHX_EVENT_CLASSES = [
    "phx-click-loading",
    "phx-change-loading",
    "phx-submit-loading",
    "phx-keydown-loading",
    "phx-keyup-loading",
    "phx-blur-loading",
    "phx-focus-loading",
    "phx-hook-loading"
  ];
  var PHX_COMPONENT = "data-phx-component";
  var PHX_LIVE_LINK = "data-phx-link";
  var PHX_TRACK_STATIC = "track-static";
  var PHX_LINK_STATE = "data-phx-link-state";
  var PHX_REF_LOADING = "data-phx-ref-loading";
  var PHX_REF_SRC = "data-phx-ref-src";
  var PHX_REF_LOCK = "data-phx-ref-lock";
  var PHX_TRACK_UPLOADS = "track-uploads";
  var PHX_UPLOAD_REF = "data-phx-upload-ref";
  var PHX_PREFLIGHTED_REFS = "data-phx-preflighted-refs";
  var PHX_DONE_REFS = "data-phx-done-refs";
  var PHX_DROP_TARGET = "drop-target";
  var PHX_ACTIVE_ENTRY_REFS = "data-phx-active-refs";
  var PHX_LIVE_FILE_UPDATED = "phx:live-file:updated";
  var PHX_SKIP = "data-phx-skip";
  var PHX_MAGIC_ID = "data-phx-id";
  var PHX_PRUNE = "data-phx-prune";
  var PHX_CONNECTED_CLASS = "phx-connected";
  var PHX_LOADING_CLASS = "phx-loading";
  var PHX_ERROR_CLASS = "phx-error";
  var PHX_CLIENT_ERROR_CLASS = "phx-client-error";
  var PHX_SERVER_ERROR_CLASS = "phx-server-error";
  var PHX_PARENT_ID = "data-phx-parent-id";
  var PHX_MAIN = "data-phx-main";
  var PHX_ROOT_ID = "data-phx-root-id";
  var PHX_VIEWPORT_TOP = "viewport-top";
  var PHX_VIEWPORT_BOTTOM = "viewport-bottom";
  var PHX_TRIGGER_ACTION = "trigger-action";
  var PHX_HAS_FOCUSED = "phx-has-focused";
  var FOCUSABLE_INPUTS = ["text", "textarea", "number", "email", "password", "search", "tel", "url", "date", "time", "datetime-local", "color", "range"];
  var CHECKABLE_INPUTS = ["checkbox", "radio"];
  var PHX_HAS_SUBMITTED = "phx-has-submitted";
  var PHX_SESSION = "data-phx-session";
  var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;
  var PHX_STICKY = "data-phx-sticky";
  var PHX_STATIC = "data-phx-static";
  var PHX_READONLY = "data-phx-readonly";
  var PHX_DISABLED = "data-phx-disabled";
  var PHX_DISABLE_WITH = "disable-with";
  var PHX_DISABLE_WITH_RESTORE = "data-phx-disable-with-restore";
  var PHX_HOOK = "hook";
  var PHX_DEBOUNCE = "debounce";
  var PHX_THROTTLE = "throttle";
  var PHX_UPDATE = "update";
  var PHX_STREAM = "stream";
  var PHX_STREAM_REF = "data-phx-stream";
  var PHX_KEY = "key";
  var PHX_PRIVATE = "phxPrivate";
  var PHX_AUTO_RECOVER = "auto-recover";
  var PHX_LV_DEBUG = "phx:live-socket:debug";
  var PHX_LV_PROFILE = "phx:live-socket:profiling";
  var PHX_LV_LATENCY_SIM = "phx:live-socket:latency-sim";
  var PHX_LV_HISTORY_POSITION = "phx:nav-history-position";
  var PHX_PROGRESS = "progress";
  var PHX_MOUNTED = "mounted";
  var PHX_RELOAD_STATUS = "__phoenix_reload_status__";
  var LOADER_TIMEOUT = 1;
  var MAX_CHILD_JOIN_ATTEMPTS = 3;
  var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;
  var BINDING_PREFIX = "phx-";
  var PUSH_TIMEOUT = 3e4;
  var DEBOUNCE_TRIGGER = "debounce-trigger";
  var THROTTLED = "throttled";
  var DEBOUNCE_PREV_KEY = "debounce-prev-key";
  var DEFAULTS = {
    debounce: 300,
    throttle: 300
  };
  var PHX_PENDING_ATTRS = [PHX_REF_LOADING, PHX_REF_SRC, PHX_REF_LOCK];
  var DYNAMICS = "d";
  var STATIC = "s";
  var ROOT = "r";
  var COMPONENTS = "c";
  var EVENTS = "e";
  var REPLY = "r";
  var TITLE = "t";
  var TEMPLATES = "p";
  var STREAM = "stream";
  var EntryUploader = class {
    constructor(entry, config, liveSocket2) {
      let { chunk_size, chunk_timeout } = config;
      this.liveSocket = liveSocket2;
      this.entry = entry;
      this.offset = 0;
      this.chunkSize = chunk_size;
      this.chunkTimeout = chunk_timeout;
      this.chunkTimer = null;
      this.errored = false;
      this.uploadChannel = liveSocket2.channel(`lvu:${entry.ref}`, { token: entry.metadata() });
    }
    error(reason) {
      if (this.errored) {
        return;
      }
      this.uploadChannel.leave();
      this.errored = true;
      clearTimeout(this.chunkTimer);
      this.entry.error(reason);
    }
    upload() {
      this.uploadChannel.onError((reason) => this.error(reason));
      this.uploadChannel.join().receive("ok", (_data) => this.readNextChunk()).receive("error", (reason) => this.error(reason));
    }
    isDone() {
      return this.offset >= this.entry.file.size;
    }
    readNextChunk() {
      let reader = new window.FileReader();
      let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);
      reader.onload = (e) => {
        if (e.target.error === null) {
          this.offset += e.target.result.byteLength;
          this.pushChunk(e.target.result);
        } else {
          return logError("Read error: " + e.target.error);
        }
      };
      reader.readAsArrayBuffer(blob);
    }
    pushChunk(chunk) {
      if (!this.uploadChannel.isJoined()) {
        return;
      }
      this.uploadChannel.push("chunk", chunk, this.chunkTimeout).receive("ok", () => {
        this.entry.progress(this.offset / this.entry.file.size * 100);
        if (!this.isDone()) {
          this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);
        }
      }).receive("error", ({ reason }) => this.error(reason));
    }
  };
  var logError = (msg, obj) => console.error && console.error(msg, obj);
  var isCid = (cid) => {
    let type = typeof cid;
    return type === "number" || type === "string" && /^(0|[1-9]\d*)$/.test(cid);
  };
  function detectDuplicateIds() {
    let ids = /* @__PURE__ */ new Set();
    let elems = document.querySelectorAll("*[id]");
    for (let i = 0, len = elems.length; i < len; i++) {
      if (ids.has(elems[i].id)) {
        console.error(`Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`);
      } else {
        ids.add(elems[i].id);
      }
    }
  }
  var debug = (view, kind, msg, obj) => {
    if (view.liveSocket.isDebugEnabled()) {
      console.log(`${view.id} ${kind}: ${msg} - `, obj);
    }
  };
  var closure2 = (val) => typeof val === "function" ? val : function() {
    return val;
  };
  var clone = (obj) => {
    return JSON.parse(JSON.stringify(obj));
  };
  var closestPhxBinding = (el2, binding, borderEl) => {
    do {
      if (el2.matches(`[${binding}]`) && !el2.disabled) {
        return el2;
      }
      el2 = el2.parentElement || el2.parentNode;
    } while (el2 !== null && el2.nodeType === 1 && !(borderEl && borderEl.isSameNode(el2) || el2.matches(PHX_VIEW_SELECTOR)));
    return null;
  };
  var isObject = (obj) => {
    return obj !== null && typeof obj === "object" && !(obj instanceof Array);
  };
  var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);
  var isEmpty = (obj) => {
    for (let x in obj) {
      return false;
    }
    return true;
  };
  var maybe = (el2, callback2) => el2 && callback2(el2);
  var channelUploader = function(entries, onError, resp, liveSocket2) {
    entries.forEach((entry) => {
      let entryUploader = new EntryUploader(entry, resp.config, liveSocket2);
      entryUploader.upload();
    });
  };
  var Browser = {
    canPushState() {
      return typeof history.pushState !== "undefined";
    },
    dropLocal(localStorage2, namespace, subkey) {
      return localStorage2.removeItem(this.localKey(namespace, subkey));
    },
    updateLocal(localStorage2, namespace, subkey, initial, func) {
      let current = this.getLocal(localStorage2, namespace, subkey);
      let key = this.localKey(namespace, subkey);
      let newVal = current === null ? initial : func(current);
      localStorage2.setItem(key, JSON.stringify(newVal));
      return newVal;
    },
    getLocal(localStorage2, namespace, subkey) {
      return JSON.parse(localStorage2.getItem(this.localKey(namespace, subkey)));
    },
    updateCurrentState(callback2) {
      if (!this.canPushState()) {
        return;
      }
      history.replaceState(callback2(history.state || {}), "", window.location.href);
    },
    pushState(kind, meta, to2) {
      if (this.canPushState()) {
        if (to2 !== window.location.href) {
          if (meta.type == "redirect" && meta.scroll) {
            let currentState = history.state || {};
            currentState.scroll = meta.scroll;
            history.replaceState(currentState, "", window.location.href);
          }
          delete meta.scroll;
          history[kind + "State"](meta, "", to2 || null);
          window.requestAnimationFrame(() => {
            let hashEl = this.getHashTargetEl(window.location.hash);
            if (hashEl) {
              hashEl.scrollIntoView();
            } else if (meta.type === "redirect") {
              window.scroll(0, 0);
            }
          });
        }
      } else {
        this.redirect(to2);
      }
    },
    setCookie(name, value, maxAgeSeconds) {
      let expires = typeof maxAgeSeconds === "number" ? ` max-age=${maxAgeSeconds};` : "";
      document.cookie = `${name}=${value};${expires} path=/`;
    },
    getCookie(name) {
      return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), "$1");
    },
    deleteCookie(name) {
      document.cookie = `${name}=; max-age=-1; path=/`;
    },
    redirect(toURL, flash) {
      if (flash) {
        this.setCookie("__phoenix_flash__", flash, 60);
      }
      window.location = toURL;
    },
    localKey(namespace, subkey) {
      return `${namespace}-${subkey}`;
    },
    getHashTargetEl(maybeHash) {
      let hash3 = maybeHash.toString().substring(1);
      if (hash3 === "") {
        return;
      }
      return document.getElementById(hash3) || document.querySelector(`a[name="${hash3}"]`);
    }
  };
  var browser_default = Browser;
  var DOM = {
    byId(id) {
      return document.getElementById(id) || logError(`no id found for ${id}`);
    },
    removeClass(el2, className) {
      el2.classList.remove(className);
      if (el2.classList.length === 0) {
        el2.removeAttribute("class");
      }
    },
    all(node, query, callback2) {
      if (!node) {
        return [];
      }
      let array = Array.from(node.querySelectorAll(query));
      return callback2 ? array.forEach(callback2) : array;
    },
    childNodeLength(html) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return template.content.childElementCount;
    },
    isUploadInput(el2) {
      return el2.type === "file" && el2.getAttribute(PHX_UPLOAD_REF) !== null;
    },
    isAutoUpload(inputEl) {
      return inputEl.hasAttribute("data-phx-auto-upload");
    },
    findUploadInputs(node) {
      const formId = node.id;
      const inputsOutsideForm = this.all(document, `input[type="file"][${PHX_UPLOAD_REF}][form="${formId}"]`);
      return this.all(node, `input[type="file"][${PHX_UPLOAD_REF}]`).concat(inputsOutsideForm);
    },
    findComponentNodeList(node, cid) {
      return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}="${cid}"]`), node);
    },
    isPhxDestroyed(node) {
      return node.id && DOM.private(node, "destroyed") ? true : false;
    },
    wantsNewTab(e) {
      let wantsNewTab = e.ctrlKey || e.shiftKey || e.metaKey || e.button && e.button === 1;
      let isDownload = e.target instanceof HTMLAnchorElement && e.target.hasAttribute("download");
      let isTargetBlank = e.target.hasAttribute("target") && e.target.getAttribute("target").toLowerCase() === "_blank";
      let isTargetNamedTab = e.target.hasAttribute("target") && !e.target.getAttribute("target").startsWith("_");
      return wantsNewTab || isTargetBlank || isDownload || isTargetNamedTab;
    },
    isUnloadableFormSubmit(e) {
      let isDialogSubmit = e.target && e.target.getAttribute("method") === "dialog" || e.submitter && e.submitter.getAttribute("formmethod") === "dialog";
      if (isDialogSubmit) {
        return false;
      } else {
        return !e.defaultPrevented && !this.wantsNewTab(e);
      }
    },
    isNewPageClick(e, currentLocation) {
      let href = e.target instanceof HTMLAnchorElement ? e.target.getAttribute("href") : null;
      let url;
      if (e.defaultPrevented || href === null || this.wantsNewTab(e)) {
        return false;
      }
      if (href.startsWith("mailto:") || href.startsWith("tel:")) {
        return false;
      }
      if (e.target.isContentEditable) {
        return false;
      }
      try {
        url = new URL(href);
      } catch (e2) {
        try {
          url = new URL(href, currentLocation);
        } catch (e3) {
          return true;
        }
      }
      if (url.host === currentLocation.host && url.protocol === currentLocation.protocol) {
        if (url.pathname === currentLocation.pathname && url.search === currentLocation.search) {
          return url.hash === "" && !url.href.endsWith("#");
        }
      }
      return url.protocol.startsWith("http");
    },
    markPhxChildDestroyed(el2) {
      if (this.isPhxChild(el2)) {
        el2.setAttribute(PHX_SESSION, "");
      }
      this.putPrivate(el2, "destroyed", true);
    },
    findPhxChildrenInFragment(html, parentId) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return this.findPhxChildren(template.content, parentId);
    },
    isIgnored(el2, phxUpdate) {
      return (el2.getAttribute(phxUpdate) || el2.getAttribute("data-phx-update")) === "ignore";
    },
    isPhxUpdate(el2, phxUpdate, updateTypes) {
      return el2.getAttribute && updateTypes.indexOf(el2.getAttribute(phxUpdate)) >= 0;
    },
    findPhxSticky(el2) {
      return this.all(el2, `[${PHX_STICKY}]`);
    },
    findPhxChildren(el2, parentId) {
      return this.all(el2, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}="${parentId}"]`);
    },
    findExistingParentCIDs(node, cids) {
      let parentCids = /* @__PURE__ */ new Set();
      let childrenCids = /* @__PURE__ */ new Set();
      cids.forEach((cid) => {
        this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}="${cid}"]`), node).forEach((parent) => {
          parentCids.add(cid);
          this.all(parent, `[${PHX_COMPONENT}]`).map((el2) => parseInt(el2.getAttribute(PHX_COMPONENT))).forEach((childCID) => childrenCids.add(childCID));
        });
      });
      childrenCids.forEach((childCid) => parentCids.delete(childCid));
      return parentCids;
    },
    filterWithinSameLiveView(nodes, parent) {
      if (parent.querySelector(PHX_VIEW_SELECTOR)) {
        return nodes.filter((el2) => this.withinSameLiveView(el2, parent));
      } else {
        return nodes;
      }
    },
    withinSameLiveView(node, parent) {
      while (node = node.parentNode) {
        if (node.isSameNode(parent)) {
          return true;
        }
        if (node.getAttribute(PHX_SESSION) !== null) {
          return false;
        }
      }
    },
    private(el2, key) {
      return el2[PHX_PRIVATE] && el2[PHX_PRIVATE][key];
    },
    deletePrivate(el2, key) {
      el2[PHX_PRIVATE] && delete el2[PHX_PRIVATE][key];
    },
    putPrivate(el2, key, value) {
      if (!el2[PHX_PRIVATE]) {
        el2[PHX_PRIVATE] = {};
      }
      el2[PHX_PRIVATE][key] = value;
    },
    updatePrivate(el2, key, defaultVal, updateFunc) {
      let existing = this.private(el2, key);
      if (existing === void 0) {
        this.putPrivate(el2, key, updateFunc(defaultVal));
      } else {
        this.putPrivate(el2, key, updateFunc(existing));
      }
    },
    syncPendingAttrs(fromEl, toEl) {
      if (!fromEl.hasAttribute(PHX_REF_SRC)) {
        return;
      }
      PHX_EVENT_CLASSES.forEach((className) => {
        fromEl.classList.contains(className) && toEl.classList.add(className);
      });
      PHX_PENDING_ATTRS.filter((attr) => fromEl.hasAttribute(attr)).forEach((attr) => {
        toEl.setAttribute(attr, fromEl.getAttribute(attr));
      });
    },
    copyPrivates(target, source) {
      if (source[PHX_PRIVATE]) {
        target[PHX_PRIVATE] = source[PHX_PRIVATE];
      }
    },
    putTitle(str) {
      let titleEl = document.querySelector("title");
      if (titleEl) {
        let { prefix, suffix, default: defaultTitle } = titleEl.dataset;
        let isEmpty2 = typeof str !== "string" || str.trim() === "";
        if (isEmpty2 && typeof defaultTitle !== "string") {
          return;
        }
        let inner = isEmpty2 ? defaultTitle : str;
        document.title = `${prefix || ""}${inner || ""}${suffix || ""}`;
      } else {
        document.title = str;
      }
    },
    debounce(el2, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, callback2) {
      let debounce3 = el2.getAttribute(phxDebounce);
      let throttle2 = el2.getAttribute(phxThrottle);
      if (debounce3 === "") {
        debounce3 = defaultDebounce;
      }
      if (throttle2 === "") {
        throttle2 = defaultThrottle;
      }
      let value = debounce3 || throttle2;
      switch (value) {
        case null:
          return callback2();
        case "blur":
          if (this.once(el2, "debounce-blur")) {
            el2.addEventListener("blur", () => {
              if (asyncFilter()) {
                callback2();
              }
            });
          }
          return;
        default:
          let timeout = parseInt(value);
          let trigger = () => throttle2 ? this.deletePrivate(el2, THROTTLED) : callback2();
          let currentCycle = this.incCycle(el2, DEBOUNCE_TRIGGER, trigger);
          if (isNaN(timeout)) {
            return logError(`invalid throttle/debounce value: ${value}`);
          }
          if (throttle2) {
            let newKeyDown = false;
            if (event.type === "keydown") {
              let prevKey = this.private(el2, DEBOUNCE_PREV_KEY);
              this.putPrivate(el2, DEBOUNCE_PREV_KEY, event.key);
              newKeyDown = prevKey !== event.key;
            }
            if (!newKeyDown && this.private(el2, THROTTLED)) {
              return false;
            } else {
              callback2();
              const t = setTimeout(() => {
                if (asyncFilter()) {
                  this.triggerCycle(el2, DEBOUNCE_TRIGGER);
                }
              }, timeout);
              this.putPrivate(el2, THROTTLED, t);
            }
          } else {
            setTimeout(() => {
              if (asyncFilter()) {
                this.triggerCycle(el2, DEBOUNCE_TRIGGER, currentCycle);
              }
            }, timeout);
          }
          let form = el2.form;
          if (form && this.once(form, "bind-debounce")) {
            form.addEventListener("submit", () => {
              Array.from(new FormData(form).entries(), ([name]) => {
                let input = form.querySelector(`[name="${name}"]`);
                this.incCycle(input, DEBOUNCE_TRIGGER);
                this.deletePrivate(input, THROTTLED);
              });
            });
          }
          if (this.once(el2, "bind-debounce")) {
            el2.addEventListener("blur", () => {
              clearTimeout(this.private(el2, THROTTLED));
              this.triggerCycle(el2, DEBOUNCE_TRIGGER);
            });
          }
      }
    },
    triggerCycle(el2, key, currentCycle) {
      let [cycle, trigger] = this.private(el2, key);
      if (!currentCycle) {
        currentCycle = cycle;
      }
      if (currentCycle === cycle) {
        this.incCycle(el2, key);
        trigger();
      }
    },
    once(el2, key) {
      if (this.private(el2, key) === true) {
        return false;
      }
      this.putPrivate(el2, key, true);
      return true;
    },
    incCycle(el2, key, trigger = function() {
    }) {
      let [currentCycle] = this.private(el2, key) || [0, trigger];
      currentCycle++;
      this.putPrivate(el2, key, [currentCycle, trigger]);
      return currentCycle;
    },
    // maintains or adds privately used hook information
    // fromEl and toEl can be the same element in the case of a newly added node
    // fromEl and toEl can be any HTML node type, so we need to check if it's an element node
    maintainPrivateHooks(fromEl, toEl, phxViewportTop, phxViewportBottom) {
      if (fromEl.hasAttribute && fromEl.hasAttribute("data-phx-hook") && !toEl.hasAttribute("data-phx-hook")) {
        toEl.setAttribute("data-phx-hook", fromEl.getAttribute("data-phx-hook"));
      }
      if (toEl.hasAttribute && (toEl.hasAttribute(phxViewportTop) || toEl.hasAttribute(phxViewportBottom))) {
        toEl.setAttribute("data-phx-hook", "Phoenix.InfiniteScroll");
      }
    },
    putCustomElHook(el2, hook) {
      if (el2.isConnected) {
        el2.setAttribute("data-phx-hook", "");
      } else {
        console.error(`
        hook attached to non-connected DOM element
        ensure you are calling createHook within your connectedCallback. ${el2.outerHTML}
      `);
      }
      this.putPrivate(el2, "custom-el-hook", hook);
    },
    getCustomElHook(el2) {
      return this.private(el2, "custom-el-hook");
    },
    isUsedInput(el2) {
      return el2.nodeType === Node.ELEMENT_NODE && (this.private(el2, PHX_HAS_FOCUSED) || this.private(el2, PHX_HAS_SUBMITTED));
    },
    resetForm(form) {
      Array.from(form.elements).forEach((input) => {
        this.deletePrivate(input, PHX_HAS_FOCUSED);
        this.deletePrivate(input, PHX_HAS_SUBMITTED);
      });
    },
    isPhxChild(node) {
      return node.getAttribute && node.getAttribute(PHX_PARENT_ID);
    },
    isPhxSticky(node) {
      return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;
    },
    isChildOfAny(el2, parents) {
      return !!parents.find((parent) => parent.contains(el2));
    },
    firstPhxChild(el2) {
      return this.isPhxChild(el2) ? el2 : this.all(el2, `[${PHX_PARENT_ID}]`)[0];
    },
    dispatchEvent(target, name, opts = {}) {
      let defaultBubble = true;
      let isUploadTarget = target.nodeName === "INPUT" && target.type === "file";
      if (isUploadTarget && name === "click") {
        defaultBubble = false;
      }
      let bubbles = opts.bubbles === void 0 ? defaultBubble : !!opts.bubbles;
      let eventOpts = { bubbles, cancelable: true, detail: opts.detail || {} };
      let event = name === "click" ? new MouseEvent("click", eventOpts) : new CustomEvent(name, eventOpts);
      target.dispatchEvent(event);
    },
    cloneNode(node, html) {
      if (typeof html === "undefined") {
        return node.cloneNode(true);
      } else {
        let cloned = node.cloneNode(false);
        cloned.innerHTML = html;
        return cloned;
      }
    },
    // merge attributes from source to target
    // if an element is ignored, we only merge data attributes
    // including removing data attributes that are no longer in the source
    mergeAttrs(target, source, opts = {}) {
      let exclude = new Set(opts.exclude || []);
      let isIgnored = opts.isIgnored;
      let sourceAttrs = source.attributes;
      for (let i = sourceAttrs.length - 1; i >= 0; i--) {
        let name = sourceAttrs[i].name;
        if (!exclude.has(name)) {
          const sourceValue = source.getAttribute(name);
          if (target.getAttribute(name) !== sourceValue && (!isIgnored || isIgnored && name.startsWith("data-"))) {
            target.setAttribute(name, sourceValue);
          }
        } else {
          if (name === "value" && target.value === source.value) {
            target.setAttribute("value", source.getAttribute(name));
          }
        }
      }
      let targetAttrs = target.attributes;
      for (let i = targetAttrs.length - 1; i >= 0; i--) {
        let name = targetAttrs[i].name;
        if (isIgnored) {
          if (name.startsWith("data-") && !source.hasAttribute(name) && !PHX_PENDING_ATTRS.includes(name)) {
            target.removeAttribute(name);
          }
        } else {
          if (!source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        }
      }
    },
    mergeFocusedInput(target, source) {
      if (!(target instanceof HTMLSelectElement)) {
        DOM.mergeAttrs(target, source, { exclude: ["value"] });
      }
      if (source.readOnly) {
        target.setAttribute("readonly", true);
      } else {
        target.removeAttribute("readonly");
      }
    },
    hasSelectionRange(el2) {
      return el2.setSelectionRange && (el2.type === "text" || el2.type === "textarea");
    },
    restoreFocus(focused, selectionStart, selectionEnd) {
      if (focused instanceof HTMLSelectElement) {
        focused.focus();
      }
      if (!DOM.isTextualInput(focused)) {
        return;
      }
      let wasFocused = focused.matches(":focus");
      if (!wasFocused) {
        focused.focus();
      }
      if (this.hasSelectionRange(focused)) {
        focused.setSelectionRange(selectionStart, selectionEnd);
      }
    },
    isFormInput(el2) {
      return /^(?:input|select|textarea)$/i.test(el2.tagName) && el2.type !== "button";
    },
    syncAttrsToProps(el2) {
      if (el2 instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el2.type.toLocaleLowerCase()) >= 0) {
        el2.checked = el2.getAttribute("checked") !== null;
      }
    },
    isTextualInput(el2) {
      return FOCUSABLE_INPUTS.indexOf(el2.type) >= 0;
    },
    isNowTriggerFormExternal(el2, phxTriggerExternal) {
      return el2.getAttribute && el2.getAttribute(phxTriggerExternal) !== null && document.body.contains(el2);
    },
    cleanChildNodes(container, phxUpdate) {
      if (DOM.isPhxUpdate(container, phxUpdate, ["append", "prepend"])) {
        let toRemove = [];
        container.childNodes.forEach((childNode) => {
          if (!childNode.id) {
            let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === "";
            if (!isEmptyTextNode && childNode.nodeType !== Node.COMMENT_NODE) {
              logError(`only HTML element tags with an id are allowed inside containers with phx-update.

removing illegal node: "${(childNode.outerHTML || childNode.nodeValue).trim()}"

`);
            }
            toRemove.push(childNode);
          }
        });
        toRemove.forEach((childNode) => childNode.remove());
      }
    },
    replaceRootContainer(container, tagName, attrs) {
      let retainedAttrs = /* @__PURE__ */ new Set(["id", PHX_SESSION, PHX_STATIC, PHX_MAIN, PHX_ROOT_ID]);
      if (container.tagName.toLowerCase() === tagName.toLowerCase()) {
        Array.from(container.attributes).filter((attr) => !retainedAttrs.has(attr.name.toLowerCase())).forEach((attr) => container.removeAttribute(attr.name));
        Object.keys(attrs).filter((name) => !retainedAttrs.has(name.toLowerCase())).forEach((attr) => container.setAttribute(attr, attrs[attr]));
        return container;
      } else {
        let newContainer = document.createElement(tagName);
        Object.keys(attrs).forEach((attr) => newContainer.setAttribute(attr, attrs[attr]));
        retainedAttrs.forEach((attr) => newContainer.setAttribute(attr, container.getAttribute(attr)));
        newContainer.innerHTML = container.innerHTML;
        container.replaceWith(newContainer);
        return newContainer;
      }
    },
    getSticky(el2, name, defaultVal) {
      let op = (DOM.private(el2, "sticky") || []).find(([existingName]) => name === existingName);
      if (op) {
        let [_name, _op, stashedResult] = op;
        return stashedResult;
      } else {
        return typeof defaultVal === "function" ? defaultVal() : defaultVal;
      }
    },
    deleteSticky(el2, name) {
      this.updatePrivate(el2, "sticky", [], (ops) => {
        return ops.filter(([existingName, _]) => existingName !== name);
      });
    },
    putSticky(el2, name, op) {
      let stashedResult = op(el2);
      this.updatePrivate(el2, "sticky", [], (ops) => {
        let existingIndex = ops.findIndex(([existingName]) => name === existingName);
        if (existingIndex >= 0) {
          ops[existingIndex] = [name, op, stashedResult];
        } else {
          ops.push([name, op, stashedResult]);
        }
        return ops;
      });
    },
    applyStickyOperations(el2) {
      let ops = DOM.private(el2, "sticky");
      if (!ops) {
        return;
      }
      ops.forEach(([name, op, _stashed]) => this.putSticky(el2, name, op));
    }
  };
  var dom_default = DOM;
  var UploadEntry = class {
    static isActive(fileEl, file) {
      let isNew = file._phxRef === void 0;
      let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return file.size > 0 && (isNew || isActive);
    }
    static isPreflighted(fileEl, file) {
      let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(",");
      let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return isPreflighted && this.isActive(fileEl, file);
    }
    static isPreflightInProgress(file) {
      return file._preflightInProgress === true;
    }
    static markPreflightInProgress(file) {
      file._preflightInProgress = true;
    }
    constructor(fileEl, file, view, autoUpload) {
      this.ref = LiveUploader.genFileRef(file);
      this.fileEl = fileEl;
      this.file = file;
      this.view = view;
      this.meta = null;
      this._isCancelled = false;
      this._isDone = false;
      this._progress = 0;
      this._lastProgressSent = -1;
      this._onDone = function() {
      };
      this._onElUpdated = this.onElUpdated.bind(this);
      this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
      this.autoUpload = autoUpload;
    }
    metadata() {
      return this.meta;
    }
    progress(progress) {
      this._progress = Math.floor(progress);
      if (this._progress > this._lastProgressSent) {
        if (this._progress >= 100) {
          this._progress = 100;
          this._lastProgressSent = 100;
          this._isDone = true;
          this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {
            LiveUploader.untrackFile(this.fileEl, this.file);
            this._onDone();
          });
        } else {
          this._lastProgressSent = this._progress;
          this.view.pushFileProgress(this.fileEl, this.ref, this._progress);
        }
      }
    }
    isCancelled() {
      return this._isCancelled;
    }
    cancel() {
      this.file._preflightInProgress = false;
      this._isCancelled = true;
      this._isDone = true;
      this._onDone();
    }
    isDone() {
      return this._isDone;
    }
    error(reason = "failed") {
      this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
      this.view.pushFileProgress(this.fileEl, this.ref, { error: reason });
      if (!this.isAutoUpload()) {
        LiveUploader.clearFiles(this.fileEl);
      }
    }
    isAutoUpload() {
      return this.autoUpload;
    }
    //private
    onDone(callback2) {
      this._onDone = () => {
        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
        callback2();
      };
    }
    onElUpdated() {
      let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      if (activeRefs.indexOf(this.ref) === -1) {
        LiveUploader.untrackFile(this.fileEl, this.file);
        this.cancel();
      }
    }
    toPreflightPayload() {
      return {
        last_modified: this.file.lastModified,
        name: this.file.name,
        relative_path: this.file.webkitRelativePath,
        size: this.file.size,
        type: this.file.type,
        ref: this.ref,
        meta: typeof this.file.meta === "function" ? this.file.meta() : void 0
      };
    }
    uploader(uploaders) {
      if (this.meta.uploader) {
        let callback2 = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);
        return { name: this.meta.uploader, callback: callback2 };
      } else {
        return { name: "channel", callback: channelUploader };
      }
    }
    zipPostFlight(resp) {
      this.meta = resp.entries[this.ref];
      if (!this.meta) {
        logError(`no preflight upload response returned with ref ${this.ref}`, { input: this.fileEl, response: resp });
      }
    }
  };
  var liveUploaderFileRef = 0;
  var LiveUploader = class _LiveUploader {
    static genFileRef(file) {
      let ref = file._phxRef;
      if (ref !== void 0) {
        return ref;
      } else {
        file._phxRef = (liveUploaderFileRef++).toString();
        return file._phxRef;
      }
    }
    static getEntryDataURL(inputEl, ref, callback2) {
      let file = this.activeFiles(inputEl).find((file2) => this.genFileRef(file2) === ref);
      callback2(URL.createObjectURL(file));
    }
    static hasUploadsInProgress(formEl) {
      let active = 0;
      dom_default.findUploadInputs(formEl).forEach((input) => {
        if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {
          active++;
        }
      });
      return active > 0;
    }
    static serializeUploads(inputEl) {
      let files = this.activeFiles(inputEl);
      let fileData = {};
      files.forEach((file) => {
        let entry = { path: inputEl.name };
        let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);
        fileData[uploadRef] = fileData[uploadRef] || [];
        entry.ref = this.genFileRef(file);
        entry.last_modified = file.lastModified;
        entry.name = file.name || entry.ref;
        entry.relative_path = file.webkitRelativePath;
        entry.type = file.type;
        entry.size = file.size;
        if (typeof file.meta === "function") {
          entry.meta = file.meta();
        }
        fileData[uploadRef].push(entry);
      });
      return fileData;
    }
    static clearFiles(inputEl) {
      inputEl.value = null;
      inputEl.removeAttribute(PHX_UPLOAD_REF);
      dom_default.putPrivate(inputEl, "files", []);
    }
    static untrackFile(inputEl, file) {
      dom_default.putPrivate(inputEl, "files", dom_default.private(inputEl, "files").filter((f) => !Object.is(f, file)));
    }
    static trackFiles(inputEl, files, dataTransfer) {
      if (inputEl.getAttribute("multiple") !== null) {
        let newFiles = files.filter((file) => !this.activeFiles(inputEl).find((f) => Object.is(f, file)));
        dom_default.updatePrivate(inputEl, "files", [], (existing) => existing.concat(newFiles));
        inputEl.value = null;
      } else {
        if (dataTransfer && dataTransfer.files.length > 0) {
          inputEl.files = dataTransfer.files;
        }
        dom_default.putPrivate(inputEl, "files", files);
      }
    }
    static activeFileInputs(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((el2) => el2.files && this.activeFiles(el2).length > 0);
    }
    static activeFiles(input) {
      return (dom_default.private(input, "files") || []).filter((f) => UploadEntry.isActive(input, f));
    }
    static inputsAwaitingPreflight(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((input) => this.filesAwaitingPreflight(input).length > 0);
    }
    static filesAwaitingPreflight(input) {
      return this.activeFiles(input).filter((f) => !UploadEntry.isPreflighted(input, f) && !UploadEntry.isPreflightInProgress(f));
    }
    static markPreflightInProgress(entries) {
      entries.forEach((entry) => UploadEntry.markPreflightInProgress(entry.file));
    }
    constructor(inputEl, view, onComplete) {
      this.autoUpload = dom_default.isAutoUpload(inputEl);
      this.view = view;
      this.onComplete = onComplete;
      this._entries = Array.from(_LiveUploader.filesAwaitingPreflight(inputEl) || []).map((file) => new UploadEntry(inputEl, file, view, this.autoUpload));
      _LiveUploader.markPreflightInProgress(this._entries);
      this.numEntriesInProgress = this._entries.length;
    }
    isAutoUpload() {
      return this.autoUpload;
    }
    entries() {
      return this._entries;
    }
    initAdapterUpload(resp, onError, liveSocket2) {
      this._entries = this._entries.map((entry) => {
        if (entry.isCancelled()) {
          this.numEntriesInProgress--;
          if (this.numEntriesInProgress === 0) {
            this.onComplete();
          }
        } else {
          entry.zipPostFlight(resp);
          entry.onDone(() => {
            this.numEntriesInProgress--;
            if (this.numEntriesInProgress === 0) {
              this.onComplete();
            }
          });
        }
        return entry;
      });
      let groupedEntries = this._entries.reduce((acc, entry) => {
        if (!entry.meta) {
          return acc;
        }
        let { name, callback: callback2 } = entry.uploader(liveSocket2.uploaders);
        acc[name] = acc[name] || { callback: callback2, entries: [] };
        acc[name].entries.push(entry);
        return acc;
      }, {});
      for (let name in groupedEntries) {
        let { callback: callback2, entries } = groupedEntries[name];
        callback2(entries, onError, resp, liveSocket2);
      }
    }
  };
  var ARIA = {
    anyOf(instance, classes) {
      return classes.find((name) => instance instanceof name);
    },
    isFocusable(el2, interactiveOnly) {
      return el2 instanceof HTMLAnchorElement && el2.rel !== "ignore" || el2 instanceof HTMLAreaElement && el2.href !== void 0 || !el2.disabled && this.anyOf(el2, [HTMLInputElement, HTMLSelectElement, HTMLTextAreaElement, HTMLButtonElement]) || el2 instanceof HTMLIFrameElement || (el2.tabIndex > 0 || !interactiveOnly && el2.getAttribute("tabindex") !== null && el2.getAttribute("aria-hidden") !== "true");
    },
    attemptFocus(el2, interactiveOnly) {
      if (this.isFocusable(el2, interactiveOnly)) {
        try {
          el2.focus();
        } catch (e) {
        }
      }
      return !!document.activeElement && document.activeElement.isSameNode(el2);
    },
    focusFirstInteractive(el2) {
      let child = el2.firstElementChild;
      while (child) {
        if (this.attemptFocus(child, true) || this.focusFirstInteractive(child, true)) {
          return true;
        }
        child = child.nextElementSibling;
      }
    },
    focusFirst(el2) {
      let child = el2.firstElementChild;
      while (child) {
        if (this.attemptFocus(child) || this.focusFirst(child)) {
          return true;
        }
        child = child.nextElementSibling;
      }
    },
    focusLast(el2) {
      let child = el2.lastElementChild;
      while (child) {
        if (this.attemptFocus(child) || this.focusLast(child)) {
          return true;
        }
        child = child.previousElementSibling;
      }
    }
  };
  var aria_default = ARIA;
  var Hooks = {
    LiveFileUpload: {
      activeRefs() {
        return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);
      },
      preflightedRefs() {
        return this.el.getAttribute(PHX_PREFLIGHTED_REFS);
      },
      mounted() {
        this.preflightedWas = this.preflightedRefs();
      },
      updated() {
        let newPreflights = this.preflightedRefs();
        if (this.preflightedWas !== newPreflights) {
          this.preflightedWas = newPreflights;
          if (newPreflights === "") {
            this.__view().cancelSubmit(this.el.form);
          }
        }
        if (this.activeRefs() === "") {
          this.el.value = null;
        }
        this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));
      }
    },
    LiveImgPreview: {
      mounted() {
        this.ref = this.el.getAttribute("data-phx-entry-ref");
        this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));
        LiveUploader.getEntryDataURL(this.inputEl, this.ref, (url) => {
          this.url = url;
          this.el.src = url;
        });
      },
      destroyed() {
        URL.revokeObjectURL(this.url);
      }
    },
    FocusWrap: {
      mounted() {
        this.focusStart = this.el.firstElementChild;
        this.focusEnd = this.el.lastElementChild;
        this.focusStart.addEventListener("focus", () => aria_default.focusLast(this.el));
        this.focusEnd.addEventListener("focus", () => aria_default.focusFirst(this.el));
        this.el.addEventListener("phx:show-end", () => this.el.focus());
        if (window.getComputedStyle(this.el).display !== "none") {
          aria_default.focusFirst(this.el);
        }
      }
    }
  };
  var findScrollContainer = (el2) => {
    if (["HTML", "BODY"].indexOf(el2.nodeName.toUpperCase()) >= 0)
      return null;
    if (["scroll", "auto"].indexOf(getComputedStyle(el2).overflowY) >= 0)
      return el2;
    return findScrollContainer(el2.parentElement);
  };
  var scrollTop = (scrollContainer) => {
    if (scrollContainer) {
      return scrollContainer.scrollTop;
    } else {
      return document.documentElement.scrollTop || document.body.scrollTop;
    }
  };
  var bottom = (scrollContainer) => {
    if (scrollContainer) {
      return scrollContainer.getBoundingClientRect().bottom;
    } else {
      return window.innerHeight || document.documentElement.clientHeight;
    }
  };
  var top = (scrollContainer) => {
    if (scrollContainer) {
      return scrollContainer.getBoundingClientRect().top;
    } else {
      return 0;
    }
  };
  var isAtViewportTop = (el2, scrollContainer) => {
    let rect = el2.getBoundingClientRect();
    return Math.ceil(rect.top) >= top(scrollContainer) && Math.ceil(rect.left) >= 0 && Math.floor(rect.top) <= bottom(scrollContainer);
  };
  var isAtViewportBottom = (el2, scrollContainer) => {
    let rect = el2.getBoundingClientRect();
    return Math.ceil(rect.bottom) >= top(scrollContainer) && Math.ceil(rect.left) >= 0 && Math.floor(rect.bottom) <= bottom(scrollContainer);
  };
  var isWithinViewport = (el2, scrollContainer) => {
    let rect = el2.getBoundingClientRect();
    return Math.ceil(rect.top) >= top(scrollContainer) && Math.ceil(rect.left) >= 0 && Math.floor(rect.top) <= bottom(scrollContainer);
  };
  Hooks.InfiniteScroll = {
    mounted() {
      this.scrollContainer = findScrollContainer(this.el);
      let scrollBefore = scrollTop(this.scrollContainer);
      let topOverran = false;
      let throttleInterval = 500;
      let pendingOp = null;
      let onTopOverrun = this.throttle(throttleInterval, (topEvent, firstChild) => {
        pendingOp = () => true;
        this.liveSocket.execJSHookPush(this.el, topEvent, { id: firstChild.id, _overran: true }, () => {
          pendingOp = null;
        });
      });
      let onFirstChildAtTop = this.throttle(throttleInterval, (topEvent, firstChild) => {
        pendingOp = () => firstChild.scrollIntoView({ block: "start" });
        this.liveSocket.execJSHookPush(this.el, topEvent, { id: firstChild.id }, () => {
          pendingOp = null;
          window.requestAnimationFrame(() => {
            if (!isWithinViewport(firstChild, this.scrollContainer)) {
              firstChild.scrollIntoView({ block: "start" });
            }
          });
        });
      });
      let onLastChildAtBottom = this.throttle(throttleInterval, (bottomEvent, lastChild2) => {
        pendingOp = () => lastChild2.scrollIntoView({ block: "end" });
        this.liveSocket.execJSHookPush(this.el, bottomEvent, { id: lastChild2.id }, () => {
          pendingOp = null;
          window.requestAnimationFrame(() => {
            if (!isWithinViewport(lastChild2, this.scrollContainer)) {
              lastChild2.scrollIntoView({ block: "end" });
            }
          });
        });
      });
      this.onScroll = (_e) => {
        let scrollNow = scrollTop(this.scrollContainer);
        if (pendingOp) {
          scrollBefore = scrollNow;
          return pendingOp();
        }
        let rect = this.el.getBoundingClientRect();
        let topEvent = this.el.getAttribute(this.liveSocket.binding("viewport-top"));
        let bottomEvent = this.el.getAttribute(this.liveSocket.binding("viewport-bottom"));
        let lastChild2 = this.el.lastElementChild;
        let firstChild = this.el.firstElementChild;
        let isScrollingUp = scrollNow < scrollBefore;
        let isScrollingDown = scrollNow > scrollBefore;
        if (isScrollingUp && topEvent && !topOverran && rect.top >= 0) {
          topOverran = true;
          onTopOverrun(topEvent, firstChild);
        } else if (isScrollingDown && topOverran && rect.top <= 0) {
          topOverran = false;
        }
        if (topEvent && isScrollingUp && isAtViewportTop(firstChild, this.scrollContainer)) {
          onFirstChildAtTop(topEvent, firstChild);
        } else if (bottomEvent && isScrollingDown && isAtViewportBottom(lastChild2, this.scrollContainer)) {
          onLastChildAtBottom(bottomEvent, lastChild2);
        }
        scrollBefore = scrollNow;
      };
      if (this.scrollContainer) {
        this.scrollContainer.addEventListener("scroll", this.onScroll);
      } else {
        window.addEventListener("scroll", this.onScroll);
      }
    },
    destroyed() {
      if (this.scrollContainer) {
        this.scrollContainer.removeEventListener("scroll", this.onScroll);
      } else {
        window.removeEventListener("scroll", this.onScroll);
      }
    },
    throttle(interval, callback2) {
      let lastCallAt = 0;
      let timer;
      return (...args) => {
        let now = Date.now();
        let remainingTime = interval - (now - lastCallAt);
        if (remainingTime <= 0 || remainingTime > interval) {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          lastCallAt = now;
          callback2(...args);
        } else if (!timer) {
          timer = setTimeout(() => {
            lastCallAt = Date.now();
            timer = null;
            callback2(...args);
          }, remainingTime);
        }
      };
    }
  };
  var hooks_default = Hooks;
  var ElementRef = class {
    constructor(el2) {
      this.el = el2;
      this.loadingRef = el2.hasAttribute(PHX_REF_LOADING) ? parseInt(el2.getAttribute(PHX_REF_LOADING), 10) : null;
      this.lockRef = el2.hasAttribute(PHX_REF_LOCK) ? parseInt(el2.getAttribute(PHX_REF_LOCK), 10) : null;
    }
    // public
    maybeUndo(ref, phxEvent, eachCloneCallback) {
      if (!this.isWithin(ref)) {
        return;
      }
      this.undoLocks(ref, phxEvent, eachCloneCallback);
      this.undoLoading(ref, phxEvent);
      if (this.isFullyResolvedBy(ref)) {
        this.el.removeAttribute(PHX_REF_SRC);
      }
    }
    // private
    isWithin(ref) {
      return !(this.loadingRef !== null && this.loadingRef > ref && (this.lockRef !== null && this.lockRef > ref));
    }
    // Check for cloned PHX_REF_LOCK element that has been morphed behind
    // the scenes while this element was locked in the DOM.
    // When we apply the cloned tree to the active DOM element, we must
    //
    //   1. execute pending mounted hooks for nodes now in the DOM
    //   2. undo any ref inside the cloned tree that has since been ack'd
    undoLocks(ref, phxEvent, eachCloneCallback) {
      if (!this.isLockUndoneBy(ref)) {
        return;
      }
      let clonedTree = dom_default.private(this.el, PHX_REF_LOCK);
      if (clonedTree) {
        eachCloneCallback(clonedTree);
        dom_default.deletePrivate(this.el, PHX_REF_LOCK);
      }
      this.el.removeAttribute(PHX_REF_LOCK);
      let opts = { detail: { ref, event: phxEvent }, bubbles: true, cancelable: false };
      this.el.dispatchEvent(new CustomEvent(`phx:undo-lock:${this.lockRef}`, opts));
    }
    undoLoading(ref, phxEvent) {
      if (!this.isLoadingUndoneBy(ref)) {
        if (this.canUndoLoading(ref) && this.el.classList.contains("phx-submit-loading")) {
          this.el.classList.remove("phx-change-loading");
        }
        return;
      }
      if (this.canUndoLoading(ref)) {
        this.el.removeAttribute(PHX_REF_LOADING);
        let disabledVal = this.el.getAttribute(PHX_DISABLED);
        let readOnlyVal = this.el.getAttribute(PHX_READONLY);
        if (readOnlyVal !== null) {
          this.el.readOnly = readOnlyVal === "true" ? true : false;
          this.el.removeAttribute(PHX_READONLY);
        }
        if (disabledVal !== null) {
          this.el.disabled = disabledVal === "true" ? true : false;
          this.el.removeAttribute(PHX_DISABLED);
        }
        let disableRestore = this.el.getAttribute(PHX_DISABLE_WITH_RESTORE);
        if (disableRestore !== null) {
          this.el.innerText = disableRestore;
          this.el.removeAttribute(PHX_DISABLE_WITH_RESTORE);
        }
        let opts = { detail: { ref, event: phxEvent }, bubbles: true, cancelable: false };
        this.el.dispatchEvent(new CustomEvent(`phx:undo-loading:${this.loadingRef}`, opts));
      }
      PHX_EVENT_CLASSES.forEach((name) => {
        if (name !== "phx-submit-loading" || this.canUndoLoading(ref)) {
          dom_default.removeClass(this.el, name);
        }
      });
    }
    isLoadingUndoneBy(ref) {
      return this.loadingRef === null ? false : this.loadingRef <= ref;
    }
    isLockUndoneBy(ref) {
      return this.lockRef === null ? false : this.lockRef <= ref;
    }
    isFullyResolvedBy(ref) {
      return (this.loadingRef === null || this.loadingRef <= ref) && (this.lockRef === null || this.lockRef <= ref);
    }
    // only remove the phx-submit-loading class if we are not locked
    canUndoLoading(ref) {
      return this.lockRef === null || this.lockRef <= ref;
    }
  };
  var DOMPostMorphRestorer = class {
    constructor(containerBefore, containerAfter, updateType) {
      let idsBefore = /* @__PURE__ */ new Set();
      let idsAfter = new Set([...containerAfter.children].map((child) => child.id));
      let elementsToModify = [];
      Array.from(containerBefore.children).forEach((child) => {
        if (child.id) {
          idsBefore.add(child.id);
          if (idsAfter.has(child.id)) {
            let previousElementId = child.previousElementSibling && child.previousElementSibling.id;
            elementsToModify.push({ elementId: child.id, previousElementId });
          }
        }
      });
      this.containerId = containerAfter.id;
      this.updateType = updateType;
      this.elementsToModify = elementsToModify;
      this.elementIdsToAdd = [...idsAfter].filter((id) => !idsBefore.has(id));
    }
    // We do the following to optimize append/prepend operations:
    //   1) Track ids of modified elements & of new elements
    //   2) All the modified elements are put back in the correct position in the DOM tree
    //      by storing the id of their previous sibling
    //   3) New elements are going to be put in the right place by morphdom during append.
    //      For prepend, we move them to the first position in the container
    perform() {
      let container = dom_default.byId(this.containerId);
      this.elementsToModify.forEach((elementToModify) => {
        if (elementToModify.previousElementId) {
          maybe(document.getElementById(elementToModify.previousElementId), (previousElem) => {
            maybe(document.getElementById(elementToModify.elementId), (elem) => {
              let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;
              if (!isInRightPlace) {
                previousElem.insertAdjacentElement("afterend", elem);
              }
            });
          });
        } else {
          maybe(document.getElementById(elementToModify.elementId), (elem) => {
            let isInRightPlace = elem.previousElementSibling == null;
            if (!isInRightPlace) {
              container.insertAdjacentElement("afterbegin", elem);
            }
          });
        }
      });
      if (this.updateType == "prepend") {
        this.elementIdsToAdd.reverse().forEach((elemId) => {
          maybe(document.getElementById(elemId), (elem) => container.insertAdjacentElement("afterbegin", elem));
        });
      }
    }
  };
  var DOCUMENT_FRAGMENT_NODE = 11;
  function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
      attr = toNodeAttrs[i];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      attrValue = attr.value;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attr.prefix === "xmlns") {
            attrName = attr.name;
          }
          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = fromNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          fromNode.setAttribute(attrName, attrValue);
        }
      }
    }
    var fromNodeAttrs = fromNode.attributes;
    for (var d3 = fromNodeAttrs.length - 1; d3 >= 0; d3--) {
      attr = fromNodeAttrs[d3];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          fromNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!toNode.hasAttribute(attrName)) {
          fromNode.removeAttribute(attrName);
        }
      }
    }
  }
  var range;
  var NS_XHTML = "http://www.w3.org/1999/xhtml";
  var doc = typeof document === "undefined" ? void 0 : document;
  var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
  function createFragmentFromTemplate(str) {
    var template = doc.createElement("template");
    template.innerHTML = str;
    return template.content.childNodes[0];
  }
  function createFragmentFromRange(str) {
    if (!range) {
      range = doc.createRange();
      range.selectNode(doc.body);
    }
    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
  }
  function createFragmentFromWrap(str) {
    var fragment = doc.createElement("body");
    fragment.innerHTML = str;
    return fragment.childNodes[0];
  }
  function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }
    return createFragmentFromWrap(str);
  }
  function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;
    if (fromNodeName === toNodeName) {
      return true;
    }
    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);
    if (fromCodeStart <= 90 && toCodeStart >= 97) {
      return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {
      return toNodeName === fromNodeName.toUpperCase();
    } else {
      return false;
    }
  }
  function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);
  }
  function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
      var nextChild = curChild.nextSibling;
      toEl.appendChild(curChild);
      curChild = nextChild;
    }
    return toEl;
  }
  function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
      fromEl[name] = toEl[name];
      if (fromEl[name]) {
        fromEl.setAttribute(name, "");
      } else {
        fromEl.removeAttribute(name);
      }
    }
  }
  var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
      var parentNode = fromEl.parentNode;
      if (parentNode) {
        var parentName = parentNode.nodeName.toUpperCase();
        if (parentName === "OPTGROUP") {
          parentNode = parentNode.parentNode;
          parentName = parentNode && parentNode.nodeName.toUpperCase();
        }
        if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
          if (fromEl.hasAttribute("selected") && !toEl.selected) {
            fromEl.setAttribute("selected", "selected");
            fromEl.removeAttribute("selected");
          }
          parentNode.selectedIndex = -1;
        }
      }
      syncBooleanAttrProp(fromEl, toEl, "selected");
    },
    /**
     * The "value" attribute is special for the <input> element since it sets
     * the initial value. Changing the "value" attribute without changing the
     * "value" property will have no effect since it is only used to the set the
     * initial value.  Similar for the "checked" attribute, and "disabled".
     */
    INPUT: function(fromEl, toEl) {
      syncBooleanAttrProp(fromEl, toEl, "checked");
      syncBooleanAttrProp(fromEl, toEl, "disabled");
      if (fromEl.value !== toEl.value) {
        fromEl.value = toEl.value;
      }
      if (!toEl.hasAttribute("value")) {
        fromEl.removeAttribute("value");
      }
    },
    TEXTAREA: function(fromEl, toEl) {
      var newValue = toEl.value;
      if (fromEl.value !== newValue) {
        fromEl.value = newValue;
      }
      var firstChild = fromEl.firstChild;
      if (firstChild) {
        var oldValue = firstChild.nodeValue;
        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
          return;
        }
        firstChild.nodeValue = newValue;
      }
    },
    SELECT: function(fromEl, toEl) {
      if (!toEl.hasAttribute("multiple")) {
        var selectedIndex = -1;
        var i = 0;
        var curChild = fromEl.firstChild;
        var optgroup;
        var nodeName;
        while (curChild) {
          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
          if (nodeName === "OPTGROUP") {
            optgroup = curChild;
            curChild = optgroup.firstChild;
          } else {
            if (nodeName === "OPTION") {
              if (curChild.hasAttribute("selected")) {
                selectedIndex = i;
                break;
              }
              i++;
            }
            curChild = curChild.nextSibling;
            if (!curChild && optgroup) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          }
        }
        fromEl.selectedIndex = selectedIndex;
      }
    }
  };
  var ELEMENT_NODE = 1;
  var DOCUMENT_FRAGMENT_NODE$1 = 11;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  function noop() {
  }
  function defaultGetNodeKey(node) {
    if (node) {
      return node.getAttribute && node.getAttribute("id") || node.id;
    }
  }
  function morphdomFactory(morphAttrs2) {
    return function morphdom2(fromNode, toNode, options) {
      if (!options) {
        options = {};
      }
      if (typeof toNode === "string") {
        if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML" || fromNode.nodeName === "BODY") {
          var toNodeHtml = toNode;
          toNode = doc.createElement("html");
          toNode.innerHTML = toNodeHtml;
        } else {
          toNode = toElement(toNode);
        }
      } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
        toNode = toNode.firstElementChild;
      }
      var getNodeKey = options.getNodeKey || defaultGetNodeKey;
      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
      var onNodeAdded = options.onNodeAdded || noop;
      var onBeforeElUpdated = options.onBeforeElUpdated || noop;
      var onElUpdated = options.onElUpdated || noop;
      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
      var onNodeDiscarded = options.onNodeDiscarded || noop;
      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
      var skipFromChildren = options.skipFromChildren || noop;
      var addChild = options.addChild || function(parent, child) {
        return parent.appendChild(child);
      };
      var childrenOnly = options.childrenOnly === true;
      var fromNodesLookup = /* @__PURE__ */ Object.create(null);
      var keyedRemovalList = [];
      function addKeyedRemoval(key) {
        keyedRemovalList.push(key);
      }
      function walkDiscardedChildNodes(node, skipKeyedNodes) {
        if (node.nodeType === ELEMENT_NODE) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = void 0;
            if (skipKeyedNodes && (key = getNodeKey(curChild))) {
              addKeyedRemoval(key);
            } else {
              onNodeDiscarded(curChild);
              if (curChild.firstChild) {
                walkDiscardedChildNodes(curChild, skipKeyedNodes);
              }
            }
            curChild = curChild.nextSibling;
          }
        }
      }
      function removeNode(node, parentNode, skipKeyedNodes) {
        if (onBeforeNodeDiscarded(node) === false) {
          return;
        }
        if (parentNode) {
          parentNode.removeChild(node);
        }
        onNodeDiscarded(node);
        walkDiscardedChildNodes(node, skipKeyedNodes);
      }
      function indexTree(node) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = getNodeKey(curChild);
            if (key) {
              fromNodesLookup[key] = curChild;
            }
            indexTree(curChild);
            curChild = curChild.nextSibling;
          }
        }
      }
      indexTree(fromNode);
      function handleNodeAdded(el2) {
        onNodeAdded(el2);
        var curChild = el2.firstChild;
        while (curChild) {
          var nextSibling = curChild.nextSibling;
          var key = getNodeKey(curChild);
          if (key) {
            var unmatchedFromEl = fromNodesLookup[key];
            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
              morphEl(unmatchedFromEl, curChild);
            } else {
              handleNodeAdded(curChild);
            }
          } else {
            handleNodeAdded(curChild);
          }
          curChild = nextSibling;
        }
      }
      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
        while (curFromNodeChild) {
          var fromNextSibling = curFromNodeChild.nextSibling;
          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
            addKeyedRemoval(curFromNodeKey);
          } else {
            removeNode(
              curFromNodeChild,
              fromEl,
              true
              /* skip keyed nodes */
            );
          }
          curFromNodeChild = fromNextSibling;
        }
      }
      function morphEl(fromEl, toEl, childrenOnly2) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
          delete fromNodesLookup[toElKey];
        }
        if (!childrenOnly2) {
          var beforeUpdateResult = onBeforeElUpdated(fromEl, toEl);
          if (beforeUpdateResult === false) {
            return;
          } else if (beforeUpdateResult instanceof HTMLElement) {
            fromEl = beforeUpdateResult;
            indexTree(fromEl);
          }
          morphAttrs2(fromEl, toEl);
          onElUpdated(fromEl);
          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
            return;
          }
        }
        if (fromEl.nodeName !== "TEXTAREA") {
          morphChildren(fromEl, toEl);
        } else {
          specialElHandlers.TEXTAREA(fromEl, toEl);
        }
      }
      function morphChildren(fromEl, toEl) {
        var skipFrom = skipFromChildren(fromEl, toEl);
        var curToNodeChild = toEl.firstChild;
        var curFromNodeChild = fromEl.firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        outer:
          while (curToNodeChild) {
            toNextSibling = curToNodeChild.nextSibling;
            curToNodeKey = getNodeKey(curToNodeChild);
            while (!skipFrom && curFromNodeChild) {
              fromNextSibling = curFromNodeChild.nextSibling;
              if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              curFromNodeKey = getNodeKey(curFromNodeChild);
              var curFromNodeType = curFromNodeChild.nodeType;
              var isCompatible = void 0;
              if (curFromNodeType === curToNodeChild.nodeType) {
                if (curFromNodeType === ELEMENT_NODE) {
                  if (curToNodeKey) {
                    if (curToNodeKey !== curFromNodeKey) {
                      if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                        if (fromNextSibling === matchingFromEl) {
                          isCompatible = false;
                        } else {
                          fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                          if (curFromNodeKey) {
                            addKeyedRemoval(curFromNodeKey);
                          } else {
                            removeNode(
                              curFromNodeChild,
                              fromEl,
                              true
                              /* skip keyed nodes */
                            );
                          }
                          curFromNodeChild = matchingFromEl;
                          curFromNodeKey = getNodeKey(curFromNodeChild);
                        }
                      } else {
                        isCompatible = false;
                      }
                    }
                  } else if (curFromNodeKey) {
                    isCompatible = false;
                  }
                  isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                  if (isCompatible) {
                    morphEl(curFromNodeChild, curToNodeChild);
                  }
                } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                  isCompatible = true;
                  if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                  }
                }
              }
              if (isCompatible) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              if (curFromNodeKey) {
                addKeyedRemoval(curFromNodeKey);
              } else {
                removeNode(
                  curFromNodeChild,
                  fromEl,
                  true
                  /* skip keyed nodes */
                );
              }
              curFromNodeChild = fromNextSibling;
            }
            if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
              if (!skipFrom) {
                addChild(fromEl, matchingFromEl);
              }
              morphEl(matchingFromEl, curToNodeChild);
            } else {
              var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
              if (onBeforeNodeAddedResult !== false) {
                if (onBeforeNodeAddedResult) {
                  curToNodeChild = onBeforeNodeAddedResult;
                }
                if (curToNodeChild.actualize) {
                  curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                }
                addChild(fromEl, curToNodeChild);
                handleNodeAdded(curToNodeChild);
              }
            }
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
          }
        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
        var specialElHandler = specialElHandlers[fromEl.nodeName];
        if (specialElHandler) {
          specialElHandler(fromEl, toEl);
        }
      }
      var morphedNode = fromNode;
      var morphedNodeType = morphedNode.nodeType;
      var toNodeType = toNode.nodeType;
      if (!childrenOnly) {
        if (morphedNodeType === ELEMENT_NODE) {
          if (toNodeType === ELEMENT_NODE) {
            if (!compareNodeNames(fromNode, toNode)) {
              onNodeDiscarded(fromNode);
              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
            }
          } else {
            morphedNode = toNode;
          }
        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
          if (toNodeType === morphedNodeType) {
            if (morphedNode.nodeValue !== toNode.nodeValue) {
              morphedNode.nodeValue = toNode.nodeValue;
            }
            return morphedNode;
          } else {
            morphedNode = toNode;
          }
        }
      }
      if (morphedNode === toNode) {
        onNodeDiscarded(fromNode);
      } else {
        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
          return;
        }
        morphEl(morphedNode, toNode, childrenOnly);
        if (keyedRemovalList) {
          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {
            var elToRemove = fromNodesLookup[keyedRemovalList[i]];
            if (elToRemove) {
              removeNode(elToRemove, elToRemove.parentNode, false);
            }
          }
        }
      }
      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        if (morphedNode.actualize) {
          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
        }
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
      }
      return morphedNode;
    };
  }
  var morphdom = morphdomFactory(morphAttrs);
  var morphdom_esm_default = morphdom;
  var DOMPatch = class {
    static patchWithClonedTree(container, clonedTree, liveSocket2) {
      let focused = liveSocket2.getActiveElement();
      let { selectionStart, selectionEnd } = focused && dom_default.hasSelectionRange(focused) ? focused : {};
      let phxUpdate = liveSocket2.binding(PHX_UPDATE);
      let externalFormTriggered = null;
      morphdom_esm_default(container, clonedTree, {
        childrenOnly: false,
        onBeforeElUpdated: (fromEl, toEl) => {
          dom_default.syncPendingAttrs(fromEl, toEl);
          if (!container.isSameNode(fromEl) && fromEl.hasAttribute(PHX_REF_LOCK)) {
            return false;
          }
          if (dom_default.isIgnored(fromEl, phxUpdate)) {
            return false;
          }
          if (focused && focused.isSameNode(fromEl) && dom_default.isFormInput(fromEl)) {
            dom_default.mergeFocusedInput(fromEl, toEl);
            return false;
          }
          if (dom_default.isNowTriggerFormExternal(toEl, liveSocket2.binding(PHX_TRIGGER_ACTION))) {
            externalFormTriggered = toEl;
          }
        }
      });
      if (externalFormTriggered) {
        liveSocket2.unload();
        Object.getPrototypeOf(externalFormTriggered).submit.call(externalFormTriggered);
      }
      liveSocket2.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));
    }
    constructor(view, container, id, html, streams, targetCID) {
      this.view = view;
      this.liveSocket = view.liveSocket;
      this.container = container;
      this.id = id;
      this.rootID = view.root.id;
      this.html = html;
      this.streams = streams;
      this.streamInserts = {};
      this.streamComponentRestore = {};
      this.targetCID = targetCID;
      this.cidPatch = isCid(this.targetCID);
      this.pendingRemoves = [];
      this.phxRemove = this.liveSocket.binding("remove");
      this.targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;
      this.callbacks = {
        beforeadded: [],
        beforeupdated: [],
        beforephxChildAdded: [],
        afteradded: [],
        afterupdated: [],
        afterdiscarded: [],
        afterphxChildAdded: [],
        aftertransitionsDiscarded: []
      };
    }
    before(kind, callback2) {
      this.callbacks[`before${kind}`].push(callback2);
    }
    after(kind, callback2) {
      this.callbacks[`after${kind}`].push(callback2);
    }
    trackBefore(kind, ...args) {
      this.callbacks[`before${kind}`].forEach((callback2) => callback2(...args));
    }
    trackAfter(kind, ...args) {
      this.callbacks[`after${kind}`].forEach((callback2) => callback2(...args));
    }
    markPrunableContentForRemoval() {
      let phxUpdate = this.liveSocket.binding(PHX_UPDATE);
      dom_default.all(this.container, `[${phxUpdate}=append] > *, [${phxUpdate}=prepend] > *`, (el2) => {
        el2.setAttribute(PHX_PRUNE, "");
      });
    }
    perform(isJoinPatch) {
      let { view, liveSocket: liveSocket2, html, container, targetContainer } = this;
      if (this.isCIDPatch() && !targetContainer) {
        return;
      }
      let focused = liveSocket2.getActiveElement();
      let { selectionStart, selectionEnd } = focused && dom_default.hasSelectionRange(focused) ? focused : {};
      let phxUpdate = liveSocket2.binding(PHX_UPDATE);
      let phxViewportTop = liveSocket2.binding(PHX_VIEWPORT_TOP);
      let phxViewportBottom = liveSocket2.binding(PHX_VIEWPORT_BOTTOM);
      let phxTriggerExternal = liveSocket2.binding(PHX_TRIGGER_ACTION);
      let added = [];
      let updates = [];
      let appendPrependUpdates = [];
      let externalFormTriggered = null;
      function morph(targetContainer2, source, withChildren = false) {
        let morphCallbacks = {
          // normally, we are running with childrenOnly, as the patch HTML for a LV
          // does not include the LV attrs (data-phx-session, etc.)
          // when we are patching a live component, we do want to patch the root element as well;
          // another case is the recursive patch of a stream item that was kept on reset (-> onBeforeNodeAdded)
          childrenOnly: targetContainer2.getAttribute(PHX_COMPONENT) === null && !withChildren,
          getNodeKey: (node) => {
            if (dom_default.isPhxDestroyed(node)) {
              return null;
            }
            if (isJoinPatch) {
              return node.id;
            }
            return node.id || node.getAttribute && node.getAttribute(PHX_MAGIC_ID);
          },
          // skip indexing from children when container is stream
          skipFromChildren: (from2) => {
            return from2.getAttribute(phxUpdate) === PHX_STREAM;
          },
          // tell morphdom how to add a child
          addChild: (parent, child) => {
            let { ref, streamAt } = this.getStreamInsert(child);
            if (ref === void 0) {
              return parent.appendChild(child);
            }
            this.setStreamRef(child, ref);
            if (streamAt === 0) {
              parent.insertAdjacentElement("afterbegin", child);
            } else if (streamAt === -1) {
              let lastChild2 = parent.lastElementChild;
              if (lastChild2 && !lastChild2.hasAttribute(PHX_STREAM_REF)) {
                let nonStreamChild = Array.from(parent.children).find((c) => !c.hasAttribute(PHX_STREAM_REF));
                parent.insertBefore(child, nonStreamChild);
              } else {
                parent.appendChild(child);
              }
            } else if (streamAt > 0) {
              let sibling = Array.from(parent.children)[streamAt];
              parent.insertBefore(child, sibling);
            }
          },
          onBeforeNodeAdded: (el2) => {
            dom_default.maintainPrivateHooks(el2, el2, phxViewportTop, phxViewportBottom);
            this.trackBefore("added", el2);
            let morphedEl = el2;
            if (this.streamComponentRestore[el2.id]) {
              morphedEl = this.streamComponentRestore[el2.id];
              delete this.streamComponentRestore[el2.id];
              morph.call(this, morphedEl, el2, true);
            }
            return morphedEl;
          },
          onNodeAdded: (el2) => {
            if (el2.getAttribute) {
              this.maybeReOrderStream(el2, true);
            }
            if (el2 instanceof HTMLImageElement && el2.srcset) {
              el2.srcset = el2.srcset;
            } else if (el2 instanceof HTMLVideoElement && el2.autoplay) {
              el2.play();
            }
            if (dom_default.isNowTriggerFormExternal(el2, phxTriggerExternal)) {
              externalFormTriggered = el2;
            }
            if (dom_default.isPhxChild(el2) && view.ownsElement(el2) || dom_default.isPhxSticky(el2) && view.ownsElement(el2.parentNode)) {
              this.trackAfter("phxChildAdded", el2);
            }
            added.push(el2);
          },
          onNodeDiscarded: (el2) => this.onNodeDiscarded(el2),
          onBeforeNodeDiscarded: (el2) => {
            if (el2.getAttribute && el2.getAttribute(PHX_PRUNE) !== null) {
              return true;
            }
            if (el2.parentElement !== null && el2.id && dom_default.isPhxUpdate(el2.parentElement, phxUpdate, [PHX_STREAM, "append", "prepend"])) {
              return false;
            }
            if (this.maybePendingRemove(el2)) {
              return false;
            }
            if (this.skipCIDSibling(el2)) {
              return false;
            }
            return true;
          },
          onElUpdated: (el2) => {
            if (dom_default.isNowTriggerFormExternal(el2, phxTriggerExternal)) {
              externalFormTriggered = el2;
            }
            updates.push(el2);
            this.maybeReOrderStream(el2, false);
          },
          onBeforeElUpdated: (fromEl, toEl) => {
            if (fromEl.id && fromEl.isSameNode(targetContainer2) && fromEl.id !== toEl.id) {
              morphCallbacks.onNodeDiscarded(fromEl);
              fromEl.replaceWith(toEl);
              return morphCallbacks.onNodeAdded(toEl);
            }
            dom_default.syncPendingAttrs(fromEl, toEl);
            dom_default.maintainPrivateHooks(fromEl, toEl, phxViewportTop, phxViewportBottom);
            dom_default.cleanChildNodes(toEl, phxUpdate);
            if (this.skipCIDSibling(toEl)) {
              this.maybeReOrderStream(fromEl);
              return false;
            }
            if (dom_default.isPhxSticky(fromEl)) {
              [PHX_SESSION, PHX_STATIC, PHX_ROOT_ID].map((attr) => [attr, fromEl.getAttribute(attr), toEl.getAttribute(attr)]).forEach(([attr, fromVal, toVal]) => {
                if (toVal && fromVal !== toVal) {
                  fromEl.setAttribute(attr, toVal);
                }
              });
              return false;
            }
            if (dom_default.isIgnored(fromEl, phxUpdate) || fromEl.form && fromEl.form.isSameNode(externalFormTriggered)) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeAttrs(fromEl, toEl, { isIgnored: dom_default.isIgnored(fromEl, phxUpdate) });
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (fromEl.type === "number" && (fromEl.validity && fromEl.validity.badInput)) {
              return false;
            }
            let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);
            let focusedSelectChanged = isFocusedFormEl && this.isChangedSelect(fromEl, toEl);
            if (fromEl.hasAttribute(PHX_REF_SRC)) {
              if (dom_default.isUploadInput(fromEl)) {
                dom_default.mergeAttrs(fromEl, toEl, { isIgnored: true });
                this.trackBefore("updated", fromEl, toEl);
                updates.push(fromEl);
              }
              dom_default.applyStickyOperations(fromEl);
              let isLocked = fromEl.hasAttribute(PHX_REF_LOCK);
              let clone22 = isLocked ? dom_default.private(fromEl, PHX_REF_LOCK) || fromEl.cloneNode(true) : null;
              if (clone22) {
                dom_default.putPrivate(fromEl, PHX_REF_LOCK, clone22);
                if (!isFocusedFormEl) {
                  fromEl = clone22;
                }
              }
            }
            if (dom_default.isPhxChild(toEl)) {
              let prevSession = fromEl.getAttribute(PHX_SESSION);
              dom_default.mergeAttrs(fromEl, toEl, { exclude: [PHX_STATIC] });
              if (prevSession !== "") {
                fromEl.setAttribute(PHX_SESSION, prevSession);
              }
              fromEl.setAttribute(PHX_ROOT_ID, this.rootID);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            dom_default.copyPrivates(toEl, fromEl);
            if (isFocusedFormEl && fromEl.type !== "hidden" && !focusedSelectChanged) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeFocusedInput(fromEl, toEl);
              dom_default.syncAttrsToProps(fromEl);
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            } else {
              if (focusedSelectChanged) {
                fromEl.blur();
              }
              if (dom_default.isPhxUpdate(toEl, phxUpdate, ["append", "prepend"])) {
                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));
              }
              dom_default.syncAttrsToProps(toEl);
              dom_default.applyStickyOperations(toEl);
              this.trackBefore("updated", fromEl, toEl);
              return fromEl;
            }
          }
        };
        morphdom_esm_default(targetContainer2, source, morphCallbacks);
      }
      this.trackBefore("added", container);
      this.trackBefore("updated", container, container);
      liveSocket2.time("morphdom", () => {
        this.streams.forEach(([ref, inserts, deleteIds, reset]) => {
          inserts.forEach(([key, streamAt, limit]) => {
            this.streamInserts[key] = { ref, streamAt, limit, reset };
          });
          if (reset !== void 0) {
            dom_default.all(container, `[${PHX_STREAM_REF}="${ref}"]`, (child) => {
              this.removeStreamChildElement(child);
            });
          }
          deleteIds.forEach((id) => {
            let child = container.querySelector(`[id="${id}"]`);
            if (child) {
              this.removeStreamChildElement(child);
            }
          });
        });
        if (isJoinPatch) {
          dom_default.all(this.container, `[${phxUpdate}=${PHX_STREAM}]`, (el2) => {
            this.liveSocket.owner(el2, (view2) => {
              if (view2 === this.view) {
                Array.from(el2.children).forEach((child) => {
                  this.removeStreamChildElement(child);
                });
              }
            });
          });
        }
        morph.call(this, targetContainer, html);
      });
      if (liveSocket2.isDebugEnabled()) {
        detectDuplicateIds();
        Array.from(document.querySelectorAll("input[name=id]")).forEach((node) => {
          if (node.form) {
            console.error('Detected an input with name="id" inside a form! This will cause problems when patching the DOM.\n', node);
          }
        });
      }
      if (appendPrependUpdates.length > 0) {
        liveSocket2.time("post-morph append/prepend restoration", () => {
          appendPrependUpdates.forEach((update) => update.perform());
        });
      }
      liveSocket2.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));
      dom_default.dispatchEvent(document, "phx:update");
      added.forEach((el2) => this.trackAfter("added", el2));
      updates.forEach((el2) => this.trackAfter("updated", el2));
      this.transitionPendingRemoves();
      if (externalFormTriggered) {
        liveSocket2.unload();
        Object.getPrototypeOf(externalFormTriggered).submit.call(externalFormTriggered);
      }
      return true;
    }
    onNodeDiscarded(el2) {
      if (dom_default.isPhxChild(el2) || dom_default.isPhxSticky(el2)) {
        this.liveSocket.destroyViewByEl(el2);
      }
      this.trackAfter("discarded", el2);
    }
    maybePendingRemove(node) {
      if (node.getAttribute && node.getAttribute(this.phxRemove) !== null) {
        this.pendingRemoves.push(node);
        return true;
      } else {
        return false;
      }
    }
    removeStreamChildElement(child) {
      if (this.streamInserts[child.id]) {
        this.streamComponentRestore[child.id] = child;
        child.remove();
      } else {
        if (!this.maybePendingRemove(child)) {
          child.remove();
          this.onNodeDiscarded(child);
        }
      }
    }
    getStreamInsert(el2) {
      let insert = el2.id ? this.streamInserts[el2.id] : {};
      return insert || {};
    }
    setStreamRef(el2, ref) {
      dom_default.putSticky(el2, PHX_STREAM_REF, (el22) => el22.setAttribute(PHX_STREAM_REF, ref));
    }
    maybeReOrderStream(el2, isNew) {
      let { ref, streamAt, reset } = this.getStreamInsert(el2);
      if (streamAt === void 0) {
        return;
      }
      this.setStreamRef(el2, ref);
      if (!reset && !isNew) {
        return;
      }
      if (!el2.parentElement) {
        return;
      }
      if (streamAt === 0) {
        el2.parentElement.insertBefore(el2, el2.parentElement.firstElementChild);
      } else if (streamAt > 0) {
        let children = Array.from(el2.parentElement.children);
        let oldIndex2 = children.indexOf(el2);
        if (streamAt >= children.length - 1) {
          el2.parentElement.appendChild(el2);
        } else {
          let sibling = children[streamAt];
          if (oldIndex2 > streamAt) {
            el2.parentElement.insertBefore(el2, sibling);
          } else {
            el2.parentElement.insertBefore(el2, sibling.nextElementSibling);
          }
        }
      }
      this.maybeLimitStream(el2);
    }
    maybeLimitStream(el2) {
      let { limit } = this.getStreamInsert(el2);
      let children = limit !== null && Array.from(el2.parentElement.children);
      if (limit && limit < 0 && children.length > limit * -1) {
        children.slice(0, children.length + limit).forEach((child) => this.removeStreamChildElement(child));
      } else if (limit && limit >= 0 && children.length > limit) {
        children.slice(limit).forEach((child) => this.removeStreamChildElement(child));
      }
    }
    transitionPendingRemoves() {
      let { pendingRemoves, liveSocket: liveSocket2 } = this;
      if (pendingRemoves.length > 0) {
        liveSocket2.transitionRemoves(pendingRemoves, false, () => {
          pendingRemoves.forEach((el2) => {
            let child = dom_default.firstPhxChild(el2);
            if (child) {
              liveSocket2.destroyViewByEl(child);
            }
            el2.remove();
          });
          this.trackAfter("transitionsDiscarded", pendingRemoves);
        });
      }
    }
    isChangedSelect(fromEl, toEl) {
      if (!(fromEl instanceof HTMLSelectElement) || fromEl.multiple) {
        return false;
      }
      if (fromEl.options.length !== toEl.options.length) {
        return true;
      }
      toEl.value = fromEl.value;
      return !fromEl.isEqualNode(toEl);
    }
    isCIDPatch() {
      return this.cidPatch;
    }
    skipCIDSibling(el2) {
      return el2.nodeType === Node.ELEMENT_NODE && el2.hasAttribute(PHX_SKIP);
    }
    targetCIDContainer(html) {
      if (!this.isCIDPatch()) {
        return;
      }
      let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);
      if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {
        return first;
      } else {
        return first && first.parentNode;
      }
    }
    indexOf(parent, child) {
      return Array.from(parent.children).indexOf(child);
    }
  };
  var VOID_TAGS = /* @__PURE__ */ new Set([
    "area",
    "base",
    "br",
    "col",
    "command",
    "embed",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  var quoteChars = /* @__PURE__ */ new Set(["'", '"']);
  var modifyRoot = (html, attrs, clearInnerHTML) => {
    let i = 0;
    let insideComment = false;
    let beforeTag, afterTag, tag, tagNameEndsAt, id, newHTML;
    let lookahead = html.match(/^(\s*(?:<!--.*?-->\s*)*)<([^\s\/>]+)/);
    if (lookahead === null) {
      throw new Error(`malformed html ${html}`);
    }
    i = lookahead[0].length;
    beforeTag = lookahead[1];
    tag = lookahead[2];
    tagNameEndsAt = i;
    for (i; i < html.length; i++) {
      if (html.charAt(i) === ">") {
        break;
      }
      if (html.charAt(i) === "=") {
        let isId = html.slice(i - 3, i) === " id";
        i++;
        let char = html.charAt(i);
        if (quoteChars.has(char)) {
          let attrStartsAt = i;
          i++;
          for (i; i < html.length; i++) {
            if (html.charAt(i) === char) {
              break;
            }
          }
          if (isId) {
            id = html.slice(attrStartsAt + 1, i);
            break;
          }
        }
      }
    }
    let closeAt = html.length - 1;
    insideComment = false;
    while (closeAt >= beforeTag.length + tag.length) {
      let char = html.charAt(closeAt);
      if (insideComment) {
        if (char === "-" && html.slice(closeAt - 3, closeAt) === "<!-") {
          insideComment = false;
          closeAt -= 4;
        } else {
          closeAt -= 1;
        }
      } else if (char === ">" && html.slice(closeAt - 2, closeAt) === "--") {
        insideComment = true;
        closeAt -= 3;
      } else if (char === ">") {
        break;
      } else {
        closeAt -= 1;
      }
    }
    afterTag = html.slice(closeAt + 1, html.length);
    let attrsStr = Object.keys(attrs).map((attr) => attrs[attr] === true ? attr : `${attr}="${attrs[attr]}"`).join(" ");
    if (clearInnerHTML) {
      let idAttrStr = id ? ` id="${id}"` : "";
      if (VOID_TAGS.has(tag)) {
        newHTML = `<${tag}${idAttrStr}${attrsStr === "" ? "" : " "}${attrsStr}/>`;
      } else {
        newHTML = `<${tag}${idAttrStr}${attrsStr === "" ? "" : " "}${attrsStr}></${tag}>`;
      }
    } else {
      let rest = html.slice(tagNameEndsAt, closeAt + 1);
      newHTML = `<${tag}${attrsStr === "" ? "" : " "}${attrsStr}${rest}`;
    }
    return [newHTML, beforeTag, afterTag];
  };
  var Rendered = class {
    static extract(diff) {
      let { [REPLY]: reply, [EVENTS]: events2, [TITLE]: title } = diff;
      delete diff[REPLY];
      delete diff[EVENTS];
      delete diff[TITLE];
      return { diff, title, reply: reply || null, events: events2 || [] };
    }
    constructor(viewId, rendered) {
      this.viewId = viewId;
      this.rendered = {};
      this.magicId = 0;
      this.mergeDiff(rendered);
    }
    parentViewId() {
      return this.viewId;
    }
    toString(onlyCids) {
      let [str, streams] = this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids, true, {});
      return [str, streams];
    }
    recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids, changeTracking, rootAttrs) {
      onlyCids = onlyCids ? new Set(onlyCids) : null;
      let output = { buffer: "", components, onlyCids, streams: /* @__PURE__ */ new Set() };
      this.toOutputBuffer(rendered, null, output, changeTracking, rootAttrs);
      return [output.buffer, output.streams];
    }
    componentCIDs(diff) {
      return Object.keys(diff[COMPONENTS] || {}).map((i) => parseInt(i));
    }
    isComponentOnlyDiff(diff) {
      if (!diff[COMPONENTS]) {
        return false;
      }
      return Object.keys(diff).length === 1;
    }
    getComponent(diff, cid) {
      return diff[COMPONENTS][cid];
    }
    resetRender(cid) {
      if (this.rendered[COMPONENTS][cid]) {
        this.rendered[COMPONENTS][cid].reset = true;
      }
    }
    mergeDiff(diff) {
      let newc = diff[COMPONENTS];
      let cache = {};
      delete diff[COMPONENTS];
      this.rendered = this.mutableMerge(this.rendered, diff);
      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};
      if (newc) {
        let oldc = this.rendered[COMPONENTS];
        for (let cid in newc) {
          newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);
        }
        for (let cid in newc) {
          oldc[cid] = newc[cid];
        }
        diff[COMPONENTS] = newc;
      }
    }
    cachedFindComponent(cid, cdiff, oldc, newc, cache) {
      if (cache[cid]) {
        return cache[cid];
      } else {
        let ndiff, stat, scid = cdiff[STATIC];
        if (isCid(scid)) {
          let tdiff;
          if (scid > 0) {
            tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);
          } else {
            tdiff = oldc[-scid];
          }
          stat = tdiff[STATIC];
          ndiff = this.cloneMerge(tdiff, cdiff, true);
          ndiff[STATIC] = stat;
        } else {
          ndiff = cdiff[STATIC] !== void 0 || oldc[cid] === void 0 ? cdiff : this.cloneMerge(oldc[cid], cdiff, false);
        }
        cache[cid] = ndiff;
        return ndiff;
      }
    }
    mutableMerge(target, source) {
      if (source[STATIC] !== void 0) {
        return source;
      } else {
        this.doMutableMerge(target, source);
        return target;
      }
    }
    doMutableMerge(target, source) {
      for (let key in source) {
        let val = source[key];
        let targetVal = target[key];
        let isObjVal = isObject(val);
        if (isObjVal && val[STATIC] === void 0 && isObject(targetVal)) {
          this.doMutableMerge(targetVal, val);
        } else {
          target[key] = val;
        }
      }
      if (target[ROOT]) {
        target.newRender = true;
      }
    }
    // Merges cid trees together, copying statics from source tree.
    //
    // The `pruneMagicId` is passed to control pruning the magicId of the
    // target. We must always prune the magicId when we are sharing statics
    // from another component. If not pruning, we replicate the logic from
    // mutableMerge, where we set newRender to true if there is a root
    // (effectively forcing the new version to be rendered instead of skipped)
    //
    cloneMerge(target, source, pruneMagicId) {
      let merged = __spreadValues(__spreadValues({}, target), source);
      for (let key in merged) {
        let val = source[key];
        let targetVal = target[key];
        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {
          merged[key] = this.cloneMerge(targetVal, val, pruneMagicId);
        } else if (val === void 0 && isObject(targetVal)) {
          merged[key] = this.cloneMerge(targetVal, {}, pruneMagicId);
        }
      }
      if (pruneMagicId) {
        delete merged.magicId;
        delete merged.newRender;
      } else if (target[ROOT]) {
        merged.newRender = true;
      }
      return merged;
    }
    componentToString(cid) {
      let [str, streams] = this.recursiveCIDToString(this.rendered[COMPONENTS], cid, null);
      let [strippedHTML, _before, _after] = modifyRoot(str, {});
      return [strippedHTML, streams];
    }
    pruneCIDs(cids) {
      cids.forEach((cid) => delete this.rendered[COMPONENTS][cid]);
    }
    // private
    get() {
      return this.rendered;
    }
    isNewFingerprint(diff = {}) {
      return !!diff[STATIC];
    }
    templateStatic(part, templates) {
      if (typeof part === "number") {
        return templates[part];
      } else {
        return part;
      }
    }
    nextMagicID() {
      this.magicId++;
      return `m${this.magicId}-${this.parentViewId()}`;
    }
    // Converts rendered tree to output buffer.
    //
    // changeTracking controls if we can apply the PHX_SKIP optimization.
    // It is disabled for comprehensions since we must re-render the entire collection
    // and no individual element is tracked inside the comprehension.
    toOutputBuffer(rendered, templates, output, changeTracking, rootAttrs = {}) {
      if (rendered[DYNAMICS]) {
        return this.comprehensionToBuffer(rendered, templates, output);
      }
      let { [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      let isRoot = rendered[ROOT];
      let prevBuffer = output.buffer;
      if (isRoot) {
        output.buffer = "";
      }
      if (changeTracking && isRoot && !rendered.magicId) {
        rendered.newRender = true;
        rendered.magicId = this.nextMagicID();
      }
      output.buffer += statics[0];
      for (let i = 1; i < statics.length; i++) {
        this.dynamicToBuffer(rendered[i - 1], templates, output, changeTracking);
        output.buffer += statics[i];
      }
      if (isRoot) {
        let skip2 = false;
        let attrs;
        if (changeTracking || rendered.magicId) {
          skip2 = changeTracking && !rendered.newRender;
          attrs = __spreadValues({ [PHX_MAGIC_ID]: rendered.magicId }, rootAttrs);
        } else {
          attrs = rootAttrs;
        }
        if (skip2) {
          attrs[PHX_SKIP] = true;
        }
        let [newRoot, commentBefore, commentAfter] = modifyRoot(output.buffer, attrs, skip2);
        rendered.newRender = false;
        output.buffer = prevBuffer + commentBefore + newRoot + commentAfter;
      }
    }
    comprehensionToBuffer(rendered, templates, output) {
      let { [DYNAMICS]: dynamics, [STATIC]: statics, [STREAM]: stream } = rendered;
      let [_ref, _inserts, deleteIds, reset] = stream || [null, {}, [], null];
      statics = this.templateStatic(statics, templates);
      let compTemplates = templates || rendered[TEMPLATES];
      for (let d3 = 0; d3 < dynamics.length; d3++) {
        let dynamic = dynamics[d3];
        output.buffer += statics[0];
        for (let i = 1; i < statics.length; i++) {
          let changeTracking = false;
          this.dynamicToBuffer(dynamic[i - 1], compTemplates, output, changeTracking);
          output.buffer += statics[i];
        }
      }
      if (stream !== void 0 && (rendered[DYNAMICS].length > 0 || deleteIds.length > 0 || reset)) {
        delete rendered[STREAM];
        rendered[DYNAMICS] = [];
        output.streams.add(stream);
      }
    }
    dynamicToBuffer(rendered, templates, output, changeTracking) {
      if (typeof rendered === "number") {
        let [str, streams] = this.recursiveCIDToString(output.components, rendered, output.onlyCids);
        output.buffer += str;
        output.streams = /* @__PURE__ */ new Set([...output.streams, ...streams]);
      } else if (isObject(rendered)) {
        this.toOutputBuffer(rendered, templates, output, changeTracking, {});
      } else {
        output.buffer += rendered;
      }
    }
    recursiveCIDToString(components, cid, onlyCids) {
      let component = components[cid] || logError(`no component for CID ${cid}`, components);
      let attrs = { [PHX_COMPONENT]: cid };
      let skip2 = onlyCids && !onlyCids.has(cid);
      component.newRender = !skip2;
      component.magicId = `c${cid}-${this.parentViewId()}`;
      let changeTracking = !component.reset;
      let [html, streams] = this.recursiveToString(component, components, onlyCids, changeTracking, attrs);
      delete component.reset;
      return [html, streams];
    }
  };
  var focusStack = [];
  var default_transition_time = 200;
  var JS = {
    // private
    exec(e, eventType, phxEvent, view, sourceEl, defaults3) {
      let [defaultKind, defaultArgs] = defaults3 || [null, { callback: defaults3 && defaults3.callback }];
      let commands = phxEvent.charAt(0) === "[" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];
      commands.forEach(([kind, args]) => {
        if (kind === defaultKind) {
          args = __spreadValues(__spreadValues({}, defaultArgs), args);
          args.callback = args.callback || defaultArgs.callback;
        }
        this.filterToEls(view.liveSocket, sourceEl, args).forEach((el2) => {
          this[`exec_${kind}`](e, eventType, phxEvent, view, sourceEl, el2, args);
        });
      });
    },
    isVisible(el2) {
      return !!(el2.offsetWidth || el2.offsetHeight || el2.getClientRects().length > 0);
    },
    // returns true if any part of the element is inside the viewport
    isInViewport(el2) {
      const rect = el2.getBoundingClientRect();
      const windowHeight = window.innerHeight || document.documentElement.clientHeight;
      const windowWidth = window.innerWidth || document.documentElement.clientWidth;
      return rect.right > 0 && rect.bottom > 0 && rect.left < windowWidth && rect.top < windowHeight;
    },
    // private
    // commands
    exec_exec(e, eventType, phxEvent, view, sourceEl, el2, { attr, to: to2 }) {
      let nodes = to2 ? dom_default.all(document, to2) : [sourceEl];
      nodes.forEach((node) => {
        let encodedJS = node.getAttribute(attr);
        if (!encodedJS) {
          throw new Error(`expected ${attr} to contain JS command on "${to2}"`);
        }
        view.liveSocket.execJS(node, encodedJS, eventType);
      });
    },
    exec_dispatch(e, eventType, phxEvent, view, sourceEl, el2, { event, detail, bubbles }) {
      detail = detail || {};
      detail.dispatcher = sourceEl;
      dom_default.dispatchEvent(el2, event, { detail, bubbles });
    },
    exec_push(e, eventType, phxEvent, view, sourceEl, el2, args) {
      let { event, data, target, page_loading, loading, value, dispatcher, callback: callback2 } = args;
      let pushOpts = { loading, value, target, page_loading: !!page_loading };
      let targetSrc = eventType === "change" && dispatcher ? dispatcher : sourceEl;
      let phxTarget = target || targetSrc.getAttribute(view.binding("target")) || targetSrc;
      const handler = (targetView, targetCtx) => {
        if (!targetView.isConnected()) {
          return;
        }
        if (eventType === "change") {
          let { newCid, _target } = args;
          _target = _target || (dom_default.isFormInput(sourceEl) ? sourceEl.name : void 0);
          if (_target) {
            pushOpts._target = _target;
          }
          targetView.pushInput(sourceEl, targetCtx, newCid, event || phxEvent, pushOpts, callback2);
        } else if (eventType === "submit") {
          let { submitter } = args;
          targetView.submitForm(sourceEl, targetCtx, event || phxEvent, submitter, pushOpts, callback2);
        } else {
          targetView.pushEvent(eventType, sourceEl, targetCtx, event || phxEvent, data, pushOpts, callback2);
        }
      };
      if (args.targetView && args.targetCtx) {
        handler(args.targetView, args.targetCtx);
      } else {
        view.withinTargets(phxTarget, handler);
      }
    },
    exec_navigate(e, eventType, phxEvent, view, sourceEl, el2, { href, replace }) {
      view.liveSocket.historyRedirect(e, href, replace ? "replace" : "push", null, sourceEl);
    },
    exec_patch(e, eventType, phxEvent, view, sourceEl, el2, { href, replace }) {
      view.liveSocket.pushHistoryPatch(e, href, replace ? "replace" : "push", sourceEl);
    },
    exec_focus(e, eventType, phxEvent, view, sourceEl, el2) {
      window.requestAnimationFrame(() => aria_default.attemptFocus(el2));
    },
    exec_focus_first(e, eventType, phxEvent, view, sourceEl, el2) {
      window.requestAnimationFrame(() => aria_default.focusFirstInteractive(el2) || aria_default.focusFirst(el2));
    },
    exec_push_focus(e, eventType, phxEvent, view, sourceEl, el2) {
      window.requestAnimationFrame(() => focusStack.push(el2 || sourceEl));
    },
    exec_pop_focus(_e, _eventType, _phxEvent, _view, _sourceEl, _el) {
      window.requestAnimationFrame(() => {
        const el2 = focusStack.pop();
        if (el2) {
          el2.focus();
        }
      });
    },
    exec_add_class(e, eventType, phxEvent, view, sourceEl, el2, { names: names2, transition, time, blocking }) {
      this.addOrRemoveClasses(el2, names2, [], transition, time, view, blocking);
    },
    exec_remove_class(e, eventType, phxEvent, view, sourceEl, el2, { names: names2, transition, time, blocking }) {
      this.addOrRemoveClasses(el2, [], names2, transition, time, view, blocking);
    },
    exec_toggle_class(e, eventType, phxEvent, view, sourceEl, el2, { names: names2, transition, time, blocking }) {
      this.toggleClasses(el2, names2, transition, time, view, blocking);
    },
    exec_toggle_attr(e, eventType, phxEvent, view, sourceEl, el2, { attr: [attr, val1, val2] }) {
      this.toggleAttr(el2, attr, val1, val2);
    },
    exec_transition(e, eventType, phxEvent, view, sourceEl, el2, { time, transition, blocking }) {
      this.addOrRemoveClasses(el2, [], [], transition, time, view, blocking);
    },
    exec_toggle(e, eventType, phxEvent, view, sourceEl, el2, { display, ins, outs, time, blocking }) {
      this.toggle(eventType, view, el2, display, ins, outs, time, blocking);
    },
    exec_show(e, eventType, phxEvent, view, sourceEl, el2, { display, transition, time, blocking }) {
      this.show(eventType, view, el2, display, transition, time, blocking);
    },
    exec_hide(e, eventType, phxEvent, view, sourceEl, el2, { display, transition, time, blocking }) {
      this.hide(eventType, view, el2, display, transition, time, blocking);
    },
    exec_set_attr(e, eventType, phxEvent, view, sourceEl, el2, { attr: [attr, val] }) {
      this.setOrRemoveAttrs(el2, [[attr, val]], []);
    },
    exec_remove_attr(e, eventType, phxEvent, view, sourceEl, el2, { attr }) {
      this.setOrRemoveAttrs(el2, [], [attr]);
    },
    // utils for commands
    show(eventType, view, el2, display, transition, time, blocking) {
      if (!this.isVisible(el2)) {
        this.toggle(eventType, view, el2, display, transition, null, time, blocking);
      }
    },
    hide(eventType, view, el2, display, transition, time, blocking) {
      if (this.isVisible(el2)) {
        this.toggle(eventType, view, el2, display, null, transition, time, blocking);
      }
    },
    toggle(eventType, view, el2, display, ins, outs, time, blocking) {
      time = time || default_transition_time;
      let [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];
      let [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];
      if (inClasses.length > 0 || outClasses.length > 0) {
        if (this.isVisible(el2)) {
          let onStart = () => {
            this.addOrRemoveClasses(el2, outStartClasses, inClasses.concat(inStartClasses).concat(inEndClasses));
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el2, outClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el2, outEndClasses, outStartClasses));
            });
          };
          let onEnd = () => {
            this.addOrRemoveClasses(el2, [], outClasses.concat(outEndClasses));
            dom_default.putSticky(el2, "toggle", (currentEl) => currentEl.style.display = "none");
            el2.dispatchEvent(new Event("phx:hide-end"));
          };
          el2.dispatchEvent(new Event("phx:hide-start"));
          if (blocking === false) {
            onStart();
            setTimeout(onEnd, time);
          } else {
            view.transition(time, onStart, onEnd);
          }
        } else {
          if (eventType === "remove") {
            return;
          }
          let onStart = () => {
            this.addOrRemoveClasses(el2, inStartClasses, outClasses.concat(outStartClasses).concat(outEndClasses));
            let stickyDisplay = display || this.defaultDisplay(el2);
            dom_default.putSticky(el2, "toggle", (currentEl) => currentEl.style.display = stickyDisplay);
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el2, inClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el2, inEndClasses, inStartClasses));
            });
          };
          let onEnd = () => {
            this.addOrRemoveClasses(el2, [], inClasses.concat(inEndClasses));
            el2.dispatchEvent(new Event("phx:show-end"));
          };
          el2.dispatchEvent(new Event("phx:show-start"));
          if (blocking === false) {
            onStart();
            setTimeout(onEnd, time);
          } else {
            view.transition(time, onStart, onEnd);
          }
        }
      } else {
        if (this.isVisible(el2)) {
          window.requestAnimationFrame(() => {
            el2.dispatchEvent(new Event("phx:hide-start"));
            dom_default.putSticky(el2, "toggle", (currentEl) => currentEl.style.display = "none");
            el2.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          window.requestAnimationFrame(() => {
            el2.dispatchEvent(new Event("phx:show-start"));
            let stickyDisplay = display || this.defaultDisplay(el2);
            dom_default.putSticky(el2, "toggle", (currentEl) => currentEl.style.display = stickyDisplay);
            el2.dispatchEvent(new Event("phx:show-end"));
          });
        }
      }
    },
    toggleClasses(el2, classes, transition, time, view, blocking) {
      window.requestAnimationFrame(() => {
        let [prevAdds, prevRemoves] = dom_default.getSticky(el2, "classes", [[], []]);
        let newAdds = classes.filter((name) => prevAdds.indexOf(name) < 0 && !el2.classList.contains(name));
        let newRemoves = classes.filter((name) => prevRemoves.indexOf(name) < 0 && el2.classList.contains(name));
        this.addOrRemoveClasses(el2, newAdds, newRemoves, transition, time, view, blocking);
      });
    },
    toggleAttr(el2, attr, val1, val2) {
      if (el2.hasAttribute(attr)) {
        if (val2 !== void 0) {
          if (el2.getAttribute(attr) === val1) {
            this.setOrRemoveAttrs(el2, [[attr, val2]], []);
          } else {
            this.setOrRemoveAttrs(el2, [[attr, val1]], []);
          }
        } else {
          this.setOrRemoveAttrs(el2, [], [attr]);
        }
      } else {
        this.setOrRemoveAttrs(el2, [[attr, val1]], []);
      }
    },
    addOrRemoveClasses(el2, adds, removes, transition, time, view, blocking) {
      time = time || default_transition_time;
      let [transitionRun, transitionStart, transitionEnd] = transition || [[], [], []];
      if (transitionRun.length > 0) {
        let onStart = () => {
          this.addOrRemoveClasses(el2, transitionStart, [].concat(transitionRun).concat(transitionEnd));
          window.requestAnimationFrame(() => {
            this.addOrRemoveClasses(el2, transitionRun, []);
            window.requestAnimationFrame(() => this.addOrRemoveClasses(el2, transitionEnd, transitionStart));
          });
        };
        let onDone = () => this.addOrRemoveClasses(el2, adds.concat(transitionEnd), removes.concat(transitionRun).concat(transitionStart));
        if (blocking === false) {
          onStart();
          setTimeout(onDone, time);
        } else {
          view.transition(time, onStart, onDone);
        }
        return;
      }
      window.requestAnimationFrame(() => {
        let [prevAdds, prevRemoves] = dom_default.getSticky(el2, "classes", [[], []]);
        let keepAdds = adds.filter((name) => prevAdds.indexOf(name) < 0 && !el2.classList.contains(name));
        let keepRemoves = removes.filter((name) => prevRemoves.indexOf(name) < 0 && el2.classList.contains(name));
        let newAdds = prevAdds.filter((name) => removes.indexOf(name) < 0).concat(keepAdds);
        let newRemoves = prevRemoves.filter((name) => adds.indexOf(name) < 0).concat(keepRemoves);
        dom_default.putSticky(el2, "classes", (currentEl) => {
          currentEl.classList.remove(...newRemoves);
          currentEl.classList.add(...newAdds);
          return [newAdds, newRemoves];
        });
      });
    },
    setOrRemoveAttrs(el2, sets, removes) {
      let [prevSets, prevRemoves] = dom_default.getSticky(el2, "attrs", [[], []]);
      let alteredAttrs = sets.map(([attr, _val]) => attr).concat(removes);
      let newSets = prevSets.filter(([attr, _val]) => !alteredAttrs.includes(attr)).concat(sets);
      let newRemoves = prevRemoves.filter((attr) => !alteredAttrs.includes(attr)).concat(removes);
      dom_default.putSticky(el2, "attrs", (currentEl) => {
        newRemoves.forEach((attr) => currentEl.removeAttribute(attr));
        newSets.forEach(([attr, val]) => currentEl.setAttribute(attr, val));
        return [newSets, newRemoves];
      });
    },
    hasAllClasses(el2, classes) {
      return classes.every((name) => el2.classList.contains(name));
    },
    isToggledOut(el2, outClasses) {
      return !this.isVisible(el2) || this.hasAllClasses(el2, outClasses);
    },
    filterToEls(liveSocket2, sourceEl, { to: to2 }) {
      let defaultQuery = () => {
        if (typeof to2 === "string") {
          return document.querySelectorAll(to2);
        } else if (to2.closest) {
          let toEl = sourceEl.closest(to2.closest);
          return toEl ? [toEl] : [];
        } else if (to2.inner) {
          return sourceEl.querySelectorAll(to2.inner);
        }
      };
      return to2 ? liveSocket2.jsQuerySelectorAll(sourceEl, to2, defaultQuery) : [sourceEl];
    },
    defaultDisplay(el2) {
      return { tr: "table-row", td: "table-cell" }[el2.tagName.toLowerCase()] || "block";
    },
    transitionClasses(val) {
      if (!val) {
        return null;
      }
      let [trans, tStart, tEnd] = Array.isArray(val) ? val : [val.split(" "), [], []];
      trans = Array.isArray(trans) ? trans : trans.split(" ");
      tStart = Array.isArray(tStart) ? tStart : tStart.split(" ");
      tEnd = Array.isArray(tEnd) ? tEnd : tEnd.split(" ");
      return [trans, tStart, tEnd];
    }
  };
  var js_default = JS;
  var HOOK_ID = "hookId";
  var viewHookID = 1;
  var ViewHook = class {
    static makeID() {
      return viewHookID++;
    }
    static elementID(el2) {
      return dom_default.private(el2, HOOK_ID);
    }
    constructor(view, el2, callbacks) {
      this.el = el2;
      this.__attachView(view);
      this.__callbacks = callbacks;
      this.__listeners = /* @__PURE__ */ new Set();
      this.__isDisconnected = false;
      dom_default.putPrivate(this.el, HOOK_ID, this.constructor.makeID());
      for (let key in this.__callbacks) {
        this[key] = this.__callbacks[key];
      }
    }
    __attachView(view) {
      if (view) {
        this.__view = () => view;
        this.liveSocket = view.liveSocket;
      } else {
        this.__view = () => {
          throw new Error(`hook not yet attached to a live view: ${this.el.outerHTML}`);
        };
        this.liveSocket = null;
      }
    }
    __mounted() {
      this.mounted && this.mounted();
    }
    __updated() {
      this.updated && this.updated();
    }
    __beforeUpdate() {
      this.beforeUpdate && this.beforeUpdate();
    }
    __destroyed() {
      this.destroyed && this.destroyed();
      dom_default.deletePrivate(this.el, HOOK_ID);
    }
    __reconnected() {
      if (this.__isDisconnected) {
        this.__isDisconnected = false;
        this.reconnected && this.reconnected();
      }
    }
    __disconnected() {
      this.__isDisconnected = true;
      this.disconnected && this.disconnected();
    }
    /**
     * Binds the hook to JS commands.
     *
     * @param {ViewHook} hook - The ViewHook instance to bind.
     *
     * @returns {Object} An object with methods to manipulate the DOM and execute JavaScript.
     */
    js() {
      let hook = this;
      return {
        /**
         * Executes encoded JavaScript in the context of the hook element.
         *
         * @param {string} encodedJS - The encoded JavaScript string to execute.
         */
        exec(encodedJS) {
          hook.__view().liveSocket.execJS(hook.el, encodedJS, "hook");
        },
        /**
         * Shows an element.
         *
         * @param {HTMLElement} el - The element to show.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.display] - The CSS display value to set. Defaults "block".
         * @param {string} [opts.transition] - The CSS transition classes to set when showing.
         * @param {number} [opts.time] - The transition duration in milliseconds. Defaults 200.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *  Defaults `true`.
         */
        show(el2, opts = {}) {
          let owner = hook.__view().liveSocket.owner(el2);
          js_default.show("hook", owner, el2, opts.display, opts.transition, opts.time, opts.blocking);
        },
        /**
         * Hides an element.
         *
         * @param {HTMLElement} el - The element to hide.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.transition] - The CSS transition classes to set when hiding.
         * @param {number} [opts.time] - The transition duration in milliseconds. Defaults 200.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        hide(el2, opts = {}) {
          let owner = hook.__view().liveSocket.owner(el2);
          js_default.hide("hook", owner, el2, null, opts.transition, opts.time, opts.blocking);
        },
        /**
         * Toggles the visibility of an element.
         *
         * @param {HTMLElement} el - The element to toggle.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.display] - The CSS display value to set. Defaults "block".
         * @param {string} [opts.in] - The CSS transition classes for showing.
         *   Accepts either the string of classes to apply when toggling in, or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-0", "opacity-100"]
         *
         * @param {string} [opts.out] - The CSS transition classes for hiding.
         *   Accepts either string of classes to apply when toggling out, or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-100", "opacity-0"]
         *
         * @param {number} [opts.time] - The transition duration in milliseconds.
         *
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        toggle(el2, opts = {}) {
          let owner = hook.__view().liveSocket.owner(el2);
          opts.in = js_default.transitionClasses(opts.in);
          opts.out = js_default.transitionClasses(opts.out);
          js_default.toggle("hook", owner, el2, opts.display, opts.in, opts.out, opts.time, opts.blocking);
        },
        /**
         * Adds CSS classes to an element.
         *
         * @param {HTMLElement} el - The element to add classes to.
         * @param {string|string[]} names - The class name(s) to add.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.transition] - The CSS transition property to set.
         *   Accepts a string of classes to apply when adding classes or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-0", "opacity-100"]
         *
         * @param {number} [opts.time] - The transition duration in milliseconds.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        addClass(el2, names2, opts = {}) {
          names2 = Array.isArray(names2) ? names2 : names2.split(" ");
          let owner = hook.__view().liveSocket.owner(el2);
          js_default.addOrRemoveClasses(el2, names2, [], opts.transition, opts.time, owner, opts.blocking);
        },
        /**
         * Removes CSS classes from an element.
         *
         * @param {HTMLElement} el - The element to remove classes from.
         * @param {string|string[]} names - The class name(s) to remove.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.transition] - The CSS transition classes to set.
         *   Accepts a string of classes to apply when removing classes or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-100", "opacity-0"]
         *
         * @param {number} [opts.time] - The transition duration in milliseconds.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        removeClass(el2, names2, opts = {}) {
          opts.transition = js_default.transitionClasses(opts.transition);
          names2 = Array.isArray(names2) ? names2 : names2.split(" ");
          let owner = hook.__view().liveSocket.owner(el2);
          js_default.addOrRemoveClasses(el2, [], names2, opts.transition, opts.time, owner, opts.blocking);
        },
        /**
         * Toggles CSS classes on an element.
         *
         * @param {HTMLElement} el - The element to toggle classes on.
         * @param {string|string[]} names - The class name(s) to toggle.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.transition] - The CSS transition classes to set.
         *   Accepts a string of classes to apply when toggling classes or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-100", "opacity-0"]
         *
         * @param {number} [opts.time] - The transition duration in milliseconds.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        toggleClass(el2, names2, opts = {}) {
          opts.transition = js_default.transitionClasses(opts.transition);
          names2 = Array.isArray(names2) ? names2 : names2.split(" ");
          let owner = hook.__view().liveSocket.owner(el2);
          js_default.toggleClasses(el2, names2, opts.transition, opts.time, owner, opts.blocking);
        },
        /**
         * Applies a CSS transition to an element.
         *
         * @param {HTMLElement} el - The element to apply the transition to.
         * @param {string|string[]} transition - The transition class(es) to apply.
         *   Accepts a string of classes to apply when transitioning or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-100", "opacity-0"]
         *
         * @param {Object} [opts={}] - Optional settings.
         * @param {number} [opts.time] - The transition duration in milliseconds.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        transition(el2, transition, opts = {}) {
          let owner = hook.__view().liveSocket.owner(el2);
          js_default.addOrRemoveClasses(el2, [], [], js_default.transitionClasses(transition), opts.time, owner, opts.blocking);
        },
        /**
         * Sets an attribute on an element.
         *
         * @param {HTMLElement} el - The element to set the attribute on.
         * @param {string} attr - The attribute name to set.
         * @param {string} val - The value to set for the attribute.
         */
        setAttribute(el2, attr, val) {
          js_default.setOrRemoveAttrs(el2, [[attr, val]], []);
        },
        /**
         * Removes an attribute from an element.
         *
         * @param {HTMLElement} el - The element to remove the attribute from.
         * @param {string} attr - The attribute name to remove.
         */
        removeAttribute(el2, attr) {
          js_default.setOrRemoveAttrs(el2, [], [attr]);
        },
        /**
         * Toggles an attribute on an element between two values.
         *
         * @param {HTMLElement} el - The element to toggle the attribute on.
         * @param {string} attr - The attribute name to toggle.
         * @param {string} val1 - The first value to toggle between.
         * @param {string} val2 - The second value to toggle between.
         */
        toggleAttribute(el2, attr, val1, val2) {
          js_default.toggleAttr(el2, attr, val1, val2);
        }
      };
    }
    pushEvent(event, payload = {}, onReply) {
      if (onReply === void 0) {
        return new Promise((resolve2, reject) => {
          try {
            const ref = this.__view().pushHookEvent(this.el, null, event, payload, (reply, _ref) => resolve2(reply));
            if (ref === false) {
              reject(new Error("unable to push hook event. LiveView not connected"));
            }
          } catch (error) {
            reject(error);
          }
        });
      }
      return this.__view().pushHookEvent(this.el, null, event, payload, onReply);
    }
    pushEventTo(phxTarget, event, payload = {}, onReply) {
      if (onReply === void 0) {
        return new Promise((resolve2, reject) => {
          try {
            this.__view().withinTargets(phxTarget, (view, targetCtx) => {
              const ref = view.pushHookEvent(this.el, targetCtx, event, payload, (reply, _ref) => resolve2(reply));
              if (ref === false) {
                reject(new Error("unable to push hook event. LiveView not connected"));
              }
            });
          } catch (error) {
            reject(error);
          }
        });
      }
      return this.__view().withinTargets(phxTarget, (view, targetCtx) => {
        return view.pushHookEvent(this.el, targetCtx, event, payload, onReply);
      });
    }
    handleEvent(event, callback2) {
      let callbackRef = (customEvent, bypass) => bypass ? event : callback2(customEvent.detail);
      window.addEventListener(`phx:${event}`, callbackRef);
      this.__listeners.add(callbackRef);
      return callbackRef;
    }
    removeHandleEvent(callbackRef) {
      let event = callbackRef(null, true);
      window.removeEventListener(`phx:${event}`, callbackRef);
      this.__listeners.delete(callbackRef);
    }
    upload(name, files) {
      return this.__view().dispatchUploads(null, name, files);
    }
    uploadTo(phxTarget, name, files) {
      return this.__view().withinTargets(phxTarget, (view, targetCtx) => {
        view.dispatchUploads(targetCtx, name, files);
      });
    }
    __cleanup__() {
      this.__listeners.forEach((callbackRef) => this.removeHandleEvent(callbackRef));
    }
  };
  var prependFormDataKey = (key, prefix) => {
    let isArray2 = key.endsWith("[]");
    let baseKey = isArray2 ? key.slice(0, -2) : key;
    baseKey = baseKey.replace(/([^\[\]]+)(\]?$)/, `${prefix}$1$2`);
    if (isArray2) {
      baseKey += "[]";
    }
    return baseKey;
  };
  var serializeForm = (form, metadata, onlyNames = []) => {
    const _a = metadata, { submitter } = _a, meta = __objRest(_a, ["submitter"]);
    let injectedElement;
    if (submitter && submitter.name) {
      const input = document.createElement("input");
      input.type = "hidden";
      const formId = submitter.getAttribute("form");
      if (formId) {
        input.setAttribute("form", formId);
      }
      input.name = submitter.name;
      input.value = submitter.value;
      submitter.parentElement.insertBefore(input, submitter);
      injectedElement = input;
    }
    const formData = new FormData(form);
    const toRemove = [];
    formData.forEach((val, key, _index) => {
      if (val instanceof File) {
        toRemove.push(key);
      }
    });
    toRemove.forEach((key) => formData.delete(key));
    const params = new URLSearchParams();
    let elements2 = Array.from(form.elements);
    for (let [key, val] of formData.entries()) {
      if (onlyNames.length === 0 || onlyNames.indexOf(key) >= 0) {
        let inputs = elements2.filter((input) => input.name === key);
        let isUnused = !inputs.some((input) => dom_default.private(input, PHX_HAS_FOCUSED) || dom_default.private(input, PHX_HAS_SUBMITTED));
        let hidden = inputs.every((input) => input.type === "hidden");
        if (isUnused && !(submitter && submitter.name == key) && !hidden) {
          params.append(prependFormDataKey(key, "_unused_"), "");
        }
        params.append(key, val);
      }
    }
    if (submitter && injectedElement) {
      submitter.parentElement.removeChild(injectedElement);
    }
    for (let metaKey in meta) {
      params.append(metaKey, meta[metaKey]);
    }
    return params.toString();
  };
  var View = class _View {
    static closestView(el2) {
      let liveViewEl = el2.closest(PHX_VIEW_SELECTOR);
      return liveViewEl ? dom_default.private(liveViewEl, "view") : null;
    }
    constructor(el2, liveSocket2, parentView, flash, liveReferer) {
      this.isDead = false;
      this.liveSocket = liveSocket2;
      this.flash = flash;
      this.parent = parentView;
      this.root = parentView ? parentView.root : this;
      this.el = el2;
      dom_default.putPrivate(this.el, "view", this);
      this.id = this.el.id;
      this.ref = 0;
      this.lastAckRef = null;
      this.childJoins = 0;
      this.loaderTimer = null;
      this.pendingDiffs = [];
      this.pendingForms = /* @__PURE__ */ new Set();
      this.redirect = false;
      this.href = null;
      this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;
      this.joinAttempts = 0;
      this.joinPending = true;
      this.destroyed = false;
      this.joinCallback = function(onDone) {
        onDone && onDone();
      };
      this.stopCallback = function() {
      };
      this.pendingJoinOps = this.parent ? null : [];
      this.viewHooks = {};
      this.formSubmits = [];
      this.children = this.parent ? null : {};
      this.root.children[this.id] = {};
      this.formsForRecovery = {};
      this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {
        let url = this.href && this.expandURL(this.href);
        return {
          redirect: this.redirect ? url : void 0,
          url: this.redirect ? void 0 : url || void 0,
          params: this.connectParams(liveReferer),
          session: this.getSession(),
          static: this.getStatic(),
          flash: this.flash
        };
      });
    }
    setHref(href) {
      this.href = href;
    }
    setRedirect(href) {
      this.redirect = true;
      this.href = href;
    }
    isMain() {
      return this.el.hasAttribute(PHX_MAIN);
    }
    connectParams(liveReferer) {
      let params = this.liveSocket.params(this.el);
      let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map((node) => node.src || node.href).filter((url) => typeof url === "string");
      if (manifest.length > 0) {
        params["_track_static"] = manifest;
      }
      params["_mounts"] = this.joinCount;
      params["_mount_attempts"] = this.joinAttempts;
      params["_live_referer"] = liveReferer;
      this.joinAttempts++;
      return params;
    }
    isConnected() {
      return this.channel.canPush();
    }
    getSession() {
      return this.el.getAttribute(PHX_SESSION);
    }
    getStatic() {
      let val = this.el.getAttribute(PHX_STATIC);
      return val === "" ? null : val;
    }
    destroy(callback2 = function() {
    }) {
      this.destroyAllChildren();
      this.destroyed = true;
      delete this.root.children[this.id];
      if (this.parent) {
        delete this.root.children[this.parent.id][this.id];
      }
      clearTimeout(this.loaderTimer);
      let onFinished = () => {
        callback2();
        for (let id in this.viewHooks) {
          this.destroyHook(this.viewHooks[id]);
        }
      };
      dom_default.markPhxChildDestroyed(this.el);
      this.log("destroyed", () => ["the child has been removed from the parent"]);
      this.channel.leave().receive("ok", onFinished).receive("error", onFinished).receive("timeout", onFinished);
    }
    setContainerClasses(...classes) {
      this.el.classList.remove(
        PHX_CONNECTED_CLASS,
        PHX_LOADING_CLASS,
        PHX_ERROR_CLASS,
        PHX_CLIENT_ERROR_CLASS,
        PHX_SERVER_ERROR_CLASS
      );
      this.el.classList.add(...classes);
    }
    showLoader(timeout) {
      clearTimeout(this.loaderTimer);
      if (timeout) {
        this.loaderTimer = setTimeout(() => this.showLoader(), timeout);
      } else {
        for (let id in this.viewHooks) {
          this.viewHooks[id].__disconnected();
        }
        this.setContainerClasses(PHX_LOADING_CLASS);
      }
    }
    execAll(binding) {
      dom_default.all(this.el, `[${binding}]`, (el2) => this.liveSocket.execJS(el2, el2.getAttribute(binding)));
    }
    hideLoader() {
      clearTimeout(this.loaderTimer);
      this.setContainerClasses(PHX_CONNECTED_CLASS);
      this.execAll(this.binding("connected"));
    }
    triggerReconnected() {
      for (let id in this.viewHooks) {
        this.viewHooks[id].__reconnected();
      }
    }
    log(kind, msgCallback) {
      this.liveSocket.log(this, kind, msgCallback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.liveSocket.transition(time, onStart, onDone);
    }
    // calls the callback with the view and target element for the given phxTarget
    // targets can be:
    //  * an element itself, then it is simply passed to liveSocket.owner;
    //  * a CID (Component ID), then we first search the component's element in the DOM
    //  * a selector, then we search the selector in the DOM and call the callback
    //    for each element found with the corresponding owner view
    withinTargets(phxTarget, callback2, dom = document, viewEl) {
      if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {
        return this.liveSocket.owner(phxTarget, (view) => callback2(view, phxTarget));
      }
      if (isCid(phxTarget)) {
        let targets = dom_default.findComponentNodeList(viewEl || this.el, phxTarget);
        if (targets.length === 0) {
          logError(`no component found matching phx-target of ${phxTarget}`);
        } else {
          callback2(this, parseInt(phxTarget));
        }
      } else {
        let targets = Array.from(dom.querySelectorAll(phxTarget));
        if (targets.length === 0) {
          logError(`nothing found matching the phx-target selector "${phxTarget}"`);
        }
        targets.forEach((target) => this.liveSocket.owner(target, (view) => callback2(view, target)));
      }
    }
    applyDiff(type, rawDiff, callback2) {
      this.log(type, () => ["", clone(rawDiff)]);
      let { diff, reply, events: events2, title } = Rendered.extract(rawDiff);
      callback2({ diff, reply, events: events2 });
      if (typeof title === "string" || type == "mount") {
        window.requestAnimationFrame(() => dom_default.putTitle(title));
      }
    }
    onJoin(resp) {
      let { rendered, container, liveview_version } = resp;
      if (container) {
        let [tag, attrs] = container;
        this.el = dom_default.replaceRootContainer(this.el, tag, attrs);
      }
      this.childJoins = 0;
      this.joinPending = true;
      this.flash = null;
      if (this.root === this) {
        this.formsForRecovery = this.getFormsForRecovery();
      }
      if (this.isMain() && window.history.state === null) {
        this.liveSocket.replaceRootHistory();
      }
      if (liveview_version !== this.liveSocket.version()) {
        console.error(`LiveView asset version mismatch. JavaScript version ${this.liveSocket.version()} vs. server ${liveview_version}. To avoid issues, please ensure that your assets use the same version as the server.`);
      }
      browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);
      this.applyDiff("mount", rendered, ({ diff, events: events2 }) => {
        this.rendered = new Rendered(this.id, diff);
        let [html, streams] = this.renderContainer(null, "join");
        this.dropPendingRefs();
        this.joinCount++;
        this.joinAttempts = 0;
        this.maybeRecoverForms(html, () => {
          this.onJoinComplete(resp, html, streams, events2);
        });
      });
    }
    dropPendingRefs() {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.refSrc()}"]`, (el2) => {
        el2.removeAttribute(PHX_REF_LOADING);
        el2.removeAttribute(PHX_REF_SRC);
        el2.removeAttribute(PHX_REF_LOCK);
      });
    }
    onJoinComplete({ live_patch }, html, streams, events2) {
      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {
        return this.applyJoinPatch(live_patch, html, streams, events2);
      }
      let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter((toEl) => {
        let fromEl = toEl.id && this.el.querySelector(`[id="${toEl.id}"]`);
        let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);
        if (phxStatic) {
          toEl.setAttribute(PHX_STATIC, phxStatic);
        }
        if (fromEl) {
          fromEl.setAttribute(PHX_ROOT_ID, this.root.id);
        }
        return this.joinChild(toEl);
      });
      if (newChildren.length === 0) {
        if (this.parent) {
          this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, streams, events2)]);
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
          this.applyJoinPatch(live_patch, html, streams, events2);
        }
      } else {
        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, streams, events2)]);
      }
    }
    attachTrueDocEl() {
      this.el = dom_default.byId(this.id);
      this.el.setAttribute(PHX_ROOT_ID, this.root.id);
    }
    // this is invoked for dead and live views, so we must filter by
    // by owner to ensure we aren't duplicating hooks across disconnect
    // and connected states. This also handles cases where hooks exist
    // in a root layout with a LV in the body
    execNewMounted(parent = this.el) {
      let phxViewportTop = this.binding(PHX_VIEWPORT_TOP);
      let phxViewportBottom = this.binding(PHX_VIEWPORT_BOTTOM);
      dom_default.all(parent, `[${phxViewportTop}], [${phxViewportBottom}]`, (hookEl) => {
        if (this.ownsElement(hookEl)) {
          dom_default.maintainPrivateHooks(hookEl, hookEl, phxViewportTop, phxViewportBottom);
          this.maybeAddNewHook(hookEl);
        }
      });
      dom_default.all(parent, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, (hookEl) => {
        if (this.ownsElement(hookEl)) {
          this.maybeAddNewHook(hookEl);
        }
      });
      dom_default.all(parent, `[${this.binding(PHX_MOUNTED)}]`, (el2) => {
        if (this.ownsElement(el2)) {
          this.maybeMounted(el2);
        }
      });
    }
    applyJoinPatch(live_patch, html, streams, events2) {
      this.attachTrueDocEl();
      let patch = new DOMPatch(this, this.el, this.id, html, streams, null);
      patch.markPrunableContentForRemoval();
      this.performPatch(patch, false, true);
      this.joinNewChildren();
      this.execNewMounted();
      this.joinPending = false;
      this.liveSocket.dispatchEvents(events2);
      this.applyPendingUpdates();
      if (live_patch) {
        let { kind, to: to2 } = live_patch;
        this.liveSocket.historyPatch(to2, kind);
      }
      this.hideLoader();
      if (this.joinCount > 1) {
        this.triggerReconnected();
      }
      this.stopCallback();
    }
    triggerBeforeUpdateHook(fromEl, toEl) {
      this.liveSocket.triggerDOM("onBeforeElUpdated", [fromEl, toEl]);
      let hook = this.getHook(fromEl);
      let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));
      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {
        hook.__beforeUpdate();
        return hook;
      }
    }
    maybeMounted(el2) {
      let phxMounted = el2.getAttribute(this.binding(PHX_MOUNTED));
      let hasBeenInvoked = phxMounted && dom_default.private(el2, "mounted");
      if (phxMounted && !hasBeenInvoked) {
        this.liveSocket.execJS(el2, phxMounted);
        dom_default.putPrivate(el2, "mounted", true);
      }
    }
    maybeAddNewHook(el2) {
      let newHook = this.addHook(el2);
      if (newHook) {
        newHook.__mounted();
      }
    }
    performPatch(patch, pruneCids, isJoinPatch = false) {
      let removedEls = [];
      let phxChildrenAdded = false;
      let updatedHookIds = /* @__PURE__ */ new Set();
      this.liveSocket.triggerDOM("onPatchStart", [patch.targetContainer]);
      patch.after("added", (el2) => {
        this.liveSocket.triggerDOM("onNodeAdded", [el2]);
        let phxViewportTop = this.binding(PHX_VIEWPORT_TOP);
        let phxViewportBottom = this.binding(PHX_VIEWPORT_BOTTOM);
        dom_default.maintainPrivateHooks(el2, el2, phxViewportTop, phxViewportBottom);
        this.maybeAddNewHook(el2);
        if (el2.getAttribute) {
          this.maybeMounted(el2);
        }
      });
      patch.after("phxChildAdded", (el2) => {
        if (dom_default.isPhxSticky(el2)) {
          this.liveSocket.joinRootViews();
        } else {
          phxChildrenAdded = true;
        }
      });
      patch.before("updated", (fromEl, toEl) => {
        let hook = this.triggerBeforeUpdateHook(fromEl, toEl);
        if (hook) {
          updatedHookIds.add(fromEl.id);
        }
      });
      patch.after("updated", (el2) => {
        if (updatedHookIds.has(el2.id)) {
          this.getHook(el2).__updated();
        }
      });
      patch.after("discarded", (el2) => {
        if (el2.nodeType === Node.ELEMENT_NODE) {
          removedEls.push(el2);
        }
      });
      patch.after("transitionsDiscarded", (els) => this.afterElementsRemoved(els, pruneCids));
      patch.perform(isJoinPatch);
      this.afterElementsRemoved(removedEls, pruneCids);
      this.liveSocket.triggerDOM("onPatchEnd", [patch.targetContainer]);
      return phxChildrenAdded;
    }
    afterElementsRemoved(elements2, pruneCids) {
      let destroyedCIDs = [];
      elements2.forEach((parent) => {
        let components = dom_default.all(parent, `[${PHX_COMPONENT}]`);
        let hooks = dom_default.all(parent, `[${this.binding(PHX_HOOK)}], [data-phx-hook]`);
        components.concat(parent).forEach((el2) => {
          let cid = this.componentID(el2);
          if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {
            destroyedCIDs.push(cid);
          }
        });
        hooks.concat(parent).forEach((hookEl) => {
          let hook = this.getHook(hookEl);
          hook && this.destroyHook(hook);
        });
      });
      if (pruneCids) {
        this.maybePushComponentsDestroyed(destroyedCIDs);
      }
    }
    joinNewChildren() {
      dom_default.findPhxChildren(this.el, this.id).forEach((el2) => this.joinChild(el2));
    }
    maybeRecoverForms(html, callback2) {
      const phxChange = this.binding("change");
      const oldForms = this.root.formsForRecovery;
      let template = document.createElement("template");
      template.innerHTML = html;
      const rootEl2 = template.content.firstElementChild;
      rootEl2.id = this.id;
      rootEl2.setAttribute(PHX_ROOT_ID, this.root.id);
      rootEl2.setAttribute(PHX_SESSION, this.getSession());
      rootEl2.setAttribute(PHX_STATIC, this.getStatic());
      rootEl2.setAttribute(PHX_PARENT_ID, this.parent ? this.parent.id : null);
      const formsToRecover = (
        // we go over all forms in the new DOM; because this is only the HTML for the current
        // view, we can be sure that all forms are owned by this view:
        dom_default.all(template.content, "form").filter((newForm) => newForm.id && oldForms[newForm.id]).filter((newForm) => !this.pendingForms.has(newForm.id)).filter((newForm) => oldForms[newForm.id].getAttribute(phxChange) === newForm.getAttribute(phxChange)).map((newForm) => {
          return [oldForms[newForm.id], newForm];
        })
      );
      if (formsToRecover.length === 0) {
        return callback2();
      }
      formsToRecover.forEach(([oldForm, newForm], i) => {
        this.pendingForms.add(newForm.id);
        this.pushFormRecovery(oldForm, newForm, template.content.firstElementChild, () => {
          this.pendingForms.delete(newForm.id);
          if (i === formsToRecover.length - 1) {
            callback2();
          }
        });
      });
    }
    getChildById(id) {
      return this.root.children[this.id][id];
    }
    getDescendentByEl(el2) {
      var _a;
      if (el2.id === this.id) {
        return this;
      } else {
        return (_a = this.children[el2.getAttribute(PHX_PARENT_ID)]) == null ? void 0 : _a[el2.id];
      }
    }
    destroyDescendent(id) {
      for (let parentId in this.root.children) {
        for (let childId in this.root.children[parentId]) {
          if (childId === id) {
            return this.root.children[parentId][childId].destroy();
          }
        }
      }
    }
    joinChild(el2) {
      let child = this.getChildById(el2.id);
      if (!child) {
        let view = new _View(el2, this.liveSocket, this);
        this.root.children[this.id][view.id] = view;
        view.join();
        this.childJoins++;
        return true;
      }
    }
    isJoinPending() {
      return this.joinPending;
    }
    ackJoin(_child) {
      this.childJoins--;
      if (this.childJoins === 0) {
        if (this.parent) {
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
        }
      }
    }
    onAllChildJoinsComplete() {
      this.pendingForms.clear();
      this.formsForRecovery = {};
      this.joinCallback(() => {
        this.pendingJoinOps.forEach(([view, op]) => {
          if (!view.isDestroyed()) {
            op();
          }
        });
        this.pendingJoinOps = [];
      });
    }
    update(diff, events2) {
      if (this.isJoinPending() || this.liveSocket.hasPendingLink() && this.root.isMain()) {
        return this.pendingDiffs.push({ diff, events: events2 });
      }
      this.rendered.mergeDiff(diff);
      let phxChildrenAdded = false;
      if (this.rendered.isComponentOnlyDiff(diff)) {
        this.liveSocket.time("component patch complete", () => {
          let parentCids = dom_default.findExistingParentCIDs(this.el, this.rendered.componentCIDs(diff));
          parentCids.forEach((parentCID) => {
            if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {
              phxChildrenAdded = true;
            }
          });
        });
      } else if (!isEmpty(diff)) {
        this.liveSocket.time("full patch complete", () => {
          let [html, streams] = this.renderContainer(diff, "update");
          let patch = new DOMPatch(this, this.el, this.id, html, streams, null);
          phxChildrenAdded = this.performPatch(patch, true);
        });
      }
      this.liveSocket.dispatchEvents(events2);
      if (phxChildrenAdded) {
        this.joinNewChildren();
      }
    }
    renderContainer(diff, kind) {
      return this.liveSocket.time(`toString diff (${kind})`, () => {
        let tag = this.el.tagName;
        let cids = diff ? this.rendered.componentCIDs(diff) : null;
        let [html, streams] = this.rendered.toString(cids);
        return [`<${tag}>${html}</${tag}>`, streams];
      });
    }
    componentPatch(diff, cid) {
      if (isEmpty(diff))
        return false;
      let [html, streams] = this.rendered.componentToString(cid);
      let patch = new DOMPatch(this, this.el, this.id, html, streams, cid);
      let childrenAdded = this.performPatch(patch, true);
      return childrenAdded;
    }
    getHook(el2) {
      return this.viewHooks[ViewHook.elementID(el2)];
    }
    addHook(el2) {
      let hookElId = ViewHook.elementID(el2);
      if (hookElId && !this.viewHooks[hookElId]) {
        let hook = dom_default.getCustomElHook(el2) || logError(`no hook found for custom element: ${el2.id}`);
        this.viewHooks[hookElId] = hook;
        hook.__attachView(this);
        return hook;
      } else if (hookElId || !el2.getAttribute) {
        return;
      } else {
        let hookName = el2.getAttribute(`data-phx-${PHX_HOOK}`) || el2.getAttribute(this.binding(PHX_HOOK));
        if (hookName && !this.ownsElement(el2)) {
          return;
        }
        let callbacks = this.liveSocket.getHookCallbacks(hookName);
        if (callbacks) {
          if (!el2.id) {
            logError(`no DOM ID for hook "${hookName}". Hooks require a unique ID on each element.`, el2);
          }
          let hook = new ViewHook(this, el2, callbacks);
          this.viewHooks[ViewHook.elementID(hook.el)] = hook;
          return hook;
        } else if (hookName !== null) {
          logError(`unknown hook found for "${hookName}"`, el2);
        }
      }
    }
    destroyHook(hook) {
      hook.__destroyed();
      hook.__cleanup__();
      delete this.viewHooks[ViewHook.elementID(hook.el)];
    }
    applyPendingUpdates() {
      this.pendingDiffs.forEach(({ diff, events: events2 }) => this.update(diff, events2));
      this.pendingDiffs = [];
      this.eachChild((child) => child.applyPendingUpdates());
    }
    eachChild(callback2) {
      let children = this.root.children[this.id] || {};
      for (let id in children) {
        callback2(this.getChildById(id));
      }
    }
    onChannel(event, cb) {
      this.liveSocket.onChannel(this.channel, event, (resp) => {
        if (this.isJoinPending()) {
          this.root.pendingJoinOps.push([this, () => cb(resp)]);
        } else {
          this.liveSocket.requestDOMUpdate(() => cb(resp));
        }
      });
    }
    bindChannel() {
      this.liveSocket.onChannel(this.channel, "diff", (rawDiff) => {
        this.liveSocket.requestDOMUpdate(() => {
          this.applyDiff("update", rawDiff, ({ diff, events: events2 }) => this.update(diff, events2));
        });
      });
      this.onChannel("redirect", ({ to: to2, flash }) => this.onRedirect({ to: to2, flash }));
      this.onChannel("live_patch", (redir) => this.onLivePatch(redir));
      this.onChannel("live_redirect", (redir) => this.onLiveRedirect(redir));
      this.channel.onError((reason) => this.onError(reason));
      this.channel.onClose((reason) => this.onClose(reason));
    }
    destroyAllChildren() {
      this.eachChild((child) => child.destroy());
    }
    onLiveRedirect(redir) {
      let { to: to2, kind, flash } = redir;
      let url = this.expandURL(to2);
      let e = new CustomEvent("phx:server-navigate", { detail: { to: to2, kind, flash } });
      this.liveSocket.historyRedirect(e, url, kind, flash);
    }
    onLivePatch(redir) {
      let { to: to2, kind } = redir;
      this.href = this.expandURL(to2);
      this.liveSocket.historyPatch(to2, kind);
    }
    expandURL(to2) {
      return to2.startsWith("/") ? `${window.location.protocol}//${window.location.host}${to2}` : to2;
    }
    onRedirect({ to: to2, flash, reloadToken }) {
      this.liveSocket.redirect(to2, flash, reloadToken);
    }
    isDestroyed() {
      return this.destroyed;
    }
    joinDead() {
      this.isDead = true;
    }
    joinPush() {
      this.joinPush = this.joinPush || this.channel.join();
      return this.joinPush;
    }
    join(callback2) {
      this.showLoader(this.liveSocket.loaderTimeout);
      this.bindChannel();
      if (this.isMain()) {
        this.stopCallback = this.liveSocket.withPageLoading({ to: this.href, kind: "initial" });
      }
      this.joinCallback = (onDone) => {
        onDone = onDone || function() {
        };
        callback2 ? callback2(this.joinCount, onDone) : onDone();
      };
      this.wrapPush(() => this.channel.join(), {
        ok: (resp) => this.liveSocket.requestDOMUpdate(() => this.onJoin(resp)),
        error: (error) => this.onJoinError(error),
        timeout: () => this.onJoinError({ reason: "timeout" })
      });
    }
    onJoinError(resp) {
      if (resp.reason === "reload") {
        this.log("error", () => [`failed mount with ${resp.status}. Falling back to page reload`, resp]);
        this.onRedirect({ to: this.root.href, reloadToken: resp.token });
        return;
      } else if (resp.reason === "unauthorized" || resp.reason === "stale") {
        this.log("error", () => ["unauthorized live_redirect. Falling back to page request", resp]);
        this.onRedirect({ to: this.root.href });
        return;
      }
      if (resp.redirect || resp.live_redirect) {
        this.joinPending = false;
        this.channel.leave();
      }
      if (resp.redirect) {
        return this.onRedirect(resp.redirect);
      }
      if (resp.live_redirect) {
        return this.onLiveRedirect(resp.live_redirect);
      }
      this.log("error", () => ["unable to join", resp]);
      if (this.isMain()) {
        this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS]);
        if (this.liveSocket.isConnected()) {
          this.liveSocket.reloadWithJitter(this);
        }
      } else {
        if (this.joinAttempts >= MAX_CHILD_JOIN_ATTEMPTS) {
          this.root.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS]);
          this.log("error", () => [`giving up trying to mount after ${MAX_CHILD_JOIN_ATTEMPTS} tries`, resp]);
          this.destroy();
        }
        let trueChildEl = dom_default.byId(this.el.id);
        if (trueChildEl) {
          dom_default.mergeAttrs(trueChildEl, this.el);
          this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS]);
          this.el = trueChildEl;
        } else {
          this.destroy();
        }
      }
    }
    onClose(reason) {
      if (this.isDestroyed()) {
        return;
      }
      if (this.isMain() && this.liveSocket.hasPendingLink() && reason !== "leave") {
        return this.liveSocket.reloadWithJitter(this);
      }
      this.destroyAllChildren();
      this.liveSocket.dropActiveElement(this);
      if (document.activeElement) {
        document.activeElement.blur();
      }
      if (this.liveSocket.isUnloaded()) {
        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);
      }
    }
    onError(reason) {
      this.onClose(reason);
      if (this.liveSocket.isConnected()) {
        this.log("error", () => ["view crashed", reason]);
      }
      if (!this.liveSocket.isUnloaded()) {
        if (this.liveSocket.isConnected()) {
          this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS]);
        } else {
          this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_CLIENT_ERROR_CLASS]);
        }
      }
    }
    displayError(classes) {
      if (this.isMain()) {
        dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: { to: this.href, kind: "error" } });
      }
      this.showLoader();
      this.setContainerClasses(...classes);
      this.execAll(this.binding("disconnected"));
    }
    wrapPush(callerPush, receives) {
      let latency = this.liveSocket.getLatencySim();
      let withLatency = latency ? (cb) => setTimeout(() => !this.isDestroyed() && cb(), latency) : (cb) => !this.isDestroyed() && cb();
      withLatency(() => {
        callerPush().receive("ok", (resp) => withLatency(() => receives.ok && receives.ok(resp))).receive("error", (reason) => withLatency(() => receives.error && receives.error(reason))).receive("timeout", () => withLatency(() => receives.timeout && receives.timeout()));
      });
    }
    pushWithReply(refGenerator, event, payload) {
      if (!this.isConnected()) {
        return Promise.reject({ error: "noconnection" });
      }
      let [ref, [el2], opts] = refGenerator ? refGenerator() : [null, [], {}];
      let oldJoinCount = this.joinCount;
      let onLoadingDone = function() {
      };
      if (opts.page_loading) {
        onLoadingDone = this.liveSocket.withPageLoading({ kind: "element", target: el2 });
      }
      if (typeof payload.cid !== "number") {
        delete payload.cid;
      }
      return new Promise((resolve2, reject) => {
        this.wrapPush(() => this.channel.push(event, payload, PUSH_TIMEOUT), {
          ok: (resp) => {
            if (ref !== null) {
              this.lastAckRef = ref;
            }
            let finish = (hookReply) => {
              if (resp.redirect) {
                this.onRedirect(resp.redirect);
              }
              if (resp.live_patch) {
                this.onLivePatch(resp.live_patch);
              }
              if (resp.live_redirect) {
                this.onLiveRedirect(resp.live_redirect);
              }
              onLoadingDone();
              resolve2({ resp, reply: hookReply });
            };
            if (resp.diff) {
              this.liveSocket.requestDOMUpdate(() => {
                this.applyDiff("update", resp.diff, ({ diff, reply, events: events2 }) => {
                  if (ref !== null) {
                    this.undoRefs(ref, payload.event);
                  }
                  this.update(diff, events2);
                  finish(reply);
                });
              });
            } else {
              if (ref !== null) {
                this.undoRefs(ref, payload.event);
              }
              finish(null);
            }
          },
          error: (reason) => reject({ error: reason }),
          timeout: () => {
            reject({ timeout: true });
            if (this.joinCount === oldJoinCount) {
              this.liveSocket.reloadWithJitter(this, () => {
                this.log("timeout", () => ["received timeout while communicating with server. Falling back to hard refresh for recovery"]);
              });
            }
          }
        });
      });
    }
    undoRefs(ref, phxEvent, onlyEls) {
      if (!this.isConnected()) {
        return;
      }
      let selector = `[${PHX_REF_SRC}="${this.refSrc()}"]`;
      if (onlyEls) {
        onlyEls = new Set(onlyEls);
        dom_default.all(document, selector, (parent) => {
          if (onlyEls && !onlyEls.has(parent)) {
            return;
          }
          dom_default.all(parent, selector, (child) => this.undoElRef(child, ref, phxEvent));
          this.undoElRef(parent, ref, phxEvent);
        });
      } else {
        dom_default.all(document, selector, (el2) => this.undoElRef(el2, ref, phxEvent));
      }
    }
    undoElRef(el2, ref, phxEvent) {
      let elRef = new ElementRef(el2);
      elRef.maybeUndo(ref, phxEvent, (clonedTree) => {
        let hook = this.triggerBeforeUpdateHook(el2, clonedTree);
        DOMPatch.patchWithClonedTree(el2, clonedTree, this.liveSocket);
        dom_default.all(el2, `[${PHX_REF_SRC}="${this.refSrc()}"]`, (child) => this.undoElRef(child, ref, phxEvent));
        this.execNewMounted(el2);
        if (hook) {
          hook.__updated();
        }
      });
    }
    refSrc() {
      return this.el.id;
    }
    putRef(elements2, phxEvent, eventType, opts = {}) {
      let newRef = this.ref++;
      let disableWith = this.binding(PHX_DISABLE_WITH);
      if (opts.loading) {
        let loadingEls = dom_default.all(document, opts.loading).map((el2) => {
          return { el: el2, lock: true, loading: true };
        });
        elements2 = elements2.concat(loadingEls);
      }
      for (let { el: el2, lock, loading } of elements2) {
        if (!lock && !loading) {
          throw new Error("putRef requires lock or loading");
        }
        el2.setAttribute(PHX_REF_SRC, this.refSrc());
        if (loading) {
          el2.setAttribute(PHX_REF_LOADING, newRef);
        }
        if (lock) {
          el2.setAttribute(PHX_REF_LOCK, newRef);
        }
        if (!loading || opts.submitter && !(el2 === opts.submitter || el2 === opts.form)) {
          continue;
        }
        let lockCompletePromise = new Promise((resolve2) => {
          el2.addEventListener(`phx:undo-lock:${newRef}`, () => resolve2(detail), { once: true });
        });
        let loadingCompletePromise = new Promise((resolve2) => {
          el2.addEventListener(`phx:undo-loading:${newRef}`, () => resolve2(detail), { once: true });
        });
        el2.classList.add(`phx-${eventType}-loading`);
        let disableText = el2.getAttribute(disableWith);
        if (disableText !== null) {
          if (!el2.getAttribute(PHX_DISABLE_WITH_RESTORE)) {
            el2.setAttribute(PHX_DISABLE_WITH_RESTORE, el2.innerText);
          }
          if (disableText !== "") {
            el2.innerText = disableText;
          }
          el2.setAttribute(PHX_DISABLED, el2.getAttribute(PHX_DISABLED) || el2.disabled);
          el2.setAttribute("disabled", "");
        }
        let detail = {
          event: phxEvent,
          eventType,
          ref: newRef,
          isLoading: loading,
          isLocked: lock,
          lockElements: elements2.filter(({ lock: lock2 }) => lock2).map(({ el: el22 }) => el22),
          loadingElements: elements2.filter(({ loading: loading2 }) => loading2).map(({ el: el22 }) => el22),
          unlock: (els) => {
            els = Array.isArray(els) ? els : [els];
            this.undoRefs(newRef, phxEvent, els);
          },
          lockComplete: lockCompletePromise,
          loadingComplete: loadingCompletePromise,
          lock: (lockEl) => {
            return new Promise((resolve2) => {
              if (this.isAcked(newRef)) {
                return resolve2(detail);
              }
              lockEl.setAttribute(PHX_REF_LOCK, newRef);
              lockEl.setAttribute(PHX_REF_SRC, this.refSrc());
              lockEl.addEventListener(`phx:lock-stop:${newRef}`, () => resolve2(detail), { once: true });
            });
          }
        };
        el2.dispatchEvent(new CustomEvent("phx:push", {
          detail,
          bubbles: true,
          cancelable: false
        }));
        if (phxEvent) {
          el2.dispatchEvent(new CustomEvent(`phx:push:${phxEvent}`, {
            detail,
            bubbles: true,
            cancelable: false
          }));
        }
      }
      return [newRef, elements2.map(({ el: el2 }) => el2), opts];
    }
    isAcked(ref) {
      return this.lastAckRef !== null && this.lastAckRef >= ref;
    }
    componentID(el2) {
      let cid = el2.getAttribute && el2.getAttribute(PHX_COMPONENT);
      return cid ? parseInt(cid) : null;
    }
    targetComponentID(target, targetCtx, opts = {}) {
      if (isCid(targetCtx)) {
        return targetCtx;
      }
      let cidOrSelector = opts.target || target.getAttribute(this.binding("target"));
      if (isCid(cidOrSelector)) {
        return parseInt(cidOrSelector);
      } else if (targetCtx && (cidOrSelector !== null || opts.target)) {
        return this.closestComponentID(targetCtx);
      } else {
        return null;
      }
    }
    closestComponentID(targetCtx) {
      if (isCid(targetCtx)) {
        return targetCtx;
      } else if (targetCtx) {
        return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), (el2) => this.ownsElement(el2) && this.componentID(el2));
      } else {
        return null;
      }
    }
    pushHookEvent(el2, targetCtx, event, payload, onReply) {
      if (!this.isConnected()) {
        this.log("hook", () => ["unable to push hook event. LiveView not connected", event, payload]);
        return false;
      }
      let [ref, els, opts] = this.putRef([{ el: el2, loading: true, lock: true }], event, "hook");
      this.pushWithReply(() => [ref, els, opts], "event", {
        type: "hook",
        event,
        value: payload,
        cid: this.closestComponentID(targetCtx)
      }).then(({ resp: _resp, reply: hookReply }) => onReply(hookReply, ref));
      return ref;
    }
    extractMeta(el2, meta, value) {
      let prefix = this.binding("value-");
      for (let i = 0; i < el2.attributes.length; i++) {
        if (!meta) {
          meta = {};
        }
        let name = el2.attributes[i].name;
        if (name.startsWith(prefix)) {
          meta[name.replace(prefix, "")] = el2.getAttribute(name);
        }
      }
      if (el2.value !== void 0 && !(el2 instanceof HTMLFormElement)) {
        if (!meta) {
          meta = {};
        }
        meta.value = el2.value;
        if (el2.tagName === "INPUT" && CHECKABLE_INPUTS.indexOf(el2.type) >= 0 && !el2.checked) {
          delete meta.value;
        }
      }
      if (value) {
        if (!meta) {
          meta = {};
        }
        for (let key in value) {
          meta[key] = value[key];
        }
      }
      return meta;
    }
    pushEvent(type, el2, targetCtx, phxEvent, meta, opts = {}, onReply) {
      this.pushWithReply(() => this.putRef([{ el: el2, loading: true, lock: true }], phxEvent, type, opts), "event", {
        type,
        event: phxEvent,
        value: this.extractMeta(el2, meta, opts.value),
        cid: this.targetComponentID(el2, targetCtx, opts)
      }).then(({ reply }) => onReply && onReply(reply));
    }
    pushFileProgress(fileEl, entryRef, progress, onReply = function() {
    }) {
      this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {
        view.pushWithReply(null, "progress", {
          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),
          ref: fileEl.getAttribute(PHX_UPLOAD_REF),
          entry_ref: entryRef,
          progress,
          cid: view.targetComponentID(fileEl.form, targetCtx)
        }).then(({ resp }) => onReply(resp));
      });
    }
    pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback2) {
      if (!inputEl.form) {
        throw new Error("form events require the input to be inside a form");
      }
      let uploads;
      let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx, opts);
      let refGenerator = () => {
        return this.putRef([
          { el: inputEl, loading: true, lock: true },
          { el: inputEl.form, loading: true, lock: true }
        ], phxEvent, "change", opts);
      };
      let formData;
      let meta = this.extractMeta(inputEl.form);
      if (inputEl instanceof HTMLButtonElement) {
        meta.submitter = inputEl;
      }
      if (inputEl.getAttribute(this.binding("change"))) {
        formData = serializeForm(inputEl.form, __spreadValues({ _target: opts._target }, meta), [inputEl.name]);
      } else {
        formData = serializeForm(inputEl.form, __spreadValues({ _target: opts._target }, meta));
      }
      if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {
        LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));
      }
      uploads = LiveUploader.serializeUploads(inputEl);
      let event = {
        type: "form",
        event: phxEvent,
        value: formData,
        uploads,
        cid
      };
      this.pushWithReply(refGenerator, "event", event).then(({ resp }) => {
        if (dom_default.isUploadInput(inputEl) && dom_default.isAutoUpload(inputEl)) {
          if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {
            let [ref, _els] = refGenerator();
            this.undoRefs(ref, phxEvent, [inputEl.form]);
            this.uploadFiles(inputEl.form, phxEvent, targetCtx, ref, cid, (_uploads) => {
              callback2 && callback2(resp);
              this.triggerAwaitingSubmit(inputEl.form, phxEvent);
              this.undoRefs(ref, phxEvent);
            });
          }
        } else {
          callback2 && callback2(resp);
        }
      });
    }
    triggerAwaitingSubmit(formEl, phxEvent) {
      let awaitingSubmit = this.getScheduledSubmit(formEl);
      if (awaitingSubmit) {
        let [_el, _ref, _opts, callback2] = awaitingSubmit;
        this.cancelSubmit(formEl, phxEvent);
        callback2();
      }
    }
    getScheduledSubmit(formEl) {
      return this.formSubmits.find(([el2, _ref, _opts, _callback]) => el2.isSameNode(formEl));
    }
    scheduleSubmit(formEl, ref, opts, callback2) {
      if (this.getScheduledSubmit(formEl)) {
        return true;
      }
      this.formSubmits.push([formEl, ref, opts, callback2]);
    }
    cancelSubmit(formEl, phxEvent) {
      this.formSubmits = this.formSubmits.filter(([el2, ref, _opts, _callback]) => {
        if (el2.isSameNode(formEl)) {
          this.undoRefs(ref, phxEvent);
          return false;
        } else {
          return true;
        }
      });
    }
    disableForm(formEl, phxEvent, opts = {}) {
      let filterIgnored = (el2) => {
        let userIgnored = closestPhxBinding(el2, `${this.binding(PHX_UPDATE)}=ignore`, el2.form);
        return !(userIgnored || closestPhxBinding(el2, "data-phx-update=ignore", el2.form));
      };
      let filterDisables = (el2) => {
        return el2.hasAttribute(this.binding(PHX_DISABLE_WITH));
      };
      let filterButton = (el2) => el2.tagName == "BUTTON";
      let filterInput = (el2) => ["INPUT", "TEXTAREA", "SELECT"].includes(el2.tagName);
      let formElements = Array.from(formEl.elements);
      let disables = formElements.filter(filterDisables);
      let buttons = formElements.filter(filterButton).filter(filterIgnored);
      let inputs = formElements.filter(filterInput).filter(filterIgnored);
      buttons.forEach((button) => {
        button.setAttribute(PHX_DISABLED, button.disabled);
        button.disabled = true;
      });
      inputs.forEach((input) => {
        input.setAttribute(PHX_READONLY, input.readOnly);
        input.readOnly = true;
        if (input.files) {
          input.setAttribute(PHX_DISABLED, input.disabled);
          input.disabled = true;
        }
      });
      let formEls = disables.concat(buttons).concat(inputs).map((el2) => {
        return { el: el2, loading: true, lock: true };
      });
      let els = [{ el: formEl, loading: true, lock: false }].concat(formEls).reverse();
      return this.putRef(els, phxEvent, "submit", opts);
    }
    pushFormSubmit(formEl, targetCtx, phxEvent, submitter, opts, onReply) {
      let refGenerator = () => this.disableForm(formEl, phxEvent, __spreadProps(__spreadValues({}, opts), {
        form: formEl,
        submitter
      }));
      let cid = this.targetComponentID(formEl, targetCtx);
      if (LiveUploader.hasUploadsInProgress(formEl)) {
        let [ref, _els] = refGenerator();
        let push = () => this.pushFormSubmit(formEl, targetCtx, phxEvent, submitter, opts, onReply);
        return this.scheduleSubmit(formEl, ref, opts, push);
      } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
        let [ref, els] = refGenerator();
        let proxyRefGen = () => [ref, els, opts];
        this.uploadFiles(formEl, phxEvent, targetCtx, ref, cid, (_uploads) => {
          if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
            return this.undoRefs(ref, phxEvent);
          }
          let meta = this.extractMeta(formEl);
          let formData = serializeForm(formEl, __spreadValues({ submitter }, meta));
          this.pushWithReply(proxyRefGen, "event", {
            type: "form",
            event: phxEvent,
            value: formData,
            cid
          }).then(({ resp }) => onReply(resp));
        });
      } else if (!(formEl.hasAttribute(PHX_REF_SRC) && formEl.classList.contains("phx-submit-loading"))) {
        let meta = this.extractMeta(formEl);
        let formData = serializeForm(formEl, __spreadValues({ submitter }, meta));
        this.pushWithReply(refGenerator, "event", {
          type: "form",
          event: phxEvent,
          value: formData,
          cid
        }).then(({ resp }) => onReply(resp));
      }
    }
    uploadFiles(formEl, phxEvent, targetCtx, ref, cid, onComplete) {
      let joinCountAtUpload = this.joinCount;
      let inputEls = LiveUploader.activeFileInputs(formEl);
      let numFileInputsInProgress = inputEls.length;
      inputEls.forEach((inputEl) => {
        let uploader = new LiveUploader(inputEl, this, () => {
          numFileInputsInProgress--;
          if (numFileInputsInProgress === 0) {
            onComplete();
          }
        });
        let entries = uploader.entries().map((entry) => entry.toPreflightPayload());
        if (entries.length === 0) {
          numFileInputsInProgress--;
          return;
        }
        let payload = {
          ref: inputEl.getAttribute(PHX_UPLOAD_REF),
          entries,
          cid: this.targetComponentID(inputEl.form, targetCtx)
        };
        this.log("upload", () => ["sending preflight request", payload]);
        this.pushWithReply(null, "allow_upload", payload).then(({ resp }) => {
          this.log("upload", () => ["got preflight response", resp]);
          uploader.entries().forEach((entry) => {
            if (resp.entries && !resp.entries[entry.ref]) {
              this.handleFailedEntryPreflight(entry.ref, "failed preflight", uploader);
            }
          });
          if (resp.error || Object.keys(resp.entries).length === 0) {
            this.undoRefs(ref, phxEvent);
            let errors = resp.error || [];
            errors.map(([entry_ref, reason]) => {
              this.handleFailedEntryPreflight(entry_ref, reason, uploader);
            });
          } else {
            let onError = (callback2) => {
              this.channel.onError(() => {
                if (this.joinCount === joinCountAtUpload) {
                  callback2();
                }
              });
            };
            uploader.initAdapterUpload(resp, onError, this.liveSocket);
          }
        });
      });
    }
    handleFailedEntryPreflight(uploadRef, reason, uploader) {
      if (uploader.isAutoUpload()) {
        let entry = uploader.entries().find((entry2) => entry2.ref === uploadRef.toString());
        if (entry) {
          entry.cancel();
        }
      } else {
        uploader.entries().map((entry) => entry.cancel());
      }
      this.log("upload", () => [`error for entry ${uploadRef}`, reason]);
    }
    dispatchUploads(targetCtx, name, filesOrBlobs) {
      let targetElement = this.targetCtxElement(targetCtx) || this.el;
      let inputs = dom_default.findUploadInputs(targetElement).filter((el2) => el2.name === name);
      if (inputs.length === 0) {
        logError(`no live file inputs found matching the name "${name}"`);
      } else if (inputs.length > 1) {
        logError(`duplicate live file inputs found matching the name "${name}"`);
      } else {
        dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, { detail: { files: filesOrBlobs } });
      }
    }
    targetCtxElement(targetCtx) {
      if (isCid(targetCtx)) {
        let [target] = dom_default.findComponentNodeList(this.el, targetCtx);
        return target;
      } else if (targetCtx) {
        return targetCtx;
      } else {
        return null;
      }
    }
    pushFormRecovery(oldForm, newForm, templateDom, callback2) {
      const phxChange = this.binding("change");
      const phxTarget = newForm.getAttribute(this.binding("target")) || newForm;
      const phxEvent = newForm.getAttribute(this.binding(PHX_AUTO_RECOVER)) || newForm.getAttribute(this.binding("change"));
      const inputs = Array.from(oldForm.elements).filter((el2) => dom_default.isFormInput(el2) && el2.name && !el2.hasAttribute(phxChange));
      if (inputs.length === 0) {
        return;
      }
      inputs.forEach((input2) => input2.hasAttribute(PHX_UPLOAD_REF) && LiveUploader.clearFiles(input2));
      let input = inputs.find((el2) => el2.type !== "hidden") || inputs[0];
      let pending = 0;
      this.withinTargets(phxTarget, (targetView, targetCtx) => {
        const cid = this.targetComponentID(newForm, targetCtx);
        pending++;
        let e = new CustomEvent("phx:form-recovery", { detail: { sourceElement: oldForm } });
        js_default.exec(e, "change", phxEvent, this, input, ["push", {
          _target: input.name,
          targetView,
          targetCtx,
          newCid: cid,
          callback: () => {
            pending--;
            if (pending === 0) {
              callback2();
            }
          }
        }]);
      }, templateDom, templateDom);
    }
    pushLinkPatch(e, href, targetEl, callback2) {
      let linkRef = this.liveSocket.setPendingLink(href);
      let loading = e.isTrusted && e.type !== "popstate";
      let refGen = targetEl ? () => this.putRef([{ el: targetEl, loading, lock: true }], null, "click") : null;
      let fallback = () => this.liveSocket.redirect(window.location.href);
      let url = href.startsWith("/") ? `${location.protocol}//${location.host}${href}` : href;
      this.pushWithReply(refGen, "live_patch", { url }).then(
        ({ resp }) => {
          this.liveSocket.requestDOMUpdate(() => {
            if (resp.link_redirect) {
              this.liveSocket.replaceMain(href, null, callback2, linkRef);
            } else {
              if (this.liveSocket.commitPendingLink(linkRef)) {
                this.href = href;
              }
              this.applyPendingUpdates();
              callback2 && callback2(linkRef);
            }
          });
        },
        ({ error: _error, timeout: _timeout }) => fallback()
      );
    }
    getFormsForRecovery() {
      if (this.joinCount === 0) {
        return {};
      }
      let phxChange = this.binding("change");
      return dom_default.all(this.el, `form[${phxChange}]`).filter((form) => form.id).filter((form) => form.elements.length > 0).filter((form) => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== "ignore").map((form) => form.cloneNode(true)).reduce((acc, form) => {
        acc[form.id] = form;
        return acc;
      }, {});
    }
    maybePushComponentsDestroyed(destroyedCIDs) {
      let willDestroyCIDs = destroyedCIDs.filter((cid) => {
        return dom_default.findComponentNodeList(this.el, cid).length === 0;
      });
      if (willDestroyCIDs.length > 0) {
        willDestroyCIDs.forEach((cid) => this.rendered.resetRender(cid));
        this.pushWithReply(null, "cids_will_destroy", { cids: willDestroyCIDs }).then(() => {
          this.liveSocket.requestDOMUpdate(() => {
            let completelyDestroyCIDs = willDestroyCIDs.filter((cid) => {
              return dom_default.findComponentNodeList(this.el, cid).length === 0;
            });
            if (completelyDestroyCIDs.length > 0) {
              this.pushWithReply(null, "cids_destroyed", { cids: completelyDestroyCIDs }).then(({ resp }) => {
                this.rendered.pruneCIDs(resp.cids);
              });
            }
          });
        });
      }
    }
    ownsElement(el2) {
      let parentViewEl = el2.closest(PHX_VIEW_SELECTOR);
      return el2.getAttribute(PHX_PARENT_ID) === this.id || parentViewEl && parentViewEl.id === this.id || !parentViewEl && this.isDead;
    }
    submitForm(form, targetCtx, phxEvent, submitter, opts = {}) {
      dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);
      const inputs = Array.from(form.elements);
      inputs.forEach((input) => dom_default.putPrivate(input, PHX_HAS_SUBMITTED, true));
      this.liveSocket.blurActiveElement(this);
      this.pushFormSubmit(form, targetCtx, phxEvent, submitter, opts, () => {
        this.liveSocket.restorePreviouslyActiveFocus();
      });
    }
    binding(kind) {
      return this.liveSocket.binding(kind);
    }
  };
  var LiveSocket = class {
    constructor(url, phxSocket, opts = {}) {
      this.unloaded = false;
      if (!phxSocket || phxSocket.constructor.name === "Object") {
        throw new Error(`
      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:

          import {Socket} from "phoenix"
          import {LiveSocket} from "phoenix_live_view"
          let liveSocket = new LiveSocket("/live", Socket, {...})
      `);
      }
      this.socket = new phxSocket(url, opts);
      this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;
      this.opts = opts;
      this.params = closure2(opts.params || {});
      this.viewLogger = opts.viewLogger;
      this.metadataCallbacks = opts.metadata || {};
      this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});
      this.activeElement = null;
      this.prevActive = null;
      this.silenced = false;
      this.main = null;
      this.outgoingMainEl = null;
      this.clickStartedAtTarget = null;
      this.linkRef = 1;
      this.roots = {};
      this.href = window.location.href;
      this.pendingLink = null;
      this.currentLocation = clone(window.location);
      this.hooks = opts.hooks || {};
      this.uploaders = opts.uploaders || {};
      this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;
      this.reloadWithJitterTimer = null;
      this.maxReloads = opts.maxReloads || MAX_RELOADS;
      this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;
      this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;
      this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;
      this.localStorage = opts.localStorage || window.localStorage;
      this.sessionStorage = opts.sessionStorage || window.sessionStorage;
      this.boundTopLevelEvents = false;
      this.boundEventNames = /* @__PURE__ */ new Set();
      this.serverCloseRef = null;
      this.domCallbacks = Object.assign(
        {
          jsQuerySelectorAll: null,
          onPatchStart: closure2(),
          onPatchEnd: closure2(),
          onNodeAdded: closure2(),
          onBeforeElUpdated: closure2()
        },
        opts.dom || {}
      );
      this.transitions = new TransitionSet();
      this.currentHistoryPosition = parseInt(this.sessionStorage.getItem(PHX_LV_HISTORY_POSITION)) || 0;
      window.addEventListener("pagehide", (_e) => {
        this.unloaded = true;
      });
      this.socket.onOpen(() => {
        if (this.isUnloaded()) {
          window.location.reload();
        }
      });
    }
    // public
    version() {
      return "1.0.2";
    }
    isProfileEnabled() {
      return this.sessionStorage.getItem(PHX_LV_PROFILE) === "true";
    }
    isDebugEnabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "true";
    }
    isDebugDisabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "false";
    }
    enableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "true");
    }
    enableProfiling() {
      this.sessionStorage.setItem(PHX_LV_PROFILE, "true");
    }
    disableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "false");
    }
    disableProfiling() {
      this.sessionStorage.removeItem(PHX_LV_PROFILE);
    }
    enableLatencySim(upperBoundMs) {
      this.enableDebug();
      console.log("latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable");
      this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);
    }
    disableLatencySim() {
      this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);
    }
    getLatencySim() {
      let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);
      return str ? parseInt(str) : null;
    }
    getSocket() {
      return this.socket;
    }
    connect() {
      if (window.location.hostname === "localhost" && !this.isDebugDisabled()) {
        this.enableDebug();
      }
      let doConnect = () => {
        this.resetReloadStatus();
        if (this.joinRootViews()) {
          this.bindTopLevelEvents();
          this.socket.connect();
        } else if (this.main) {
          this.socket.connect();
        } else {
          this.bindTopLevelEvents({ dead: true });
        }
        this.joinDeadView();
      };
      if (["complete", "loaded", "interactive"].indexOf(document.readyState) >= 0) {
        doConnect();
      } else {
        document.addEventListener("DOMContentLoaded", () => doConnect());
      }
    }
    disconnect(callback2) {
      clearTimeout(this.reloadWithJitterTimer);
      if (this.serverCloseRef) {
        this.socket.off(this.serverCloseRef);
        this.serverCloseRef = null;
      }
      this.socket.disconnect(callback2);
    }
    replaceTransport(transport) {
      clearTimeout(this.reloadWithJitterTimer);
      this.socket.replaceTransport(transport);
      this.connect();
    }
    execJS(el2, encodedJS, eventType = null) {
      let e = new CustomEvent("phx:exec", { detail: { sourceElement: el2 } });
      this.owner(el2, (view) => js_default.exec(e, eventType, encodedJS, view, el2));
    }
    // private
    execJSHookPush(el2, phxEvent, data, callback2) {
      this.withinOwners(el2, (view) => {
        let e = new CustomEvent("phx:exec", { detail: { sourceElement: el2 } });
        js_default.exec(e, "hook", phxEvent, view, el2, ["push", { data, callback: callback2 }]);
      });
    }
    unload() {
      if (this.unloaded) {
        return;
      }
      if (this.main && this.isConnected()) {
        this.log(this.main, "socket", () => ["disconnect for page nav"]);
      }
      this.unloaded = true;
      this.destroyAllViews();
      this.disconnect();
    }
    triggerDOM(kind, args) {
      this.domCallbacks[kind](...args);
    }
    time(name, func) {
      if (!this.isProfileEnabled() || !console.time) {
        return func();
      }
      console.time(name);
      let result = func();
      console.timeEnd(name);
      return result;
    }
    log(view, kind, msgCallback) {
      if (this.viewLogger) {
        let [msg, obj] = msgCallback();
        this.viewLogger(view, kind, msg, obj);
      } else if (this.isDebugEnabled()) {
        let [msg, obj] = msgCallback();
        debug(view, kind, msg, obj);
      }
    }
    requestDOMUpdate(callback2) {
      this.transitions.after(callback2);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.transitions.addTransition(time, onStart, onDone);
    }
    onChannel(channel, event, cb) {
      channel.on(event, (data) => {
        let latency = this.getLatencySim();
        if (!latency) {
          cb(data);
        } else {
          setTimeout(() => cb(data), latency);
        }
      });
    }
    reloadWithJitter(view, log) {
      clearTimeout(this.reloadWithJitterTimer);
      this.disconnect();
      let minMs = this.reloadJitterMin;
      let maxMs = this.reloadJitterMax;
      let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
      let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, (count) => count + 1);
      if (tries >= this.maxReloads) {
        afterMs = this.failsafeJitter;
      }
      this.reloadWithJitterTimer = setTimeout(() => {
        if (view.isDestroyed() || view.isConnected()) {
          return;
        }
        view.destroy();
        log ? log() : this.log(view, "join", () => [`encountered ${tries} consecutive reloads`]);
        if (tries >= this.maxReloads) {
          this.log(view, "join", () => [`exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`]);
        }
        if (this.hasPendingLink()) {
          window.location = this.pendingLink;
        } else {
          window.location.reload();
        }
      }, afterMs);
    }
    getHookCallbacks(name) {
      return name && name.startsWith("Phoenix.") ? hooks_default[name.split(".")[1]] : this.hooks[name];
    }
    isUnloaded() {
      return this.unloaded;
    }
    isConnected() {
      return this.socket.isConnected();
    }
    getBindingPrefix() {
      return this.bindingPrefix;
    }
    binding(kind) {
      return `${this.getBindingPrefix()}${kind}`;
    }
    channel(topic, params) {
      return this.socket.channel(topic, params);
    }
    joinDeadView() {
      let body = document.body;
      if (body && !this.isPhxView(body) && !this.isPhxView(document.firstElementChild)) {
        let view = this.newRootView(body);
        view.setHref(this.getHref());
        view.joinDead();
        if (!this.main) {
          this.main = view;
        }
        window.requestAnimationFrame(() => {
          var _a;
          view.execNewMounted();
          this.maybeScroll((_a = history.state) == null ? void 0 : _a.scroll);
        });
      }
    }
    joinRootViews() {
      let rootsFound = false;
      dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, (rootEl2) => {
        if (!this.getRootById(rootEl2.id)) {
          let view = this.newRootView(rootEl2);
          view.setHref(this.getHref());
          view.join();
          if (rootEl2.hasAttribute(PHX_MAIN)) {
            this.main = view;
          }
        }
        rootsFound = true;
      });
      return rootsFound;
    }
    redirect(to2, flash, reloadToken) {
      if (reloadToken) {
        browser_default.setCookie(PHX_RELOAD_STATUS, reloadToken, 60);
      }
      this.unload();
      browser_default.redirect(to2, flash);
    }
    replaceMain(href, flash, callback2 = null, linkRef = this.setPendingLink(href)) {
      let liveReferer = this.currentLocation.href;
      this.outgoingMainEl = this.outgoingMainEl || this.main.el;
      let removeEls = dom_default.all(this.outgoingMainEl, `[${this.binding("remove")}]`);
      let newMainEl = dom_default.cloneNode(this.outgoingMainEl, "");
      this.main.showLoader(this.loaderTimeout);
      this.main.destroy();
      this.main = this.newRootView(newMainEl, flash, liveReferer);
      this.main.setRedirect(href);
      this.transitionRemoves(removeEls, true);
      this.main.join((joinCount, onDone) => {
        if (joinCount === 1 && this.commitPendingLink(linkRef)) {
          this.requestDOMUpdate(() => {
            removeEls.forEach((el2) => el2.remove());
            dom_default.findPhxSticky(document).forEach((el2) => newMainEl.appendChild(el2));
            this.outgoingMainEl.replaceWith(newMainEl);
            this.outgoingMainEl = null;
            callback2 && callback2(linkRef);
            onDone();
          });
        }
      });
    }
    transitionRemoves(elements2, skipSticky, callback2) {
      let removeAttr = this.binding("remove");
      if (skipSticky) {
        const stickies = dom_default.findPhxSticky(document) || [];
        elements2 = elements2.filter((el2) => !dom_default.isChildOfAny(el2, stickies));
      }
      let silenceEvents = (e) => {
        e.preventDefault();
        e.stopImmediatePropagation();
      };
      elements2.forEach((el2) => {
        for (let event of this.boundEventNames) {
          el2.addEventListener(event, silenceEvents, true);
        }
        this.execJS(el2, el2.getAttribute(removeAttr), "remove");
      });
      this.requestDOMUpdate(() => {
        elements2.forEach((el2) => {
          for (let event of this.boundEventNames) {
            el2.removeEventListener(event, silenceEvents, true);
          }
        });
        callback2 && callback2();
      });
    }
    isPhxView(el2) {
      return el2.getAttribute && el2.getAttribute(PHX_SESSION) !== null;
    }
    newRootView(el2, flash, liveReferer) {
      let view = new View(el2, this, null, flash, liveReferer);
      this.roots[view.id] = view;
      return view;
    }
    owner(childEl, callback2) {
      let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), (el2) => this.getViewByEl(el2)) || this.main;
      return view && callback2 ? callback2(view) : view;
    }
    withinOwners(childEl, callback2) {
      this.owner(childEl, (view) => callback2(view, childEl));
    }
    getViewByEl(el2) {
      let rootId = el2.getAttribute(PHX_ROOT_ID);
      return maybe(this.getRootById(rootId), (root) => root.getDescendentByEl(el2));
    }
    getRootById(id) {
      return this.roots[id];
    }
    destroyAllViews() {
      for (let id in this.roots) {
        this.roots[id].destroy();
        delete this.roots[id];
      }
      this.main = null;
    }
    destroyViewByEl(el2) {
      let root = this.getRootById(el2.getAttribute(PHX_ROOT_ID));
      if (root && root.id === el2.id) {
        root.destroy();
        delete this.roots[root.id];
      } else if (root) {
        root.destroyDescendent(el2.id);
      }
    }
    getActiveElement() {
      return document.activeElement;
    }
    dropActiveElement(view) {
      if (this.prevActive && view.ownsElement(this.prevActive)) {
        this.prevActive = null;
      }
    }
    restorePreviouslyActiveFocus() {
      if (this.prevActive && this.prevActive !== document.body) {
        this.prevActive.focus();
      }
    }
    blurActiveElement() {
      this.prevActive = this.getActiveElement();
      if (this.prevActive !== document.body) {
        this.prevActive.blur();
      }
    }
    bindTopLevelEvents({ dead } = {}) {
      if (this.boundTopLevelEvents) {
        return;
      }
      this.boundTopLevelEvents = true;
      this.serverCloseRef = this.socket.onClose((event) => {
        if (event && event.code === 1e3 && this.main) {
          return this.reloadWithJitter(this.main);
        }
      });
      document.body.addEventListener("click", function() {
      });
      window.addEventListener("pageshow", (e) => {
        if (e.persisted) {
          this.getSocket().disconnect();
          this.withPageLoading({ to: window.location.href, kind: "redirect" });
          window.location.reload();
        }
      }, true);
      if (!dead) {
        this.bindNav();
      }
      this.bindClicks();
      if (!dead) {
        this.bindForms();
      }
      this.bind({ keyup: "keyup", keydown: "keydown" }, (e, type, view, targetEl, phxEvent, _phxTarget) => {
        let matchKey = targetEl.getAttribute(this.binding(PHX_KEY));
        let pressedKey = e.key && e.key.toLowerCase();
        if (matchKey && matchKey.toLowerCase() !== pressedKey) {
          return;
        }
        let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
        js_default.exec(e, type, phxEvent, view, targetEl, ["push", { data }]);
      });
      this.bind({ blur: "focusout", focus: "focusin" }, (e, type, view, targetEl, phxEvent, phxTarget) => {
        if (!phxTarget) {
          let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
          js_default.exec(e, type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      this.bind({ blur: "blur", focus: "focus" }, (e, type, view, targetEl, phxEvent, phxTarget) => {
        if (phxTarget === "window") {
          let data = this.eventMeta(type, e, targetEl);
          js_default.exec(e, type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      this.on("dragover", (e) => e.preventDefault());
      this.on("drop", (e) => {
        e.preventDefault();
        let dropTargetId = maybe(closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)), (trueTarget) => {
          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));
        });
        let dropTarget = dropTargetId && document.getElementById(dropTargetId);
        let files = Array.from(e.dataTransfer.files || []);
        if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {
          return;
        }
        LiveUploader.trackFiles(dropTarget, files, e.dataTransfer);
        dropTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
      this.on(PHX_TRACK_UPLOADS, (e) => {
        let uploadTarget = e.target;
        if (!dom_default.isUploadInput(uploadTarget)) {
          return;
        }
        let files = Array.from(e.detail.files || []).filter((f) => f instanceof File || f instanceof Blob);
        LiveUploader.trackFiles(uploadTarget, files);
        uploadTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
    }
    eventMeta(eventName, e, targetEl) {
      let callback2 = this.metadataCallbacks[eventName];
      return callback2 ? callback2(e, targetEl) : {};
    }
    setPendingLink(href) {
      this.linkRef++;
      this.pendingLink = href;
      this.resetReloadStatus();
      return this.linkRef;
    }
    // anytime we are navigating or connecting, drop reload cookie in case
    // we issue the cookie but the next request was interrupted and the server never dropped it
    resetReloadStatus() {
      browser_default.deleteCookie(PHX_RELOAD_STATUS);
    }
    commitPendingLink(linkRef) {
      if (this.linkRef !== linkRef) {
        return false;
      } else {
        this.href = this.pendingLink;
        this.pendingLink = null;
        return true;
      }
    }
    getHref() {
      return this.href;
    }
    hasPendingLink() {
      return !!this.pendingLink;
    }
    bind(events2, callback2) {
      for (let event in events2) {
        let browserEventName = events2[event];
        this.on(browserEventName, (e) => {
          let binding = this.binding(event);
          let windowBinding = this.binding(`window-${event}`);
          let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);
          if (targetPhxEvent) {
            this.debounce(e.target, e, browserEventName, () => {
              this.withinOwners(e.target, (view) => {
                callback2(e, event, view, e.target, targetPhxEvent, null);
              });
            });
          } else {
            dom_default.all(document, `[${windowBinding}]`, (el2) => {
              let phxEvent = el2.getAttribute(windowBinding);
              this.debounce(el2, e, browserEventName, () => {
                this.withinOwners(el2, (view) => {
                  callback2(e, event, view, el2, phxEvent, "window");
                });
              });
            });
          }
        });
      }
    }
    bindClicks() {
      this.on("mousedown", (e) => this.clickStartedAtTarget = e.target);
      this.bindClick("click", "click");
    }
    bindClick(eventName, bindingName) {
      let click = this.binding(bindingName);
      window.addEventListener(eventName, (e) => {
        let target = null;
        if (e.detail === 0)
          this.clickStartedAtTarget = e.target;
        let clickStartedAtTarget = this.clickStartedAtTarget || e.target;
        target = closestPhxBinding(e.target, click);
        this.dispatchClickAway(e, clickStartedAtTarget);
        this.clickStartedAtTarget = null;
        let phxEvent = target && target.getAttribute(click);
        if (!phxEvent) {
          if (dom_default.isNewPageClick(e, window.location)) {
            this.unload();
          }
          return;
        }
        if (target.getAttribute("href") === "#") {
          e.preventDefault();
        }
        if (target.hasAttribute(PHX_REF_SRC)) {
          return;
        }
        this.debounce(target, e, "click", () => {
          this.withinOwners(target, (view) => {
            js_default.exec(e, "click", phxEvent, view, target, ["push", { data: this.eventMeta("click", e, target) }]);
          });
        });
      }, false);
    }
    dispatchClickAway(e, clickStartedAt) {
      let phxClickAway = this.binding("click-away");
      dom_default.all(document, `[${phxClickAway}]`, (el2) => {
        if (!(el2.isSameNode(clickStartedAt) || el2.contains(clickStartedAt))) {
          this.withinOwners(el2, (view) => {
            let phxEvent = el2.getAttribute(phxClickAway);
            if (js_default.isVisible(el2) && js_default.isInViewport(el2)) {
              js_default.exec(e, "click", phxEvent, view, el2, ["push", { data: this.eventMeta("click", e, e.target) }]);
            }
          });
        }
      });
    }
    bindNav() {
      if (!browser_default.canPushState()) {
        return;
      }
      if (history.scrollRestoration) {
        history.scrollRestoration = "manual";
      }
      let scrollTimer = null;
      window.addEventListener("scroll", (_e) => {
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => {
          browser_default.updateCurrentState((state) => Object.assign(state, { scroll: window.scrollY }));
        }, 100);
      });
      window.addEventListener("popstate", (event) => {
        if (!this.registerNewLocation(window.location)) {
          return;
        }
        let { type, backType, id, root, scroll, position } = event.state || {};
        let href = window.location.href;
        let isForward = position > this.currentHistoryPosition;
        type = isForward ? type : backType || type;
        this.currentHistoryPosition = position || 0;
        this.sessionStorage.setItem(PHX_LV_HISTORY_POSITION, this.currentHistoryPosition.toString());
        dom_default.dispatchEvent(window, "phx:navigate", { detail: { href, patch: type === "patch", pop: true, direction: isForward ? "forward" : "backward" } });
        this.requestDOMUpdate(() => {
          if (this.main.isConnected() && (type === "patch" && id === this.main.id)) {
            this.main.pushLinkPatch(event, href, null, () => {
              this.maybeScroll(scroll);
            });
          } else {
            this.replaceMain(href, null, () => {
              if (root) {
                this.replaceRootHistory();
              }
              this.maybeScroll(scroll);
            });
          }
        });
      }, false);
      window.addEventListener("click", (e) => {
        let target = closestPhxBinding(e.target, PHX_LIVE_LINK);
        let type = target && target.getAttribute(PHX_LIVE_LINK);
        if (!type || !this.isConnected() || !this.main || dom_default.wantsNewTab(e)) {
          return;
        }
        let href = target.href instanceof SVGAnimatedString ? target.href.baseVal : target.href;
        let linkState = target.getAttribute(PHX_LINK_STATE);
        e.preventDefault();
        e.stopImmediatePropagation();
        if (this.pendingLink === href) {
          return;
        }
        this.requestDOMUpdate(() => {
          if (type === "patch") {
            this.pushHistoryPatch(e, href, linkState, target);
          } else if (type === "redirect") {
            this.historyRedirect(e, href, linkState, null, target);
          } else {
            throw new Error(`expected ${PHX_LIVE_LINK} to be "patch" or "redirect", got: ${type}`);
          }
          let phxClick = target.getAttribute(this.binding("click"));
          if (phxClick) {
            this.requestDOMUpdate(() => this.execJS(target, phxClick, "click"));
          }
        });
      }, false);
    }
    maybeScroll(scroll) {
      if (typeof scroll === "number") {
        requestAnimationFrame(() => {
          window.scrollTo(0, scroll);
        });
      }
    }
    dispatchEvent(event, payload = {}) {
      dom_default.dispatchEvent(window, `phx:${event}`, { detail: payload });
    }
    dispatchEvents(events2) {
      events2.forEach(([event, payload]) => this.dispatchEvent(event, payload));
    }
    withPageLoading(info, callback2) {
      dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: info });
      let done = () => dom_default.dispatchEvent(window, "phx:page-loading-stop", { detail: info });
      return callback2 ? callback2(done) : done;
    }
    pushHistoryPatch(e, href, linkState, targetEl) {
      if (!this.isConnected() || !this.main.isMain()) {
        return browser_default.redirect(href);
      }
      this.withPageLoading({ to: href, kind: "patch" }, (done) => {
        this.main.pushLinkPatch(e, href, targetEl, (linkRef) => {
          this.historyPatch(href, linkState, linkRef);
          done();
        });
      });
    }
    historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {
      if (!this.commitPendingLink(linkRef)) {
        return;
      }
      this.currentHistoryPosition++;
      this.sessionStorage.setItem(PHX_LV_HISTORY_POSITION, this.currentHistoryPosition.toString());
      browser_default.updateCurrentState((state) => __spreadProps(__spreadValues({}, state), { backType: "patch" }));
      browser_default.pushState(linkState, {
        type: "patch",
        id: this.main.id,
        position: this.currentHistoryPosition
      }, href);
      dom_default.dispatchEvent(window, "phx:navigate", { detail: { patch: true, href, pop: false, direction: "forward" } });
      this.registerNewLocation(window.location);
    }
    historyRedirect(e, href, linkState, flash, targetEl) {
      if (targetEl && e.isTrusted && e.type !== "popstate") {
        targetEl.classList.add("phx-click-loading");
      }
      if (!this.isConnected() || !this.main.isMain()) {
        return browser_default.redirect(href, flash);
      }
      if (/^\/$|^\/[^\/]+.*$/.test(href)) {
        let { protocol, host } = window.location;
        href = `${protocol}//${host}${href}`;
      }
      let scroll = window.scrollY;
      this.withPageLoading({ to: href, kind: "redirect" }, (done) => {
        this.replaceMain(href, flash, (linkRef) => {
          if (linkRef === this.linkRef) {
            this.currentHistoryPosition++;
            this.sessionStorage.setItem(PHX_LV_HISTORY_POSITION, this.currentHistoryPosition.toString());
            browser_default.updateCurrentState((state) => __spreadProps(__spreadValues({}, state), { backType: "redirect" }));
            browser_default.pushState(linkState, {
              type: "redirect",
              id: this.main.id,
              scroll,
              position: this.currentHistoryPosition
            }, href);
            dom_default.dispatchEvent(window, "phx:navigate", { detail: { href, patch: false, pop: false, direction: "forward" } });
            this.registerNewLocation(window.location);
          }
          done();
        });
      });
    }
    replaceRootHistory() {
      browser_default.pushState("replace", {
        root: true,
        type: "patch",
        id: this.main.id,
        position: this.currentHistoryPosition
        // Preserve current position
      });
    }
    registerNewLocation(newLocation) {
      let { pathname, search } = this.currentLocation;
      if (pathname + search === newLocation.pathname + newLocation.search) {
        return false;
      } else {
        this.currentLocation = clone(newLocation);
        return true;
      }
    }
    bindForms() {
      let iterations = 0;
      let externalFormSubmitted = false;
      this.on("submit", (e) => {
        let phxSubmit = e.target.getAttribute(this.binding("submit"));
        let phxChange = e.target.getAttribute(this.binding("change"));
        if (!externalFormSubmitted && phxChange && !phxSubmit) {
          externalFormSubmitted = true;
          e.preventDefault();
          this.withinOwners(e.target, (view) => {
            view.disableForm(e.target);
            window.requestAnimationFrame(() => {
              if (dom_default.isUnloadableFormSubmit(e)) {
                this.unload();
              }
              e.target.submit();
            });
          });
        }
      });
      this.on("submit", (e) => {
        let phxEvent = e.target.getAttribute(this.binding("submit"));
        if (!phxEvent) {
          if (dom_default.isUnloadableFormSubmit(e)) {
            this.unload();
          }
          return;
        }
        e.preventDefault();
        e.target.disabled = true;
        this.withinOwners(e.target, (view) => {
          js_default.exec(e, "submit", phxEvent, view, e.target, ["push", { submitter: e.submitter }]);
        });
      });
      for (let type of ["change", "input"]) {
        this.on(type, (e) => {
          if (e instanceof CustomEvent && e.target.form === void 0) {
            if (e.detail && e.detail.dispatcher) {
              throw new Error(`dispatching a custom ${type} event is only supported on input elements inside a form`);
            }
            return;
          }
          let phxChange = this.binding("change");
          let input = e.target;
          if (e.isComposing) {
            const key = `composition-listener-${type}`;
            if (!dom_default.private(input, key)) {
              dom_default.putPrivate(input, key, true);
              input.addEventListener("compositionend", () => {
                input.dispatchEvent(new Event(type, { bubbles: true }));
                dom_default.deletePrivate(input, key);
              }, { once: true });
            }
            return;
          }
          let inputEvent = input.getAttribute(phxChange);
          let formEvent = input.form && input.form.getAttribute(phxChange);
          let phxEvent = inputEvent || formEvent;
          if (!phxEvent) {
            return;
          }
          if (input.type === "number" && input.validity && input.validity.badInput) {
            return;
          }
          let dispatcher = inputEvent ? input : input.form;
          let currentIterations = iterations;
          iterations++;
          let { at, type: lastType } = dom_default.private(input, "prev-iteration") || {};
          if (at === currentIterations - 1 && type === "change" && lastType === "input") {
            return;
          }
          dom_default.putPrivate(input, "prev-iteration", { at: currentIterations, type });
          this.debounce(input, e, type, () => {
            this.withinOwners(dispatcher, (view) => {
              dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);
              js_default.exec(e, "change", phxEvent, view, input, ["push", { _target: e.target.name, dispatcher }]);
            });
          });
        });
      }
      this.on("reset", (e) => {
        let form = e.target;
        dom_default.resetForm(form);
        let input = Array.from(form.elements).find((el2) => el2.type === "reset");
        if (input) {
          window.requestAnimationFrame(() => {
            input.dispatchEvent(new Event("input", { bubbles: true, cancelable: false }));
          });
        }
      });
    }
    debounce(el2, event, eventType, callback2) {
      if (eventType === "blur" || eventType === "focusout") {
        return callback2();
      }
      let phxDebounce = this.binding(PHX_DEBOUNCE);
      let phxThrottle = this.binding(PHX_THROTTLE);
      let defaultDebounce = this.defaults.debounce.toString();
      let defaultThrottle = this.defaults.throttle.toString();
      this.withinOwners(el2, (view) => {
        let asyncFilter = () => !view.isDestroyed() && document.body.contains(el2);
        dom_default.debounce(el2, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, () => {
          callback2();
        });
      });
    }
    silenceEvents(callback2) {
      this.silenced = true;
      callback2();
      this.silenced = false;
    }
    on(event, callback2) {
      this.boundEventNames.add(event);
      window.addEventListener(event, (e) => {
        if (!this.silenced) {
          callback2(e);
        }
      });
    }
    jsQuerySelectorAll(sourceEl, query, defaultQuery) {
      let all = this.domCallbacks.jsQuerySelectorAll;
      return all ? all(sourceEl, query, defaultQuery) : defaultQuery();
    }
  };
  var TransitionSet = class {
    constructor() {
      this.transitions = /* @__PURE__ */ new Set();
      this.pendingOps = [];
    }
    reset() {
      this.transitions.forEach((timer) => {
        clearTimeout(timer);
        this.transitions.delete(timer);
      });
      this.flushPendingOps();
    }
    after(callback2) {
      if (this.size() === 0) {
        callback2();
      } else {
        this.pushPendingOp(callback2);
      }
    }
    addTransition(time, onStart, onDone) {
      onStart();
      let timer = setTimeout(() => {
        this.transitions.delete(timer);
        onDone();
        this.flushPendingOps();
      }, time);
      this.transitions.add(timer);
    }
    pushPendingOp(op) {
      this.pendingOps.push(op);
    }
    size() {
      return this.transitions.size;
    }
    flushPendingOps() {
      if (this.size() > 0) {
        return;
      }
      let op = this.pendingOps.shift();
      if (op) {
        op();
        this.flushPendingOps();
      }
    }
  };

  // js/app.js
  var import_topbar = __toESM(require_topbar());

  // node_modules/@kurkle/color/dist/color.esm.js
  function round(v) {
    return v + 0.5 | 0;
  }
  var lim = (v, l, h) => Math.max(Math.min(v, h), l);
  function p2b(v) {
    return lim(round(v * 2.55), 0, 255);
  }
  function n2b(v) {
    return lim(round(v * 255), 0, 255);
  }
  function b2n(v) {
    return lim(round(v / 2.55) / 100, 0, 1);
  }
  function n2p(v) {
    return lim(round(v * 100), 0, 100);
  }
  var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
  var hex = [..."0123456789ABCDEF"];
  var h1 = (b) => hex[b & 15];
  var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
  var eq = (b) => (b & 240) >> 4 === (b & 15);
  var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
  function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === "#") {
      if (len === 4 || len === 5) {
        ret = {
          r: 255 & map$1[str[1]] * 17,
          g: 255 & map$1[str[2]] * 17,
          b: 255 & map$1[str[3]] * 17,
          a: len === 5 ? map$1[str[4]] * 17 : 255
        };
      } else if (len === 7 || len === 9) {
        ret = {
          r: map$1[str[1]] << 4 | map$1[str[2]],
          g: map$1[str[3]] << 4 | map$1[str[4]],
          b: map$1[str[5]] << 4 | map$1[str[6]],
          a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
        };
      }
    }
    return ret;
  }
  var alpha = (a, f) => a < 255 ? f(a) : "";
  function hexString(v) {
    var f = isShort(v) ? h1 : h2;
    return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
  }
  var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
  function hsl2rgbn(h, s, l) {
    const a = s * Math.min(l, 1 - l);
    const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return [f(0), f(8), f(4)];
  }
  function hsv2rgbn(h, s, v) {
    const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    return [f(5), f(3), f(1)];
  }
  function hwb2rgbn(h, w, b) {
    const rgb = hsl2rgbn(h, 1, 0.5);
    let i;
    if (w + b > 1) {
      i = 1 / (w + b);
      w *= i;
      b *= i;
    }
    for (i = 0; i < 3; i++) {
      rgb[i] *= 1 - w - b;
      rgb[i] += w;
    }
    return rgb;
  }
  function hueValue(r, g, b, d3, max2) {
    if (r === max2) {
      return (g - b) / d3 + (g < b ? 6 : 0);
    }
    if (g === max2) {
      return (b - r) / d3 + 2;
    }
    return (r - g) / d3 + 4;
  }
  function rgb2hsl(v) {
    const range3 = 255;
    const r = v.r / range3;
    const g = v.g / range3;
    const b = v.b / range3;
    const max2 = Math.max(r, g, b);
    const min2 = Math.min(r, g, b);
    const l = (max2 + min2) / 2;
    let h, s, d3;
    if (max2 !== min2) {
      d3 = max2 - min2;
      s = l > 0.5 ? d3 / (2 - max2 - min2) : d3 / (max2 + min2);
      h = hueValue(r, g, b, d3, max2);
      h = h * 60 + 0.5;
    }
    return [h | 0, s || 0, l];
  }
  function calln(f, a, b, c) {
    return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
  }
  function hsl2rgb(h, s, l) {
    return calln(hsl2rgbn, h, s, l);
  }
  function hwb2rgb(h, w, b) {
    return calln(hwb2rgbn, h, w, b);
  }
  function hsv2rgb(h, s, v) {
    return calln(hsv2rgbn, h, s, v);
  }
  function hue(h) {
    return (h % 360 + 360) % 360;
  }
  function hueParse(str) {
    const m3 = HUE_RE.exec(str);
    let a = 255;
    let v;
    if (!m3) {
      return;
    }
    if (m3[5] !== v) {
      a = m3[6] ? p2b(+m3[5]) : n2b(+m3[5]);
    }
    const h = hue(+m3[2]);
    const p1 = +m3[3] / 100;
    const p2 = +m3[4] / 100;
    if (m3[1] === "hwb") {
      v = hwb2rgb(h, p1, p2);
    } else if (m3[1] === "hsv") {
      v = hsv2rgb(h, p1, p2);
    } else {
      v = hsl2rgb(h, p1, p2);
    }
    return {
      r: v[0],
      g: v[1],
      b: v[2],
      a
    };
  }
  function rotate(v, deg) {
    var h = rgb2hsl(v);
    h[0] = hue(h[0] + deg);
    h = hsl2rgb(h);
    v.r = h[0];
    v.g = h[1];
    v.b = h[2];
  }
  function hslString(v) {
    if (!v) {
      return;
    }
    const a = rgb2hsl(v);
    const h = a[0];
    const s = n2p(a[1]);
    const l = n2p(a[2]);
    return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
  }
  var map = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
  };
  var names$1 = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
  };
  function unpack() {
    const unpacked = {};
    const keys = Object.keys(names$1);
    const tkeys = Object.keys(map);
    let i, j, k, ok, nk;
    for (i = 0; i < keys.length; i++) {
      ok = nk = keys[i];
      for (j = 0; j < tkeys.length; j++) {
        k = tkeys[j];
        nk = nk.replace(k, map[k]);
      }
      k = parseInt(names$1[ok], 16);
      unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
    }
    return unpacked;
  }
  var names;
  function nameParse(str) {
    if (!names) {
      names = unpack();
      names.transparent = [0, 0, 0, 0];
    }
    const a = names[str.toLowerCase()];
    return a && {
      r: a[0],
      g: a[1],
      b: a[2],
      a: a.length === 4 ? a[3] : 255
    };
  }
  var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  function rgbParse(str) {
    const m3 = RGB_RE.exec(str);
    let a = 255;
    let r, g, b;
    if (!m3) {
      return;
    }
    if (m3[7] !== r) {
      const v = +m3[7];
      a = m3[8] ? p2b(v) : lim(v * 255, 0, 255);
    }
    r = +m3[1];
    g = +m3[3];
    b = +m3[5];
    r = 255 & (m3[2] ? p2b(r) : lim(r, 0, 255));
    g = 255 & (m3[4] ? p2b(g) : lim(g, 0, 255));
    b = 255 & (m3[6] ? p2b(b) : lim(b, 0, 255));
    return {
      r,
      g,
      b,
      a
    };
  }
  function rgbString(v) {
    return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
  }
  var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
  var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  function interpolate(rgb1, rgb2, t) {
    const r = from(b2n(rgb1.r));
    const g = from(b2n(rgb1.g));
    const b = from(b2n(rgb1.b));
    return {
      r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
      g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
      b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
      a: rgb1.a + t * (rgb2.a - rgb1.a)
    };
  }
  function modHSL(v, i, ratio) {
    if (v) {
      let tmp = rgb2hsl(v);
      tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
      tmp = hsl2rgb(tmp);
      v.r = tmp[0];
      v.g = tmp[1];
      v.b = tmp[2];
    }
  }
  function clone2(v, proto) {
    return v ? Object.assign(proto || {}, v) : v;
  }
  function fromObject(input) {
    var v = { r: 0, g: 0, b: 0, a: 255 };
    if (Array.isArray(input)) {
      if (input.length >= 3) {
        v = { r: input[0], g: input[1], b: input[2], a: 255 };
        if (input.length > 3) {
          v.a = n2b(input[3]);
        }
      }
    } else {
      v = clone2(input, { r: 0, g: 0, b: 0, a: 1 });
      v.a = n2b(v.a);
    }
    return v;
  }
  function functionParse(str) {
    if (str.charAt(0) === "r") {
      return rgbParse(str);
    }
    return hueParse(str);
  }
  var Color = class {
    constructor(input) {
      if (input instanceof Color) {
        return input;
      }
      const type = typeof input;
      let v;
      if (type === "object") {
        v = fromObject(input);
      } else if (type === "string") {
        v = hexParse(input) || nameParse(input) || functionParse(input);
      }
      this._rgb = v;
      this._valid = !!v;
    }
    get valid() {
      return this._valid;
    }
    get rgb() {
      var v = clone2(this._rgb);
      if (v) {
        v.a = b2n(v.a);
      }
      return v;
    }
    set rgb(obj) {
      this._rgb = fromObject(obj);
    }
    rgbString() {
      return this._valid ? rgbString(this._rgb) : void 0;
    }
    hexString() {
      return this._valid ? hexString(this._rgb) : void 0;
    }
    hslString() {
      return this._valid ? hslString(this._rgb) : void 0;
    }
    mix(color2, weight) {
      if (color2) {
        const c1 = this.rgb;
        const c2 = color2.rgb;
        let w2;
        const p = weight === w2 ? 0.5 : weight;
        const w = 2 * p - 1;
        const a = c1.a - c2.a;
        const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        w2 = 1 - w1;
        c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
        c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
        c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
        c1.a = p * c1.a + (1 - p) * c2.a;
        this.rgb = c1;
      }
      return this;
    }
    interpolate(color2, t) {
      if (color2) {
        this._rgb = interpolate(this._rgb, color2._rgb, t);
      }
      return this;
    }
    clone() {
      return new Color(this.rgb);
    }
    alpha(a) {
      this._rgb.a = n2b(a);
      return this;
    }
    clearer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 - ratio;
      return this;
    }
    greyscale() {
      const rgb = this._rgb;
      const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
      rgb.r = rgb.g = rgb.b = val;
      return this;
    }
    opaquer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 + ratio;
      return this;
    }
    negate() {
      const v = this._rgb;
      v.r = 255 - v.r;
      v.g = 255 - v.g;
      v.b = 255 - v.b;
      return this;
    }
    lighten(ratio) {
      modHSL(this._rgb, 2, ratio);
      return this;
    }
    darken(ratio) {
      modHSL(this._rgb, 2, -ratio);
      return this;
    }
    saturate(ratio) {
      modHSL(this._rgb, 1, ratio);
      return this;
    }
    desaturate(ratio) {
      modHSL(this._rgb, 1, -ratio);
      return this;
    }
    rotate(deg) {
      rotate(this._rgb, deg);
      return this;
    }
  };

  // node_modules/chart.js/dist/chunks/helpers.dataset.js
  function noop2() {
  }
  var uid = (() => {
    let id = 0;
    return () => id++;
  })();
  function isNullOrUndef(value) {
    return value === null || value === void 0;
  }
  function isArray(value) {
    if (Array.isArray && Array.isArray(value)) {
      return true;
    }
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
      return true;
    }
    return false;
  }
  function isObject2(value) {
    return value !== null && Object.prototype.toString.call(value) === "[object Object]";
  }
  function isNumberFinite(value) {
    return (typeof value === "number" || value instanceof Number) && isFinite(+value);
  }
  function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
  }
  function valueOrDefault(value, defaultValue) {
    return typeof value === "undefined" ? defaultValue : value;
  }
  var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
  var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
  function callback(fn2, args, thisArg) {
    if (fn2 && typeof fn2.call === "function") {
      return fn2.apply(thisArg, args);
    }
  }
  function each(loopable, fn2, thisArg, reverse) {
    let i, len, keys;
    if (isArray(loopable)) {
      len = loopable.length;
      if (reverse) {
        for (i = len - 1; i >= 0; i--) {
          fn2.call(thisArg, loopable[i], i);
        }
      } else {
        for (i = 0; i < len; i++) {
          fn2.call(thisArg, loopable[i], i);
        }
      }
    } else if (isObject2(loopable)) {
      keys = Object.keys(loopable);
      len = keys.length;
      for (i = 0; i < len; i++) {
        fn2.call(thisArg, loopable[keys[i]], keys[i]);
      }
    }
  }
  function _elementsEqual(a0, a1) {
    let i, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) {
      return false;
    }
    for (i = 0, ilen = a0.length; i < ilen; ++i) {
      v0 = a0[i];
      v1 = a1[i];
      if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
        return false;
      }
    }
    return true;
  }
  function clone3(source) {
    if (isArray(source)) {
      return source.map(clone3);
    }
    if (isObject2(source)) {
      const target = /* @__PURE__ */ Object.create(null);
      const keys = Object.keys(source);
      const klen = keys.length;
      let k = 0;
      for (; k < klen; ++k) {
        target[keys[k]] = clone3(source[keys[k]]);
      }
      return target;
    }
    return source;
  }
  function isValidKey(key) {
    return [
      "__proto__",
      "prototype",
      "constructor"
    ].indexOf(key) === -1;
  }
  function _merger(key, target, source, options) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject2(tval) && isObject2(sval)) {
      merge(tval, sval, options);
    } else {
      target[key] = clone3(sval);
    }
  }
  function merge(target, source, options) {
    const sources = isArray(source) ? source : [
      source
    ];
    const ilen = sources.length;
    if (!isObject2(target)) {
      return target;
    }
    options = options || {};
    const merger = options.merger || _merger;
    let current;
    for (let i = 0; i < ilen; ++i) {
      current = sources[i];
      if (!isObject2(current)) {
        continue;
      }
      const keys = Object.keys(current);
      for (let k = 0, klen = keys.length; k < klen; ++k) {
        merger(keys[k], target, current, options);
      }
    }
    return target;
  }
  function mergeIf(target, source) {
    return merge(target, source, {
      merger: _mergerIf
    });
  }
  function _mergerIf(key, target, source) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject2(tval) && isObject2(sval)) {
      mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
      target[key] = clone3(sval);
    }
  }
  var keyResolvers = {
    // Chart.helpers.core resolveObjectKey should resolve empty key to root object
    "": (v) => v,
    // default resolvers
    x: (o) => o.x,
    y: (o) => o.y
  };
  function _splitKey(key) {
    const parts = key.split(".");
    const keys = [];
    let tmp = "";
    for (const part of parts) {
      tmp += part;
      if (tmp.endsWith("\\")) {
        tmp = tmp.slice(0, -1) + ".";
      } else {
        keys.push(tmp);
        tmp = "";
      }
    }
    return keys;
  }
  function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj) => {
      for (const k of keys) {
        if (k === "") {
          break;
        }
        obj = obj && obj[k];
      }
      return obj;
    };
  }
  function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
  }
  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  var defined = (value) => typeof value !== "undefined";
  var isFunction = (value) => typeof value === "function";
  var setsEqual = (a, b) => {
    if (a.size !== b.size) {
      return false;
    }
    for (const item of a) {
      if (!b.has(item)) {
        return false;
      }
    }
    return true;
  };
  function _isClickEvent(e) {
    return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
  }
  var PI = Math.PI;
  var TAU = 2 * PI;
  var PITAU = TAU + PI;
  var INFINITY = Number.POSITIVE_INFINITY;
  var RAD_PER_DEG = PI / 180;
  var HALF_PI = PI / 2;
  var QUARTER_PI = PI / 4;
  var TWO_THIRDS_PI = PI * 2 / 3;
  var log10 = Math.log10;
  var sign = Math.sign;
  function almostEquals(x, y3, epsilon) {
    return Math.abs(x - y3) < epsilon;
  }
  function niceNum(range3) {
    const roundedRange = Math.round(range3);
    range3 = almostEquals(range3, roundedRange, range3 / 1e3) ? roundedRange : range3;
    const niceRange = Math.pow(10, Math.floor(log10(range3)));
    const fraction = range3 / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
  }
  function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i;
    for (i = 1; i < sqrt; i++) {
      if (value % i === 0) {
        result.push(i);
        result.push(value / i);
      }
    }
    if (sqrt === (sqrt | 0)) {
      result.push(sqrt);
    }
    result.sort((a, b) => a - b).pop();
    return result;
  }
  function isNonPrimitive(n) {
    return typeof n === "symbol" || typeof n === "object" && n !== null && !(Symbol.toPrimitive in n || "toString" in n || "valueOf" in n);
  }
  function isNumber(n) {
    return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);
  }
  function almostWhole(x, epsilon) {
    const rounded = Math.round(x);
    return rounded - epsilon <= x && rounded + epsilon >= x;
  }
  function _setMinAndMaxByKey(array, target, property) {
    let i, ilen, value;
    for (i = 0, ilen = array.length; i < ilen; i++) {
      value = array[i][property];
      if (!isNaN(value)) {
        target.min = Math.min(target.min, value);
        target.max = Math.max(target.max, value);
      }
    }
  }
  function toRadians(degrees) {
    return degrees * (PI / 180);
  }
  function toDegrees(radians) {
    return radians * (180 / PI);
  }
  function _decimalPlaces(x) {
    if (!isNumberFinite(x)) {
      return;
    }
    let e = 1;
    let p = 0;
    while (Math.round(x * e) / e !== x) {
      e *= 10;
      p++;
    }
    return p;
  }
  function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
      angle += TAU;
    }
    return {
      angle,
      distance: radialDistanceFromCenter
    };
  }
  function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
  }
  function _angleDiff(a, b) {
    return (a - b + PITAU) % TAU - PI;
  }
  function _normalizeAngle(a) {
    return (a % TAU + TAU) % TAU;
  }
  function _angleBetween(angle, start2, end2, sameAngleIsFullCircle) {
    const a = _normalizeAngle(angle);
    const s = _normalizeAngle(start2);
    const e = _normalizeAngle(end2);
    const angleToStart = _normalizeAngle(s - a);
    const angleToEnd = _normalizeAngle(e - a);
    const startToAngle = _normalizeAngle(a - s);
    const endToAngle = _normalizeAngle(a - e);
    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
  }
  function _limitValue(value, min2, max2) {
    return Math.max(min2, Math.min(max2, value));
  }
  function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
  }
  function _isBetween(value, start2, end2, epsilon = 1e-6) {
    return value >= Math.min(start2, end2) - epsilon && value <= Math.max(start2, end2) + epsilon;
  }
  function _lookup(table, value, cmp) {
    cmp = cmp || ((index3) => table[index3] < value);
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while (hi - lo > 1) {
      mid = lo + hi >> 1;
      if (cmp(mid)) {
        lo = mid;
      } else {
        hi = mid;
      }
    }
    return {
      lo,
      hi
    };
  }
  var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index3) => {
    const ti = table[index3][key];
    return ti < value || ti === value && table[index3 + 1][key] === value;
  } : (index3) => table[index3][key] < value);
  var _rlookupByKey = (table, key, value) => _lookup(table, value, (index3) => table[index3][key] >= value);
  function _filterBetween(values, min2, max2) {
    let start2 = 0;
    let end2 = values.length;
    while (start2 < end2 && values[start2] < min2) {
      start2++;
    }
    while (end2 > start2 && values[end2 - 1] > max2) {
      end2--;
    }
    return start2 > 0 || end2 < values.length ? values.slice(start2, end2) : values;
  }
  var arrayEvents = [
    "push",
    "pop",
    "shift",
    "splice",
    "unshift"
  ];
  function listenArrayEvents(array, listener) {
    if (array._chartjs) {
      array._chartjs.listeners.push(listener);
      return;
    }
    Object.defineProperty(array, "_chartjs", {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [
          listener
        ]
      }
    });
    arrayEvents.forEach((key) => {
      const method = "_onData" + _capitalize(key);
      const base = array[key];
      Object.defineProperty(array, key, {
        configurable: true,
        enumerable: false,
        value(...args) {
          const res = base.apply(this, args);
          array._chartjs.listeners.forEach((object) => {
            if (typeof object[method] === "function") {
              object[method](...args);
            }
          });
          return res;
        }
      });
    });
  }
  function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) {
      return;
    }
    const listeners = stub.listeners;
    const index3 = listeners.indexOf(listener);
    if (index3 !== -1) {
      listeners.splice(index3, 1);
    }
    if (listeners.length > 0) {
      return;
    }
    arrayEvents.forEach((key) => {
      delete array[key];
    });
    delete array._chartjs;
  }
  function _arrayUnique(items) {
    const set2 = new Set(items);
    if (set2.size === items.length) {
      return items;
    }
    return Array.from(set2);
  }
  var requestAnimFrame = function() {
    if (typeof window === "undefined") {
      return function(callback2) {
        return callback2();
      };
    }
    return window.requestAnimationFrame;
  }();
  function throttled(fn2, thisArg) {
    let argsToUse = [];
    let ticking = false;
    return function(...args) {
      argsToUse = args;
      if (!ticking) {
        ticking = true;
        requestAnimFrame.call(window, () => {
          ticking = false;
          fn2.apply(thisArg, argsToUse);
        });
      }
    };
  }
  function debounce(fn2, delay) {
    let timeout;
    return function(...args) {
      if (delay) {
        clearTimeout(timeout);
        timeout = setTimeout(fn2, delay, args);
      } else {
        fn2.apply(this, args);
      }
      return delay;
    };
  }
  var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
  var _alignStartEnd = (align, start2, end2) => align === "start" ? start2 : align === "end" ? end2 : (start2 + end2) / 2;
  var _textX = (align, left2, right2, rtl) => {
    const check = rtl ? "left" : "right";
    return align === check ? right2 : align === "center" ? (left2 + right2) / 2 : left2;
  };
  function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start2 = 0;
    let count = pointCount;
    if (meta._sorted) {
      const { iScale, vScale, _parsed } = meta;
      const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;
      const axis = iScale.axis;
      const { min: min2, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
      if (minDefined) {
        start2 = Math.min(
          // @ts-expect-error Need to type _parsed
          _lookupByKey(_parsed, axis, min2).lo,
          // @ts-expect-error Need to fix types on _lookupByKey
          animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min2)).lo
        );
        if (spanGaps) {
          const distanceToDefinedLo = _parsed.slice(0, start2 + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
          start2 -= Math.max(0, distanceToDefinedLo);
        }
        start2 = _limitValue(start2, 0, pointCount - 1);
      }
      if (maxDefined) {
        let end2 = Math.max(
          // @ts-expect-error Need to type _parsed
          _lookupByKey(_parsed, iScale.axis, max2, true).hi + 1,
          // @ts-expect-error Need to fix types on _lookupByKey
          animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max2), true).hi + 1
        );
        if (spanGaps) {
          const distanceToDefinedHi = _parsed.slice(end2 - 1).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
          end2 += Math.max(0, distanceToDefinedHi);
        }
        count = _limitValue(end2, start2, pointCount) - start2;
      } else {
        count = pointCount - start2;
      }
    }
    return {
      start: start2,
      count
    };
  }
  function _scaleRangesChanged(meta) {
    const { xScale, yScale, _scaleRanges } = meta;
    const newRanges = {
      xmin: xScale.min,
      xmax: xScale.max,
      ymin: yScale.min,
      ymax: yScale.max
    };
    if (!_scaleRanges) {
      meta._scaleRanges = newRanges;
      return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
  }
  var atEdge = (t) => t === 0 || t === 1;
  var elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
  var elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
  var effects = {
    linear: (t) => t,
    easeInQuad: (t) => t * t,
    easeOutQuad: (t) => -t * (t - 2),
    easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
    easeInCubic: (t) => t * t * t,
    easeOutCubic: (t) => (t -= 1) * t * t + 1,
    easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
    easeInQuart: (t) => t * t * t * t,
    easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
    easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
    easeInQuint: (t) => t * t * t * t * t,
    easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
    easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
    easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
    easeOutSine: (t) => Math.sin(t * HALF_PI),
    easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
    easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
    easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
    easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
    easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
    easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
    easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
    easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
    easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
    easeInOutElastic(t) {
      const s = 0.1125;
      const p = 0.45;
      return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
    },
    easeInBack(t) {
      const s = 1.70158;
      return t * t * ((s + 1) * t - s);
    },
    easeOutBack(t) {
      const s = 1.70158;
      return (t -= 1) * t * ((s + 1) * t + s) + 1;
    },
    easeInOutBack(t) {
      let s = 1.70158;
      if ((t /= 0.5) < 1) {
        return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
      }
      return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
    },
    easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
    easeOutBounce(t) {
      const m3 = 7.5625;
      const d3 = 2.75;
      if (t < 1 / d3) {
        return m3 * t * t;
      }
      if (t < 2 / d3) {
        return m3 * (t -= 1.5 / d3) * t + 0.75;
      }
      if (t < 2.5 / d3) {
        return m3 * (t -= 2.25 / d3) * t + 0.9375;
      }
      return m3 * (t -= 2.625 / d3) * t + 0.984375;
    },
    easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
  };
  function isPatternOrGradient(value) {
    if (value && typeof value === "object") {
      const type = value.toString();
      return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
    }
    return false;
  }
  function color(value) {
    return isPatternOrGradient(value) ? value : new Color(value);
  }
  function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
  }
  var numbers = [
    "x",
    "y",
    "borderWidth",
    "radius",
    "tension"
  ];
  var colors = [
    "color",
    "borderColor",
    "backgroundColor"
  ];
  function applyAnimationsDefaults(defaults3) {
    defaults3.set("animation", {
      delay: void 0,
      duration: 1e3,
      easing: "easeOutQuart",
      fn: void 0,
      from: void 0,
      loop: void 0,
      to: void 0,
      type: void 0
    });
    defaults3.describe("animation", {
      _fallback: false,
      _indexable: false,
      _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
    });
    defaults3.set("animations", {
      colors: {
        type: "color",
        properties: colors
      },
      numbers: {
        type: "number",
        properties: numbers
      }
    });
    defaults3.describe("animations", {
      _fallback: "animation"
    });
    defaults3.set("transitions", {
      active: {
        animation: {
          duration: 400
        }
      },
      resize: {
        animation: {
          duration: 0
        }
      },
      show: {
        animations: {
          colors: {
            from: "transparent"
          },
          visible: {
            type: "boolean",
            duration: 0
          }
        }
      },
      hide: {
        animations: {
          colors: {
            to: "transparent"
          },
          visible: {
            type: "boolean",
            easing: "linear",
            fn: (v) => v | 0
          }
        }
      }
    });
  }
  function applyLayoutsDefaults(defaults3) {
    defaults3.set("layout", {
      autoPadding: true,
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    });
  }
  var intlCache = /* @__PURE__ */ new Map();
  function getNumberFormat(locale, options) {
    options = options || {};
    const cacheKey = locale + JSON.stringify(options);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
      formatter = new Intl.NumberFormat(locale, options);
      intlCache.set(cacheKey, formatter);
    }
    return formatter;
  }
  function formatNumber(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
  }
  var formatters = {
    values(value) {
      return isArray(value) ? value : "" + value;
    },
    numeric(tickValue, index3, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const locale = this.chart.options.locale;
      let notation;
      let delta = tickValue;
      if (ticks.length > 1) {
        const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
        if (maxTick < 1e-4 || maxTick > 1e15) {
          notation = "scientific";
        }
        delta = calculateDelta(tickValue, ticks);
      }
      const logDelta = log10(Math.abs(delta));
      const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
      const options = {
        notation,
        minimumFractionDigits: numDecimal,
        maximumFractionDigits: numDecimal
      };
      Object.assign(options, this.options.ticks.format);
      return formatNumber(tickValue, locale, options);
    },
    logarithmic(tickValue, index3, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const remain = ticks[index3].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
      if ([
        1,
        2,
        3,
        5,
        10,
        15
      ].includes(remain) || index3 > 0.8 * ticks.length) {
        return formatters.numeric.call(this, tickValue, index3, ticks);
      }
      return "";
    }
  };
  function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
      delta = tickValue - Math.floor(tickValue);
    }
    return delta;
  }
  var Ticks = {
    formatters
  };
  function applyScaleDefaults(defaults3) {
    defaults3.set("scale", {
      display: true,
      offset: false,
      reverse: false,
      beginAtZero: false,
      bounds: "ticks",
      clip: true,
      grace: 0,
      grid: {
        display: true,
        lineWidth: 1,
        drawOnChartArea: true,
        drawTicks: true,
        tickLength: 8,
        tickWidth: (_ctx, options) => options.lineWidth,
        tickColor: (_ctx, options) => options.color,
        offset: false
      },
      border: {
        display: true,
        dash: [],
        dashOffset: 0,
        width: 1
      },
      title: {
        display: false,
        text: "",
        padding: {
          top: 4,
          bottom: 4
        }
      },
      ticks: {
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        textStrokeWidth: 0,
        textStrokeColor: "",
        padding: 3,
        display: true,
        autoSkip: true,
        autoSkipPadding: 3,
        labelOffset: 0,
        callback: Ticks.formatters.values,
        minor: {},
        major: {},
        align: "center",
        crossAlign: "near",
        showLabelBackdrop: false,
        backdropColor: "rgba(255, 255, 255, 0.75)",
        backdropPadding: 2
      }
    });
    defaults3.route("scale.ticks", "color", "", "color");
    defaults3.route("scale.grid", "color", "", "borderColor");
    defaults3.route("scale.border", "color", "", "borderColor");
    defaults3.route("scale.title", "color", "", "color");
    defaults3.describe("scale", {
      _fallback: false,
      _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
      _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
    });
    defaults3.describe("scales", {
      _fallback: "scale"
    });
    defaults3.describe("scale.ticks", {
      _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
      _indexable: (name) => name !== "backdropPadding"
    });
  }
  var overrides = /* @__PURE__ */ Object.create(null);
  var descriptors = /* @__PURE__ */ Object.create(null);
  function getScope$1(node, key) {
    if (!key) {
      return node;
    }
    const keys = key.split(".");
    for (let i = 0, n = keys.length; i < n; ++i) {
      const k = keys[i];
      node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
    }
    return node;
  }
  function set(root, scope, values) {
    if (typeof scope === "string") {
      return merge(getScope$1(root, scope), values);
    }
    return merge(getScope$1(root, ""), scope);
  }
  var Defaults = class {
    constructor(_descriptors2, _appliers) {
      this.animation = void 0;
      this.backgroundColor = "rgba(0,0,0,0.1)";
      this.borderColor = "rgba(0,0,0,0.1)";
      this.color = "#666";
      this.datasets = {};
      this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
      this.elements = {};
      this.events = [
        "mousemove",
        "mouseout",
        "click",
        "touchstart",
        "touchmove"
      ];
      this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      };
      this.hover = {};
      this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
      this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
      this.hoverColor = (ctx, options) => getHoverColor(options.color);
      this.indexAxis = "x";
      this.interaction = {
        mode: "nearest",
        intersect: true,
        includeInvisible: false
      };
      this.maintainAspectRatio = true;
      this.onHover = null;
      this.onClick = null;
      this.parsing = true;
      this.plugins = {};
      this.responsive = true;
      this.scale = void 0;
      this.scales = {};
      this.showLine = true;
      this.drawActiveElementsOnTop = true;
      this.describe(_descriptors2);
      this.apply(_appliers);
    }
    set(scope, values) {
      return set(this, scope, values);
    }
    get(scope) {
      return getScope$1(this, scope);
    }
    describe(scope, values) {
      return set(descriptors, scope, values);
    }
    override(scope, values) {
      return set(overrides, scope, values);
    }
    route(scope, name, targetScope, targetName) {
      const scopeObject = getScope$1(this, scope);
      const targetScopeObject = getScope$1(this, targetScope);
      const privateName = "_" + name;
      Object.defineProperties(scopeObject, {
        [privateName]: {
          value: scopeObject[name],
          writable: true
        },
        [name]: {
          enumerable: true,
          get() {
            const local = this[privateName];
            const target = targetScopeObject[targetName];
            if (isObject2(local)) {
              return Object.assign({}, target, local);
            }
            return valueOrDefault(local, target);
          },
          set(value) {
            this[privateName] = value;
          }
        }
      });
    }
    apply(appliers) {
      appliers.forEach((apply) => apply(this));
    }
  };
  var defaults = /* @__PURE__ */ new Defaults({
    _scriptable: (name) => !name.startsWith("on"),
    _indexable: (name) => name !== "events",
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: false,
      _indexable: false
    }
  }, [
    applyAnimationsDefaults,
    applyLayoutsDefaults,
    applyScaleDefaults
  ]);
  function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
      return null;
    }
    return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
  }
  function _measureText(ctx, data, gc, longest, string) {
    let textWidth = data[string];
    if (!textWidth) {
      textWidth = data[string] = ctx.measureText(string).width;
      gc.push(string);
    }
    if (textWidth > longest) {
      longest = textWidth;
    }
    return longest;
  }
  function _longestText(ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    let data = cache.data = cache.data || {};
    let gc = cache.garbageCollect = cache.garbageCollect || [];
    if (cache.font !== font) {
      data = cache.data = {};
      gc = cache.garbageCollect = [];
      cache.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i, j, jlen, thing, nestedThing;
    for (i = 0; i < ilen; i++) {
      thing = arrayOfThings[i];
      if (thing !== void 0 && thing !== null && !isArray(thing)) {
        longest = _measureText(ctx, data, gc, longest, thing);
      } else if (isArray(thing)) {
        for (j = 0, jlen = thing.length; j < jlen; j++) {
          nestedThing = thing[j];
          if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
            longest = _measureText(ctx, data, gc, longest, nestedThing);
          }
        }
      }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
      for (i = 0; i < gcLen; i++) {
        delete data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
    return longest;
  }
  function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
  }
  function clearCanvas(canvas, ctx) {
    if (!ctx && !canvas) {
      return;
    }
    ctx = ctx || canvas.getContext("2d");
    ctx.save();
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  function drawPoint(ctx, options, x, y3) {
    drawPointLegend(ctx, options, x, y3, null);
  }
  function drawPointLegend(ctx, options, x, y3, w) {
    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
    const style = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === "object") {
      type = style.toString();
      if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
        ctx.save();
        ctx.translate(x, y3);
        ctx.rotate(rad);
        ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
        ctx.restore();
        return;
      }
    }
    if (isNaN(radius) || radius <= 0) {
      return;
    }
    ctx.beginPath();
    switch (style) {
      default:
        if (w) {
          ctx.ellipse(x, y3, w / 2, radius, 0, 0, TAU);
        } else {
          ctx.arc(x, y3, radius, 0, TAU);
        }
        ctx.closePath();
        break;
      case "triangle":
        width = w ? w / 2 : radius;
        ctx.moveTo(x + Math.sin(rad) * width, y3 - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * width, y3 - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * width, y3 - Math.cos(rad) * radius);
        ctx.closePath();
        break;
      case "rectRounded":
        cornerRadius = radius * 0.516;
        size = radius - cornerRadius;
        xOffset = Math.cos(rad + QUARTER_PI) * size;
        xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
        yOffset = Math.sin(rad + QUARTER_PI) * size;
        yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
        ctx.arc(x - xOffsetW, y3 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
        ctx.arc(x + yOffsetW, y3 - xOffset, cornerRadius, rad - HALF_PI, rad);
        ctx.arc(x + xOffsetW, y3 + yOffset, cornerRadius, rad, rad + HALF_PI);
        ctx.arc(x - yOffsetW, y3 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
        ctx.closePath();
        break;
      case "rect":
        if (!rotation) {
          size = Math.SQRT1_2 * radius;
          width = w ? w / 2 : size;
          ctx.rect(x - width, y3 - size, 2 * width, 2 * size);
          break;
        }
        rad += QUARTER_PI;
      case "rectRot":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y3 - yOffset);
        ctx.lineTo(x + yOffsetW, y3 - xOffset);
        ctx.lineTo(x + xOffsetW, y3 + yOffset);
        ctx.lineTo(x - yOffsetW, y3 + xOffset);
        ctx.closePath();
        break;
      case "crossRot":
        rad += QUARTER_PI;
      case "cross":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y3 - yOffset);
        ctx.lineTo(x + xOffsetW, y3 + yOffset);
        ctx.moveTo(x + yOffsetW, y3 - xOffset);
        ctx.lineTo(x - yOffsetW, y3 + xOffset);
        break;
      case "star":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y3 - yOffset);
        ctx.lineTo(x + xOffsetW, y3 + yOffset);
        ctx.moveTo(x + yOffsetW, y3 - xOffset);
        ctx.lineTo(x - yOffsetW, y3 + xOffset);
        rad += QUARTER_PI;
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y3 - yOffset);
        ctx.lineTo(x + xOffsetW, y3 + yOffset);
        ctx.moveTo(x + yOffsetW, y3 - xOffset);
        ctx.lineTo(x - yOffsetW, y3 + xOffset);
        break;
      case "line":
        xOffset = w ? w / 2 : Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y3 - yOffset);
        ctx.lineTo(x + xOffset, y3 + yOffset);
        break;
      case "dash":
        ctx.moveTo(x, y3);
        ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y3 + Math.sin(rad) * radius);
        break;
      case false:
        ctx.closePath();
        break;
    }
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  function _isPointInArea(point, area, margin) {
    margin = margin || 0.5;
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
  }
  function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
  }
  function unclipArea(ctx) {
    ctx.restore();
  }
  function _steppedLineTo(ctx, previous, target, flip2, mode) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    if (mode === "middle") {
      const midpoint = (previous.x + target.x) / 2;
      ctx.lineTo(midpoint, previous.y);
      ctx.lineTo(midpoint, target.y);
    } else if (mode === "after" !== !!flip2) {
      ctx.lineTo(previous.x, target.y);
    } else {
      ctx.lineTo(target.x, previous.y);
    }
    ctx.lineTo(target.x, target.y);
  }
  function _bezierCurveTo(ctx, previous, target, flip2) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    ctx.bezierCurveTo(flip2 ? previous.cp1x : previous.cp2x, flip2 ? previous.cp1y : previous.cp2y, flip2 ? target.cp2x : target.cp1x, flip2 ? target.cp2y : target.cp1y, target.x, target.y);
  }
  function setRenderOpts(ctx, opts) {
    if (opts.translation) {
      ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
      ctx.rotate(opts.rotation);
    }
    if (opts.color) {
      ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
      ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
      ctx.textBaseline = opts.textBaseline;
    }
  }
  function decorateText(ctx, x, y3, line, opts) {
    if (opts.strikethrough || opts.underline) {
      const metrics = ctx.measureText(line);
      const left2 = x - metrics.actualBoundingBoxLeft;
      const right2 = x + metrics.actualBoundingBoxRight;
      const top3 = y3 - metrics.actualBoundingBoxAscent;
      const bottom3 = y3 + metrics.actualBoundingBoxDescent;
      const yDecoration = opts.strikethrough ? (top3 + bottom3) / 2 : bottom3;
      ctx.strokeStyle = ctx.fillStyle;
      ctx.beginPath();
      ctx.lineWidth = opts.decorationWidth || 2;
      ctx.moveTo(left2, yDecoration);
      ctx.lineTo(right2, yDecoration);
      ctx.stroke();
    }
  }
  function drawBackdrop(ctx, opts) {
    const oldColor = ctx.fillStyle;
    ctx.fillStyle = opts.color;
    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
    ctx.fillStyle = oldColor;
  }
  function renderText(ctx, text, x, y3, font, opts = {}) {
    const lines = isArray(text) ? text : [
      text
    ];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
    let i, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for (i = 0; i < lines.length; ++i) {
      line = lines[i];
      if (opts.backdrop) {
        drawBackdrop(ctx, opts.backdrop);
      }
      if (stroke) {
        if (opts.strokeColor) {
          ctx.strokeStyle = opts.strokeColor;
        }
        if (!isNullOrUndef(opts.strokeWidth)) {
          ctx.lineWidth = opts.strokeWidth;
        }
        ctx.strokeText(line, x, y3, opts.maxWidth);
      }
      ctx.fillText(line, x, y3, opts.maxWidth);
      decorateText(ctx, x, y3, line, opts);
      y3 += Number(font.lineHeight);
    }
    ctx.restore();
  }
  function addRoundedRectPath(ctx, rect) {
    const { x, y: y3, w, h, radius } = rect;
    ctx.arc(x + radius.topLeft, y3 + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
    ctx.lineTo(x, y3 + h - radius.bottomLeft);
    ctx.arc(x + radius.bottomLeft, y3 + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    ctx.lineTo(x + w - radius.bottomRight, y3 + h);
    ctx.arc(x + w - radius.bottomRight, y3 + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    ctx.lineTo(x + w, y3 + radius.topRight);
    ctx.arc(x + w - radius.topRight, y3 + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    ctx.lineTo(x + radius.topLeft, y3);
  }
  var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
  var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
  function toLineHeight(value, size) {
    const matches2 = ("" + value).match(LINE_HEIGHT);
    if (!matches2 || matches2[1] === "normal") {
      return size * 1.2;
    }
    value = +matches2[2];
    switch (matches2[3]) {
      case "px":
        return value;
      case "%":
        value /= 100;
        break;
    }
    return size * value;
  }
  var numberOrZero = (v) => +v || 0;
  function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject2(props);
    const keys = objProps ? Object.keys(props) : props;
    const read2 = isObject2(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
    for (const prop of keys) {
      ret[prop] = numberOrZero(read2(prop));
    }
    return ret;
  }
  function toTRBL(value) {
    return _readValueToProps(value, {
      top: "y",
      right: "x",
      bottom: "y",
      left: "x"
    });
  }
  function toTRBLCorners(value) {
    return _readValueToProps(value, [
      "topLeft",
      "topRight",
      "bottomLeft",
      "bottomRight"
    ]);
  }
  function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
  }
  function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults.font;
    let size = valueOrDefault(options.size, fallback.size);
    if (typeof size === "string") {
      size = parseInt(size, 10);
    }
    let style = valueOrDefault(options.style, fallback.style);
    if (style && !("" + style).match(FONT_STYLE)) {
      console.warn('Invalid font style specified: "' + style + '"');
      style = void 0;
    }
    const font = {
      family: valueOrDefault(options.family, fallback.family),
      lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
      size,
      style,
      weight: valueOrDefault(options.weight, fallback.weight),
      string: ""
    };
    font.string = toFontString(font);
    return font;
  }
  function resolve(inputs, context, index3, info) {
    let cacheable = true;
    let i, ilen, value;
    for (i = 0, ilen = inputs.length; i < ilen; ++i) {
      value = inputs[i];
      if (value === void 0) {
        continue;
      }
      if (context !== void 0 && typeof value === "function") {
        value = value(context);
        cacheable = false;
      }
      if (index3 !== void 0 && isArray(value)) {
        value = value[index3 % value.length];
        cacheable = false;
      }
      if (value !== void 0) {
        if (info && !cacheable) {
          info.cacheable = false;
        }
        return value;
      }
    }
  }
  function _addGrace(minmax, grace, beginAtZero) {
    const { min: min2, max: max2 } = minmax;
    const change = toDimension(grace, (max2 - min2) / 2);
    const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
    return {
      min: keepZero(min2, -Math.abs(change)),
      max: keepZero(max2, change)
    };
  }
  function createContext(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
  }
  function _createResolver(scopes, prefixes = [
    ""
  ], rootScopes, fallback, getTarget = () => scopes[0]) {
    const finalRootScopes = rootScopes || scopes;
    if (typeof fallback === "undefined") {
      fallback = _resolve("_fallback", scopes);
    }
    const cache = {
      [Symbol.toStringTag]: "Object",
      _cacheable: true,
      _scopes: scopes,
      _rootScopes: finalRootScopes,
      _fallback: fallback,
      _getTarget: getTarget,
      override: (scope) => _createResolver([
        scope,
        ...scopes
      ], prefixes, finalRootScopes, fallback)
    };
    return new Proxy(cache, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(target, prop) {
        delete target[prop];
        delete target._keys;
        delete scopes[0][prop];
        return true;
      },
      /**
      * A trap for getting property values.
      */
      get(target, prop) {
        return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(target, prop) {
        return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(scopes[0]);
      },
      /**
      * A trap for the in operator.
      */
      has(target, prop) {
        return getKeysFromAllScopes(target).includes(prop);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys(target) {
        return getKeysFromAllScopes(target);
      },
      /**
      * A trap for setting property values.
      */
      set(target, prop, value) {
        const storage = target._storage || (target._storage = getTarget());
        target[prop] = storage[prop] = value;
        delete target._keys;
        return true;
      }
    });
  }
  function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    const cache = {
      _cacheable: false,
      _proxy: proxy,
      _context: context,
      _subProxy: subProxy,
      _stack: /* @__PURE__ */ new Set(),
      _descriptors: _descriptors(proxy, descriptorDefaults),
      setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
      override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
    };
    return new Proxy(cache, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(target, prop) {
        delete target[prop];
        delete proxy[prop];
        return true;
      },
      /**
      * A trap for getting property values.
      */
      get(target, prop, receiver) {
        return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(target, prop) {
        return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
          enumerable: true,
          configurable: true
        } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(proxy);
      },
      /**
      * A trap for the in operator.
      */
      has(target, prop) {
        return Reflect.has(proxy, prop);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys() {
        return Reflect.ownKeys(proxy);
      },
      /**
      * A trap for setting property values.
      */
      set(target, prop, value) {
        proxy[prop] = value;
        delete target[prop];
        return true;
      }
    });
  }
  function _descriptors(proxy, defaults3 = {
    scriptable: true,
    indexable: true
  }) {
    const { _scriptable = defaults3.scriptable, _indexable = defaults3.indexable, _allKeys = defaults3.allKeys } = proxy;
    return {
      allKeys: _allKeys,
      scriptable: _scriptable,
      indexable: _indexable,
      isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
      isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
    };
  }
  var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
  var needsSubResolver = (prop, value) => isObject2(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
  function _cached(target, prop, resolve2) {
    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") {
      return target[prop];
    }
    const value = resolve2();
    target[prop] = value;
    return value;
  }
  function _resolveWithContext(target, prop, receiver) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    let value = _proxy[prop];
    if (isFunction(value) && descriptors2.isScriptable(prop)) {
      value = _resolveScriptable(prop, value, target, receiver);
    }
    if (isArray(value) && value.length) {
      value = _resolveArray(prop, value, target, descriptors2.isIndexable);
    }
    if (needsSubResolver(prop, value)) {
      value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
    }
    return value;
  }
  function _resolveScriptable(prop, getValue, target, receiver) {
    const { _proxy, _context, _subProxy, _stack } = target;
    if (_stack.has(prop)) {
      throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
    }
    _stack.add(prop);
    let value = getValue(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) {
      value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    }
    return value;
  }
  function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    if (typeof _context.index !== "undefined" && isIndexable(prop)) {
      return value[_context.index % value.length];
    } else if (isObject2(value[0])) {
      const arr = value;
      const scopes = _proxy._scopes.filter((s) => s !== arr);
      value = [];
      for (const item of arr) {
        const resolver = createSubResolver(scopes, _proxy, prop, item);
        value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
      }
    }
    return value;
  }
  function resolveFallback(fallback, prop, value) {
    return isFunction(fallback) ? fallback(prop, value) : fallback;
  }
  var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
  function addScopes(set2, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes) {
      const scope = getScope(key, parent);
      if (scope) {
        set2.add(scope);
        const fallback = resolveFallback(scope._fallback, key, value);
        if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
          return fallback;
        }
      } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
        return null;
      }
    }
    return false;
  }
  function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [
      ...parentScopes,
      ...rootScopes
    ];
    const set2 = /* @__PURE__ */ new Set();
    set2.add(value);
    let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
    if (key === null) {
      return false;
    }
    if (typeof fallback !== "undefined" && fallback !== prop) {
      key = addScopesFromKey(set2, allScopes, fallback, key, value);
      if (key === null) {
        return false;
      }
    }
    return _createResolver(Array.from(set2), [
      ""
    ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
  }
  function addScopesFromKey(set2, allScopes, key, fallback, item) {
    while (key) {
      key = addScopes(set2, allScopes, key, fallback, item);
    }
    return key;
  }
  function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
      parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray(target) && isObject2(value)) {
      return value;
    }
    return target || {};
  }
  function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix of prefixes) {
      value = _resolve(readKey(prefix, prop), scopes);
      if (typeof value !== "undefined") {
        return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
      }
    }
  }
  function _resolve(key, scopes) {
    for (const scope of scopes) {
      if (!scope) {
        continue;
      }
      const value = scope[key];
      if (typeof value !== "undefined") {
        return value;
      }
    }
  }
  function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) {
      keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys;
  }
  function resolveKeysFromAllScopes(scopes) {
    const set2 = /* @__PURE__ */ new Set();
    for (const scope of scopes) {
      for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
        set2.add(key);
      }
    }
    return Array.from(set2);
  }
  function _parseObjectDataRadialScale(meta, data, start2, count) {
    const { iScale } = meta;
    const { key = "r" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index3, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index3 = i + start2;
      item = data[index3];
      parsed[i] = {
        r: iScale.parse(resolveObjectKey(item, key), index3)
      };
    }
    return parsed;
  }
  var EPSILON = Number.EPSILON || 1e-14;
  var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
  var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
  function splineCurve(firstPoint, middlePoint, afterPoint, t) {
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t * s01;
    const fb = t * s12;
    return {
      previous: {
        x: current.x - fa * (next.x - previous.x),
        y: current.y - fa * (next.y - previous.y)
      },
      next: {
        x: current.x + fb * (next.x - previous.x),
        y: current.y + fb * (next.y - previous.y)
      }
    };
  }
  function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i = 0; i < pointsLen - 1; ++i) {
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent || !pointAfter) {
        continue;
      }
      if (almostEquals(deltaK[i], 0, EPSILON)) {
        mK[i] = mK[i + 1] = 0;
        continue;
      }
      alphaK = mK[i] / deltaK[i];
      betaK = mK[i + 1] / deltaK[i];
      squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
      if (squaredMagnitude <= 9) {
        continue;
      }
      tauK = 3 / Math.sqrt(squaredMagnitude);
      mK[i] = alphaK * tauK * deltaK[i];
      mK[i + 1] = betaK * tauK * deltaK[i];
    }
  }
  function monotoneCompute(points, mK, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i = 0; i < pointsLen; ++i) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent) {
        continue;
      }
      const iPixel = pointCurrent[indexAxis];
      const vPixel = pointCurrent[valueAxis];
      if (pointBefore) {
        delta = (iPixel - pointBefore[indexAxis]) / 3;
        pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
        pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
      }
      if (pointAfter) {
        delta = (pointAfter[indexAxis] - iPixel) / 3;
        pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
        pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
      }
    }
  }
  function splineCurveMonotone(points, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    let i, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (i = 0; i < pointsLen; ++i) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent) {
        continue;
      }
      if (pointAfter) {
        const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
        deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
      }
      mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
  }
  function capControlPoint(pt, min2, max2) {
    return Math.max(Math.min(pt, max2), min2);
  }
  function capBezierPoints(points, area) {
    let i, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      inAreaPrev = inArea;
      inArea = inAreaNext;
      inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
      if (!inArea) {
        continue;
      }
      point = points[i];
      if (inAreaPrev) {
        point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
        point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
      }
      if (inAreaNext) {
        point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
        point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
      }
    }
  }
  function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
    let i, ilen, point, controlPoints;
    if (options.spanGaps) {
      points = points.filter((pt) => !pt.skip);
    }
    if (options.cubicInterpolationMode === "monotone") {
      splineCurveMonotone(points, indexAxis);
    } else {
      let prev = loop ? points[points.length - 1] : points[0];
      for (i = 0, ilen = points.length; i < ilen; ++i) {
        point = points[i];
        controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
        point.cp1x = controlPoints.previous.x;
        point.cp1y = controlPoints.previous.y;
        point.cp2x = controlPoints.next.x;
        point.cp2y = controlPoints.next.y;
        prev = point;
      }
    }
    if (options.capBezierPoints) {
      capBezierPoints(points, area);
    }
  }
  function _isDomSupported() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === "[object ShadowRoot]") {
      parent = parent.host;
    }
    return parent;
  }
  function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === "string") {
      valueInPixels = parseInt(styleValue, 10);
      if (styleValue.indexOf("%") !== -1) {
        valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
      }
    } else {
      valueInPixels = styleValue;
    }
    return valueInPixels;
  }
  var getComputedStyle2 = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
  function getStyle(el2, property) {
    return getComputedStyle2(el2).getPropertyValue(property);
  }
  var positions = [
    "top",
    "right",
    "bottom",
    "left"
  ];
  function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? "-" + suffix : "";
    for (let i = 0; i < 4; i++) {
      const pos = positions[i];
      result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
  }
  var useOffsetPos = (x, y3, target) => (x > 0 || y3 > 0) && (!target || !target.shadowRoot);
  function getCanvasPosition(e, canvas) {
    const touches = e.touches;
    const source = touches && touches.length ? touches[0] : e;
    const { offsetX, offsetY } = source;
    let box = false;
    let x, y3;
    if (useOffsetPos(offsetX, offsetY, e.target)) {
      x = offsetX;
      y3 = offsetY;
    } else {
      const rect = canvas.getBoundingClientRect();
      x = source.clientX - rect.left;
      y3 = source.clientY - rect.top;
      box = true;
    }
    return {
      x,
      y: y3,
      box
    };
  }
  function getRelativePosition(event, chart) {
    if ("native" in event) {
      return event;
    }
    const { canvas, currentDevicePixelRatio } = chart;
    const style = getComputedStyle2(canvas);
    const borderBox = style.boxSizing === "border-box";
    const paddings = getPositionedStyle(style, "padding");
    const borders = getPositionedStyle(style, "border", "width");
    const { x, y: y3, box } = getCanvasPosition(event, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width, height } = chart;
    if (borderBox) {
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    return {
      x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
      y: Math.round((y3 - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
  }
  function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === void 0 || height === void 0) {
      const container = canvas && _getParentNode(canvas);
      if (!container) {
        width = canvas.clientWidth;
        height = canvas.clientHeight;
      } else {
        const rect = container.getBoundingClientRect();
        const containerStyle = getComputedStyle2(container);
        const containerBorder = getPositionedStyle(containerStyle, "border", "width");
        const containerPadding = getPositionedStyle(containerStyle, "padding");
        width = rect.width - containerPadding.width - containerBorder.width;
        height = rect.height - containerPadding.height - containerBorder.height;
        maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
        maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
      }
    }
    return {
      width,
      height,
      maxWidth: maxWidth || INFINITY,
      maxHeight: maxHeight || INFINITY
    };
  }
  var round1 = (v) => Math.round(v * 10) / 10;
  function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle2(canvas);
    const margins = getPositionedStyle(style, "margin");
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width, height } = containerSize;
    if (style.boxSizing === "content-box") {
      const borders = getPositionedStyle(style, "border", "width");
      const paddings = getPositionedStyle(style, "padding");
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
      height = round1(width / 2);
    }
    const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
      height = containerSize.height;
      width = round1(Math.floor(height * aspectRatio));
    }
    return {
      width,
      height
    };
  }
  function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = Math.floor(chart.height);
    chart.width = Math.floor(chart.width);
    const canvas = chart.canvas;
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
      canvas.style.height = `${chart.height}px`;
      canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
      chart.currentDevicePixelRatio = pixelRatio;
      canvas.height = deviceHeight;
      canvas.width = deviceWidth;
      chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      return true;
    }
    return false;
  }
  var supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
      const options = {
        get passive() {
          passiveSupported = true;
          return false;
        }
      };
      if (_isDomSupported()) {
        window.addEventListener("test", null, options);
        window.removeEventListener("test", null, options);
      }
    } catch (e) {
    }
    return passiveSupported;
  }();
  function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches2 = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches2 ? +matches2[1] : void 0;
  }
  function _pointInLine(p1, p2, t, mode) {
    return {
      x: p1.x + t * (p2.x - p1.x),
      y: p1.y + t * (p2.y - p1.y)
    };
  }
  function _steppedInterpolation(p1, p2, t, mode) {
    return {
      x: p1.x + t * (p2.x - p1.x),
      y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
    };
  }
  function _bezierInterpolation(p1, p2, t, mode) {
    const cp1 = {
      x: p1.cp2x,
      y: p1.cp2y
    };
    const cp2 = {
      x: p2.cp1x,
      y: p2.cp1y
    };
    const a = _pointInLine(p1, cp1, t);
    const b = _pointInLine(cp1, cp2, t);
    const c = _pointInLine(cp2, p2, t);
    const d3 = _pointInLine(a, b, t);
    const e = _pointInLine(b, c, t);
    return _pointInLine(d3, e, t);
  }
  var getRightToLeftAdapter = function(rectX, width) {
    return {
      x(x) {
        return rectX + rectX + width - x;
      },
      setWidth(w) {
        width = w;
      },
      textAlign(align) {
        if (align === "center") {
          return align;
        }
        return align === "right" ? "left" : "right";
      },
      xPlus(x, value) {
        return x - value;
      },
      leftForLtr(x, itemWidth) {
        return x - itemWidth;
      }
    };
  };
  var getLeftToRightAdapter = function() {
    return {
      x(x) {
        return x;
      },
      setWidth(w) {
      },
      textAlign(align) {
        return align;
      },
      xPlus(x, value) {
        return x + value;
      },
      leftForLtr(x, _itemWidth) {
        return x;
      }
    };
  };
  function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
  }
  function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === "ltr" || direction === "rtl") {
      style = ctx.canvas.style;
      original = [
        style.getPropertyValue("direction"),
        style.getPropertyPriority("direction")
      ];
      style.setProperty("direction", direction, "important");
      ctx.prevTextDirection = original;
    }
  }
  function restoreTextDirection(ctx, original) {
    if (original !== void 0) {
      delete ctx.prevTextDirection;
      ctx.canvas.style.setProperty("direction", original[0], original[1]);
    }
  }
  function propertyFn(property) {
    if (property === "angle") {
      return {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle
      };
    }
    return {
      between: _isBetween,
      compare: (a, b) => a - b,
      normalize: (x) => x
    };
  }
  function normalizeSegment({ start: start2, end: end2, count, loop, style }) {
    return {
      start: start2 % count,
      end: end2 % count,
      loop: loop && (end2 - start2 + 1) % count === 0,
      style
    };
  }
  function getSegment(segment, points, bounds) {
    const { property, start: startBound, end: endBound } = bounds;
    const { between, normalize } = propertyFn(property);
    const count = points.length;
    let { start: start2, end: end2, loop } = segment;
    let i, ilen;
    if (loop) {
      start2 += count;
      end2 += count;
      for (i = 0, ilen = count; i < ilen; ++i) {
        if (!between(normalize(points[start2 % count][property]), startBound, endBound)) {
          break;
        }
        start2--;
        end2--;
      }
      start2 %= count;
      end2 %= count;
    }
    if (end2 < start2) {
      end2 += count;
    }
    return {
      start: start2,
      end: end2,
      loop,
      style: segment.style
    };
  }
  function _boundSegment(segment, points, bounds) {
    if (!bounds) {
      return [
        segment
      ];
    }
    const { property, start: startBound, end: endBound } = bounds;
    const count = points.length;
    const { compare, between, normalize } = propertyFn(property);
    const { start: start2, end: end2, loop, style } = getSegment(segment, points, bounds);
    const result = [];
    let inside = false;
    let subStart = null;
    let value, point, prevValue;
    const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
    const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
    const shouldStart = () => inside || startIsBefore();
    const shouldStop = () => !inside || endIsBefore();
    for (let i = start2, prev = start2; i <= end2; ++i) {
      point = points[i % count];
      if (point.skip) {
        continue;
      }
      value = normalize(point[property]);
      if (value === prevValue) {
        continue;
      }
      inside = between(value, startBound, endBound);
      if (subStart === null && shouldStart()) {
        subStart = compare(value, startBound) === 0 ? i : prev;
      }
      if (subStart !== null && shouldStop()) {
        result.push(normalizeSegment({
          start: subStart,
          end: i,
          loop,
          count,
          style
        }));
        subStart = null;
      }
      prev = i;
      prevValue = value;
    }
    if (subStart !== null) {
      result.push(normalizeSegment({
        start: subStart,
        end: end2,
        loop,
        count,
        style
      }));
    }
    return result;
  }
  function _boundSegments(line, bounds) {
    const result = [];
    const segments = line.segments;
    for (let i = 0; i < segments.length; i++) {
      const sub = _boundSegment(segments[i], line.points, bounds);
      if (sub.length) {
        result.push(...sub);
      }
    }
    return result;
  }
  function findStartAndEnd(points, count, loop, spanGaps) {
    let start2 = 0;
    let end2 = count - 1;
    if (loop && !spanGaps) {
      while (start2 < count && !points[start2].skip) {
        start2++;
      }
    }
    while (start2 < count && points[start2].skip) {
      start2++;
    }
    start2 %= count;
    if (loop) {
      end2 += start2;
    }
    while (end2 > start2 && points[end2 % count].skip) {
      end2--;
    }
    end2 %= count;
    return {
      start: start2,
      end: end2
    };
  }
  function solidSegments(points, start2, max2, loop) {
    const count = points.length;
    const result = [];
    let last = start2;
    let prev = points[start2];
    let end2;
    for (end2 = start2 + 1; end2 <= max2; ++end2) {
      const cur = points[end2 % count];
      if (cur.skip || cur.stop) {
        if (!prev.skip) {
          loop = false;
          result.push({
            start: start2 % count,
            end: (end2 - 1) % count,
            loop
          });
          start2 = last = cur.stop ? end2 : null;
        }
      } else {
        last = end2;
        if (prev.skip) {
          start2 = end2;
        }
      }
      prev = cur;
    }
    if (last !== null) {
      result.push({
        start: start2 % count,
        end: last % count,
        loop
      });
    }
    return result;
  }
  function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) {
      return [];
    }
    const loop = !!line._loop;
    const { start: start2, end: end2 } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) {
      return splitByStyles(line, [
        {
          start: start2,
          end: end2,
          loop
        }
      ], points, segmentOptions);
    }
    const max2 = end2 < start2 ? end2 + count : end2;
    const completeLoop = !!line._fullLoop && start2 === 0 && end2 === count - 1;
    return splitByStyles(line, solidSegments(points, start2, max2, completeLoop), points, segmentOptions);
  }
  function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) {
      return segments;
    }
    return doSplitByStyles(line, segments, points, segmentOptions);
  }
  function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start2 = segments[0].start;
    let i = start2;
    function addStyle(s, e, l, st) {
      const dir = spanGaps ? -1 : 1;
      if (s === e) {
        return;
      }
      s += count;
      while (points[s % count].skip) {
        s -= dir;
      }
      while (points[e % count].skip) {
        e += dir;
      }
      if (s % count !== e % count) {
        result.push({
          start: s % count,
          end: e % count,
          loop: l,
          style: st
        });
        prevStyle = st;
        start2 = e % count;
      }
    }
    for (const segment of segments) {
      start2 = spanGaps ? start2 : segment.start;
      let prev = points[start2 % count];
      let style;
      for (i = start2 + 1; i <= segment.end; i++) {
        const pt = points[i % count];
        style = readStyle(segmentOptions.setContext(createContext(chartContext, {
          type: "segment",
          p0: prev,
          p1: pt,
          p0DataIndex: (i - 1) % count,
          p1DataIndex: i % count,
          datasetIndex
        })));
        if (styleChanged(style, prevStyle)) {
          addStyle(start2, i - 1, segment.loop, prevStyle);
        }
        prev = pt;
        prevStyle = style;
      }
      if (start2 < i - 1) {
        addStyle(start2, i - 1, segment.loop, prevStyle);
      }
    }
    return result;
  }
  function readStyle(options) {
    return {
      backgroundColor: options.backgroundColor,
      borderCapStyle: options.borderCapStyle,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderJoinStyle: options.borderJoinStyle,
      borderWidth: options.borderWidth,
      borderColor: options.borderColor
    };
  }
  function styleChanged(style, prevStyle) {
    if (!prevStyle) {
      return false;
    }
    const cache = [];
    const replacer = function(key, value) {
      if (!isPatternOrGradient(value)) {
        return value;
      }
      if (!cache.includes(value)) {
        cache.push(value);
      }
      return cache.indexOf(value);
    };
    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
  }
  function getSizeForArea(scale, chartArea, field) {
    return scale.options.clip ? scale[field] : chartArea[field];
  }
  function getDatasetArea(meta, chartArea) {
    const { xScale, yScale } = meta;
    if (xScale && yScale) {
      return {
        left: getSizeForArea(xScale, chartArea, "left"),
        right: getSizeForArea(xScale, chartArea, "right"),
        top: getSizeForArea(yScale, chartArea, "top"),
        bottom: getSizeForArea(yScale, chartArea, "bottom")
      };
    }
    return chartArea;
  }
  function getDatasetClipArea(chart, meta) {
    const clip = meta._clip;
    if (clip.disabled) {
      return false;
    }
    const area = getDatasetArea(meta, chart.chartArea);
    return {
      left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),
      right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),
      top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),
      bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)
    };
  }

  // node_modules/chart.js/dist/chart.js
  var Animator = class {
    constructor() {
      this._request = null;
      this._charts = /* @__PURE__ */ new Map();
      this._running = false;
      this._lastDate = void 0;
    }
    _notify(chart, anims, date, type) {
      const callbacks = anims.listeners[type];
      const numSteps = anims.duration;
      callbacks.forEach((fn2) => fn2({
        chart,
        initial: anims.initial,
        numSteps,
        currentStep: Math.min(date - anims.start, numSteps)
      }));
    }
    _refresh() {
      if (this._request) {
        return;
      }
      this._running = true;
      this._request = requestAnimFrame.call(window, () => {
        this._update();
        this._request = null;
        if (this._running) {
          this._refresh();
        }
      });
    }
    _update(date = Date.now()) {
      let remaining = 0;
      this._charts.forEach((anims, chart) => {
        if (!anims.running || !anims.items.length) {
          return;
        }
        const items = anims.items;
        let i = items.length - 1;
        let draw2 = false;
        let item;
        for (; i >= 0; --i) {
          item = items[i];
          if (item._active) {
            if (item._total > anims.duration) {
              anims.duration = item._total;
            }
            item.tick(date);
            draw2 = true;
          } else {
            items[i] = items[items.length - 1];
            items.pop();
          }
        }
        if (draw2) {
          chart.draw();
          this._notify(chart, anims, date, "progress");
        }
        if (!items.length) {
          anims.running = false;
          this._notify(chart, anims, date, "complete");
          anims.initial = false;
        }
        remaining += items.length;
      });
      this._lastDate = date;
      if (remaining === 0) {
        this._running = false;
      }
    }
    _getAnims(chart) {
      const charts = this._charts;
      let anims = charts.get(chart);
      if (!anims) {
        anims = {
          running: false,
          initial: true,
          items: [],
          listeners: {
            complete: [],
            progress: []
          }
        };
        charts.set(chart, anims);
      }
      return anims;
    }
    listen(chart, event, cb) {
      this._getAnims(chart).listeners[event].push(cb);
    }
    add(chart, items) {
      if (!items || !items.length) {
        return;
      }
      this._getAnims(chart).items.push(...items);
    }
    has(chart) {
      return this._getAnims(chart).items.length > 0;
    }
    start(chart) {
      const anims = this._charts.get(chart);
      if (!anims) {
        return;
      }
      anims.running = true;
      anims.start = Date.now();
      anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
      this._refresh();
    }
    running(chart) {
      if (!this._running) {
        return false;
      }
      const anims = this._charts.get(chart);
      if (!anims || !anims.running || !anims.items.length) {
        return false;
      }
      return true;
    }
    stop(chart) {
      const anims = this._charts.get(chart);
      if (!anims || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      for (; i >= 0; --i) {
        items[i].cancel();
      }
      anims.items = [];
      this._notify(chart, anims, Date.now(), "complete");
    }
    remove(chart) {
      return this._charts.delete(chart);
    }
  };
  var animator = /* @__PURE__ */ new Animator();
  var transparent = "transparent";
  var interpolators = {
    boolean(from2, to2, factor) {
      return factor > 0.5 ? to2 : from2;
    },
    color(from2, to2, factor) {
      const c0 = color(from2 || transparent);
      const c1 = c0.valid && color(to2 || transparent);
      return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
    },
    number(from2, to2, factor) {
      return from2 + (to2 - from2) * factor;
    }
  };
  var Animation = class {
    constructor(cfg, target, prop, to2) {
      const currentValue = target[prop];
      to2 = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      const from2 = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
      this._active = true;
      this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
      this._easing = effects[cfg.easing] || effects.linear;
      this._start = Math.floor(Date.now() + (cfg.delay || 0));
      this._duration = this._total = Math.floor(cfg.duration);
      this._loop = !!cfg.loop;
      this._target = target;
      this._prop = prop;
      this._from = from2;
      this._to = to2;
      this._promises = void 0;
    }
    active() {
      return this._active;
    }
    update(cfg, to2, date) {
      if (this._active) {
        this._notify(false);
        const currentValue = this._target[this._prop];
        const elapsed = date - this._start;
        const remain = this._duration - elapsed;
        this._start = date;
        this._duration = Math.floor(Math.max(remain, cfg.duration));
        this._total += elapsed;
        this._loop = !!cfg.loop;
        this._to = resolve([
          cfg.to,
          to2,
          currentValue,
          cfg.from
        ]);
        this._from = resolve([
          cfg.from,
          currentValue,
          to2
        ]);
      }
    }
    cancel() {
      if (this._active) {
        this.tick(Date.now());
        this._active = false;
        this._notify(false);
      }
    }
    tick(date) {
      const elapsed = date - this._start;
      const duration = this._duration;
      const prop = this._prop;
      const from2 = this._from;
      const loop = this._loop;
      const to2 = this._to;
      let factor;
      this._active = from2 !== to2 && (loop || elapsed < duration);
      if (!this._active) {
        this._target[prop] = to2;
        this._notify(true);
        return;
      }
      if (elapsed < 0) {
        this._target[prop] = from2;
        return;
      }
      factor = elapsed / duration % 2;
      factor = loop && factor > 1 ? 2 - factor : factor;
      factor = this._easing(Math.min(1, Math.max(0, factor)));
      this._target[prop] = this._fn(from2, to2, factor);
    }
    wait() {
      const promises = this._promises || (this._promises = []);
      return new Promise((res, rej) => {
        promises.push({
          res,
          rej
        });
      });
    }
    _notify(resolved) {
      const method = resolved ? "res" : "rej";
      const promises = this._promises || [];
      for (let i = 0; i < promises.length; i++) {
        promises[i][method]();
      }
    }
  };
  var Animations = class {
    constructor(chart, config) {
      this._chart = chart;
      this._properties = /* @__PURE__ */ new Map();
      this.configure(config);
    }
    configure(config) {
      if (!isObject2(config)) {
        return;
      }
      const animationOptions = Object.keys(defaults.animation);
      const animatedProps = this._properties;
      Object.getOwnPropertyNames(config).forEach((key) => {
        const cfg = config[key];
        if (!isObject2(cfg)) {
          return;
        }
        const resolved = {};
        for (const option2 of animationOptions) {
          resolved[option2] = cfg[option2];
        }
        (isArray(cfg.properties) && cfg.properties || [
          key
        ]).forEach((prop) => {
          if (prop === key || !animatedProps.has(prop)) {
            animatedProps.set(prop, resolved);
          }
        });
      });
    }
    _animateOptions(target, values) {
      const newOptions = values.options;
      const options = resolveTargetOptions(target, newOptions);
      if (!options) {
        return [];
      }
      const animations = this._createAnimations(options, newOptions);
      if (newOptions.$shared) {
        awaitAll(target.options.$animations, newOptions).then(() => {
          target.options = newOptions;
        }, () => {
        });
      }
      return animations;
    }
    _createAnimations(target, values) {
      const animatedProps = this._properties;
      const animations = [];
      const running = target.$animations || (target.$animations = {});
      const props = Object.keys(values);
      const date = Date.now();
      let i;
      for (i = props.length - 1; i >= 0; --i) {
        const prop = props[i];
        if (prop.charAt(0) === "$") {
          continue;
        }
        if (prop === "options") {
          animations.push(...this._animateOptions(target, values));
          continue;
        }
        const value = values[prop];
        let animation = running[prop];
        const cfg = animatedProps.get(prop);
        if (animation) {
          if (cfg && animation.active()) {
            animation.update(cfg, value, date);
            continue;
          } else {
            animation.cancel();
          }
        }
        if (!cfg || !cfg.duration) {
          target[prop] = value;
          continue;
        }
        running[prop] = animation = new Animation(cfg, target, prop, value);
        animations.push(animation);
      }
      return animations;
    }
    update(target, values) {
      if (this._properties.size === 0) {
        Object.assign(target, values);
        return;
      }
      const animations = this._createAnimations(target, values);
      if (animations.length) {
        animator.add(this._chart, animations);
        return true;
      }
    }
  };
  function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for (let i = 0; i < keys.length; i++) {
      const anim = animations[keys[i]];
      if (anim && anim.active()) {
        running.push(anim.wait());
      }
    }
    return Promise.all(running);
  }
  function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
      return;
    }
    let options = target.options;
    if (!options) {
      target.options = newOptions;
      return;
    }
    if (options.$shared) {
      target.options = options = Object.assign({}, options, {
        $shared: false,
        $animations: {}
      });
    }
    return options;
  }
  function scaleClip(scale, allowedOverflow) {
    const opts = scale && scale.options || {};
    const reverse = opts.reverse;
    const min2 = opts.min === void 0 ? allowedOverflow : 0;
    const max2 = opts.max === void 0 ? allowedOverflow : 0;
    return {
      start: reverse ? max2 : min2,
      end: reverse ? min2 : max2
    };
  }
  function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
      return false;
    }
    const x = scaleClip(xScale, allowedOverflow);
    const y3 = scaleClip(yScale, allowedOverflow);
    return {
      top: y3.end,
      right: x.end,
      bottom: y3.start,
      left: x.start
    };
  }
  function toClip(value) {
    let t, r, b, l;
    if (isObject2(value)) {
      t = value.top;
      r = value.right;
      b = value.bottom;
      l = value.left;
    } else {
      t = r = b = l = value;
    }
    return {
      top: t,
      right: r,
      bottom: b,
      left: l,
      disabled: value === false
    };
  }
  function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      keys.push(metasets[i].index);
    }
    return keys;
  }
  function applyStack(stack, value, dsIndex, options = {}) {
    const keys = stack.keys;
    const singleMode = options.mode === "single";
    let i, ilen, datasetIndex, otherValue;
    if (value === null) {
      return;
    }
    let found = false;
    for (i = 0, ilen = keys.length; i < ilen; ++i) {
      datasetIndex = +keys[i];
      if (datasetIndex === dsIndex) {
        found = true;
        if (options.all) {
          continue;
        }
        break;
      }
      otherValue = stack.values[datasetIndex];
      if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
        value += otherValue;
      }
    }
    if (!found && !options.all) {
      return 0;
    }
    return value;
  }
  function convertObjectDataToArray(data, meta) {
    const { iScale, vScale } = meta;
    const iAxisKey = iScale.axis === "x" ? "x" : "y";
    const vAxisKey = vScale.axis === "x" ? "x" : "y";
    const keys = Object.keys(data);
    const adata = new Array(keys.length);
    let i, ilen, key;
    for (i = 0, ilen = keys.length; i < ilen; ++i) {
      key = keys[i];
      adata[i] = {
        [iAxisKey]: key,
        [vAxisKey]: data[key]
      };
    }
    return adata;
  }
  function isStacked(scale, meta) {
    const stacked = scale && scale.options.stacked;
    return stacked || stacked === void 0 && meta.stack !== void 0;
  }
  function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
  }
  function getUserBounds(scale) {
    const { min: min2, max: max2, minDefined, maxDefined } = scale.getUserBounds();
    return {
      min: minDefined ? min2 : Number.NEGATIVE_INFINITY,
      max: maxDefined ? max2 : Number.POSITIVE_INFINITY
    };
  }
  function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
  }
  function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
      const value = stack[meta.index];
      if (positive && value > 0 || !positive && value < 0) {
        return meta.index;
      }
    }
    return null;
  }
  function updateStacks(controller, parsed) {
    const { chart, _cachedMeta: meta } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale, vScale, index: datasetIndex } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for (let i = 0; i < ilen; ++i) {
      const item = parsed[i];
      const { [iAxis]: index3, [vAxis]: value } = item;
      const itemStacks = item._stacks || (item._stacks = {});
      stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index3);
      stack[datasetIndex] = value;
      stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
      stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
      const visualValues = stack._visualValues || (stack._visualValues = {});
      visualValues[datasetIndex] = value;
    }
  }
  function getFirstScaleId(chart, axis) {
    const scales2 = chart.scales;
    return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
  }
  function createDatasetContext(parent, index3) {
    return createContext(parent, {
      active: false,
      dataset: void 0,
      datasetIndex: index3,
      index: index3,
      mode: "default",
      type: "dataset"
    });
  }
  function createDataContext(parent, index3, element) {
    return createContext(parent, {
      active: false,
      dataIndex: index3,
      parsed: void 0,
      raw: void 0,
      element,
      index: index3,
      mode: "default",
      type: "data"
    });
  }
  function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) {
      return;
    }
    items = items || meta._parsed;
    for (const parsed of items) {
      const stacks = parsed._stacks;
      if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
        return;
      }
      delete stacks[axis][datasetIndex];
      if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
        delete stacks[axis]._visualValues[datasetIndex];
      }
    }
  }
  var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
  var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
  var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
    keys: getSortedDatasetIndices(chart, true),
    values: null
  };
  var DatasetController = class {
    constructor(chart, datasetIndex) {
      this.chart = chart;
      this._ctx = chart.ctx;
      this.index = datasetIndex;
      this._cachedDataOpts = {};
      this._cachedMeta = this.getMeta();
      this._type = this._cachedMeta.type;
      this.options = void 0;
      this._parsing = false;
      this._data = void 0;
      this._objectData = void 0;
      this._sharedOptions = void 0;
      this._drawStart = void 0;
      this._drawCount = void 0;
      this.enableOptionSharing = false;
      this.supportsDecimation = false;
      this.$context = void 0;
      this._syncList = [];
      this.datasetElementType = new.target.datasetElementType;
      this.dataElementType = new.target.dataElementType;
      this.initialize();
    }
    initialize() {
      const meta = this._cachedMeta;
      this.configure();
      this.linkScales();
      meta._stacked = isStacked(meta.vScale, meta);
      this.addElements();
      if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
        console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
      }
    }
    updateIndex(datasetIndex) {
      if (this.index !== datasetIndex) {
        clearStacks(this._cachedMeta);
      }
      this.index = datasetIndex;
    }
    linkScales() {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      const chooseId = (axis, x, y3, r) => axis === "x" ? x : axis === "r" ? r : y3;
      const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
      const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
      const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
      const indexAxis = meta.indexAxis;
      const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
      const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
      meta.xScale = this.getScaleForId(xid);
      meta.yScale = this.getScaleForId(yid);
      meta.rScale = this.getScaleForId(rid);
      meta.iScale = this.getScaleForId(iid);
      meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
      return this.chart.data.datasets[this.index];
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(scaleID) {
      return this.chart.scales[scaleID];
    }
    _getOtherScale(scale) {
      const meta = this._cachedMeta;
      return scale === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
      this._update("reset");
    }
    _destroy() {
      const meta = this._cachedMeta;
      if (this._data) {
        unlistenArrayEvents(this._data, this);
      }
      if (meta._stacked) {
        clearStacks(meta);
      }
    }
    _dataCheck() {
      const dataset = this.getDataset();
      const data = dataset.data || (dataset.data = []);
      const _data = this._data;
      if (isObject2(data)) {
        const meta = this._cachedMeta;
        this._data = convertObjectDataToArray(data, meta);
      } else if (_data !== data) {
        if (_data) {
          unlistenArrayEvents(_data, this);
          const meta = this._cachedMeta;
          clearStacks(meta);
          meta._parsed = [];
        }
        if (data && Object.isExtensible(data)) {
          listenArrayEvents(data, this);
        }
        this._syncList = [];
        this._data = data;
      }
    }
    addElements() {
      const meta = this._cachedMeta;
      this._dataCheck();
      if (this.datasetElementType) {
        meta.dataset = new this.datasetElementType();
      }
    }
    buildOrUpdateElements(resetNewElements) {
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      let stackChanged = false;
      this._dataCheck();
      const oldStacked = meta._stacked;
      meta._stacked = isStacked(meta.vScale, meta);
      if (meta.stack !== dataset.stack) {
        stackChanged = true;
        clearStacks(meta);
        meta.stack = dataset.stack;
      }
      this._resyncElements(resetNewElements);
      if (stackChanged || oldStacked !== meta._stacked) {
        updateStacks(this, meta._parsed);
        meta._stacked = isStacked(meta.vScale, meta);
      }
    }
    configure() {
      const config = this.chart.config;
      const scopeKeys = config.datasetScopeKeys(this._type);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
      this.options = config.createResolver(scopes, this.getContext());
      this._parsing = this.options.parsing;
      this._cachedDataOpts = {};
    }
    parse(start2, count) {
      const { _cachedMeta: meta, _data: data } = this;
      const { iScale, _stacked } = meta;
      const iAxis = iScale.axis;
      let sorted = start2 === 0 && count === data.length ? true : meta._sorted;
      let prev = start2 > 0 && meta._parsed[start2 - 1];
      let i, cur, parsed;
      if (this._parsing === false) {
        meta._parsed = data;
        meta._sorted = true;
        parsed = data;
      } else {
        if (isArray(data[start2])) {
          parsed = this.parseArrayData(meta, data, start2, count);
        } else if (isObject2(data[start2])) {
          parsed = this.parseObjectData(meta, data, start2, count);
        } else {
          parsed = this.parsePrimitiveData(meta, data, start2, count);
        }
        const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
        for (i = 0; i < count; ++i) {
          meta._parsed[i + start2] = cur = parsed[i];
          if (sorted) {
            if (isNotInOrderComparedToPrev()) {
              sorted = false;
            }
            prev = cur;
          }
        }
        meta._sorted = sorted;
      }
      if (_stacked) {
        updateStacks(this, parsed);
      }
    }
    parsePrimitiveData(meta, data, start2, count) {
      const { iScale, vScale } = meta;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const labels = iScale.getLabels();
      const singleScale = iScale === vScale;
      const parsed = new Array(count);
      let i, ilen, index3;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index3 = i + start2;
        parsed[i] = {
          [iAxis]: singleScale || iScale.parse(labels[index3], index3),
          [vAxis]: vScale.parse(data[index3], index3)
        };
      }
      return parsed;
    }
    parseArrayData(meta, data, start2, count) {
      const { xScale, yScale } = meta;
      const parsed = new Array(count);
      let i, ilen, index3, item;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index3 = i + start2;
        item = data[index3];
        parsed[i] = {
          x: xScale.parse(item[0], index3),
          y: yScale.parse(item[1], index3)
        };
      }
      return parsed;
    }
    parseObjectData(meta, data, start2, count) {
      const { xScale, yScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const parsed = new Array(count);
      let i, ilen, index3, item;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index3 = i + start2;
        item = data[index3];
        parsed[i] = {
          x: xScale.parse(resolveObjectKey(item, xAxisKey), index3),
          y: yScale.parse(resolveObjectKey(item, yAxisKey), index3)
        };
      }
      return parsed;
    }
    getParsed(index3) {
      return this._cachedMeta._parsed[index3];
    }
    getDataElement(index3) {
      return this._cachedMeta.data[index3];
    }
    applyStack(scale, parsed, mode) {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const value = parsed[scale.axis];
      const stack = {
        keys: getSortedDatasetIndices(chart, true),
        values: parsed._stacks[scale.axis]._visualValues
      };
      return applyStack(stack, value, meta.index, {
        mode
      });
    }
    updateRangeFromParsed(range3, scale, parsed, stack) {
      const parsedValue = parsed[scale.axis];
      let value = parsedValue === null ? NaN : parsedValue;
      const values = stack && parsed._stacks[scale.axis];
      if (stack && values) {
        stack.values = values;
        value = applyStack(stack, parsedValue, this._cachedMeta.index);
      }
      range3.min = Math.min(range3.min, value);
      range3.max = Math.max(range3.max, value);
    }
    getMinMax(scale, canStack) {
      const meta = this._cachedMeta;
      const _parsed = meta._parsed;
      const sorted = meta._sorted && scale === meta.iScale;
      const ilen = _parsed.length;
      const otherScale = this._getOtherScale(scale);
      const stack = createStack(canStack, meta, this.chart);
      const range3 = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
      let i, parsed;
      function _skip() {
        parsed = _parsed[i];
        const otherValue = parsed[otherScale.axis];
        return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
      }
      for (i = 0; i < ilen; ++i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range3, scale, parsed, stack);
        if (sorted) {
          break;
        }
      }
      if (sorted) {
        for (i = ilen - 1; i >= 0; --i) {
          if (_skip()) {
            continue;
          }
          this.updateRangeFromParsed(range3, scale, parsed, stack);
          break;
        }
      }
      return range3;
    }
    getAllParsedValues(scale) {
      const parsed = this._cachedMeta._parsed;
      const values = [];
      let i, ilen, value;
      for (i = 0, ilen = parsed.length; i < ilen; ++i) {
        value = parsed[i][scale.axis];
        if (isNumberFinite(value)) {
          values.push(value);
        }
      }
      return values;
    }
    getMaxOverflow() {
      return false;
    }
    getLabelAndValue(index3) {
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const vScale = meta.vScale;
      const parsed = this.getParsed(index3);
      return {
        label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
        value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
      };
    }
    _update(mode) {
      const meta = this._cachedMeta;
      this.update(mode || "default");
      meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
    }
    update(mode) {
    }
    draw() {
      const ctx = this._ctx;
      const chart = this.chart;
      const meta = this._cachedMeta;
      const elements2 = meta.data || [];
      const area = chart.chartArea;
      const active = [];
      const start2 = this._drawStart || 0;
      const count = this._drawCount || elements2.length - start2;
      const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
      let i;
      if (meta.dataset) {
        meta.dataset.draw(ctx, area, start2, count);
      }
      for (i = start2; i < start2 + count; ++i) {
        const element = elements2[i];
        if (element.hidden) {
          continue;
        }
        if (element.active && drawActiveElementsOnTop) {
          active.push(element);
        } else {
          element.draw(ctx, area);
        }
      }
      for (i = 0; i < active.length; ++i) {
        active[i].draw(ctx, area);
      }
    }
    getStyle(index3, active) {
      const mode = active ? "active" : "default";
      return index3 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index3 || 0, mode);
    }
    getContext(index3, active, mode) {
      const dataset = this.getDataset();
      let context;
      if (index3 >= 0 && index3 < this._cachedMeta.data.length) {
        const element = this._cachedMeta.data[index3];
        context = element.$context || (element.$context = createDataContext(this.getContext(), index3, element));
        context.parsed = this.getParsed(index3);
        context.raw = dataset.data[index3];
        context.index = context.dataIndex = index3;
      } else {
        context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
        context.dataset = dataset;
        context.index = context.datasetIndex = this.index;
      }
      context.active = !!active;
      context.mode = mode;
      return context;
    }
    resolveDatasetElementOptions(mode) {
      return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
    resolveDataElementOptions(index3, mode) {
      return this._resolveElementOptions(this.dataElementType.id, mode, index3);
    }
    _resolveElementOptions(elementType, mode = "default", index3) {
      const active = mode === "active";
      const cache = this._cachedDataOpts;
      const cacheKey = elementType + "-" + mode;
      const cached = cache[cacheKey];
      const sharing = this.enableOptionSharing && defined(index3);
      if (cached) {
        return cloneIfNotShared(cached, sharing);
      }
      const config = this.chart.config;
      const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
      const prefixes = active ? [
        `${elementType}Hover`,
        "hover",
        elementType,
        ""
      ] : [
        elementType,
        ""
      ];
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      const names2 = Object.keys(defaults.elements[elementType]);
      const context = () => this.getContext(index3, active, mode);
      const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
      if (values.$shared) {
        values.$shared = sharing;
        cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
      }
      return values;
    }
    _resolveAnimations(index3, transition, active) {
      const chart = this.chart;
      const cache = this._cachedDataOpts;
      const cacheKey = `animation-${transition}`;
      const cached = cache[cacheKey];
      if (cached) {
        return cached;
      }
      let options;
      if (chart.options.animation !== false) {
        const config = this.chart.config;
        const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        options = config.createResolver(scopes, this.getContext(index3, active, transition));
      }
      const animations = new Animations(chart, options && options.animations);
      if (options && options._cacheable) {
        cache[cacheKey] = Object.freeze(animations);
      }
      return animations;
    }
    getSharedOptions(options) {
      if (!options.$shared) {
        return;
      }
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
    }
    includeOptions(mode, sharedOptions) {
      return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
    _getSharedOptions(start2, mode) {
      const firstOpts = this.resolveDataElementOptions(start2, mode);
      const previouslySharedOptions = this._sharedOptions;
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
      return {
        sharedOptions,
        includeOptions
      };
    }
    updateElement(element, index3, properties, mode) {
      if (isDirectUpdateMode(mode)) {
        Object.assign(element, properties);
      } else {
        this._resolveAnimations(index3, mode).update(element, properties);
      }
    }
    updateSharedOptions(sharedOptions, mode, newOptions) {
      if (sharedOptions && !isDirectUpdateMode(mode)) {
        this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
      }
    }
    _setStyle(element, index3, mode, active) {
      element.active = active;
      const options = this.getStyle(index3, active);
      this._resolveAnimations(index3, mode, active).update(element, {
        options: !active && this.getSharedOptions(options) || options
      });
    }
    removeHoverStyle(element, datasetIndex, index3) {
      this._setStyle(element, index3, "active", false);
    }
    setHoverStyle(element, datasetIndex, index3) {
      this._setStyle(element, index3, "active", true);
    }
    _removeDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", false);
      }
    }
    _setDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", true);
      }
    }
    _resyncElements(resetNewElements) {
      const data = this._data;
      const elements2 = this._cachedMeta.data;
      for (const [method, arg1, arg2] of this._syncList) {
        this[method](arg1, arg2);
      }
      this._syncList = [];
      const numMeta = elements2.length;
      const numData = data.length;
      const count = Math.min(numData, numMeta);
      if (count) {
        this.parse(0, count);
      }
      if (numData > numMeta) {
        this._insertElements(numMeta, numData - numMeta, resetNewElements);
      } else if (numData < numMeta) {
        this._removeElements(numData, numMeta - numData);
      }
    }
    _insertElements(start2, count, resetNewElements = true) {
      const meta = this._cachedMeta;
      const data = meta.data;
      const end2 = start2 + count;
      let i;
      const move = (arr) => {
        arr.length += count;
        for (i = arr.length - 1; i >= end2; i--) {
          arr[i] = arr[i - count];
        }
      };
      move(data);
      for (i = start2; i < end2; ++i) {
        data[i] = new this.dataElementType();
      }
      if (this._parsing) {
        move(meta._parsed);
      }
      this.parse(start2, count);
      if (resetNewElements) {
        this.updateElements(data, start2, count, "reset");
      }
    }
    updateElements(element, start2, count, mode) {
    }
    _removeElements(start2, count) {
      const meta = this._cachedMeta;
      if (this._parsing) {
        const removed = meta._parsed.splice(start2, count);
        if (meta._stacked) {
          clearStacks(meta, removed);
        }
      }
      meta.data.splice(start2, count);
    }
    _sync(args) {
      if (this._parsing) {
        this._syncList.push(args);
      } else {
        const [method, arg1, arg2] = args;
        this[method](arg1, arg2);
      }
      this.chart._dataChanges.push([
        this.index,
        ...args
      ]);
    }
    _onDataPush() {
      const count = arguments.length;
      this._sync([
        "_insertElements",
        this.getDataset().data.length - count,
        count
      ]);
    }
    _onDataPop() {
      this._sync([
        "_removeElements",
        this._cachedMeta.data.length - 1,
        1
      ]);
    }
    _onDataShift() {
      this._sync([
        "_removeElements",
        0,
        1
      ]);
    }
    _onDataSplice(start2, count) {
      if (count) {
        this._sync([
          "_removeElements",
          start2,
          count
        ]);
      }
      const newCount = arguments.length - 2;
      if (newCount) {
        this._sync([
          "_insertElements",
          start2,
          newCount
        ]);
      }
    }
    _onDataUnshift() {
      this._sync([
        "_insertElements",
        0,
        arguments.length
      ]);
    }
  };
  __publicField(DatasetController, "defaults", {});
  __publicField(DatasetController, "datasetElementType", null);
  __publicField(DatasetController, "dataElementType", null);
  function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
      const visibleMetas = scale.getMatchingVisibleMetas(type);
      let values = [];
      for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
        values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
      }
      scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
    }
    return scale._cache.$bar;
  }
  function computeMinSampleSize(meta) {
    const scale = meta.iScale;
    const values = getAllScaleValues(scale, meta.type);
    let min2 = scale._length;
    let i, ilen, curr, prev;
    const updateMinAndPrev = () => {
      if (curr === 32767 || curr === -32768) {
        return;
      }
      if (defined(prev)) {
        min2 = Math.min(min2, Math.abs(curr - prev) || min2);
      }
      prev = curr;
    };
    for (i = 0, ilen = values.length; i < ilen; ++i) {
      curr = scale.getPixelForValue(values[i]);
      updateMinAndPrev();
    }
    prev = void 0;
    for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
      curr = scale.getPixelForTick(i);
      updateMinAndPrev();
    }
    return min2;
  }
  function computeFitCategoryTraits(index3, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size, ratio;
    if (isNullOrUndef(thickness)) {
      size = ruler.min * options.categoryPercentage;
      ratio = options.barPercentage;
    } else {
      size = thickness * stackCount;
      ratio = 1;
    }
    return {
      chunk: size / stackCount,
      ratio,
      start: ruler.pixels[index3] - size / 2
    };
  }
  function computeFlexCategoryTraits(index3, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index3];
    let prev = index3 > 0 ? pixels[index3 - 1] : null;
    let next = index3 < pixels.length - 1 ? pixels[index3 + 1] : null;
    const percent = options.categoryPercentage;
    if (prev === null) {
      prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
      next = curr + curr - prev;
    }
    const start2 = curr - (curr - Math.min(prev, next)) / 2 * percent;
    const size = Math.abs(next - prev) / 2 * percent;
    return {
      chunk: size / stackCount,
      ratio: options.barPercentage,
      start: start2
    };
  }
  function parseFloatBar(entry, item, vScale, i) {
    const startValue = vScale.parse(entry[0], i);
    const endValue = vScale.parse(entry[1], i);
    const min2 = Math.min(startValue, endValue);
    const max2 = Math.max(startValue, endValue);
    let barStart = min2;
    let barEnd = max2;
    if (Math.abs(min2) > Math.abs(max2)) {
      barStart = max2;
      barEnd = min2;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
      barStart,
      barEnd,
      start: startValue,
      end: endValue,
      min: min2,
      max: max2
    };
  }
  function parseValue(entry, item, vScale, i) {
    if (isArray(entry)) {
      parseFloatBar(entry, item, vScale, i);
    } else {
      item[vScale.axis] = vScale.parse(entry, i);
    }
    return item;
  }
  function parseArrayOrPrimitive(meta, data, start2, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i, ilen, item, entry;
    for (i = start2, ilen = start2 + count; i < ilen; ++i) {
      entry = data[i];
      item = {};
      item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
      parsed.push(parseValue(entry, item, vScale, i));
    }
    return parsed;
  }
  function isFloatBar(custom) {
    return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
  }
  function barSign(size, vScale, actualBase) {
    if (size !== 0) {
      return sign(size);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
  }
  function borderProps(properties) {
    let reverse, start2, end2, top3, bottom3;
    if (properties.horizontal) {
      reverse = properties.base > properties.x;
      start2 = "left";
      end2 = "right";
    } else {
      reverse = properties.base < properties.y;
      start2 = "bottom";
      end2 = "top";
    }
    if (reverse) {
      top3 = "end";
      bottom3 = "start";
    } else {
      top3 = "start";
      bottom3 = "end";
    }
    return {
      start: start2,
      end: end2,
      reverse,
      top: top3,
      bottom: bottom3
    };
  }
  function setBorderSkipped(properties, options, stack, index3) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
      properties.borderSkipped = res;
      return;
    }
    if (edge === true) {
      properties.borderSkipped = {
        top: true,
        right: true,
        bottom: true,
        left: true
      };
      return;
    }
    const { start: start2, end: end2, reverse, top: top3, bottom: bottom3 } = borderProps(properties);
    if (edge === "middle" && stack) {
      properties.enableBorderRadius = true;
      if ((stack._top || 0) === index3) {
        edge = top3;
      } else if ((stack._bottom || 0) === index3) {
        edge = bottom3;
      } else {
        res[parseEdge(bottom3, start2, end2, reverse)] = true;
        edge = top3;
      }
    }
    res[parseEdge(edge, start2, end2, reverse)] = true;
    properties.borderSkipped = res;
  }
  function parseEdge(edge, a, b, reverse) {
    if (reverse) {
      edge = swap(edge, a, b);
      edge = startEnd(edge, b, a);
    } else {
      edge = startEnd(edge, a, b);
    }
    return edge;
  }
  function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
  }
  function startEnd(v, start2, end2) {
    return v === "start" ? start2 : v === "end" ? end2 : v;
  }
  function setInflateAmount(properties, { inflateAmount }, ratio) {
    properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
  }
  var BarController = class extends DatasetController {
    parsePrimitiveData(meta, data, start2, count) {
      return parseArrayOrPrimitive(meta, data, start2, count);
    }
    parseArrayData(meta, data, start2, count) {
      return parseArrayOrPrimitive(meta, data, start2, count);
    }
    parseObjectData(meta, data, start2, count) {
      const { iScale, vScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
      const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
      const parsed = [];
      let i, ilen, item, obj;
      for (i = start2, ilen = start2 + count; i < ilen; ++i) {
        obj = data[i];
        item = {};
        item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
        parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
      }
      return parsed;
    }
    updateRangeFromParsed(range3, scale, parsed, stack) {
      super.updateRangeFromParsed(range3, scale, parsed, stack);
      const custom = parsed._custom;
      if (custom && scale === this._cachedMeta.vScale) {
        range3.min = Math.min(range3.min, custom.min);
        range3.max = Math.max(range3.max, custom.max);
      }
    }
    getMaxOverflow() {
      return 0;
    }
    getLabelAndValue(index3) {
      const meta = this._cachedMeta;
      const { iScale, vScale } = meta;
      const parsed = this.getParsed(index3);
      const custom = parsed._custom;
      const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
      return {
        label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
        value
      };
    }
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
      const meta = this._cachedMeta;
      meta.stack = this.getDataset().stack;
    }
    update(mode) {
      const meta = this._cachedMeta;
      this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start2, count, mode) {
      const reset = mode === "reset";
      const { index: index3, _cachedMeta: { vScale } } = this;
      const base = vScale.getBasePixel();
      const horizontal = vScale.isHorizontal();
      const ruler = this._getRuler();
      const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
      for (let i = start2; i < start2 + count; i++) {
        const parsed = this.getParsed(i);
        const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
          base,
          head: base
        } : this._calculateBarValuePixels(i);
        const ipixels = this._calculateBarIndexPixels(i, ruler);
        const stack = (parsed._stacks || {})[vScale.axis];
        const properties = {
          horizontal,
          base: vpixels.base,
          enableBorderRadius: !stack || isFloatBar(parsed._custom) || index3 === stack._top || index3 === stack._bottom,
          x: horizontal ? vpixels.head : ipixels.center,
          y: horizontal ? ipixels.center : vpixels.head,
          height: horizontal ? ipixels.size : Math.abs(vpixels.size),
          width: horizontal ? Math.abs(vpixels.size) : ipixels.size
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
        }
        const options = properties.options || bars[i].options;
        setBorderSkipped(properties, options, stack, index3);
        setInflateAmount(properties, options, ruler.ratio);
        this.updateElement(bars[i], i, properties, mode);
      }
    }
    _getStacks(last, dataIndex) {
      const { iScale } = this._cachedMeta;
      const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
      const stacked = iScale.options.stacked;
      const stacks = [];
      const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
      const iScaleValue = currentParsed && currentParsed[iScale.axis];
      const skipNull = (meta) => {
        const parsed = meta._parsed.find((item) => item[iScale.axis] === iScaleValue);
        const val = parsed && parsed[meta.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          return true;
        }
      };
      for (const meta of metasets) {
        if (dataIndex !== void 0 && skipNull(meta)) {
          continue;
        }
        if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
          stacks.push(meta.stack);
        }
        if (meta.index === last) {
          break;
        }
      }
      if (!stacks.length) {
        stacks.push(void 0);
      }
      return stacks;
    }
    _getStackCount(index3) {
      return this._getStacks(void 0, index3).length;
    }
    _getStackIndex(datasetIndex, name, dataIndex) {
      const stacks = this._getStacks(datasetIndex, dataIndex);
      const index3 = name !== void 0 ? stacks.indexOf(name) : -1;
      return index3 === -1 ? stacks.length - 1 : index3;
    }
    _getRuler() {
      const opts = this.options;
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const pixels = [];
      let i, ilen;
      for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
        pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
      }
      const barThickness = opts.barThickness;
      const min2 = barThickness || computeMinSampleSize(meta);
      return {
        min: min2,
        pixels,
        start: iScale._startPixel,
        end: iScale._endPixel,
        stackCount: this._getStackCount(),
        scale: iScale,
        grouped: opts.grouped,
        ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
      };
    }
    _calculateBarValuePixels(index3) {
      const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
      const actualBase = baseValue || 0;
      const parsed = this.getParsed(index3);
      const custom = parsed._custom;
      const floating = isFloatBar(custom);
      let value = parsed[vScale.axis];
      let start2 = 0;
      let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
      let head, size;
      if (length !== value) {
        start2 = length - value;
        length = value;
      }
      if (floating) {
        value = custom.barStart;
        length = custom.barEnd - custom.barStart;
        if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
          start2 = 0;
        }
        start2 += value;
      }
      const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start2;
      let base = vScale.getPixelForValue(startValue);
      if (this.chart.getDataVisibility(index3)) {
        head = vScale.getPixelForValue(start2 + length);
      } else {
        head = base;
      }
      size = head - base;
      if (Math.abs(size) < minBarLength) {
        size = barSign(size, vScale, actualBase) * minBarLength;
        if (value === actualBase) {
          base -= size / 2;
        }
        const startPixel = vScale.getPixelForDecimal(0);
        const endPixel = vScale.getPixelForDecimal(1);
        const min2 = Math.min(startPixel, endPixel);
        const max2 = Math.max(startPixel, endPixel);
        base = Math.max(Math.min(base, max2), min2);
        head = base + size;
        if (_stacked && !floating) {
          parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
        }
      }
      if (base === vScale.getPixelForValue(actualBase)) {
        const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
        base += halfGrid;
        size -= halfGrid;
      }
      return {
        size,
        base,
        head,
        center: head + size / 2
      };
    }
    _calculateBarIndexPixels(index3, ruler) {
      const scale = ruler.scale;
      const options = this.options;
      const skipNull = options.skipNull;
      const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
      let center, size;
      if (ruler.grouped) {
        const stackCount = skipNull ? this._getStackCount(index3) : ruler.stackCount;
        const range3 = options.barThickness === "flex" ? computeFlexCategoryTraits(index3, ruler, options, stackCount) : computeFitCategoryTraits(index3, ruler, options, stackCount);
        const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index3 : void 0);
        center = range3.start + range3.chunk * stackIndex + range3.chunk / 2;
        size = Math.min(maxBarThickness, range3.chunk * range3.ratio);
      } else {
        center = scale.getPixelForValue(this.getParsed(index3)[scale.axis], index3);
        size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
      }
      return {
        base: center - size / 2,
        head: center + size / 2,
        center,
        size
      };
    }
    draw() {
      const meta = this._cachedMeta;
      const vScale = meta.vScale;
      const rects = meta.data;
      const ilen = rects.length;
      let i = 0;
      for (; i < ilen; ++i) {
        if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {
          rects[i].draw(this._ctx);
        }
      }
    }
  };
  __publicField(BarController, "id", "bar");
  __publicField(BarController, "defaults", {
    datasetElementType: false,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  });
  __publicField(BarController, "overrides", {
    scales: {
      _index_: {
        type: "category",
        offset: true,
        grid: {
          offset: true
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: true
      }
    }
  });
  var BubbleController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
    }
    parsePrimitiveData(meta, data, start2, count) {
      const parsed = super.parsePrimitiveData(meta, data, start2, count);
      for (let i = 0; i < parsed.length; i++) {
        parsed[i]._custom = this.resolveDataElementOptions(i + start2).radius;
      }
      return parsed;
    }
    parseArrayData(meta, data, start2, count) {
      const parsed = super.parseArrayData(meta, data, start2, count);
      for (let i = 0; i < parsed.length; i++) {
        const item = data[start2 + i];
        parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start2).radius);
      }
      return parsed;
    }
    parseObjectData(meta, data, start2, count) {
      const parsed = super.parseObjectData(meta, data, start2, count);
      for (let i = 0; i < parsed.length; i++) {
        const item = data[start2 + i];
        parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start2).radius);
      }
      return parsed;
    }
    getMaxOverflow() {
      const data = this._cachedMeta.data;
      let max2 = 0;
      for (let i = data.length - 1; i >= 0; --i) {
        max2 = Math.max(max2, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max2 > 0 && max2;
    }
    getLabelAndValue(index3) {
      const meta = this._cachedMeta;
      const labels = this.chart.data.labels || [];
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index3);
      const x = xScale.getLabelForValue(parsed.x);
      const y3 = yScale.getLabelForValue(parsed.y);
      const r = parsed._custom;
      return {
        label: labels[index3] || "",
        value: "(" + x + ", " + y3 + (r ? ", " + r : "") + ")"
      };
    }
    update(mode) {
      const points = this._cachedMeta.data;
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start2, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      for (let i = start2; i < start2 + count; i++) {
        const point = points[i];
        const parsed = !reset && this.getParsed(i);
        const properties = {};
        const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
        const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
        properties.skip = isNaN(iPixel) || isNaN(vPixel);
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
          if (reset) {
            properties.options.radius = 0;
          }
        }
        this.updateElement(point, i, properties, mode);
      }
    }
    resolveDataElementOptions(index3, mode) {
      const parsed = this.getParsed(index3);
      let values = super.resolveDataElementOptions(index3, mode);
      if (values.$shared) {
        values = Object.assign({}, values, {
          $shared: false
        });
      }
      const radius = values.radius;
      if (mode !== "active") {
        values.radius = 0;
      }
      values.radius += valueOrDefault(parsed && parsed._custom, radius);
      return values;
    }
  };
  __publicField(BubbleController, "id", "bubble");
  __publicField(BubbleController, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "borderWidth",
          "radius"
        ]
      }
    }
  });
  __publicField(BubbleController, "overrides", {
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < TAU) {
      const startAngle = rotation;
      const endAngle = startAngle + circumference;
      const startX = Math.cos(startAngle);
      const startY = Math.sin(startAngle);
      const endX = Math.cos(endAngle);
      const endY = Math.sin(endAngle);
      const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
      const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
      const maxX = calcMax(0, startX, endX);
      const maxY = calcMax(HALF_PI, startY, endY);
      const minX = calcMin(PI, startX, endX);
      const minY = calcMin(PI + HALF_PI, startY, endY);
      ratioX = (maxX - minX) / 2;
      ratioY = (maxY - minY) / 2;
      offsetX = -(maxX + minX) / 2;
      offsetY = -(maxY + minY) / 2;
    }
    return {
      ratioX,
      ratioY,
      offsetX,
      offsetY
    };
  }
  var DoughnutController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.enableOptionSharing = true;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.offsetX = void 0;
      this.offsetY = void 0;
    }
    linkScales() {
    }
    parse(start2, count) {
      const data = this.getDataset().data;
      const meta = this._cachedMeta;
      if (this._parsing === false) {
        meta._parsed = data;
      } else {
        let getter = (i2) => +data[i2];
        if (isObject2(data[start2])) {
          const { key = "value" } = this._parsing;
          getter = (i2) => +resolveObjectKey(data[i2], key);
        }
        let i, ilen;
        for (i = start2, ilen = start2 + count; i < ilen; ++i) {
          meta._parsed[i] = getter(i);
        }
      }
    }
    _getRotation() {
      return toRadians(this.options.rotation - 90);
    }
    _getCircumference() {
      return toRadians(this.options.circumference);
    }
    _getRotationExtents() {
      let min2 = TAU;
      let max2 = -TAU;
      for (let i = 0; i < this.chart.data.datasets.length; ++i) {
        if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
          const controller = this.chart.getDatasetMeta(i).controller;
          const rotation = controller._getRotation();
          const circumference = controller._getCircumference();
          min2 = Math.min(min2, rotation);
          max2 = Math.max(max2, rotation + circumference);
        }
      }
      return {
        rotation: min2,
        circumference: max2 - min2
      };
    }
    update(mode) {
      const chart = this.chart;
      const { chartArea } = chart;
      const meta = this._cachedMeta;
      const arcs = meta.data;
      const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
      const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
      const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
      const chartWeight = this._getRingWeight(this.index);
      const { circumference, rotation } = this._getRotationExtents();
      const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
      const maxWidth = (chartArea.width - spacing) / ratioX;
      const maxHeight = (chartArea.height - spacing) / ratioY;
      const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
      const outerRadius = toDimension(this.options.radius, maxRadius);
      const innerRadius = Math.max(outerRadius * cutout, 0);
      const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
      this.offsetX = offsetX * outerRadius;
      this.offsetY = offsetY * outerRadius;
      meta.total = this.calculateTotal();
      this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
      this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    _circumference(i, reset) {
      const opts = this.options;
      const meta = this._cachedMeta;
      const circumference = this._getCircumference();
      if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
        return 0;
      }
      return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
    }
    updateElements(arcs, start2, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const centerX = (chartArea.left + chartArea.right) / 2;
      const centerY = (chartArea.top + chartArea.bottom) / 2;
      const animateScale = reset && animationOpts.animateScale;
      const innerRadius = animateScale ? 0 : this.innerRadius;
      const outerRadius = animateScale ? 0 : this.outerRadius;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
      let startAngle = this._getRotation();
      let i;
      for (i = 0; i < start2; ++i) {
        startAngle += this._circumference(i, reset);
      }
      for (i = start2; i < start2 + count; ++i) {
        const circumference = this._circumference(i, reset);
        const arc = arcs[i];
        const properties = {
          x: centerX + this.offsetX,
          y: centerY + this.offsetY,
          startAngle,
          endAngle: startAngle + circumference,
          circumference,
          outerRadius,
          innerRadius
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
        }
        startAngle += circumference;
        this.updateElement(arc, i, properties, mode);
      }
    }
    calculateTotal() {
      const meta = this._cachedMeta;
      const metaData = meta.data;
      let total = 0;
      let i;
      for (i = 0; i < metaData.length; i++) {
        const value = meta._parsed[i];
        if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
          total += Math.abs(value);
        }
      }
      return total;
    }
    calculateCircumference(value) {
      const total = this._cachedMeta.total;
      if (total > 0 && !isNaN(value)) {
        return TAU * (Math.abs(value) / total);
      }
      return 0;
    }
    getLabelAndValue(index3) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index3], chart.options.locale);
      return {
        label: labels[index3] || "",
        value
      };
    }
    getMaxBorderWidth(arcs) {
      let max2 = 0;
      const chart = this.chart;
      let i, ilen, meta, controller, options;
      if (!arcs) {
        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            meta = chart.getDatasetMeta(i);
            arcs = meta.data;
            controller = meta.controller;
            break;
          }
        }
      }
      if (!arcs) {
        return 0;
      }
      for (i = 0, ilen = arcs.length; i < ilen; ++i) {
        options = controller.resolveDataElementOptions(i);
        if (options.borderAlign !== "inner") {
          max2 = Math.max(max2, options.borderWidth || 0, options.hoverBorderWidth || 0);
        }
      }
      return max2;
    }
    getMaxOffset(arcs) {
      let max2 = 0;
      for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
        const options = this.resolveDataElementOptions(i);
        max2 = Math.max(max2, options.offset || 0, options.hoverOffset || 0);
      }
      return max2;
    }
    _getRingWeightOffset(datasetIndex) {
      let ringWeightOffset = 0;
      for (let i = 0; i < datasetIndex; ++i) {
        if (this.chart.isDatasetVisible(i)) {
          ringWeightOffset += this._getRingWeight(i);
        }
      }
      return ringWeightOffset;
    }
    _getRingWeight(datasetIndex) {
      return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
    _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
  };
  __publicField(DoughnutController, "id", "doughnut");
  __publicField(DoughnutController, "defaults", {
    datasetElementType: false,
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: false
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "circumference",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "startAngle",
          "x",
          "y",
          "offset",
          "borderWidth",
          "spacing"
        ]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  });
  __publicField(DoughnutController, "descriptors", {
    _scriptable: (name) => name !== "spacing",
    _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
  });
  __publicField(DoughnutController, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle, color: color2 } } = chart.legend.options;
              return data.labels.map((label, i) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color2,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i),
                  index: i
                };
              });
            }
            return [];
          }
        },
        onClick(e, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      }
    }
  });
  var LineController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      this.supportsDecimation = true;
      super.initialize();
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { dataset: line, data: points = [], _dataset } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start: start2, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start2;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start2 = 0;
        count = points.length;
      }
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
      this.updateElements(points, start2, count, mode);
    }
    updateElements(points, start2, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      const end2 = start2 + count;
      const pointsCount = points.length;
      let prevParsed = start2 > 0 && this.getParsed(start2 - 1);
      for (let i = 0; i < pointsCount; ++i) {
        const point = points[i];
        const properties = directUpdate ? point : {};
        if (i < start2 || i >= end2) {
          properties.skip = true;
          continue;
        }
        const parsed = this.getParsed(i);
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i, properties, mode);
        }
        prevParsed = parsed;
      }
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      const data = meta.data || [];
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
      const meta = this._cachedMeta;
      meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
      super.draw();
    }
  };
  __publicField(LineController, "id", "line");
  __publicField(LineController, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: true,
    spanGaps: false
  });
  __publicField(LineController, "overrides", {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  });
  var PolarAreaController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.innerRadius = void 0;
      this.outerRadius = void 0;
    }
    getLabelAndValue(index3) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index3].r, chart.options.locale);
      return {
        label: labels[index3] || "",
        value
      };
    }
    parseObjectData(meta, data, start2, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start2, count);
    }
    update(mode) {
      const arcs = this._cachedMeta.data;
      this._updateRadius();
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    getMinMax() {
      const meta = this._cachedMeta;
      const range3 = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      meta.data.forEach((element, index3) => {
        const parsed = this.getParsed(index3).r;
        if (!isNaN(parsed) && this.chart.getDataVisibility(index3)) {
          if (parsed < range3.min) {
            range3.min = parsed;
          }
          if (parsed > range3.max) {
            range3.max = parsed;
          }
        }
      });
      return range3;
    }
    _updateRadius() {
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
      const outerRadius = Math.max(minSize / 2, 0);
      const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
      const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
      this.outerRadius = outerRadius - radiusLength * this.index;
      this.innerRadius = this.outerRadius - radiusLength;
    }
    updateElements(arcs, start2, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const scale = this._cachedMeta.rScale;
      const centerX = scale.xCenter;
      const centerY = scale.yCenter;
      const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
      let angle = datasetStartAngle;
      let i;
      const defaultAngle = 360 / this.countVisibleElements();
      for (i = 0; i < start2; ++i) {
        angle += this._computeAngle(i, mode, defaultAngle);
      }
      for (i = start2; i < start2 + count; i++) {
        const arc = arcs[i];
        let startAngle = angle;
        let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
        let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
        angle = endAngle;
        if (reset) {
          if (animationOpts.animateScale) {
            outerRadius = 0;
          }
          if (animationOpts.animateRotate) {
            startAngle = endAngle = datasetStartAngle;
          }
        }
        const properties = {
          x: centerX,
          y: centerY,
          innerRadius: 0,
          outerRadius,
          startAngle,
          endAngle,
          options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
        };
        this.updateElement(arc, i, properties, mode);
      }
    }
    countVisibleElements() {
      const meta = this._cachedMeta;
      let count = 0;
      meta.data.forEach((element, index3) => {
        if (!isNaN(this.getParsed(index3).r) && this.chart.getDataVisibility(index3)) {
          count++;
        }
      });
      return count;
    }
    _computeAngle(index3, mode, defaultAngle) {
      return this.chart.getDataVisibility(index3) ? toRadians(this.resolveDataElementOptions(index3, mode).angle || defaultAngle) : 0;
    }
  };
  __publicField(PolarAreaController, "id", "polarArea");
  __publicField(PolarAreaController, "defaults", {
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: true
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "startAngle",
          "endAngle",
          "innerRadius",
          "outerRadius"
        ]
      }
    },
    indexAxis: "r",
    startAngle: 0
  });
  __publicField(PolarAreaController, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle, color: color2 } } = chart.legend.options;
              return data.labels.map((label, i) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color2,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i),
                  index: i
                };
              });
            }
            return [];
          }
        },
        onClick(e, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      }
    },
    scales: {
      r: {
        type: "radialLinear",
        angleLines: {
          display: false
        },
        beginAtZero: true,
        grid: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        startAngle: 0
      }
    }
  });
  var PieController = class extends DoughnutController {
  };
  __publicField(PieController, "id", "pie");
  __publicField(PieController, "defaults", {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  });
  var RadarController = class extends DatasetController {
    getLabelAndValue(index3) {
      const vScale = this._cachedMeta.vScale;
      const parsed = this.getParsed(index3);
      return {
        label: vScale.getLabels()[index3],
        value: "" + vScale.getLabelForValue(parsed[vScale.axis])
      };
    }
    parseObjectData(meta, data, start2, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start2, count);
    }
    update(mode) {
      const meta = this._cachedMeta;
      const line = meta.dataset;
      const points = meta.data || [];
      const labels = meta.iScale.getLabels();
      line.points = points;
      if (mode !== "resize") {
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
          options.borderWidth = 0;
        }
        const properties = {
          _loop: true,
          _fullLoop: labels.length === points.length,
          options
        };
        this.updateElement(line, void 0, properties, mode);
      }
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start2, count, mode) {
      const scale = this._cachedMeta.rScale;
      const reset = mode === "reset";
      for (let i = start2; i < start2 + count; i++) {
        const point = points[i];
        const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
        const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
        const x = reset ? scale.xCenter : pointPosition.x;
        const y3 = reset ? scale.yCenter : pointPosition.y;
        const properties = {
          x,
          y: y3,
          angle: pointPosition.angle,
          skip: isNaN(x) || isNaN(y3),
          options
        };
        this.updateElement(point, i, properties, mode);
      }
    }
  };
  __publicField(RadarController, "id", "radar");
  __publicField(RadarController, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    indexAxis: "r",
    showLine: true,
    elements: {
      line: {
        fill: "start"
      }
    }
  });
  __publicField(RadarController, "overrides", {
    aspectRatio: 1,
    scales: {
      r: {
        type: "radialLinear"
      }
    }
  });
  var ScatterController = class extends DatasetController {
    getLabelAndValue(index3) {
      const meta = this._cachedMeta;
      const labels = this.chart.data.labels || [];
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index3);
      const x = xScale.getLabelForValue(parsed.x);
      const y3 = yScale.getLabelForValue(parsed.y);
      return {
        label: labels[index3] || "",
        value: "(" + x + ", " + y3 + ")"
      };
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { data: points = [] } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start: start2, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start2;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start2 = 0;
        count = points.length;
      }
      if (this.options.showLine) {
        if (!this.datasetElementType) {
          this.addElements();
        }
        const { dataset: line, _dataset } = meta;
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        options.segment = this.options.segment;
        this.updateElement(line, void 0, {
          animated: !animationsDisabled,
          options
        }, mode);
      } else if (this.datasetElementType) {
        delete meta.dataset;
        this.datasetElementType = false;
      }
      this.updateElements(points, start2, count, mode);
    }
    addElements() {
      const { showLine } = this.options;
      if (!this.datasetElementType && showLine) {
        this.datasetElementType = this.chart.registry.getElement("line");
      }
      super.addElements();
    }
    updateElements(points, start2, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const firstOpts = this.resolveDataElementOptions(start2, mode);
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      let prevParsed = start2 > 0 && this.getParsed(start2 - 1);
      for (let i = start2; i < start2 + count; ++i) {
        const point = points[i];
        const parsed = this.getParsed(i);
        const properties = directUpdate ? point : {};
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i, properties, mode);
        }
        prevParsed = parsed;
      }
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const data = meta.data || [];
      if (!this.options.showLine) {
        let max2 = 0;
        for (let i = data.length - 1; i >= 0; --i) {
          max2 = Math.max(max2, data[i].size(this.resolveDataElementOptions(i)) / 2);
        }
        return max2 > 0 && max2;
      }
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
  };
  __publicField(ScatterController, "id", "scatter");
  __publicField(ScatterController, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    showLine: false,
    fill: false
  });
  __publicField(ScatterController, "overrides", {
    interaction: {
      mode: "point"
    },
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  var controllers = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BarController,
    BubbleController,
    DoughnutController,
    LineController,
    PieController,
    PolarAreaController,
    RadarController,
    ScatterController
  });
  function abstract() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
  }
  var DateAdapterBase = class {
    constructor(options) {
      __publicField(this, "options");
      this.options = options || {};
    }
    /**
    * Override default date adapter methods.
    * Accepts type parameter to define options type.
    * @example
    * Chart._adapters._date.override<{myAdapterOption: string}>({
    *   init() {
    *     console.log(this.options.myAdapterOption);
    *   }
    * })
    */
    static override(members) {
      Object.assign(DateAdapterBase.prototype, members);
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    init() {
    }
    formats() {
      return abstract();
    }
    parse() {
      return abstract();
    }
    format() {
      return abstract();
    }
    add() {
      return abstract();
    }
    diff() {
      return abstract();
    }
    startOf() {
      return abstract();
    }
    endOf() {
      return abstract();
    }
  };
  var adapters = {
    _date: DateAdapterBase
  };
  function binarySearch(metaset, axis, value, intersect) {
    const { controller, data, _sorted } = metaset;
    const iScale = controller._cachedMeta.iScale;
    const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;
    if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
      const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
      if (!intersect) {
        const result = lookupMethod(data, axis, value);
        if (spanGaps) {
          const { vScale } = controller._cachedMeta;
          const { _parsed } = metaset;
          const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
          result.lo -= Math.max(0, distanceToDefinedLo);
          const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
          result.hi += Math.max(0, distanceToDefinedHi);
        }
        return result;
      } else if (controller._sharedOptions) {
        const el2 = data[0];
        const range3 = typeof el2.getRange === "function" && el2.getRange(axis);
        if (range3) {
          const start2 = lookupMethod(data, axis, value - range3);
          const end2 = lookupMethod(data, axis, value + range3);
          return {
            lo: start2.lo,
            hi: end2.hi
          };
        }
      }
    }
    return {
      lo: 0,
      hi: data.length - 1
    };
  }
  function evaluateInteractionItems(chart, axis, position, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
      const { index: index3, data } = metasets[i];
      const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
      for (let j = lo; j <= hi; ++j) {
        const element = data[j];
        if (!element.skip) {
          handler(element, index3, j);
        }
      }
    }
  }
  function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf("x") !== -1;
    const useY = axis.indexOf("y") !== -1;
    return function(pt1, pt2) {
      const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
      const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
  }
  function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return items;
    }
    const evaluationFunc = function(element, datasetIndex, index3) {
      if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
        return;
      }
      if (element.inRange(position.x, position.y, useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index: index3
        });
      }
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
  }
  function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index3) {
      const { startAngle, endAngle } = element.getProps([
        "startAngle",
        "endAngle"
      ], useFinalPosition);
      const { angle } = getAngleFromPoint(element, {
        x: position.x,
        y: position.y
      });
      if (_angleBetween(angle, startAngle, endAngle)) {
        items.push({
          element,
          datasetIndex,
          index: index3
        });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index3) {
      const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
      if (intersect && !inRange2) {
        return;
      }
      const center = element.getCenterPoint(useFinalPosition);
      const pointInArea = !!includeInvisible || chart.isPointInArea(center);
      if (!pointInArea && !inRange2) {
        return;
      }
      const distance = distanceMetric(position, center);
      if (distance < minDistance) {
        items = [
          {
            element,
            datasetIndex,
            index: index3
          }
        ];
        minDistance = distance;
      } else if (distance === minDistance) {
        items.push({
          element,
          datasetIndex,
          index: index3
        });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return [];
    }
    return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
  }
  function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index3) => {
      if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index: index3
        });
        intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
      }
    });
    if (intersect && !intersectsItem) {
      return [];
    }
    return items;
  }
  var Interaction = {
    evaluateInteractionItems,
    modes: {
      index(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "x";
        const includeInvisible = options.includeInvisible || false;
        const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        const elements2 = [];
        if (!items.length) {
          return [];
        }
        chart.getSortedVisibleDatasetMetas().forEach((meta) => {
          const index3 = items[0].index;
          const element = meta.data[index3];
          if (element && !element.skip) {
            elements2.push({
              element,
              datasetIndex: meta.index,
              index: index3
            });
          }
        });
        return elements2;
      },
      dataset(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        if (items.length > 0) {
          const datasetIndex = items[0].datasetIndex;
          const data = chart.getDatasetMeta(datasetIndex).data;
          items = [];
          for (let i = 0; i < data.length; ++i) {
            items.push({
              element: data[i],
              datasetIndex,
              index: i
            });
          }
        }
        return items;
      },
      point(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
      },
      nearest(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
      },
      x(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
      },
      y(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
      }
    }
  };
  var STATIC_POSITIONS = [
    "left",
    "top",
    "right",
    "bottom"
  ];
  function filterByPosition(array, position) {
    return array.filter((v) => v.pos === position);
  }
  function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
  }
  function sortByWeight(array, reverse) {
    return array.sort((a, b) => {
      const v0 = reverse ? b : a;
      const v1 = reverse ? a : b;
      return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
  }
  function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i, ilen, box, pos, stack, stackWeight;
    for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
      box = boxes[i];
      ({ position: pos, options: { stack, stackWeight = 1 } } = box);
      layoutBoxes.push({
        index: i,
        box,
        pos,
        horizontal: box.isHorizontal(),
        weight: box.weight,
        stack: stack && pos + stack,
        stackWeight
      });
    }
    return layoutBoxes;
  }
  function buildStacks(layouts2) {
    const stacks = {};
    for (const wrap of layouts2) {
      const { stack, pos, stackWeight } = wrap;
      if (!stack || !STATIC_POSITIONS.includes(pos)) {
        continue;
      }
      const _stack = stacks[stack] || (stacks[stack] = {
        count: 0,
        placed: 0,
        weight: 0,
        size: 0
      });
      _stack.count++;
      _stack.weight += stackWeight;
    }
    return stacks;
  }
  function setLayoutDims(layouts2, params) {
    const stacks = buildStacks(layouts2);
    const { vBoxMaxWidth, hBoxMaxHeight } = params;
    let i, ilen, layout;
    for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
      layout = layouts2[i];
      const { fullSize } = layout.box;
      const stack = stacks[layout.stack];
      const factor = stack && layout.stackWeight / stack.weight;
      if (layout.horizontal) {
        layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
        layout.height = hBoxMaxHeight;
      } else {
        layout.width = vBoxMaxWidth;
        layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
      }
    }
    return stacks;
  }
  function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
    const left2 = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
    const right2 = sortByWeight(filterByPosition(layoutBoxes, "right"));
    const top3 = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
    const bottom3 = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
    return {
      fullSize,
      leftAndTop: left2.concat(top3),
      rightAndBottom: right2.concat(centerVertical).concat(bottom3).concat(centerHorizontal),
      chartArea: filterByPosition(layoutBoxes, "chartArea"),
      vertical: left2.concat(right2).concat(centerVertical),
      horizontal: top3.concat(bottom3).concat(centerHorizontal)
    };
  }
  function getCombinedMax(maxPadding, chartArea, a, b) {
    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
  }
  function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
  }
  function updateDims(chartArea, params, layout, stacks) {
    const { pos, box } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!isObject2(pos)) {
      if (layout.size) {
        chartArea[pos] -= layout.size;
      }
      const stack = stacks[layout.stack] || {
        size: 0,
        count: 1
      };
      stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
      layout.size = stack.size / stack.count;
      chartArea[pos] += layout.size;
    }
    if (box.getPadding) {
      updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? {
      same: widthChanged,
      other: heightChanged
    } : {
      same: heightChanged,
      other: widthChanged
    };
  }
  function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
      const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
      chartArea[pos] += change;
      return change;
    }
    chartArea.y += updatePos("top");
    chartArea.x += updatePos("left");
    updatePos("right");
    updatePos("bottom");
  }
  function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions2) {
      const margin = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      positions2.forEach((pos) => {
        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
      });
      return margin;
    }
    return horizontal ? marginForPositions([
      "left",
      "right"
    ]) : marginForPositions([
      "top",
      "bottom"
    ]);
  }
  function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i, ilen, layout, box, refit, changed;
    for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
      layout = boxes[i];
      box = layout.box;
      box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
      const { same, other } = updateDims(chartArea, params, layout, stacks);
      refit |= same && refitBoxes.length;
      changed = changed || other;
      if (!box.fullSize) {
        refitBoxes.push(layout);
      }
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
  }
  function setBoxDims(box, left2, top3, width, height) {
    box.top = top3;
    box.left = left2;
    box.right = left2 + width;
    box.bottom = top3 + height;
    box.width = width;
    box.height = height;
  }
  function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x, y: y3 } = chartArea;
    for (const layout of boxes) {
      const box = layout.box;
      const stack = stacks[layout.stack] || {
        count: 1,
        placed: 0,
        weight: 1
      };
      const weight = layout.stackWeight / stack.weight || 1;
      if (layout.horizontal) {
        const width = chartArea.w * weight;
        const height = stack.size || box.height;
        if (defined(stack.start)) {
          y3 = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, userPadding.left, y3, params.outerWidth - userPadding.right - userPadding.left, height);
        } else {
          setBoxDims(box, chartArea.left + stack.placed, y3, width, height);
        }
        stack.start = y3;
        stack.placed += width;
        y3 = box.bottom;
      } else {
        const height = chartArea.h * weight;
        const width = stack.size || box.width;
        if (defined(stack.start)) {
          x = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
        } else {
          setBoxDims(box, x, chartArea.top + stack.placed, width, height);
        }
        stack.start = x;
        stack.placed += height;
        x = box.right;
      }
    }
    chartArea.x = x;
    chartArea.y = y3;
  }
  var layouts = {
    addBox(chart, item) {
      if (!chart.boxes) {
        chart.boxes = [];
      }
      item.fullSize = item.fullSize || false;
      item.position = item.position || "top";
      item.weight = item.weight || 0;
      item._layers = item._layers || function() {
        return [
          {
            z: 0,
            draw(chartArea) {
              item.draw(chartArea);
            }
          }
        ];
      };
      chart.boxes.push(item);
    },
    removeBox(chart, layoutItem) {
      const index3 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
      if (index3 !== -1) {
        chart.boxes.splice(index3, 1);
      }
    },
    configure(chart, item, options) {
      item.fullSize = options.fullSize;
      item.position = options.position;
      item.weight = options.weight;
    },
    update(chart, width, height, minPadding) {
      if (!chart) {
        return;
      }
      const padding = toPadding(chart.options.layout.padding);
      const availableWidth = Math.max(width - padding.width, 0);
      const availableHeight = Math.max(height - padding.height, 0);
      const boxes = buildLayoutBoxes(chart.boxes);
      const verticalBoxes = boxes.vertical;
      const horizontalBoxes = boxes.horizontal;
      each(chart.boxes, (box) => {
        if (typeof box.beforeLayout === "function") {
          box.beforeLayout();
        }
      });
      const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
      const params = Object.freeze({
        outerWidth: width,
        outerHeight: height,
        padding,
        availableWidth,
        availableHeight,
        vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
        hBoxMaxHeight: availableHeight / 2
      });
      const maxPadding = Object.assign({}, padding);
      updateMaxPadding(maxPadding, toPadding(minPadding));
      const chartArea = Object.assign({
        maxPadding,
        w: availableWidth,
        h: availableHeight,
        x: padding.left,
        y: padding.top
      }, padding);
      const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
      fitBoxes(boxes.fullSize, chartArea, params, stacks);
      fitBoxes(verticalBoxes, chartArea, params, stacks);
      if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
        fitBoxes(verticalBoxes, chartArea, params, stacks);
      }
      handleMaxPadding(chartArea);
      placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
      chartArea.x += chartArea.w;
      chartArea.y += chartArea.h;
      placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
      chart.chartArea = {
        left: chartArea.left,
        top: chartArea.top,
        right: chartArea.left + chartArea.w,
        bottom: chartArea.top + chartArea.h,
        height: chartArea.h,
        width: chartArea.w
      };
      each(boxes.chartArea, (layout) => {
        const box = layout.box;
        Object.assign(box, chart.chartArea);
        box.update(chartArea.w, chartArea.h, {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        });
      });
    }
  };
  var BasePlatform = class {
    acquireContext(canvas, aspectRatio) {
    }
    releaseContext(context) {
      return false;
    }
    addEventListener(chart, type, listener) {
    }
    removeEventListener(chart, type, listener) {
    }
    getDevicePixelRatio() {
      return 1;
    }
    getMaximumSize(element, width, height, aspectRatio) {
      width = Math.max(0, width || element.width);
      height = height || element.height;
      return {
        width,
        height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
      };
    }
    isAttached(canvas) {
      return true;
    }
    updateConfig(config) {
    }
  };
  var BasicPlatform = class extends BasePlatform {
    acquireContext(item) {
      return item && item.getContext && item.getContext("2d") || null;
    }
    updateConfig(config) {
      config.options.animation = false;
    }
  };
  var EXPANDO_KEY = "$chartjs";
  var EVENT_TYPES = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
  };
  var isNullOrEmpty = (value) => value === null || value === "";
  function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute("height");
    const renderWidth = canvas.getAttribute("width");
    canvas[EXPANDO_KEY] = {
      initial: {
        height: renderHeight,
        width: renderWidth,
        style: {
          display: style.display,
          height: style.height,
          width: style.width
        }
      }
    };
    style.display = style.display || "block";
    style.boxSizing = style.boxSizing || "border-box";
    if (isNullOrEmpty(renderWidth)) {
      const displayWidth = readUsedSize(canvas, "width");
      if (displayWidth !== void 0) {
        canvas.width = displayWidth;
      }
    }
    if (isNullOrEmpty(renderHeight)) {
      if (canvas.style.height === "") {
        canvas.height = canvas.width / (aspectRatio || 2);
      } else {
        const displayHeight = readUsedSize(canvas, "height");
        if (displayHeight !== void 0) {
          canvas.height = displayHeight;
        }
      }
    }
    return canvas;
  }
  var eventListenerOptions = supportsEventListenerOptions ? {
    passive: true
  } : false;
  function addListener(node, type, listener) {
    if (node) {
      node.addEventListener(type, listener, eventListenerOptions);
    }
  }
  function removeListener(chart, type, listener) {
    if (chart && chart.canvas) {
      chart.canvas.removeEventListener(type, listener, eventListenerOptions);
    }
  }
  function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x, y: y3 } = getRelativePosition(event, chart);
    return {
      type,
      chart,
      native: event,
      x: x !== void 0 ? x : null,
      y: y3 !== void 0 ? y3 : null
    };
  }
  function nodeListContains(nodeList, canvas) {
    for (const node of nodeList) {
      if (node === canvas || node.contains(canvas)) {
        return true;
      }
    }
  }
  function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.addedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    return observer;
  }
  function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.removedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    return observer;
  }
  var drpListeningCharts = /* @__PURE__ */ new Map();
  var oldDevicePixelRatio = 0;
  function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
      return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart) => {
      if (chart.currentDevicePixelRatio !== dpr) {
        resize();
      }
    });
  }
  function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) {
      window.addEventListener("resize", onWindowResize);
    }
    drpListeningCharts.set(chart, resize);
  }
  function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
      window.removeEventListener("resize", onWindowResize);
    }
  }
  function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      return;
    }
    const resize = throttled((width, height) => {
      const w = container.clientWidth;
      listener(width, height);
      if (w < container.clientWidth) {
        listener();
      }
    }, window);
    const observer = new ResizeObserver((entries) => {
      const entry = entries[0];
      const width = entry.contentRect.width;
      const height = entry.contentRect.height;
      if (width === 0 && height === 0) {
        return;
      }
      resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
  }
  function releaseObserver(chart, type, observer) {
    if (observer) {
      observer.disconnect();
    }
    if (type === "resize") {
      unlistenDevicePixelRatioChanges(chart);
    }
  }
  function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = throttled((event) => {
      if (chart.ctx !== null) {
        listener(fromNativeEvent(event, chart));
      }
    }, chart);
    addListener(canvas, type, proxy);
    return proxy;
  }
  var DomPlatform = class extends BasePlatform {
    acquireContext(canvas, aspectRatio) {
      const context = canvas && canvas.getContext && canvas.getContext("2d");
      if (context && context.canvas === canvas) {
        initCanvas(canvas, aspectRatio);
        return context;
      }
      return null;
    }
    releaseContext(context) {
      const canvas = context.canvas;
      if (!canvas[EXPANDO_KEY]) {
        return false;
      }
      const initial = canvas[EXPANDO_KEY].initial;
      [
        "height",
        "width"
      ].forEach((prop) => {
        const value = initial[prop];
        if (isNullOrUndef(value)) {
          canvas.removeAttribute(prop);
        } else {
          canvas.setAttribute(prop, value);
        }
      });
      const style = initial.style || {};
      Object.keys(style).forEach((key) => {
        canvas.style[key] = style[key];
      });
      canvas.width = canvas.width;
      delete canvas[EXPANDO_KEY];
      return true;
    }
    addEventListener(chart, type, listener) {
      this.removeEventListener(chart, type);
      const proxies = chart.$proxies || (chart.$proxies = {});
      const handlers = {
        attach: createAttachObserver,
        detach: createDetachObserver,
        resize: createResizeObserver
      };
      const handler = handlers[type] || createProxyAndListen;
      proxies[type] = handler(chart, type, listener);
    }
    removeEventListener(chart, type) {
      const proxies = chart.$proxies || (chart.$proxies = {});
      const proxy = proxies[type];
      if (!proxy) {
        return;
      }
      const handlers = {
        attach: releaseObserver,
        detach: releaseObserver,
        resize: releaseObserver
      };
      const handler = handlers[type] || removeListener;
      handler(chart, type, proxy);
      proxies[type] = void 0;
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio;
    }
    getMaximumSize(canvas, width, height, aspectRatio) {
      return getMaximumSize(canvas, width, height, aspectRatio);
    }
    isAttached(canvas) {
      const container = canvas && _getParentNode(canvas);
      return !!(container && container.isConnected);
    }
  };
  function _detectPlatform(canvas) {
    if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
      return BasicPlatform;
    }
    return DomPlatform;
  }
  var Element2 = class {
    constructor() {
      __publicField(this, "x");
      __publicField(this, "y");
      __publicField(this, "active", false);
      __publicField(this, "options");
      __publicField(this, "$animations");
    }
    tooltipPosition(useFinalPosition) {
      const { x, y: y3 } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x,
        y: y3
      };
    }
    hasValue() {
      return isNumber(this.x) && isNumber(this.y);
    }
    getProps(props, final) {
      const anims = this.$animations;
      if (!final || !anims) {
        return this;
      }
      const ret = {};
      props.forEach((prop) => {
        ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
      });
      return ret;
    }
  };
  __publicField(Element2, "defaults", {});
  __publicField(Element2, "defaultRoutes");
  function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const determinedMaxTicks = determineMaxTicks(scale);
    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
      skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
      return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
      let i, ilen;
      const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
      skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
      for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
        skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
      }
      skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
      return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
  }
  function determineMaxTicks(scale) {
    const offset2 = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset2 ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
  }
  function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
      return Math.max(spacing, 1);
    }
    const factors = _factorize(evenMajorSpacing);
    for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
      const factor = factors[i];
      if (factor > spacing) {
        return factor;
      }
    }
    return Math.max(spacing, 1);
  }
  function getMajorIndices(ticks) {
    const result = [];
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (ticks[i].major) {
        result.push(i);
      }
    }
    return result;
  }
  function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i;
    spacing = Math.ceil(spacing);
    for (i = 0; i < ticks.length; i++) {
      if (i === next) {
        newTicks.push(ticks[i]);
        count++;
        next = majorIndices[count * spacing];
      }
    }
  }
  function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start2 = valueOrDefault(majorStart, 0);
    const end2 = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
      length = majorEnd - majorStart;
      spacing = length / Math.floor(length / spacing);
    }
    next = start2;
    while (next < 0) {
      count++;
      next = Math.round(start2 + count * spacing);
    }
    for (i = Math.max(start2, 0); i < end2; i++) {
      if (i === next) {
        newTicks.push(ticks[i]);
        count++;
        next = Math.round(start2 + count * spacing);
      }
    }
  }
  function getEvenSpacing(arr) {
    const len = arr.length;
    let i, diff;
    if (len < 2) {
      return false;
    }
    for (diff = arr[0], i = 1; i < len; ++i) {
      if (arr[i] - arr[i - 1] !== diff) {
        return false;
      }
    }
    return diff;
  }
  var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
  var offsetFromEdge = (scale, edge, offset2) => edge === "top" || edge === "left" ? scale[edge] + offset2 : scale[edge] - offset2;
  var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
  function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i = 0;
    for (; i < len; i += increment) {
      result.push(arr[Math.floor(i)]);
    }
    return result;
  }
  function getPixelForGridLine(scale, index3, offsetGridLines) {
    const length = scale.ticks.length;
    const validIndex2 = Math.min(index3, length - 1);
    const start2 = scale._startPixel;
    const end2 = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex2);
    let offset2;
    if (offsetGridLines) {
      if (length === 1) {
        offset2 = Math.max(lineValue - start2, end2 - lineValue);
      } else if (index3 === 0) {
        offset2 = (scale.getPixelForTick(1) - lineValue) / 2;
      } else {
        offset2 = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
      }
      lineValue += validIndex2 < index3 ? offset2 : -offset2;
      if (lineValue < start2 - epsilon || lineValue > end2 + epsilon) {
        return;
      }
    }
    return lineValue;
  }
  function garbageCollect(caches, length) {
    each(caches, (cache) => {
      const gc = cache.gc;
      const gcLen = gc.length / 2;
      let i;
      if (gcLen > length) {
        for (i = 0; i < gcLen; ++i) {
          delete cache.data[gc[i]];
        }
        gc.splice(0, gcLen);
      }
    });
  }
  function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
  }
  function getTitleHeight(options, fallback) {
    if (!options.display) {
      return 0;
    }
    const font = toFont(options.font, fallback);
    const padding = toPadding(options.padding);
    const lines = isArray(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
  }
  function createScaleContext(parent, scale) {
    return createContext(parent, {
      scale,
      type: "scale"
    });
  }
  function createTickContext(parent, index3, tick) {
    return createContext(parent, {
      tick,
      index: index3,
      type: "tick"
    });
  }
  function titleAlign(align, position, reverse) {
    let ret = _toLeftRightCenter(align);
    if (reverse && position !== "right" || !reverse && position === "right") {
      ret = reverseAlign(ret);
    }
    return ret;
  }
  function titleArgs(scale, offset2, position, align) {
    const { top: top3, left: left2, bottom: bottom3, right: right2, chart } = scale;
    const { chartArea, scales: scales2 } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom3 - top3;
    const width = right2 - left2;
    if (scale.isHorizontal()) {
      titleX = _alignStartEnd(align, left2, right2);
      if (isObject2(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset2;
      } else if (position === "center") {
        titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset2;
      } else {
        titleY = offsetFromEdge(scale, position, offset2);
      }
      maxWidth = right2 - left2;
    } else {
      if (isObject2(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset2;
      } else if (position === "center") {
        titleX = (chartArea.left + chartArea.right) / 2 - width + offset2;
      } else {
        titleX = offsetFromEdge(scale, position, offset2);
      }
      titleY = _alignStartEnd(align, bottom3, top3);
      rotation = position === "left" ? -HALF_PI : HALF_PI;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  var Scale = class extends Element2 {
    constructor(cfg) {
      super();
      this.id = cfg.id;
      this.type = cfg.type;
      this.options = void 0;
      this.ctx = cfg.ctx;
      this.chart = cfg.chart;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      this.maxWidth = void 0;
      this.maxHeight = void 0;
      this.paddingTop = void 0;
      this.paddingBottom = void 0;
      this.paddingLeft = void 0;
      this.paddingRight = void 0;
      this.axis = void 0;
      this.labelRotation = void 0;
      this.min = void 0;
      this.max = void 0;
      this._range = void 0;
      this.ticks = [];
      this._gridLineItems = null;
      this._labelItems = null;
      this._labelSizes = null;
      this._length = 0;
      this._maxLength = 0;
      this._longestTextCache = {};
      this._startPixel = void 0;
      this._endPixel = void 0;
      this._reversePixels = false;
      this._userMax = void 0;
      this._userMin = void 0;
      this._suggestedMax = void 0;
      this._suggestedMin = void 0;
      this._ticksLength = 0;
      this._borderValue = 0;
      this._cache = {};
      this._dataLimitsCached = false;
      this.$context = void 0;
    }
    init(options) {
      this.options = options.setContext(this.getContext());
      this.axis = options.axis;
      this._userMin = this.parse(options.min);
      this._userMax = this.parse(options.max);
      this._suggestedMin = this.parse(options.suggestedMin);
      this._suggestedMax = this.parse(options.suggestedMax);
    }
    parse(raw, index3) {
      return raw;
    }
    getUserBounds() {
      let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
      _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
      _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
      _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
      _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
      return {
        min: finiteOrDefault(_userMin, _suggestedMin),
        max: finiteOrDefault(_userMax, _suggestedMax),
        minDefined: isNumberFinite(_userMin),
        maxDefined: isNumberFinite(_userMax)
      };
    }
    getMinMax(canStack) {
      let { min: min2, max: max2, minDefined, maxDefined } = this.getUserBounds();
      let range3;
      if (minDefined && maxDefined) {
        return {
          min: min2,
          max: max2
        };
      }
      const metas = this.getMatchingVisibleMetas();
      for (let i = 0, ilen = metas.length; i < ilen; ++i) {
        range3 = metas[i].controller.getMinMax(this, canStack);
        if (!minDefined) {
          min2 = Math.min(min2, range3.min);
        }
        if (!maxDefined) {
          max2 = Math.max(max2, range3.max);
        }
      }
      min2 = maxDefined && min2 > max2 ? max2 : min2;
      max2 = minDefined && min2 > max2 ? min2 : max2;
      return {
        min: finiteOrDefault(min2, finiteOrDefault(max2, min2)),
        max: finiteOrDefault(max2, finiteOrDefault(min2, max2))
      };
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      };
    }
    getTicks() {
      return this.ticks;
    }
    getLabels() {
      const data = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
    }
    getLabelItems(chartArea = this.chart.chartArea) {
      const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
      return items;
    }
    beforeLayout() {
      this._cache = {};
      this._dataLimitsCached = false;
    }
    beforeUpdate() {
      callback(this.options.beforeUpdate, [
        this
      ]);
    }
    update(maxWidth, maxHeight, margins) {
      const { beginAtZero, grace, ticks: tickOpts } = this.options;
      const sampleSize = tickOpts.sampleSize;
      this.beforeUpdate();
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, margins);
      this.ticks = null;
      this._labelSizes = null;
      this._gridLineItems = null;
      this._labelItems = null;
      this.beforeSetDimensions();
      this.setDimensions();
      this.afterSetDimensions();
      this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
      if (!this._dataLimitsCached) {
        this.beforeDataLimits();
        this.determineDataLimits();
        this.afterDataLimits();
        this._range = _addGrace(this, grace, beginAtZero);
        this._dataLimitsCached = true;
      }
      this.beforeBuildTicks();
      this.ticks = this.buildTicks() || [];
      this.afterBuildTicks();
      const samplingEnabled = sampleSize < this.ticks.length;
      this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
      this.configure();
      this.beforeCalculateLabelRotation();
      this.calculateLabelRotation();
      this.afterCalculateLabelRotation();
      if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
        this.ticks = autoSkip(this, this.ticks);
        this._labelSizes = null;
        this.afterAutoSkip();
      }
      if (samplingEnabled) {
        this._convertTicksToLabels(this.ticks);
      }
      this.beforeFit();
      this.fit();
      this.afterFit();
      this.afterUpdate();
    }
    configure() {
      let reversePixels = this.options.reverse;
      let startPixel, endPixel;
      if (this.isHorizontal()) {
        startPixel = this.left;
        endPixel = this.right;
      } else {
        startPixel = this.top;
        endPixel = this.bottom;
        reversePixels = !reversePixels;
      }
      this._startPixel = startPixel;
      this._endPixel = endPixel;
      this._reversePixels = reversePixels;
      this._length = endPixel - startPixel;
      this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
      callback(this.options.afterUpdate, [
        this
      ]);
    }
    beforeSetDimensions() {
      callback(this.options.beforeSetDimensions, [
        this
      ]);
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = 0;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = 0;
        this.bottom = this.height;
      }
      this.paddingLeft = 0;
      this.paddingTop = 0;
      this.paddingRight = 0;
      this.paddingBottom = 0;
    }
    afterSetDimensions() {
      callback(this.options.afterSetDimensions, [
        this
      ]);
    }
    _callHooks(name) {
      this.chart.notifyPlugins(name, this.getContext());
      callback(this.options[name], [
        this
      ]);
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {
    }
    afterDataLimits() {
      this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
      return [];
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
      callback(this.options.beforeTickToLabelConversion, [
        this
      ]);
    }
    generateTickLabels(ticks) {
      const tickOpts = this.options.ticks;
      let i, ilen, tick;
      for (i = 0, ilen = ticks.length; i < ilen; i++) {
        tick = ticks[i];
        tick.label = callback(tickOpts.callback, [
          tick.value,
          i,
          ticks
        ], this);
      }
    }
    afterTickToLabelConversion() {
      callback(this.options.afterTickToLabelConversion, [
        this
      ]);
    }
    beforeCalculateLabelRotation() {
      callback(this.options.beforeCalculateLabelRotation, [
        this
      ]);
    }
    calculateLabelRotation() {
      const options = this.options;
      const tickOpts = options.ticks;
      const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
      const minRotation = tickOpts.minRotation || 0;
      const maxRotation = tickOpts.maxRotation;
      let labelRotation = minRotation;
      let tickWidth, maxHeight, maxLabelDiagonal;
      if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
        this.labelRotation = minRotation;
        return;
      }
      const labelSizes = this._getLabelSizes();
      const maxLabelWidth = labelSizes.widest.width;
      const maxLabelHeight = labelSizes.highest.height;
      const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
      tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
      if (maxLabelWidth + 6 > tickWidth) {
        tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
        maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
        maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
        labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
        labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
      }
      this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
      callback(this.options.afterCalculateLabelRotation, [
        this
      ]);
    }
    afterAutoSkip() {
    }
    beforeFit() {
      callback(this.options.beforeFit, [
        this
      ]);
    }
    fit() {
      const minSize = {
        width: 0,
        height: 0
      };
      const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
      const display = this._isVisible();
      const isHorizontal = this.isHorizontal();
      if (display) {
        const titleHeight = getTitleHeight(titleOpts, chart.options.font);
        if (isHorizontal) {
          minSize.width = this.maxWidth;
          minSize.height = getTickMarkLength(gridOpts) + titleHeight;
        } else {
          minSize.height = this.maxHeight;
          minSize.width = getTickMarkLength(gridOpts) + titleHeight;
        }
        if (tickOpts.display && this.ticks.length) {
          const { first, last, widest, highest } = this._getLabelSizes();
          const tickPadding = tickOpts.padding * 2;
          const angleRadians = toRadians(this.labelRotation);
          const cos = Math.cos(angleRadians);
          const sin = Math.sin(angleRadians);
          if (isHorizontal) {
            const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
            minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
          } else {
            const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
            minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
          }
          this._calculatePadding(first, last, sin, cos);
        }
      }
      this._handleMargins();
      if (isHorizontal) {
        this.width = this._length = chart.width - this._margins.left - this._margins.right;
        this.height = minSize.height;
      } else {
        this.width = minSize.width;
        this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
      }
    }
    _calculatePadding(first, last, sin, cos) {
      const { ticks: { align, padding }, position } = this.options;
      const isRotated = this.labelRotation !== 0;
      const labelsBelowTicks = position !== "top" && this.axis === "x";
      if (this.isHorizontal()) {
        const offsetLeft = this.getPixelForTick(0) - this.left;
        const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
        let paddingLeft = 0;
        let paddingRight = 0;
        if (isRotated) {
          if (labelsBelowTicks) {
            paddingLeft = cos * first.width;
            paddingRight = sin * last.height;
          } else {
            paddingLeft = sin * first.height;
            paddingRight = cos * last.width;
          }
        } else if (align === "start") {
          paddingRight = last.width;
        } else if (align === "end") {
          paddingLeft = first.width;
        } else if (align !== "inner") {
          paddingLeft = first.width / 2;
          paddingRight = last.width / 2;
        }
        this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
        this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
      } else {
        let paddingTop = last.height / 2;
        let paddingBottom = first.height / 2;
        if (align === "start") {
          paddingTop = 0;
          paddingBottom = first.height;
        } else if (align === "end") {
          paddingTop = last.height;
          paddingBottom = 0;
        }
        this.paddingTop = paddingTop + padding;
        this.paddingBottom = paddingBottom + padding;
      }
    }
    _handleMargins() {
      if (this._margins) {
        this._margins.left = Math.max(this.paddingLeft, this._margins.left);
        this._margins.top = Math.max(this.paddingTop, this._margins.top);
        this._margins.right = Math.max(this.paddingRight, this._margins.right);
        this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
      }
    }
    afterFit() {
      callback(this.options.afterFit, [
        this
      ]);
    }
    isHorizontal() {
      const { axis, position } = this.options;
      return position === "top" || position === "bottom" || axis === "x";
    }
    isFullSize() {
      return this.options.fullSize;
    }
    _convertTicksToLabels(ticks) {
      this.beforeTickToLabelConversion();
      this.generateTickLabels(ticks);
      let i, ilen;
      for (i = 0, ilen = ticks.length; i < ilen; i++) {
        if (isNullOrUndef(ticks[i].label)) {
          ticks.splice(i, 1);
          ilen--;
          i--;
        }
      }
      this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
      let labelSizes = this._labelSizes;
      if (!labelSizes) {
        const sampleSize = this.options.ticks.sampleSize;
        let ticks = this.ticks;
        if (sampleSize < ticks.length) {
          ticks = sample(ticks, sampleSize);
        }
        this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
      }
      return labelSizes;
    }
    _computeLabelSizes(ticks, length, maxTicksLimit) {
      const { ctx, _longestTextCache: caches } = this;
      const widths = [];
      const heights = [];
      const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
      let widestLabelSize = 0;
      let highestLabelSize = 0;
      let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
      for (i = 0; i < length; i += increment) {
        label = ticks[i].label;
        tickFont = this._resolveTickFontOptions(i);
        ctx.font = fontString = tickFont.string;
        cache = caches[fontString] = caches[fontString] || {
          data: {},
          gc: []
        };
        lineHeight = tickFont.lineHeight;
        width = height = 0;
        if (!isNullOrUndef(label) && !isArray(label)) {
          width = _measureText(ctx, cache.data, cache.gc, width, label);
          height = lineHeight;
        } else if (isArray(label)) {
          for (j = 0, jlen = label.length; j < jlen; ++j) {
            nestedLabel = label[j];
            if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
              width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
              height += lineHeight;
            }
          }
        }
        widths.push(width);
        heights.push(height);
        widestLabelSize = Math.max(width, widestLabelSize);
        highestLabelSize = Math.max(height, highestLabelSize);
      }
      garbageCollect(caches, length);
      const widest = widths.indexOf(widestLabelSize);
      const highest = heights.indexOf(highestLabelSize);
      const valueAt = (idx) => ({
        width: widths[idx] || 0,
        height: heights[idx] || 0
      });
      return {
        first: valueAt(0),
        last: valueAt(length - 1),
        widest: valueAt(widest),
        highest: valueAt(highest),
        widths,
        heights
      };
    }
    getLabelForValue(value) {
      return value;
    }
    getPixelForValue(value, index3) {
      return NaN;
    }
    getValueForPixel(pixel) {
    }
    getPixelForTick(index3) {
      const ticks = this.ticks;
      if (index3 < 0 || index3 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index3].value);
    }
    getPixelForDecimal(decimal) {
      if (this._reversePixels) {
        decimal = 1 - decimal;
      }
      const pixel = this._startPixel + decimal * this._length;
      return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
    }
    getDecimalForPixel(pixel) {
      const decimal = (pixel - this._startPixel) / this._length;
      return this._reversePixels ? 1 - decimal : decimal;
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
      const { min: min2, max: max2 } = this;
      return min2 < 0 && max2 < 0 ? max2 : min2 > 0 && max2 > 0 ? min2 : 0;
    }
    getContext(index3) {
      const ticks = this.ticks || [];
      if (index3 >= 0 && index3 < ticks.length) {
        const tick = ticks[index3];
        return tick.$context || (tick.$context = createTickContext(this.getContext(), index3, tick));
      }
      return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
    _tickSize() {
      const optionTicks = this.options.ticks;
      const rot = toRadians(this.labelRotation);
      const cos = Math.abs(Math.cos(rot));
      const sin = Math.abs(Math.sin(rot));
      const labelSizes = this._getLabelSizes();
      const padding = optionTicks.autoSkipPadding || 0;
      const w = labelSizes ? labelSizes.widest.width + padding : 0;
      const h = labelSizes ? labelSizes.highest.height + padding : 0;
      return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
    }
    _isVisible() {
      const display = this.options.display;
      if (display !== "auto") {
        return !!display;
      }
      return this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(chartArea) {
      const axis = this.axis;
      const chart = this.chart;
      const options = this.options;
      const { grid, position, border } = options;
      const offset2 = grid.offset;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const ticksLength = ticks.length + (offset2 ? 1 : 0);
      const tl = getTickMarkLength(grid);
      const items = [];
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = borderOpts.display ? borderOpts.width : 0;
      const axisHalfWidth = axisWidth / 2;
      const alignBorderValue = function(pixel) {
        return _alignPixel(chart, pixel, axisWidth);
      };
      let borderValue, i, lineValue, alignedLineValue;
      let tx1, ty1, tx2, ty2, x1, y1, x2, y22;
      if (position === "top") {
        borderValue = alignBorderValue(this.bottom);
        ty1 = this.bottom - tl;
        ty2 = borderValue - axisHalfWidth;
        y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
        y22 = chartArea.bottom;
      } else if (position === "bottom") {
        borderValue = alignBorderValue(this.top);
        y1 = chartArea.top;
        y22 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
        ty1 = borderValue + axisHalfWidth;
        ty2 = this.top + tl;
      } else if (position === "left") {
        borderValue = alignBorderValue(this.right);
        tx1 = this.right - tl;
        tx2 = borderValue - axisHalfWidth;
        x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
        x2 = chartArea.right;
      } else if (position === "right") {
        borderValue = alignBorderValue(this.left);
        x1 = chartArea.left;
        x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
        tx1 = borderValue + axisHalfWidth;
        tx2 = this.left + tl;
      } else if (axis === "x") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        y1 = chartArea.top;
        y22 = chartArea.bottom;
        ty1 = borderValue + axisHalfWidth;
        ty2 = ty1 + tl;
      } else if (axis === "y") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        tx1 = borderValue - axisHalfWidth;
        tx2 = tx1 - tl;
        x1 = chartArea.left;
        x2 = chartArea.right;
      }
      const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
      const step = Math.max(1, Math.ceil(ticksLength / limit));
      for (i = 0; i < ticksLength; i += step) {
        const context = this.getContext(i);
        const optsAtIndex = grid.setContext(context);
        const optsAtIndexBorder = border.setContext(context);
        const lineWidth = optsAtIndex.lineWidth;
        const lineColor = optsAtIndex.color;
        const borderDash = optsAtIndexBorder.dash || [];
        const borderDashOffset = optsAtIndexBorder.dashOffset;
        const tickWidth = optsAtIndex.tickWidth;
        const tickColor = optsAtIndex.tickColor;
        const tickBorderDash = optsAtIndex.tickBorderDash || [];
        const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
        lineValue = getPixelForGridLine(this, i, offset2);
        if (lineValue === void 0) {
          continue;
        }
        alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
        if (isHorizontal) {
          tx1 = tx2 = x1 = x2 = alignedLineValue;
        } else {
          ty1 = ty2 = y1 = y22 = alignedLineValue;
        }
        items.push({
          tx1,
          ty1,
          tx2,
          ty2,
          x1,
          y1,
          x2,
          y2: y22,
          width: lineWidth,
          color: lineColor,
          borderDash,
          borderDashOffset,
          tickWidth,
          tickColor,
          tickBorderDash,
          tickBorderDashOffset
        });
      }
      this._ticksLength = ticksLength;
      this._borderValue = borderValue;
      return items;
    }
    _computeLabelItems(chartArea) {
      const axis = this.axis;
      const options = this.options;
      const { position, ticks: optionTicks } = options;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const { align, crossAlign, padding, mirror } = optionTicks;
      const tl = getTickMarkLength(options.grid);
      const tickAndPadding = tl + padding;
      const hTickAndPadding = mirror ? -padding : tickAndPadding;
      const rotation = -toRadians(this.labelRotation);
      const items = [];
      let i, ilen, tick, label, x, y3, textAlign, pixel, font, lineHeight, lineCount, textOffset;
      let textBaseline = "middle";
      if (position === "top") {
        y3 = this.bottom - hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "bottom") {
        y3 = this.top + hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "left") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x = ret.x;
      } else if (position === "right") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x = ret.x;
      } else if (axis === "x") {
        if (position === "center") {
          y3 = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          y3 = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
        }
        textAlign = this._getXAxisLabelAlignment();
      } else if (axis === "y") {
        if (position === "center") {
          x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          x = this.chart.scales[positionAxisID].getPixelForValue(value);
        }
        textAlign = this._getYAxisLabelAlignment(tl).textAlign;
      }
      if (axis === "y") {
        if (align === "start") {
          textBaseline = "top";
        } else if (align === "end") {
          textBaseline = "bottom";
        }
      }
      const labelSizes = this._getLabelSizes();
      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        tick = ticks[i];
        label = tick.label;
        const optsAtIndex = optionTicks.setContext(this.getContext(i));
        pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
        font = this._resolveTickFontOptions(i);
        lineHeight = font.lineHeight;
        lineCount = isArray(label) ? label.length : 1;
        const halfCount = lineCount / 2;
        const color2 = optsAtIndex.color;
        const strokeColor = optsAtIndex.textStrokeColor;
        const strokeWidth = optsAtIndex.textStrokeWidth;
        let tickTextAlign = textAlign;
        if (isHorizontal) {
          x = pixel;
          if (textAlign === "inner") {
            if (i === ilen - 1) {
              tickTextAlign = !this.options.reverse ? "right" : "left";
            } else if (i === 0) {
              tickTextAlign = !this.options.reverse ? "left" : "right";
            } else {
              tickTextAlign = "center";
            }
          }
          if (position === "top") {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = -lineCount * lineHeight + lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
            } else {
              textOffset = -labelSizes.highest.height + lineHeight / 2;
            }
          } else {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
            } else {
              textOffset = labelSizes.highest.height - lineCount * lineHeight;
            }
          }
          if (mirror) {
            textOffset *= -1;
          }
          if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
            x += lineHeight / 2 * Math.sin(rotation);
          }
        } else {
          y3 = pixel;
          textOffset = (1 - lineCount) * lineHeight / 2;
        }
        let backdrop;
        if (optsAtIndex.showLabelBackdrop) {
          const labelPadding = toPadding(optsAtIndex.backdropPadding);
          const height = labelSizes.heights[i];
          const width = labelSizes.widths[i];
          let top3 = textOffset - labelPadding.top;
          let left2 = 0 - labelPadding.left;
          switch (textBaseline) {
            case "middle":
              top3 -= height / 2;
              break;
            case "bottom":
              top3 -= height;
              break;
          }
          switch (textAlign) {
            case "center":
              left2 -= width / 2;
              break;
            case "right":
              left2 -= width;
              break;
            case "inner":
              if (i === ilen - 1) {
                left2 -= width;
              } else if (i > 0) {
                left2 -= width / 2;
              }
              break;
          }
          backdrop = {
            left: left2,
            top: top3,
            width: width + labelPadding.width,
            height: height + labelPadding.height,
            color: optsAtIndex.backdropColor
          };
        }
        items.push({
          label,
          font,
          textOffset,
          options: {
            rotation,
            color: color2,
            strokeColor,
            strokeWidth,
            textAlign: tickTextAlign,
            textBaseline,
            translation: [
              x,
              y3
            ],
            backdrop
          }
        });
      }
      return items;
    }
    _getXAxisLabelAlignment() {
      const { position, ticks } = this.options;
      const rotation = -toRadians(this.labelRotation);
      if (rotation) {
        return position === "top" ? "left" : "right";
      }
      let align = "center";
      if (ticks.align === "start") {
        align = "left";
      } else if (ticks.align === "end") {
        align = "right";
      } else if (ticks.align === "inner") {
        align = "inner";
      }
      return align;
    }
    _getYAxisLabelAlignment(tl) {
      const { position, ticks: { crossAlign, mirror, padding } } = this.options;
      const labelSizes = this._getLabelSizes();
      const tickAndPadding = tl + padding;
      const widest = labelSizes.widest.width;
      let textAlign;
      let x;
      if (position === "left") {
        if (mirror) {
          x = this.right + padding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x += widest / 2;
          } else {
            textAlign = "right";
            x += widest;
          }
        } else {
          x = this.right - tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x -= widest / 2;
          } else {
            textAlign = "left";
            x = this.left;
          }
        }
      } else if (position === "right") {
        if (mirror) {
          x = this.left + padding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x -= widest / 2;
          } else {
            textAlign = "left";
            x -= widest;
          }
        } else {
          x = this.left + tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x += widest / 2;
          } else {
            textAlign = "right";
            x = this.right;
          }
        }
      } else {
        textAlign = "right";
      }
      return {
        textAlign,
        x
      };
    }
    _computeLabelArea() {
      if (this.options.ticks.mirror) {
        return;
      }
      const chart = this.chart;
      const position = this.options.position;
      if (position === "left" || position === "right") {
        return {
          top: 0,
          left: this.left,
          bottom: chart.height,
          right: this.right
        };
      }
      if (position === "top" || position === "bottom") {
        return {
          top: this.top,
          left: 0,
          bottom: this.bottom,
          right: chart.width
        };
      }
    }
    drawBackground() {
      const { ctx, options: { backgroundColor }, left: left2, top: top3, width, height } = this;
      if (backgroundColor) {
        ctx.save();
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(left2, top3, width, height);
        ctx.restore();
      }
    }
    getLineWidthForValue(value) {
      const grid = this.options.grid;
      if (!this._isVisible() || !grid.display) {
        return 0;
      }
      const ticks = this.ticks;
      const index3 = ticks.findIndex((t) => t.value === value);
      if (index3 >= 0) {
        const opts = grid.setContext(this.getContext(index3));
        return opts.lineWidth;
      }
      return 0;
    }
    drawGrid(chartArea) {
      const grid = this.options.grid;
      const ctx = this.ctx;
      const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
      let i, ilen;
      const drawLine = (p1, p2, style) => {
        if (!style.width || !style.color) {
          return;
        }
        ctx.save();
        ctx.lineWidth = style.width;
        ctx.strokeStyle = style.color;
        ctx.setLineDash(style.borderDash || []);
        ctx.lineDashOffset = style.borderDashOffset;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        ctx.restore();
      };
      if (grid.display) {
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          const item = items[i];
          if (grid.drawOnChartArea) {
            drawLine({
              x: item.x1,
              y: item.y1
            }, {
              x: item.x2,
              y: item.y2
            }, item);
          }
          if (grid.drawTicks) {
            drawLine({
              x: item.tx1,
              y: item.ty1
            }, {
              x: item.tx2,
              y: item.ty2
            }, {
              color: item.tickColor,
              width: item.tickWidth,
              borderDash: item.tickBorderDash,
              borderDashOffset: item.tickBorderDashOffset
            });
          }
        }
      }
    }
    drawBorder() {
      const { chart, ctx, options: { border, grid } } = this;
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = border.display ? borderOpts.width : 0;
      if (!axisWidth) {
        return;
      }
      const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
      const borderValue = this._borderValue;
      let x1, x2, y1, y22;
      if (this.isHorizontal()) {
        x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
        x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
        y1 = y22 = borderValue;
      } else {
        y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
        y22 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
        x1 = x2 = borderValue;
      }
      ctx.save();
      ctx.lineWidth = borderOpts.width;
      ctx.strokeStyle = borderOpts.color;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y22);
      ctx.stroke();
      ctx.restore();
    }
    drawLabels(chartArea) {
      const optionTicks = this.options.ticks;
      if (!optionTicks.display) {
        return;
      }
      const ctx = this.ctx;
      const area = this._computeLabelArea();
      if (area) {
        clipArea(ctx, area);
      }
      const items = this.getLabelItems(chartArea);
      for (const item of items) {
        const renderTextOptions = item.options;
        const tickFont = item.font;
        const label = item.label;
        const y3 = item.textOffset;
        renderText(ctx, label, 0, y3, tickFont, renderTextOptions);
      }
      if (area) {
        unclipArea(ctx);
      }
    }
    drawTitle() {
      const { ctx, options: { position, title, reverse } } = this;
      if (!title.display) {
        return;
      }
      const font = toFont(title.font);
      const padding = toPadding(title.padding);
      const align = title.align;
      let offset2 = font.lineHeight / 2;
      if (position === "bottom" || position === "center" || isObject2(position)) {
        offset2 += padding.bottom;
        if (isArray(title.text)) {
          offset2 += font.lineHeight * (title.text.length - 1);
        }
      } else {
        offset2 += padding.top;
      }
      const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset2, position, align);
      renderText(ctx, title.text, 0, 0, font, {
        color: title.color,
        maxWidth,
        rotation,
        textAlign: titleAlign(align, position, reverse),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
    draw(chartArea) {
      if (!this._isVisible()) {
        return;
      }
      this.drawBackground();
      this.drawGrid(chartArea);
      this.drawBorder();
      this.drawTitle();
      this.drawLabels(chartArea);
    }
    _layers() {
      const opts = this.options;
      const tz = opts.ticks && opts.ticks.z || 0;
      const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
      const bz = valueOrDefault(opts.border && opts.border.z, 0);
      if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
        return [
          {
            z: tz,
            draw: (chartArea) => {
              this.draw(chartArea);
            }
          }
        ];
      }
      return [
        {
          z: gz,
          draw: (chartArea) => {
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawTitle();
          }
        },
        {
          z: bz,
          draw: () => {
            this.drawBorder();
          }
        },
        {
          z: tz,
          draw: (chartArea) => {
            this.drawLabels(chartArea);
          }
        }
      ];
    }
    getMatchingVisibleMetas(type) {
      const metas = this.chart.getSortedVisibleDatasetMetas();
      const axisID = this.axis + "AxisID";
      const result = [];
      let i, ilen;
      for (i = 0, ilen = metas.length; i < ilen; ++i) {
        const meta = metas[i];
        if (meta[axisID] === this.id && (!type || meta.type === type)) {
          result.push(meta);
        }
      }
      return result;
    }
    _resolveTickFontOptions(index3) {
      const opts = this.options.ticks.setContext(this.getContext(index3));
      return toFont(opts.font);
    }
    _maxDigits() {
      const fontSize = this._resolveTickFontOptions(0).lineHeight;
      return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
  };
  var TypedRegistry = class {
    constructor(type, scope, override) {
      this.type = type;
      this.scope = scope;
      this.override = override;
      this.items = /* @__PURE__ */ Object.create(null);
    }
    isForType(type) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
    register(item) {
      const proto = Object.getPrototypeOf(item);
      let parentScope;
      if (isIChartComponent(proto)) {
        parentScope = this.register(proto);
      }
      const items = this.items;
      const id = item.id;
      const scope = this.scope + "." + id;
      if (!id) {
        throw new Error("class does not have id: " + item);
      }
      if (id in items) {
        return scope;
      }
      items[id] = item;
      registerDefaults(item, scope, parentScope);
      if (this.override) {
        defaults.override(item.id, item.overrides);
      }
      return scope;
    }
    get(id) {
      return this.items[id];
    }
    unregister(item) {
      const items = this.items;
      const id = item.id;
      const scope = this.scope;
      if (id in items) {
        delete items[id];
      }
      if (scope && id in defaults[scope]) {
        delete defaults[scope][id];
        if (this.override) {
          delete overrides[id];
        }
      }
    }
  };
  function registerDefaults(item, scope, parentScope) {
    const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
      parentScope ? defaults.get(parentScope) : {},
      defaults.get(scope),
      item.defaults
    ]);
    defaults.set(scope, itemDefaults);
    if (item.defaultRoutes) {
      routeDefaults(scope, item.defaultRoutes);
    }
    if (item.descriptors) {
      defaults.describe(scope, item.descriptors);
    }
  }
  function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property) => {
      const propertyParts = property.split(".");
      const sourceName = propertyParts.pop();
      const sourceScope = [
        scope
      ].concat(propertyParts).join(".");
      const parts = routes[property].split(".");
      const targetName = parts.pop();
      const targetScope = parts.join(".");
      defaults.route(sourceScope, sourceName, targetScope, targetName);
    });
  }
  function isIChartComponent(proto) {
    return "id" in proto && "defaults" in proto;
  }
  var Registry = class {
    constructor() {
      this.controllers = new TypedRegistry(DatasetController, "datasets", true);
      this.elements = new TypedRegistry(Element2, "elements");
      this.plugins = new TypedRegistry(Object, "plugins");
      this.scales = new TypedRegistry(Scale, "scales");
      this._typedRegistries = [
        this.controllers,
        this.scales,
        this.elements
      ];
    }
    add(...args) {
      this._each("register", args);
    }
    remove(...args) {
      this._each("unregister", args);
    }
    addControllers(...args) {
      this._each("register", args, this.controllers);
    }
    addElements(...args) {
      this._each("register", args, this.elements);
    }
    addPlugins(...args) {
      this._each("register", args, this.plugins);
    }
    addScales(...args) {
      this._each("register", args, this.scales);
    }
    getController(id) {
      return this._get(id, this.controllers, "controller");
    }
    getElement(id) {
      return this._get(id, this.elements, "element");
    }
    getPlugin(id) {
      return this._get(id, this.plugins, "plugin");
    }
    getScale(id) {
      return this._get(id, this.scales, "scale");
    }
    removeControllers(...args) {
      this._each("unregister", args, this.controllers);
    }
    removeElements(...args) {
      this._each("unregister", args, this.elements);
    }
    removePlugins(...args) {
      this._each("unregister", args, this.plugins);
    }
    removeScales(...args) {
      this._each("unregister", args, this.scales);
    }
    _each(method, args, typedRegistry) {
      [
        ...args
      ].forEach((arg) => {
        const reg = typedRegistry || this._getRegistryForType(arg);
        if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
          this._exec(method, reg, arg);
        } else {
          each(arg, (item) => {
            const itemReg = typedRegistry || this._getRegistryForType(item);
            this._exec(method, itemReg, item);
          });
        }
      });
    }
    _exec(method, registry2, component) {
      const camelMethod = _capitalize(method);
      callback(component["before" + camelMethod], [], component);
      registry2[method](component);
      callback(component["after" + camelMethod], [], component);
    }
    _getRegistryForType(type) {
      for (let i = 0; i < this._typedRegistries.length; i++) {
        const reg = this._typedRegistries[i];
        if (reg.isForType(type)) {
          return reg;
        }
      }
      return this.plugins;
    }
    _get(id, typedRegistry, type) {
      const item = typedRegistry.get(id);
      if (item === void 0) {
        throw new Error('"' + id + '" is not a registered ' + type + ".");
      }
      return item;
    }
  };
  var registry = /* @__PURE__ */ new Registry();
  var PluginService = class {
    constructor() {
      this._init = [];
    }
    notify(chart, hook, args, filter) {
      if (hook === "beforeInit") {
        this._init = this._createDescriptors(chart, true);
        this._notify(this._init, chart, "install");
      }
      const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
      const result = this._notify(descriptors2, chart, hook, args);
      if (hook === "afterDestroy") {
        this._notify(descriptors2, chart, "stop");
        this._notify(this._init, chart, "uninstall");
      }
      return result;
    }
    _notify(descriptors2, chart, hook, args) {
      args = args || {};
      for (const descriptor of descriptors2) {
        const plugin = descriptor.plugin;
        const method = plugin[hook];
        const params = [
          chart,
          args,
          descriptor.options
        ];
        if (callback(method, params, plugin) === false && args.cancelable) {
          return false;
        }
      }
      return true;
    }
    invalidate() {
      if (!isNullOrUndef(this._cache)) {
        this._oldCache = this._cache;
        this._cache = void 0;
      }
    }
    _descriptors(chart) {
      if (this._cache) {
        return this._cache;
      }
      const descriptors2 = this._cache = this._createDescriptors(chart);
      this._notifyStateChanges(chart);
      return descriptors2;
    }
    _createDescriptors(chart, all) {
      const config = chart && chart.config;
      const options = valueOrDefault(config.options && config.options.plugins, {});
      const plugins3 = allPlugins(config);
      return options === false && !all ? [] : createDescriptors(chart, plugins3, options, all);
    }
    _notifyStateChanges(chart) {
      const previousDescriptors = this._oldCache || [];
      const descriptors2 = this._cache;
      const diff = (a, b) => a.filter((x) => !b.some((y3) => x.plugin.id === y3.plugin.id));
      this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
      this._notify(diff(descriptors2, previousDescriptors), chart, "start");
    }
  };
  function allPlugins(config) {
    const localIds = {};
    const plugins3 = [];
    const keys = Object.keys(registry.plugins.items);
    for (let i = 0; i < keys.length; i++) {
      plugins3.push(registry.getPlugin(keys[i]));
    }
    const local = config.plugins || [];
    for (let i = 0; i < local.length; i++) {
      const plugin = local[i];
      if (plugins3.indexOf(plugin) === -1) {
        plugins3.push(plugin);
        localIds[plugin.id] = true;
      }
    }
    return {
      plugins: plugins3,
      localIds
    };
  }
  function getOpts(options, all) {
    if (!all && options === false) {
      return null;
    }
    if (options === true) {
      return {};
    }
    return options;
  }
  function createDescriptors(chart, { plugins: plugins3, localIds }, options, all) {
    const result = [];
    const context = chart.getContext();
    for (const plugin of plugins3) {
      const id = plugin.id;
      const opts = getOpts(options[id], all);
      if (opts === null) {
        continue;
      }
      result.push({
        plugin,
        options: pluginOpts(chart.config, {
          plugin,
          local: localIds[id]
        }, opts, context)
      });
    }
    return result;
  }
  function pluginOpts(config, { plugin, local }, opts, context) {
    const keys = config.pluginScopeKeys(plugin);
    const scopes = config.getOptionScopes(opts, keys);
    if (local && plugin.defaults) {
      scopes.push(plugin.defaults);
    }
    return config.createResolver(scopes, context, [
      ""
    ], {
      scriptable: false,
      indexable: false,
      allKeys: true
    });
  }
  function getIndexAxis(type, options) {
    const datasetDefaults = defaults.datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
  }
  function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === "_index_") {
      axis = indexAxis;
    } else if (id === "_value_") {
      axis = indexAxis === "x" ? "y" : "x";
    }
    return axis;
  }
  function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? "_index_" : "_value_";
  }
  function idMatchesAxis(id) {
    if (id === "x" || id === "y" || id === "r") {
      return id;
    }
  }
  function axisFromPosition(position) {
    if (position === "top" || position === "bottom") {
      return "x";
    }
    if (position === "left" || position === "right") {
      return "y";
    }
  }
  function determineAxis(id, ...scaleOptions) {
    if (idMatchesAxis(id)) {
      return id;
    }
    for (const opts of scaleOptions) {
      const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
      if (axis) {
        return axis;
      }
    }
    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
  }
  function getAxisFromDataset(id, axis, dataset) {
    if (dataset[axis + "AxisID"] === id) {
      return {
        axis
      };
    }
  }
  function retrieveAxisFromDatasets(id, config) {
    if (config.data && config.data.datasets) {
      const boundDs = config.data.datasets.filter((d3) => d3.xAxisID === id || d3.yAxisID === id);
      if (boundDs.length) {
        return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
      }
    }
    return {};
  }
  function mergeScaleConfig(config, options) {
    const chartDefaults = overrides[config.type] || {
      scales: {}
    };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const scales2 = /* @__PURE__ */ Object.create(null);
    Object.keys(configScales).forEach((id) => {
      const scaleConf = configScales[id];
      if (!isObject2(scaleConf)) {
        return console.error(`Invalid scale configuration for scale: ${id}`);
      }
      if (scaleConf._proxy) {
        return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
      }
      const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
      const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
      const defaultScaleOptions = chartDefaults.scales || {};
      scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
        {
          axis
        },
        scaleConf,
        defaultScaleOptions[axis],
        defaultScaleOptions[defaultId]
      ]);
    });
    config.data.datasets.forEach((dataset) => {
      const type = dataset.type || config.type;
      const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
      const datasetDefaults = overrides[type] || {};
      const defaultScaleOptions = datasetDefaults.scales || {};
      Object.keys(defaultScaleOptions).forEach((defaultID) => {
        const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
        const id = dataset[axis + "AxisID"] || axis;
        scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
        mergeIf(scales2[id], [
          {
            axis
          },
          configScales[id],
          defaultScaleOptions[defaultID]
        ]);
      });
    });
    Object.keys(scales2).forEach((key) => {
      const scale = scales2[key];
      mergeIf(scale, [
        defaults.scales[scale.type],
        defaults.scale
      ]);
    });
    return scales2;
  }
  function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = valueOrDefault(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
  }
  function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
  }
  function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
  }
  var keyCache = /* @__PURE__ */ new Map();
  var keysCached = /* @__PURE__ */ new Set();
  function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
      keys = generate();
      keyCache.set(cacheKey, keys);
      keysCached.add(keys);
    }
    return keys;
  }
  var addIfFound = (set2, obj, key) => {
    const opts = resolveObjectKey(obj, key);
    if (opts !== void 0) {
      set2.add(opts);
    }
  };
  var Config = class {
    constructor(config) {
      this._config = initConfig(config);
      this._scopeCache = /* @__PURE__ */ new Map();
      this._resolverCache = /* @__PURE__ */ new Map();
    }
    get platform() {
      return this._config.platform;
    }
    get type() {
      return this._config.type;
    }
    set type(type) {
      this._config.type = type;
    }
    get data() {
      return this._config.data;
    }
    set data(data) {
      this._config.data = initData(data);
    }
    get options() {
      return this._config.options;
    }
    set options(options) {
      this._config.options = options;
    }
    get plugins() {
      return this._config.plugins;
    }
    update() {
      const config = this._config;
      this.clearCache();
      initOptions(config);
    }
    clearCache() {
      this._scopeCache.clear();
      this._resolverCache.clear();
    }
    datasetScopeKeys(datasetType) {
      return cachedKeys(datasetType, () => [
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetAnimationScopeKeys(datasetType, transition) {
      return cachedKeys(`${datasetType}.transition.${transition}`, () => [
        [
          `datasets.${datasetType}.transitions.${transition}`,
          `transitions.${transition}`
        ],
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetElementScopeKeys(datasetType, elementType) {
      return cachedKeys(`${datasetType}-${elementType}`, () => [
        [
          `datasets.${datasetType}.elements.${elementType}`,
          `datasets.${datasetType}`,
          `elements.${elementType}`,
          ""
        ]
      ]);
    }
    pluginScopeKeys(plugin) {
      const id = plugin.id;
      const type = this.type;
      return cachedKeys(`${type}-plugin-${id}`, () => [
        [
          `plugins.${id}`,
          ...plugin.additionalOptionScopes || []
        ]
      ]);
    }
    _cachedScopes(mainScope, resetCache) {
      const _scopeCache = this._scopeCache;
      let cache = _scopeCache.get(mainScope);
      if (!cache || resetCache) {
        cache = /* @__PURE__ */ new Map();
        _scopeCache.set(mainScope, cache);
      }
      return cache;
    }
    getOptionScopes(mainScope, keyLists, resetCache) {
      const { options, type } = this;
      const cache = this._cachedScopes(mainScope, resetCache);
      const cached = cache.get(keyLists);
      if (cached) {
        return cached;
      }
      const scopes = /* @__PURE__ */ new Set();
      keyLists.forEach((keys) => {
        if (mainScope) {
          scopes.add(mainScope);
          keys.forEach((key) => addIfFound(scopes, mainScope, key));
        }
        keys.forEach((key) => addIfFound(scopes, options, key));
        keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
        keys.forEach((key) => addIfFound(scopes, defaults, key));
        keys.forEach((key) => addIfFound(scopes, descriptors, key));
      });
      const array = Array.from(scopes);
      if (array.length === 0) {
        array.push(/* @__PURE__ */ Object.create(null));
      }
      if (keysCached.has(keyLists)) {
        cache.set(keyLists, array);
      }
      return array;
    }
    chartOptionScopes() {
      const { options, type } = this;
      return [
        options,
        overrides[type] || {},
        defaults.datasets[type] || {},
        {
          type
        },
        defaults,
        descriptors
      ];
    }
    resolveNamedOptions(scopes, names2, context, prefixes = [
      ""
    ]) {
      const result = {
        $shared: true
      };
      const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
      let options = resolver;
      if (needContext(resolver, names2)) {
        result.$shared = false;
        context = isFunction(context) ? context() : context;
        const subResolver = this.createResolver(scopes, context, subPrefixes);
        options = _attachContext(resolver, context, subResolver);
      }
      for (const prop of names2) {
        result[prop] = options[prop];
      }
      return result;
    }
    createResolver(scopes, context, prefixes = [
      ""
    ], descriptorDefaults) {
      const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
      return isObject2(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
    }
  };
  function getResolver(resolverCache, scopes, prefixes) {
    let cache = resolverCache.get(scopes);
    if (!cache) {
      cache = /* @__PURE__ */ new Map();
      resolverCache.set(scopes, cache);
    }
    const cacheKey = prefixes.join();
    let cached = cache.get(cacheKey);
    if (!cached) {
      const resolver = _createResolver(scopes, prefixes);
      cached = {
        resolver,
        subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
      };
      cache.set(cacheKey, cached);
    }
    return cached;
  }
  var hasFunction = (value) => isObject2(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
  function needContext(proxy, names2) {
    const { isScriptable, isIndexable } = _descriptors(proxy);
    for (const prop of names2) {
      const scriptable = isScriptable(prop);
      const indexable = isIndexable(prop);
      const value = (indexable || scriptable) && proxy[prop];
      if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
        return true;
      }
    }
    return false;
  }
  var version = "4.4.9";
  var KNOWN_POSITIONS = [
    "top",
    "bottom",
    "left",
    "right",
    "chartArea"
  ];
  function positionIsHorizontal(position, axis) {
    return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
  }
  function compare2Level(l1, l2) {
    return function(a, b) {
      return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
    };
  }
  function onAnimationsComplete(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    chart.notifyPlugins("afterRender");
    callback(animationOptions && animationOptions.onComplete, [
      context
    ], chart);
  }
  function onAnimationProgress(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    callback(animationOptions && animationOptions.onProgress, [
      context
    ], chart);
  }
  function getCanvas(item) {
    if (_isDomSupported() && typeof item === "string") {
      item = document.getElementById(item);
    } else if (item && item.length) {
      item = item[0];
    }
    if (item && item.canvas) {
      item = item.canvas;
    }
    return item;
  }
  var instances = {};
  var getChart = (key) => {
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c) => c.canvas === canvas).pop();
  };
  function moveNumericKeys(obj, start2, move) {
    const keys = Object.keys(obj);
    for (const key of keys) {
      const intKey = +key;
      if (intKey >= start2) {
        const value = obj[key];
        delete obj[key];
        if (move > 0 || intKey > start2) {
          obj[intKey + move] = value;
        }
      }
    }
  }
  function determineLastEvent(e, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e.type === "mouseout") {
      return null;
    }
    if (isClick) {
      return lastEvent;
    }
    return e;
  }
  var Chart = class {
    static register(...items) {
      registry.add(...items);
      invalidatePlugins();
    }
    static unregister(...items) {
      registry.remove(...items);
      invalidatePlugins();
    }
    constructor(item, userConfig) {
      const config = this.config = new Config(userConfig);
      const initialCanvas = getCanvas(item);
      const existingChart = getChart(initialCanvas);
      if (existingChart) {
        throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
      }
      const options = config.createResolver(config.chartOptionScopes(), this.getContext());
      this.platform = new (config.platform || _detectPlatform(initialCanvas))();
      this.platform.updateConfig(config);
      const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
      const canvas = context && context.canvas;
      const height = canvas && canvas.height;
      const width = canvas && canvas.width;
      this.id = uid();
      this.ctx = context;
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this._options = options;
      this._aspectRatio = this.aspectRatio;
      this._layers = [];
      this._metasets = [];
      this._stacks = void 0;
      this.boxes = [];
      this.currentDevicePixelRatio = void 0;
      this.chartArea = void 0;
      this._active = [];
      this._lastEvent = void 0;
      this._listeners = {};
      this._responsiveListeners = void 0;
      this._sortedMetasets = [];
      this.scales = {};
      this._plugins = new PluginService();
      this.$proxies = {};
      this._hiddenIndices = {};
      this.attached = false;
      this._animationsDisabled = void 0;
      this.$context = void 0;
      this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
      this._dataChanges = [];
      instances[this.id] = this;
      if (!context || !canvas) {
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }
      animator.listen(this, "complete", onAnimationsComplete);
      animator.listen(this, "progress", onAnimationProgress);
      this._initialize();
      if (this.attached) {
        this.update();
      }
    }
    get aspectRatio() {
      const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
      if (!isNullOrUndef(aspectRatio)) {
        return aspectRatio;
      }
      if (maintainAspectRatio && _aspectRatio) {
        return _aspectRatio;
      }
      return height ? width / height : null;
    }
    get data() {
      return this.config.data;
    }
    set data(data) {
      this.config.data = data;
    }
    get options() {
      return this._options;
    }
    set options(options) {
      this.config.options = options;
    }
    get registry() {
      return registry;
    }
    _initialize() {
      this.notifyPlugins("beforeInit");
      if (this.options.responsive) {
        this.resize();
      } else {
        retinaScale(this, this.options.devicePixelRatio);
      }
      this.bindEvents();
      this.notifyPlugins("afterInit");
      return this;
    }
    clear() {
      clearCanvas(this.canvas, this.ctx);
      return this;
    }
    stop() {
      animator.stop(this);
      return this;
    }
    resize(width, height) {
      if (!animator.running(this)) {
        this._resize(width, height);
      } else {
        this._resizeBeforeDraw = {
          width,
          height
        };
      }
    }
    _resize(width, height) {
      const options = this.options;
      const canvas = this.canvas;
      const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
      const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
      const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
      const mode = this.width ? "resize" : "attach";
      this.width = newSize.width;
      this.height = newSize.height;
      this._aspectRatio = this.aspectRatio;
      if (!retinaScale(this, newRatio, true)) {
        return;
      }
      this.notifyPlugins("resize", {
        size: newSize
      });
      callback(options.onResize, [
        this,
        newSize
      ], this);
      if (this.attached) {
        if (this._doResize(mode)) {
          this.render();
        }
      }
    }
    ensureScalesHaveIDs() {
      const options = this.options;
      const scalesOptions = options.scales || {};
      each(scalesOptions, (axisOptions, axisID) => {
        axisOptions.id = axisID;
      });
    }
    buildOrUpdateScales() {
      const options = this.options;
      const scaleOpts = options.scales;
      const scales2 = this.scales;
      const updated = Object.keys(scales2).reduce((obj, id) => {
        obj[id] = false;
        return obj;
      }, {});
      let items = [];
      if (scaleOpts) {
        items = items.concat(Object.keys(scaleOpts).map((id) => {
          const scaleOptions = scaleOpts[id];
          const axis = determineAxis(id, scaleOptions);
          const isRadial = axis === "r";
          const isHorizontal = axis === "x";
          return {
            options: scaleOptions,
            dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
            dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
          };
        }));
      }
      each(items, (item) => {
        const scaleOptions = item.options;
        const id = scaleOptions.id;
        const axis = determineAxis(id, scaleOptions);
        const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
        if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
          scaleOptions.position = item.dposition;
        }
        updated[id] = true;
        let scale = null;
        if (id in scales2 && scales2[id].type === scaleType) {
          scale = scales2[id];
        } else {
          const scaleClass = registry.getScale(scaleType);
          scale = new scaleClass({
            id,
            type: scaleType,
            ctx: this.ctx,
            chart: this
          });
          scales2[scale.id] = scale;
        }
        scale.init(scaleOptions, options);
      });
      each(updated, (hasUpdated, id) => {
        if (!hasUpdated) {
          delete scales2[id];
        }
      });
      each(scales2, (scale) => {
        layouts.configure(this, scale, scale.options);
        layouts.addBox(this, scale);
      });
    }
    _updateMetasets() {
      const metasets = this._metasets;
      const numData = this.data.datasets.length;
      const numMeta = metasets.length;
      metasets.sort((a, b) => a.index - b.index);
      if (numMeta > numData) {
        for (let i = numData; i < numMeta; ++i) {
          this._destroyDatasetMeta(i);
        }
        metasets.splice(numData, numMeta - numData);
      }
      this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
    }
    _removeUnreferencedMetasets() {
      const { _metasets: metasets, data: { datasets } } = this;
      if (metasets.length > datasets.length) {
        delete this._stacks;
      }
      metasets.forEach((meta, index3) => {
        if (datasets.filter((x) => x === meta._dataset).length === 0) {
          this._destroyDatasetMeta(index3);
        }
      });
    }
    buildOrUpdateControllers() {
      const newControllers = [];
      const datasets = this.data.datasets;
      let i, ilen;
      this._removeUnreferencedMetasets();
      for (i = 0, ilen = datasets.length; i < ilen; i++) {
        const dataset = datasets[i];
        let meta = this.getDatasetMeta(i);
        const type = dataset.type || this.config.type;
        if (meta.type && meta.type !== type) {
          this._destroyDatasetMeta(i);
          meta = this.getDatasetMeta(i);
        }
        meta.type = type;
        meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
        meta.order = dataset.order || 0;
        meta.index = i;
        meta.label = "" + dataset.label;
        meta.visible = this.isDatasetVisible(i);
        if (meta.controller) {
          meta.controller.updateIndex(i);
          meta.controller.linkScales();
        } else {
          const ControllerClass = registry.getController(type);
          const { datasetElementType, dataElementType } = defaults.datasets[type];
          Object.assign(ControllerClass, {
            dataElementType: registry.getElement(dataElementType),
            datasetElementType: datasetElementType && registry.getElement(datasetElementType)
          });
          meta.controller = new ControllerClass(this, i);
          newControllers.push(meta.controller);
        }
      }
      this._updateMetasets();
      return newControllers;
    }
    _resetElements() {
      each(this.data.datasets, (dataset, datasetIndex) => {
        this.getDatasetMeta(datasetIndex).controller.reset();
      }, this);
    }
    reset() {
      this._resetElements();
      this.notifyPlugins("reset");
    }
    update(mode) {
      const config = this.config;
      config.update();
      const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
      const animsDisabled = this._animationsDisabled = !options.animation;
      this._updateScales();
      this._checkEventBindings();
      this._updateHiddenIndices();
      this._plugins.invalidate();
      if (this.notifyPlugins("beforeUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      const newControllers = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let minPadding = 0;
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
        const { controller } = this.getDatasetMeta(i);
        const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
        controller.buildOrUpdateElements(reset);
        minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
      }
      minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
      this._updateLayout(minPadding);
      if (!animsDisabled) {
        each(newControllers, (controller) => {
          controller.reset();
        });
      }
      this._updateDatasets(mode);
      this.notifyPlugins("afterUpdate", {
        mode
      });
      this._layers.sort(compare2Level("z", "_idx"));
      const { _active, _lastEvent } = this;
      if (_lastEvent) {
        this._eventHandler(_lastEvent, true);
      } else if (_active.length) {
        this._updateHoverStyles(_active, _active, true);
      }
      this.render();
    }
    _updateScales() {
      each(this.scales, (scale) => {
        layouts.removeBox(this, scale);
      });
      this.ensureScalesHaveIDs();
      this.buildOrUpdateScales();
    }
    _checkEventBindings() {
      const options = this.options;
      const existingEvents = new Set(Object.keys(this._listeners));
      const newEvents = new Set(options.events);
      if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
        this.unbindEvents();
        this.bindEvents();
      }
    }
    _updateHiddenIndices() {
      const { _hiddenIndices } = this;
      const changes = this._getUniformDataChanges() || [];
      for (const { method, start: start2, count } of changes) {
        const move = method === "_removeElements" ? -count : count;
        moveNumericKeys(_hiddenIndices, start2, move);
      }
    }
    _getUniformDataChanges() {
      const _dataChanges = this._dataChanges;
      if (!_dataChanges || !_dataChanges.length) {
        return;
      }
      this._dataChanges = [];
      const datasetCount = this.data.datasets.length;
      const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
      const changeSet = makeSet(0);
      for (let i = 1; i < datasetCount; i++) {
        if (!setsEqual(changeSet, makeSet(i))) {
          return;
        }
      }
      return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
        method: a[1],
        start: +a[2],
        count: +a[3]
      }));
    }
    _updateLayout(minPadding) {
      if (this.notifyPlugins("beforeLayout", {
        cancelable: true
      }) === false) {
        return;
      }
      layouts.update(this, this.width, this.height, minPadding);
      const area = this.chartArea;
      const noArea = area.width <= 0 || area.height <= 0;
      this._layers = [];
      each(this.boxes, (box) => {
        if (noArea && box.position === "chartArea") {
          return;
        }
        if (box.configure) {
          box.configure();
        }
        this._layers.push(...box._layers());
      }, this);
      this._layers.forEach((item, index3) => {
        item._idx = index3;
      });
      this.notifyPlugins("afterLayout");
    }
    _updateDatasets(mode) {
      if (this.notifyPlugins("beforeDatasetsUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this.getDatasetMeta(i).controller.configure();
      }
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this._updateDataset(i, isFunction(mode) ? mode({
          datasetIndex: i
        }) : mode);
      }
      this.notifyPlugins("afterDatasetsUpdate", {
        mode
      });
    }
    _updateDataset(index3, mode) {
      const meta = this.getDatasetMeta(index3);
      const args = {
        meta,
        index: index3,
        mode,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
        return;
      }
      meta.controller._update(mode);
      args.cancelable = false;
      this.notifyPlugins("afterDatasetUpdate", args);
    }
    render() {
      if (this.notifyPlugins("beforeRender", {
        cancelable: true
      }) === false) {
        return;
      }
      if (animator.has(this)) {
        if (this.attached && !animator.running(this)) {
          animator.start(this);
        }
      } else {
        this.draw();
        onAnimationsComplete({
          chart: this
        });
      }
    }
    draw() {
      let i;
      if (this._resizeBeforeDraw) {
        const { width, height } = this._resizeBeforeDraw;
        this._resizeBeforeDraw = null;
        this._resize(width, height);
      }
      this.clear();
      if (this.width <= 0 || this.height <= 0) {
        return;
      }
      if (this.notifyPlugins("beforeDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const layers = this._layers;
      for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
        layers[i].draw(this.chartArea);
      }
      this._drawDatasets();
      for (; i < layers.length; ++i) {
        layers[i].draw(this.chartArea);
      }
      this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(filterVisible) {
      const metasets = this._sortedMetasets;
      const result = [];
      let i, ilen;
      for (i = 0, ilen = metasets.length; i < ilen; ++i) {
        const meta = metasets[i];
        if (!filterVisible || meta.visible) {
          result.push(meta);
        }
      }
      return result;
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
      if (this.notifyPlugins("beforeDatasetsDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const metasets = this.getSortedVisibleDatasetMetas();
      for (let i = metasets.length - 1; i >= 0; --i) {
        this._drawDataset(metasets[i]);
      }
      this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(meta) {
      const ctx = this.ctx;
      const args = {
        meta,
        index: meta.index,
        cancelable: true
      };
      const clip = getDatasetClipArea(this, meta);
      if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
        return;
      }
      if (clip) {
        clipArea(ctx, clip);
      }
      meta.controller.draw();
      if (clip) {
        unclipArea(ctx);
      }
      args.cancelable = false;
      this.notifyPlugins("afterDatasetDraw", args);
    }
    isPointInArea(point) {
      return _isPointInArea(point, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e, mode, options, useFinalPosition) {
      const method = Interaction.modes[mode];
      if (typeof method === "function") {
        return method(this, e, options, useFinalPosition);
      }
      return [];
    }
    getDatasetMeta(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      const metasets = this._metasets;
      let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
      if (!meta) {
        meta = {
          type: null,
          data: [],
          dataset: null,
          controller: null,
          hidden: null,
          xAxisID: null,
          yAxisID: null,
          order: dataset && dataset.order || 0,
          index: datasetIndex,
          _dataset: dataset,
          _parsed: [],
          _sorted: false
        };
        metasets.push(meta);
      }
      return meta;
    }
    getContext() {
      return this.$context || (this.$context = createContext(null, {
        chart: this,
        type: "chart"
      }));
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      if (!dataset) {
        return false;
      }
      const meta = this.getDatasetMeta(datasetIndex);
      return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
      const meta = this.getDatasetMeta(datasetIndex);
      meta.hidden = !visible;
    }
    toggleDataVisibility(index3) {
      this._hiddenIndices[index3] = !this._hiddenIndices[index3];
    }
    getDataVisibility(index3) {
      return !this._hiddenIndices[index3];
    }
    _updateVisibility(datasetIndex, dataIndex, visible) {
      const mode = visible ? "show" : "hide";
      const meta = this.getDatasetMeta(datasetIndex);
      const anims = meta.controller._resolveAnimations(void 0, mode);
      if (defined(dataIndex)) {
        meta.data[dataIndex].hidden = !visible;
        this.update();
      } else {
        this.setDatasetVisibility(datasetIndex, visible);
        anims.update(meta, {
          visible
        });
        this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
      }
    }
    hide(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, true);
    }
    _destroyDatasetMeta(datasetIndex) {
      const meta = this._metasets[datasetIndex];
      if (meta && meta.controller) {
        meta.controller._destroy();
      }
      delete this._metasets[datasetIndex];
    }
    _stop() {
      let i, ilen;
      this.stop();
      animator.remove(this);
      for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this._destroyDatasetMeta(i);
      }
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const { canvas, ctx } = this;
      this._stop();
      this.config.clearCache();
      if (canvas) {
        this.unbindEvents();
        clearCanvas(canvas, ctx);
        this.platform.releaseContext(ctx);
        this.canvas = null;
        this.ctx = null;
      }
      delete instances[this.id];
      this.notifyPlugins("afterDestroy");
    }
    toBase64Image(...args) {
      return this.canvas.toDataURL(...args);
    }
    bindEvents() {
      this.bindUserEvents();
      if (this.options.responsive) {
        this.bindResponsiveEvents();
      } else {
        this.attached = true;
      }
    }
    bindUserEvents() {
      const listeners = this._listeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const listener = (e, x, y3) => {
        e.offsetX = x;
        e.offsetY = y3;
        this._eventHandler(e);
      };
      each(this.options.events, (type) => _add(type, listener));
    }
    bindResponsiveEvents() {
      if (!this._responsiveListeners) {
        this._responsiveListeners = {};
      }
      const listeners = this._responsiveListeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const _remove = (type, listener2) => {
        if (listeners[type]) {
          platform.removeEventListener(this, type, listener2);
          delete listeners[type];
        }
      };
      const listener = (width, height) => {
        if (this.canvas) {
          this.resize(width, height);
        }
      };
      let detached;
      const attached = () => {
        _remove("attach", attached);
        this.attached = true;
        this.resize();
        _add("resize", listener);
        _add("detach", detached);
      };
      detached = () => {
        this.attached = false;
        _remove("resize", listener);
        this._stop();
        this._resize(0, 0);
        _add("attach", attached);
      };
      if (platform.isAttached(this.canvas)) {
        attached();
      } else {
        detached();
      }
    }
    unbindEvents() {
      each(this._listeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._listeners = {};
      each(this._responsiveListeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._responsiveListeners = void 0;
    }
    updateHoverStyle(items, mode, enabled) {
      const prefix = enabled ? "set" : "remove";
      let meta, item, i, ilen;
      if (mode === "dataset") {
        meta = this.getDatasetMeta(items[0].datasetIndex);
        meta.controller["_" + prefix + "DatasetHoverStyle"]();
      }
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        item = items[i];
        const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
        if (controller) {
          controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
        }
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements) {
      const lastActive = this._active || [];
      const active = activeElements.map(({ datasetIndex, index: index3 }) => {
        const meta = this.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("No dataset found at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index3],
          index: index3
        };
      });
      const changed = !_elementsEqual(active, lastActive);
      if (changed) {
        this._active = active;
        this._lastEvent = null;
        this._updateHoverStyles(active, lastActive);
      }
    }
    notifyPlugins(hook, args, filter) {
      return this._plugins.notify(this, hook, args, filter);
    }
    isPluginEnabled(pluginId) {
      return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
    }
    _updateHoverStyles(active, lastActive, replay) {
      const hoverOptions = this.options.hover;
      const diff = (a, b) => a.filter((x) => !b.some((y3) => x.datasetIndex === y3.datasetIndex && x.index === y3.index));
      const deactivated = diff(lastActive, active);
      const activated = replay ? active : diff(active, lastActive);
      if (deactivated.length) {
        this.updateHoverStyle(deactivated, hoverOptions.mode, false);
      }
      if (activated.length && hoverOptions.mode) {
        this.updateHoverStyle(activated, hoverOptions.mode, true);
      }
    }
    _eventHandler(e, replay) {
      const args = {
        event: e,
        replay,
        cancelable: true,
        inChartArea: this.isPointInArea(e)
      };
      const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
      if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
        return;
      }
      const changed = this._handleEvent(e, replay, args.inChartArea);
      args.cancelable = false;
      this.notifyPlugins("afterEvent", args, eventFilter);
      if (changed || args.changed) {
        this.render();
      }
      return this;
    }
    _handleEvent(e, replay, inChartArea) {
      const { _active: lastActive = [], options } = this;
      const useFinalPosition = replay;
      const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
      const isClick = _isClickEvent(e);
      const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
      if (inChartArea) {
        this._lastEvent = null;
        callback(options.onHover, [
          e,
          active,
          this
        ], this);
        if (isClick) {
          callback(options.onClick, [
            e,
            active,
            this
          ], this);
        }
      }
      const changed = !_elementsEqual(active, lastActive);
      if (changed || replay) {
        this._active = active;
        this._updateHoverStyles(active, lastActive, replay);
      }
      this._lastEvent = lastEvent;
      return changed;
    }
    _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
      if (e.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const hoverOptions = this.options.hover;
      return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
  };
  __publicField(Chart, "defaults", defaults);
  __publicField(Chart, "instances", instances);
  __publicField(Chart, "overrides", overrides);
  __publicField(Chart, "registry", registry);
  __publicField(Chart, "version", version);
  __publicField(Chart, "getChart", getChart);
  function invalidatePlugins() {
    return each(Chart.instances, (chart) => chart._plugins.invalidate());
  }
  function clipArc(ctx, element, endAngle) {
    const { startAngle, pixelMargin, x, y: y3, outerRadius, innerRadius } = element;
    let angleMargin = pixelMargin / outerRadius;
    ctx.beginPath();
    ctx.arc(x, y3, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
      angleMargin = pixelMargin / innerRadius;
      ctx.arc(x, y3, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
      ctx.arc(x, y3, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
    }
    ctx.closePath();
    ctx.clip();
  }
  function toRadiusCorners(value) {
    return _readValueToProps(value, [
      "outerStart",
      "outerEnd",
      "innerStart",
      "innerEnd"
    ]);
  }
  function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    const computeOuterLimit = (val) => {
      const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
      return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
      outerStart: computeOuterLimit(o.outerStart),
      outerEnd: computeOuterLimit(o.outerEnd),
      innerStart: _limitValue(o.innerStart, 0, innerLimit),
      innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
    };
  }
  function rThetaToXY(r, theta, x, y3) {
    return {
      x: x + r * Math.cos(theta),
      y: y3 + r * Math.sin(theta)
    };
  }
  function pathArc(ctx, element, offset2, spacing, end2, circular) {
    const { x, y: y3, startAngle: start2, pixelMargin, innerRadius: innerR } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset2 - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset2 + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha2 = end2 - start2;
    if (spacing) {
      const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
      const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
      const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
      const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
      spacingOffset = (alpha2 - adjustedAngle) / 2;
    }
    const beta = Math.max(1e-3, alpha2 * outerRadius - offset2 / PI) / outerRadius;
    const angleOffset = (alpha2 - beta) / 2;
    const startAngle = start2 + angleOffset + spacingOffset;
    const endAngle = end2 - angleOffset - spacingOffset;
    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
      const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
      ctx.arc(x, y3, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
      ctx.arc(x, y3, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
      if (outerEnd > 0) {
        const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y3);
        ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
      }
      const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y3);
      ctx.lineTo(p4.x, p4.y);
      if (innerEnd > 0) {
        const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y3);
        ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
      }
      const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
      ctx.arc(x, y3, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
      ctx.arc(x, y3, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
      if (innerStart > 0) {
        const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y3);
        ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
      }
      const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y3);
      ctx.lineTo(p8.x, p8.y);
      if (outerStart > 0) {
        const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y3);
        ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
      }
    } else {
      ctx.moveTo(x, y3);
      const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
      const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y3;
      ctx.lineTo(outerStartX, outerStartY);
      const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
      const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y3;
      ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
  }
  function drawArc(ctx, element, offset2, spacing, circular) {
    const { fullCircles, startAngle, circumference } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset2, spacing, endAngle, circular);
      for (let i = 0; i < fullCircles; ++i) {
        ctx.fill();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + (circumference % TAU || TAU);
      }
    }
    pathArc(ctx, element, offset2, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
  }
  function drawBorder(ctx, element, offset2, spacing, circular) {
    const { fullCircles, startAngle, circumference, options } = element;
    const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
    const inner = options.borderAlign === "inner";
    if (!borderWidth) {
      return;
    }
    ctx.setLineDash(borderDash || []);
    ctx.lineDashOffset = borderDashOffset;
    if (inner) {
      ctx.lineWidth = borderWidth * 2;
      ctx.lineJoin = borderJoinStyle || "round";
    } else {
      ctx.lineWidth = borderWidth;
      ctx.lineJoin = borderJoinStyle || "bevel";
    }
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset2, spacing, endAngle, circular);
      for (let i = 0; i < fullCircles; ++i) {
        ctx.stroke();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + (circumference % TAU || TAU);
      }
    }
    if (inner) {
      clipArc(ctx, element, endAngle);
    }
    if (!fullCircles) {
      pathArc(ctx, element, offset2, spacing, endAngle, circular);
      ctx.stroke();
    }
  }
  var ArcElement = class extends Element2 {
    constructor(cfg) {
      super();
      __publicField(this, "circumference");
      __publicField(this, "endAngle");
      __publicField(this, "fullCircles");
      __publicField(this, "innerRadius");
      __publicField(this, "outerRadius");
      __publicField(this, "pixelMargin");
      __publicField(this, "startAngle");
      this.options = void 0;
      this.circumference = void 0;
      this.startAngle = void 0;
      this.endAngle = void 0;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.pixelMargin = 0;
      this.fullCircles = 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(chartX, chartY, useFinalPosition) {
      const point = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      const { angle, distance } = getAngleFromPoint(point, {
        x: chartX,
        y: chartY
      });
      const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "circumference"
      ], useFinalPosition);
      const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
      const _circumference = valueOrDefault(circumference, endAngle - startAngle);
      const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
      const betweenAngles = _circumference >= TAU || nonZeroBetween;
      const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
      return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
      const { x, y: y3, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ], useFinalPosition);
      const { offset: offset2, spacing } = this.options;
      const halfAngle = (startAngle + endAngle) / 2;
      const halfRadius = (innerRadius + outerRadius + spacing + offset2) / 2;
      return {
        x: x + Math.cos(halfAngle) * halfRadius,
        y: y3 + Math.sin(halfAngle) * halfRadius
      };
    }
    tooltipPosition(useFinalPosition) {
      return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
      const { options, circumference } = this;
      const offset2 = (options.offset || 0) / 4;
      const spacing = (options.spacing || 0) / 2;
      const circular = options.circular;
      this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
      this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
      if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
        return;
      }
      ctx.save();
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * offset2, Math.sin(halfAngle) * offset2);
      const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
      const radiusOffset = offset2 * fix;
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      drawArc(ctx, this, radiusOffset, spacing, circular);
      drawBorder(ctx, this, radiusOffset, spacing, circular);
      ctx.restore();
    }
  };
  __publicField(ArcElement, "id", "arc");
  __publicField(ArcElement, "defaults", {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: true
  });
  __publicField(ArcElement, "defaultRoutes", {
    backgroundColor: "backgroundColor"
  });
  __publicField(ArcElement, "descriptors", {
    _scriptable: true,
    _indexable: (name) => name !== "borderDash"
  });
  function setStyle(ctx, options, style = options) {
    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
  }
  function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
  }
  function getLineMethod(options) {
    if (options.stepped) {
      return _steppedLineTo;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierCurveTo;
    }
    return lineTo;
  }
  function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
    const { start: segmentStart, end: segmentEnd } = segment;
    const start2 = Math.max(paramsStart, segmentStart);
    const end2 = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
      count,
      start: start2,
      loop: segment.loop,
      ilen: end2 < start2 && !outside ? count + end2 - start2 : end2 - start2
    };
  }
  function pathSegment(ctx, line, segment, params) {
    const { points, options } = line;
    const { count, start: start2, loop, ilen } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options);
    let { move = true, reverse } = params || {};
    let i, point, prev;
    for (i = 0; i <= ilen; ++i) {
      point = points[(start2 + (reverse ? ilen - i : i)) % count];
      if (point.skip) {
        continue;
      } else if (move) {
        ctx.moveTo(point.x, point.y);
        move = false;
      } else {
        lineMethod(ctx, prev, point, reverse, options.stepped);
      }
      prev = point;
    }
    if (loop) {
      point = points[(start2 + (reverse ? ilen : 0)) % count];
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    return !!loop;
  }
  function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count, start: start2, ilen } = pathVars(points, segment, params);
    const { move = true, reverse } = params || {};
    let avgX = 0;
    let countX = 0;
    let i, point, prevX, minY, maxY, lastY;
    const pointIndex = (index3) => (start2 + (reverse ? ilen - index3 : index3)) % count;
    const drawX = () => {
      if (minY !== maxY) {
        ctx.lineTo(avgX, maxY);
        ctx.lineTo(avgX, minY);
        ctx.lineTo(avgX, lastY);
      }
    };
    if (move) {
      point = points[pointIndex(0)];
      ctx.moveTo(point.x, point.y);
    }
    for (i = 0; i <= ilen; ++i) {
      point = points[pointIndex(i)];
      if (point.skip) {
        continue;
      }
      const x = point.x;
      const y3 = point.y;
      const truncX = x | 0;
      if (truncX === prevX) {
        if (y3 < minY) {
          minY = y3;
        } else if (y3 > maxY) {
          maxY = y3;
        }
        avgX = (countX * avgX + x) / ++countX;
      } else {
        drawX();
        ctx.lineTo(x, y3);
        prevX = truncX;
        countX = 0;
        minY = maxY = y3;
      }
      lastY = y3;
    }
    drawX();
  }
  function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
  }
  function _getInterpolationMethod(options) {
    if (options.stepped) {
      return _steppedInterpolation;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierInterpolation;
    }
    return _pointInLine;
  }
  function strokePathWithCache(ctx, line, start2, count) {
    let path = line._path;
    if (!path) {
      path = line._path = new Path2D();
      if (line.path(path, start2, count)) {
        path.closePath();
      }
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
  }
  function strokePathDirect(ctx, line, start2, count) {
    const { segments, options } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments) {
      setStyle(ctx, options, segment.style);
      ctx.beginPath();
      if (segmentMethod(ctx, line, segment, {
        start: start2,
        end: start2 + count - 1
      })) {
        ctx.closePath();
      }
      ctx.stroke();
    }
  }
  var usePath2D = typeof Path2D === "function";
  function draw(ctx, line, start2, count) {
    if (usePath2D && !line.options.segment) {
      strokePathWithCache(ctx, line, start2, count);
    } else {
      strokePathDirect(ctx, line, start2, count);
    }
  }
  var LineElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.animated = true;
      this.options = void 0;
      this._chart = void 0;
      this._loop = void 0;
      this._fullLoop = void 0;
      this._path = void 0;
      this._points = void 0;
      this._segments = void 0;
      this._decimated = false;
      this._pointsUpdated = false;
      this._datasetIndex = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    updateControlPoints(chartArea, indexAxis) {
      const options = this.options;
      if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
        const loop = options.spanGaps ? this._loop : this._fullLoop;
        _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
        this._pointsUpdated = true;
      }
    }
    set points(points) {
      this._points = points;
      delete this._segments;
      delete this._path;
      this._pointsUpdated = false;
    }
    get points() {
      return this._points;
    }
    get segments() {
      return this._segments || (this._segments = _computeSegments(this, this.options.segment));
    }
    first() {
      const segments = this.segments;
      const points = this.points;
      return segments.length && points[segments[0].start];
    }
    last() {
      const segments = this.segments;
      const points = this.points;
      const count = segments.length;
      return count && points[segments[count - 1].end];
    }
    interpolate(point, property) {
      const options = this.options;
      const value = point[property];
      const points = this.points;
      const segments = _boundSegments(this, {
        property,
        start: value,
        end: value
      });
      if (!segments.length) {
        return;
      }
      const result = [];
      const _interpolate = _getInterpolationMethod(options);
      let i, ilen;
      for (i = 0, ilen = segments.length; i < ilen; ++i) {
        const { start: start2, end: end2 } = segments[i];
        const p1 = points[start2];
        const p2 = points[end2];
        if (p1 === p2) {
          result.push(p1);
          continue;
        }
        const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
        const interpolated = _interpolate(p1, p2, t, options.stepped);
        interpolated[property] = point[property];
        result.push(interpolated);
      }
      return result.length === 1 ? result[0] : result;
    }
    pathSegment(ctx, segment, params) {
      const segmentMethod = _getSegmentMethod(this);
      return segmentMethod(ctx, this, segment, params);
    }
    path(ctx, start2, count) {
      const segments = this.segments;
      const segmentMethod = _getSegmentMethod(this);
      let loop = this._loop;
      start2 = start2 || 0;
      count = count || this.points.length - start2;
      for (const segment of segments) {
        loop &= segmentMethod(ctx, this, segment, {
          start: start2,
          end: start2 + count - 1
        });
      }
      return !!loop;
    }
    draw(ctx, chartArea, start2, count) {
      const options = this.options || {};
      const points = this.points || [];
      if (points.length && options.borderWidth) {
        ctx.save();
        draw(ctx, this, start2, count);
        ctx.restore();
      }
      if (this.animated) {
        this._pointsUpdated = false;
        this._path = void 0;
      }
    }
  };
  __publicField(LineElement, "id", "line");
  __publicField(LineElement, "defaults", {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: "default",
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
  });
  __publicField(LineElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  __publicField(LineElement, "descriptors", {
    _scriptable: true,
    _indexable: (name) => name !== "borderDash" && name !== "fill"
  });
  function inRange$1(el2, pos, axis, useFinalPosition) {
    const options = el2.options;
    const { [axis]: value } = el2.getProps([
      axis
    ], useFinalPosition);
    return Math.abs(pos - value) < options.radius + options.hitRadius;
  }
  var PointElement = class extends Element2 {
    constructor(cfg) {
      super();
      __publicField(this, "parsed");
      __publicField(this, "skip");
      __publicField(this, "stop");
      this.options = void 0;
      this.parsed = void 0;
      this.skip = void 0;
      this.stop = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      const options = this.options;
      const { x, y: y3 } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y3, 2) < Math.pow(options.hitRadius + options.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange$1(this, mouseX, "x", useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange$1(this, mouseY, "y", useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x, y: y3 } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x,
        y: y3
      };
    }
    size(options) {
      options = options || this.options || {};
      let radius = options.radius || 0;
      radius = Math.max(radius, radius && options.hoverRadius || 0);
      const borderWidth = radius && options.borderWidth || 0;
      return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
      const options = this.options;
      if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
        return;
      }
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.fillStyle = options.backgroundColor;
      drawPoint(ctx, options, this.x, this.y);
    }
    getRange() {
      const options = this.options || {};
      return options.radius + options.hitRadius;
    }
  };
  __publicField(PointElement, "id", "point");
  /**
  * @type {any}
  */
  __publicField(PointElement, "defaults", {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  });
  /**
  * @type {any}
  */
  __publicField(PointElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  function getBarBounds(bar, useFinalPosition) {
    const { x, y: y3, base, width, height } = bar.getProps([
      "x",
      "y",
      "base",
      "width",
      "height"
    ], useFinalPosition);
    let left2, right2, top3, bottom3, half;
    if (bar.horizontal) {
      half = height / 2;
      left2 = Math.min(x, base);
      right2 = Math.max(x, base);
      top3 = y3 - half;
      bottom3 = y3 + half;
    } else {
      half = width / 2;
      left2 = x - half;
      right2 = x + half;
      top3 = Math.min(y3, base);
      bottom3 = Math.max(y3, base);
    }
    return {
      left: left2,
      top: top3,
      right: right2,
      bottom: bottom3
    };
  }
  function skipOrLimit(skip2, value, min2, max2) {
    return skip2 ? 0 : _limitValue(value, min2, max2);
  }
  function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip2 = bar.borderSkipped;
    const o = toTRBL(value);
    return {
      t: skipOrLimit(skip2.top, o.top, 0, maxH),
      r: skipOrLimit(skip2.right, o.right, 0, maxW),
      b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
      l: skipOrLimit(skip2.left, o.left, 0, maxW)
    };
  }
  function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius } = bar.getProps([
      "enableBorderRadius"
    ]);
    const value = bar.options.borderRadius;
    const o = toTRBLCorners(value);
    const maxR = Math.min(maxW, maxH);
    const skip2 = bar.borderSkipped;
    const enableBorder = enableBorderRadius || isObject2(value);
    return {
      topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
      topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
      bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
      bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
    };
  }
  function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
      outer: {
        x: bounds.left,
        y: bounds.top,
        w: width,
        h: height,
        radius
      },
      inner: {
        x: bounds.left + border.l,
        y: bounds.top + border.t,
        w: width - border.l - border.r,
        h: height - border.t - border.b,
        radius: {
          topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
          topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
          bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
          bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
        }
      }
    };
  }
  function inRange(bar, x, y3, useFinalPosition) {
    const skipX = x === null;
    const skipY = y3 === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y3, bounds.top, bounds.bottom));
  }
  function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
  }
  function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
  }
  function inflateRect(rect, amount, refRect = {}) {
    const x = rect.x !== refRect.x ? -amount : 0;
    const y3 = rect.y !== refRect.y ? -amount : 0;
    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y3;
    return {
      x: rect.x + x,
      y: rect.y + y3,
      w: rect.w + w,
      h: rect.h + h,
      radius: rect.radius
    };
  }
  var BarElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.horizontal = void 0;
      this.base = void 0;
      this.width = void 0;
      this.height = void 0;
      this.inflateAmount = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    draw(ctx) {
      const { inflateAmount, options: { borderColor, backgroundColor } } = this;
      const { inner, outer } = boundingRects(this);
      const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
      ctx.save();
      if (outer.w !== inner.w || outer.h !== inner.h) {
        ctx.beginPath();
        addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
        ctx.clip();
        addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
        ctx.fillStyle = borderColor;
        ctx.fill("evenodd");
      }
      ctx.beginPath();
      addRectPath(ctx, inflateRect(inner, inflateAmount));
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x, y: y3, base, horizontal } = this.getProps([
        "x",
        "y",
        "base",
        "horizontal"
      ], useFinalPosition);
      return {
        x: horizontal ? (x + base) / 2 : x,
        y: horizontal ? y3 : (y3 + base) / 2
      };
    }
    getRange(axis) {
      return axis === "x" ? this.width / 2 : this.height / 2;
    }
  };
  __publicField(BarElement, "id", "bar");
  __publicField(BarElement, "defaults", {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  });
  __publicField(BarElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  var elements = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcElement,
    BarElement,
    LineElement,
    PointElement
  });
  var BORDER_COLORS = [
    "rgb(54, 162, 235)",
    "rgb(255, 99, 132)",
    "rgb(255, 159, 64)",
    "rgb(255, 205, 86)",
    "rgb(75, 192, 192)",
    "rgb(153, 102, 255)",
    "rgb(201, 203, 207)"
    // grey
  ];
  var BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
  function getBorderColor(i) {
    return BORDER_COLORS[i % BORDER_COLORS.length];
  }
  function getBackgroundColor(i) {
    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
  }
  function colorizeDefaultDataset(dataset, i) {
    dataset.borderColor = getBorderColor(i);
    dataset.backgroundColor = getBackgroundColor(i);
    return ++i;
  }
  function colorizeDoughnutDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));
    return i;
  }
  function colorizePolarAreaDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));
    return i;
  }
  function getColorizer(chart) {
    let i = 0;
    return (dataset, datasetIndex) => {
      const controller = chart.getDatasetMeta(datasetIndex).controller;
      if (controller instanceof DoughnutController) {
        i = colorizeDoughnutDataset(dataset, i);
      } else if (controller instanceof PolarAreaController) {
        i = colorizePolarAreaDataset(dataset, i);
      } else if (controller) {
        i = colorizeDefaultDataset(dataset, i);
      }
    };
  }
  function containsColorsDefinitions(descriptors2) {
    let k;
    for (k in descriptors2) {
      if (descriptors2[k].borderColor || descriptors2[k].backgroundColor) {
        return true;
      }
    }
    return false;
  }
  function containsColorsDefinition(descriptor) {
    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
  }
  function containsDefaultColorsDefenitions() {
    return defaults.borderColor !== "rgba(0,0,0,0.1)" || defaults.backgroundColor !== "rgba(0,0,0,0.1)";
  }
  var plugin_colors = {
    id: "colors",
    defaults: {
      enabled: true,
      forceOverride: false
    },
    beforeLayout(chart, _args, options) {
      if (!options.enabled) {
        return;
      }
      const { data: { datasets }, options: chartOptions } = chart.config;
      const { elements: elements2 } = chartOptions;
      const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2) || containsDefaultColorsDefenitions();
      if (!options.forceOverride && containsColorDefenition) {
        return;
      }
      const colorizer = getColorizer(chart);
      datasets.forEach(colorizer);
    }
  };
  function lttbDecimation(data, start2, count, availableWidth, options) {
    const samples = options.samples || availableWidth;
    if (samples >= count) {
      return data.slice(start2, start2 + count);
    }
    const decimated = [];
    const bucketWidth = (count - 2) / (samples - 2);
    let sampledIndex = 0;
    const endIndex = start2 + count - 1;
    let a = start2;
    let i, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data[a];
    for (i = 0; i < samples - 2; i++) {
      let avgX = 0;
      let avgY = 0;
      let j;
      const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start2;
      const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start2;
      const avgRangeLength = avgRangeEnd - avgRangeStart;
      for (j = avgRangeStart; j < avgRangeEnd; j++) {
        avgX += data[j].x;
        avgY += data[j].y;
      }
      avgX /= avgRangeLength;
      avgY /= avgRangeLength;
      const rangeOffs = Math.floor(i * bucketWidth) + 1 + start2;
      const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start2;
      const { x: pointAx, y: pointAy } = data[a];
      maxArea = area = -1;
      for (j = rangeOffs; j < rangeTo; j++) {
        area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
        if (area > maxArea) {
          maxArea = area;
          maxAreaPoint = data[j];
          nextA = j;
        }
      }
      decimated[sampledIndex++] = maxAreaPoint;
      a = nextA;
    }
    decimated[sampledIndex++] = data[endIndex];
    return decimated;
  }
  function minMaxDecimation(data, start2, count, availableWidth) {
    let avgX = 0;
    let countX = 0;
    let i, point, x, y3, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    const decimated = [];
    const endIndex = start2 + count - 1;
    const xMin = data[start2].x;
    const xMax = data[endIndex].x;
    const dx = xMax - xMin;
    for (i = start2; i < start2 + count; ++i) {
      point = data[i];
      x = (point.x - xMin) / dx * availableWidth;
      y3 = point.y;
      const truncX = x | 0;
      if (truncX === prevX) {
        if (y3 < minY) {
          minY = y3;
          minIndex = i;
        } else if (y3 > maxY) {
          maxY = y3;
          maxIndex = i;
        }
        avgX = (countX * avgX + point.x) / ++countX;
      } else {
        const lastIndex = i - 1;
        if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
          const intermediateIndex1 = Math.min(minIndex, maxIndex);
          const intermediateIndex2 = Math.max(minIndex, maxIndex);
          if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
            decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex1]), {
              x: avgX
            }));
          }
          if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
            decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex2]), {
              x: avgX
            }));
          }
        }
        if (i > 0 && lastIndex !== startIndex) {
          decimated.push(data[lastIndex]);
        }
        decimated.push(point);
        prevX = truncX;
        countX = 0;
        minY = maxY = y3;
        minIndex = maxIndex = startIndex = i;
      }
    }
    return decimated;
  }
  function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
      const data = dataset._data;
      delete dataset._decimated;
      delete dataset._data;
      Object.defineProperty(dataset, "data", {
        configurable: true,
        enumerable: true,
        writable: true,
        value: data
      });
    }
  }
  function cleanDecimatedData(chart) {
    chart.data.datasets.forEach((dataset) => {
      cleanDecimatedDataset(dataset);
    });
  }
  function getStartAndCountOfVisiblePointsSimplified(meta, points) {
    const pointCount = points.length;
    let start2 = 0;
    let count;
    const { iScale } = meta;
    const { min: min2, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start2 = _limitValue(_lookupByKey(points, iScale.axis, min2).lo, 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(_lookupByKey(points, iScale.axis, max2).hi + 1, start2, pointCount) - start2;
    } else {
      count = pointCount - start2;
    }
    return {
      start: start2,
      count
    };
  }
  var plugin_decimation = {
    id: "decimation",
    defaults: {
      algorithm: "min-max",
      enabled: false
    },
    beforeElementsUpdate: (chart, args, options) => {
      if (!options.enabled) {
        cleanDecimatedData(chart);
        return;
      }
      const availableWidth = chart.width;
      chart.data.datasets.forEach((dataset, datasetIndex) => {
        const { _data, indexAxis } = dataset;
        const meta = chart.getDatasetMeta(datasetIndex);
        const data = _data || dataset.data;
        if (resolve([
          indexAxis,
          chart.options.indexAxis
        ]) === "y") {
          return;
        }
        if (!meta.controller.supportsDecimation) {
          return;
        }
        const xAxis = chart.scales[meta.xAxisID];
        if (xAxis.type !== "linear" && xAxis.type !== "time") {
          return;
        }
        if (chart.options.parsing) {
          return;
        }
        let { start: start2, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
        const threshold = options.threshold || 4 * availableWidth;
        if (count <= threshold) {
          cleanDecimatedDataset(dataset);
          return;
        }
        if (isNullOrUndef(_data)) {
          dataset._data = data;
          delete dataset.data;
          Object.defineProperty(dataset, "data", {
            configurable: true,
            enumerable: true,
            get: function() {
              return this._decimated;
            },
            set: function(d3) {
              this._data = d3;
            }
          });
        }
        let decimated;
        switch (options.algorithm) {
          case "lttb":
            decimated = lttbDecimation(data, start2, count, availableWidth, options);
            break;
          case "min-max":
            decimated = minMaxDecimation(data, start2, count, availableWidth);
            break;
          default:
            throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
        }
        dataset._decimated = decimated;
      });
    },
    destroy(chart) {
      cleanDecimatedData(chart);
    }
  };
  function _segments(line, target, property) {
    const segments = line.segments;
    const points = line.points;
    const tpoints = target.points;
    const parts = [];
    for (const segment of segments) {
      let { start: start2, end: end2 } = segment;
      end2 = _findSegmentEnd(start2, end2, points);
      const bounds = _getBounds(property, points[start2], points[end2], segment.loop);
      if (!target.segments) {
        parts.push({
          source: segment,
          target: bounds,
          start: points[start2],
          end: points[end2]
        });
        continue;
      }
      const targetSegments = _boundSegments(target, bounds);
      for (const tgt of targetSegments) {
        const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
        const fillSources = _boundSegment(segment, points, subBounds);
        for (const fillSource of fillSources) {
          parts.push({
            source: fillSource,
            target: tgt,
            start: {
              [property]: _getEdge(bounds, subBounds, "start", Math.max)
            },
            end: {
              [property]: _getEdge(bounds, subBounds, "end", Math.min)
            }
          });
        }
      }
    }
    return parts;
  }
  function _getBounds(property, first, last, loop) {
    if (loop) {
      return;
    }
    let start2 = first[property];
    let end2 = last[property];
    if (property === "angle") {
      start2 = _normalizeAngle(start2);
      end2 = _normalizeAngle(end2);
    }
    return {
      property,
      start: start2,
      end: end2
    };
  }
  function _pointsFromSegments(boundary, line) {
    const { x = null, y: y3 = null } = boundary || {};
    const linePoints = line.points;
    const points = [];
    line.segments.forEach(({ start: start2, end: end2 }) => {
      end2 = _findSegmentEnd(start2, end2, linePoints);
      const first = linePoints[start2];
      const last = linePoints[end2];
      if (y3 !== null) {
        points.push({
          x: first.x,
          y: y3
        });
        points.push({
          x: last.x,
          y: y3
        });
      } else if (x !== null) {
        points.push({
          x,
          y: first.y
        });
        points.push({
          x,
          y: last.y
        });
      }
    });
    return points;
  }
  function _findSegmentEnd(start2, end2, points) {
    for (; end2 > start2; end2--) {
      const point = points[end2];
      if (!isNaN(point.x) && !isNaN(point.y)) {
        break;
      }
    }
    return end2;
  }
  function _getEdge(a, b, prop, fn2) {
    if (a && b) {
      return fn2(a[prop], b[prop]);
    }
    return a ? a[prop] : b ? b[prop] : 0;
  }
  function _createBoundaryLine(boundary, line) {
    let points = [];
    let _loop = false;
    if (isArray(boundary)) {
      _loop = true;
      points = boundary;
    } else {
      points = _pointsFromSegments(boundary, line);
    }
    return points.length ? new LineElement({
      points,
      options: {
        tension: 0
      },
      _loop,
      _fullLoop: _loop
    }) : null;
  }
  function _shouldApplyFill(source) {
    return source && source.fill !== false;
  }
  function _resolveTarget(sources, index3, propagate) {
    const source = sources[index3];
    let fill2 = source.fill;
    const visited = [
      index3
    ];
    let target;
    if (!propagate) {
      return fill2;
    }
    while (fill2 !== false && visited.indexOf(fill2) === -1) {
      if (!isNumberFinite(fill2)) {
        return fill2;
      }
      target = sources[fill2];
      if (!target) {
        return false;
      }
      if (target.visible) {
        return fill2;
      }
      visited.push(fill2);
      fill2 = target.fill;
    }
    return false;
  }
  function _decodeFill(line, index3, count) {
    const fill2 = parseFillOption(line);
    if (isObject2(fill2)) {
      return isNaN(fill2.value) ? false : fill2;
    }
    let target = parseFloat(fill2);
    if (isNumberFinite(target) && Math.floor(target) === target) {
      return decodeTargetIndex(fill2[0], index3, target, count);
    }
    return [
      "origin",
      "start",
      "end",
      "stack",
      "shape"
    ].indexOf(fill2) >= 0 && fill2;
  }
  function decodeTargetIndex(firstCh, index3, target, count) {
    if (firstCh === "-" || firstCh === "+") {
      target = index3 + target;
    }
    if (target === index3 || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  function _getTargetPixel(fill2, scale) {
    let pixel = null;
    if (fill2 === "start") {
      pixel = scale.bottom;
    } else if (fill2 === "end") {
      pixel = scale.top;
    } else if (isObject2(fill2)) {
      pixel = scale.getPixelForValue(fill2.value);
    } else if (scale.getBasePixel) {
      pixel = scale.getBasePixel();
    }
    return pixel;
  }
  function _getTargetValue(fill2, scale, startValue) {
    let value;
    if (fill2 === "start") {
      value = startValue;
    } else if (fill2 === "end") {
      value = scale.options.reverse ? scale.min : scale.max;
    } else if (isObject2(fill2)) {
      value = fill2.value;
    } else {
      value = scale.getBaseValue();
    }
    return value;
  }
  function parseFillOption(line) {
    const options = line.options;
    const fillOption = options.fill;
    let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
    if (fill2 === void 0) {
      fill2 = !!options.backgroundColor;
    }
    if (fill2 === false || fill2 === null) {
      return false;
    }
    if (fill2 === true) {
      return "origin";
    }
    return fill2;
  }
  function _buildStackLine(source) {
    const { scale, index: index3, line } = source;
    const points = [];
    const segments = line.segments;
    const sourcePoints = line.points;
    const linesBelow = getLinesBelow(scale, index3);
    linesBelow.push(_createBoundaryLine({
      x: null,
      y: scale.bottom
    }, line));
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      for (let j = segment.start; j <= segment.end; j++) {
        addPointsBelow(points, sourcePoints[j], linesBelow);
      }
    }
    return new LineElement({
      points,
      options: {}
    });
  }
  function getLinesBelow(scale, index3) {
    const below = [];
    const metas = scale.getMatchingVisibleMetas("line");
    for (let i = 0; i < metas.length; i++) {
      const meta = metas[i];
      if (meta.index === index3) {
        break;
      }
      if (!meta.hidden) {
        below.unshift(meta.dataset);
      }
    }
    return below;
  }
  function addPointsBelow(points, sourcePoint, linesBelow) {
    const postponed = [];
    for (let j = 0; j < linesBelow.length; j++) {
      const line = linesBelow[j];
      const { first, last, point } = findPoint(line, sourcePoint, "x");
      if (!point || first && last) {
        continue;
      }
      if (first) {
        postponed.unshift(point);
      } else {
        points.push(point);
        if (!last) {
          break;
        }
      }
    }
    points.push(...postponed);
  }
  function findPoint(line, sourcePoint, property) {
    const point = line.interpolate(sourcePoint, property);
    if (!point) {
      return {};
    }
    const pointValue = point[property];
    const segments = line.segments;
    const linePoints = line.points;
    let first = false;
    let last = false;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      const firstValue = linePoints[segment.start][property];
      const lastValue = linePoints[segment.end][property];
      if (_isBetween(pointValue, firstValue, lastValue)) {
        first = pointValue === firstValue;
        last = pointValue === lastValue;
        break;
      }
    }
    return {
      first,
      last,
      point
    };
  }
  var simpleArc = class {
    constructor(opts) {
      this.x = opts.x;
      this.y = opts.y;
      this.radius = opts.radius;
    }
    pathSegment(ctx, bounds, opts) {
      const { x, y: y3, radius } = this;
      bounds = bounds || {
        start: 0,
        end: TAU
      };
      ctx.arc(x, y3, radius, bounds.end, bounds.start, true);
      return !opts.bounds;
    }
    interpolate(point) {
      const { x, y: y3, radius } = this;
      const angle = point.angle;
      return {
        x: x + Math.cos(angle) * radius,
        y: y3 + Math.sin(angle) * radius,
        angle
      };
    }
  };
  function _getTarget(source) {
    const { chart, fill: fill2, line } = source;
    if (isNumberFinite(fill2)) {
      return getLineByIndex(chart, fill2);
    }
    if (fill2 === "stack") {
      return _buildStackLine(source);
    }
    if (fill2 === "shape") {
      return true;
    }
    const boundary = computeBoundary(source);
    if (boundary instanceof simpleArc) {
      return boundary;
    }
    return _createBoundaryLine(boundary, line);
  }
  function getLineByIndex(chart, index3) {
    const meta = chart.getDatasetMeta(index3);
    const visible = meta && chart.isDatasetVisible(index3);
    return visible ? meta.dataset : null;
  }
  function computeBoundary(source) {
    const scale = source.scale || {};
    if (scale.getPointPositionForValue) {
      return computeCircularBoundary(source);
    }
    return computeLinearBoundary(source);
  }
  function computeLinearBoundary(source) {
    const { scale = {}, fill: fill2 } = source;
    const pixel = _getTargetPixel(fill2, scale);
    if (isNumberFinite(pixel)) {
      const horizontal = scale.isHorizontal();
      return {
        x: horizontal ? pixel : null,
        y: horizontal ? null : pixel
      };
    }
    return null;
  }
  function computeCircularBoundary(source) {
    const { scale, fill: fill2 } = source;
    const options = scale.options;
    const length = scale.getLabels().length;
    const start2 = options.reverse ? scale.max : scale.min;
    const value = _getTargetValue(fill2, scale, start2);
    const target = [];
    if (options.grid.circular) {
      const center = scale.getPointPositionForValue(0, start2);
      return new simpleArc({
        x: center.x,
        y: center.y,
        radius: scale.getDistanceFromCenterForValue(value)
      });
    }
    for (let i = 0; i < length; ++i) {
      target.push(scale.getPointPositionForValue(i, value));
    }
    return target;
  }
  function _drawfill(ctx, source, area) {
    const target = _getTarget(source);
    const { chart, index: index3, line, scale, axis } = source;
    const lineOpts = line.options;
    const fillOption = lineOpts.fill;
    const color2 = lineOpts.backgroundColor;
    const { above = color2, below = color2 } = fillOption || {};
    const meta = chart.getDatasetMeta(index3);
    const clip = getDatasetClipArea(chart, meta);
    if (target && line.points.length) {
      clipArea(ctx, area);
      doFill(ctx, {
        line,
        target,
        above,
        below,
        area,
        scale,
        axis,
        clip
      });
      unclipArea(ctx);
    }
  }
  function doFill(ctx, cfg) {
    const { line, target, above, below, area, scale, clip } = cfg;
    const property = line._loop ? "angle" : cfg.axis;
    ctx.save();
    if (property === "x" && below !== above) {
      clipVertical(ctx, target, area.top);
      fill(ctx, {
        line,
        target,
        color: above,
        scale,
        property,
        clip
      });
      ctx.restore();
      ctx.save();
      clipVertical(ctx, target, area.bottom);
    }
    fill(ctx, {
      line,
      target,
      color: below,
      scale,
      property,
      clip
    });
    ctx.restore();
  }
  function clipVertical(ctx, target, clipY) {
    const { segments, points } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments) {
      const { start: start2, end: end2 } = segment;
      const firstPoint = points[start2];
      const lastPoint = points[_findSegmentEnd(start2, end2, points)];
      if (first) {
        ctx.moveTo(firstPoint.x, firstPoint.y);
        first = false;
      } else {
        ctx.lineTo(firstPoint.x, clipY);
        ctx.lineTo(firstPoint.x, firstPoint.y);
      }
      lineLoop = !!target.pathSegment(ctx, segment, {
        move: lineLoop
      });
      if (lineLoop) {
        ctx.closePath();
      } else {
        ctx.lineTo(lastPoint.x, clipY);
      }
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
  }
  function fill(ctx, cfg) {
    const { line, target, property, color: color2, scale, clip } = cfg;
    const segments = _segments(line, target, property);
    for (const { source: src, target: tgt, start: start2, end: end2 } of segments) {
      const { style: { backgroundColor = color2 } = {} } = src;
      const notShape = target !== true;
      ctx.save();
      ctx.fillStyle = backgroundColor;
      clipBounds(ctx, scale, clip, notShape && _getBounds(property, start2, end2));
      ctx.beginPath();
      const lineLoop = !!line.pathSegment(ctx, src);
      let loop;
      if (notShape) {
        if (lineLoop) {
          ctx.closePath();
        } else {
          interpolatedLineTo(ctx, target, end2, property);
        }
        const targetLoop = !!target.pathSegment(ctx, tgt, {
          move: lineLoop,
          reverse: true
        });
        loop = lineLoop && targetLoop;
        if (!loop) {
          interpolatedLineTo(ctx, target, start2, property);
        }
      }
      ctx.closePath();
      ctx.fill(loop ? "evenodd" : "nonzero");
      ctx.restore();
    }
  }
  function clipBounds(ctx, scale, clip, bounds) {
    const chartArea = scale.chart.chartArea;
    const { property, start: start2, end: end2 } = bounds || {};
    if (property === "x" || property === "y") {
      let left2, top3, right2, bottom3;
      if (property === "x") {
        left2 = start2;
        top3 = chartArea.top;
        right2 = end2;
        bottom3 = chartArea.bottom;
      } else {
        left2 = chartArea.left;
        top3 = start2;
        right2 = chartArea.right;
        bottom3 = end2;
      }
      ctx.beginPath();
      if (clip) {
        left2 = Math.max(left2, clip.left);
        right2 = Math.min(right2, clip.right);
        top3 = Math.max(top3, clip.top);
        bottom3 = Math.min(bottom3, clip.bottom);
      }
      ctx.rect(left2, top3, right2 - left2, bottom3 - top3);
      ctx.clip();
    }
  }
  function interpolatedLineTo(ctx, target, point, property) {
    const interpolatedPoint = target.interpolate(point, property);
    if (interpolatedPoint) {
      ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
    }
  }
  var index = {
    id: "filler",
    afterDatasetsUpdate(chart, _args, options) {
      const count = (chart.data.datasets || []).length;
      const sources = [];
      let meta, i, line, source;
      for (i = 0; i < count; ++i) {
        meta = chart.getDatasetMeta(i);
        line = meta.dataset;
        source = null;
        if (line && line.options && line instanceof LineElement) {
          source = {
            visible: chart.isDatasetVisible(i),
            index: i,
            fill: _decodeFill(line, i, count),
            chart,
            axis: meta.controller.options.indexAxis,
            scale: meta.vScale,
            line
          };
        }
        meta.$filler = source;
        sources.push(source);
      }
      for (i = 0; i < count; ++i) {
        source = sources[i];
        if (!source || source.fill === false) {
          continue;
        }
        source.fill = _resolveTarget(sources, i, options.propagate);
      }
    },
    beforeDraw(chart, _args, options) {
      const draw2 = options.drawTime === "beforeDraw";
      const metasets = chart.getSortedVisibleDatasetMetas();
      const area = chart.chartArea;
      for (let i = metasets.length - 1; i >= 0; --i) {
        const source = metasets[i].$filler;
        if (!source) {
          continue;
        }
        source.line.updateControlPoints(area, source.axis);
        if (draw2 && source.fill) {
          _drawfill(chart.ctx, source, area);
        }
      }
    },
    beforeDatasetsDraw(chart, _args, options) {
      if (options.drawTime !== "beforeDatasetsDraw") {
        return;
      }
      const metasets = chart.getSortedVisibleDatasetMetas();
      for (let i = metasets.length - 1; i >= 0; --i) {
        const source = metasets[i].$filler;
        if (_shouldApplyFill(source)) {
          _drawfill(chart.ctx, source, chart.chartArea);
        }
      }
    },
    beforeDatasetDraw(chart, args, options) {
      const source = args.meta.$filler;
      if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
        return;
      }
      _drawfill(chart.ctx, source, chart.chartArea);
    },
    defaults: {
      propagate: true,
      drawTime: "beforeDatasetDraw"
    }
  };
  var getBoxSize = (labelOpts, fontSize) => {
    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
    if (labelOpts.usePointStyle) {
      boxHeight = Math.min(boxHeight, fontSize);
      boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
      boxWidth,
      boxHeight,
      itemHeight: Math.max(fontSize, boxHeight)
    };
  };
  var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
  var Legend = class extends Element2 {
    constructor(config) {
      super();
      this._added = false;
      this.legendHitBoxes = [];
      this._hoveredItem = null;
      this.doughnutMode = false;
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this.legendItems = void 0;
      this.columnSizes = void 0;
      this.lineWidths = void 0;
      this.maxHeight = void 0;
      this.maxWidth = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.height = void 0;
      this.width = void 0;
      this._margins = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight, margins) {
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins;
      this.setDimensions();
      this.buildLabels();
      this.fit();
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = this._margins.left;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = this._margins.top;
        this.bottom = this.height;
      }
    }
    buildLabels() {
      const labelOpts = this.options.labels || {};
      let legendItems = callback(labelOpts.generateLabels, [
        this.chart
      ], this) || [];
      if (labelOpts.filter) {
        legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
      }
      if (labelOpts.sort) {
        legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
      }
      if (this.options.reverse) {
        legendItems.reverse();
      }
      this.legendItems = legendItems;
    }
    fit() {
      const { options, ctx } = this;
      if (!options.display) {
        this.width = this.height = 0;
        return;
      }
      const labelOpts = options.labels;
      const labelFont = toFont(labelOpts.font);
      const fontSize = labelFont.size;
      const titleHeight = this._computeTitleHeight();
      const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
      let width, height;
      ctx.font = labelFont.string;
      if (this.isHorizontal()) {
        width = this.maxWidth;
        height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
      } else {
        height = this.maxHeight;
        width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
      }
      this.width = Math.min(width, options.maxWidth || this.maxWidth);
      this.height = Math.min(height, options.maxHeight || this.maxHeight);
    }
    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
      const { ctx, maxWidth, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const lineWidths = this.lineWidths = [
        0
      ];
      const lineHeight = itemHeight + padding;
      let totalHeight = titleHeight;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      let row = -1;
      let top3 = -lineHeight;
      this.legendItems.forEach((legendItem, i) => {
        const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
        if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
          totalHeight += lineHeight;
          lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
          top3 += lineHeight;
          row++;
        }
        hitboxes[i] = {
          left: 0,
          top: top3,
          row,
          width: itemWidth,
          height: itemHeight
        };
        lineWidths[lineWidths.length - 1] += itemWidth + padding;
      });
      return totalHeight;
    }
    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
      const { ctx, maxHeight, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const columnSizes = this.columnSizes = [];
      const heightLimit = maxHeight - titleHeight;
      let totalWidth = padding;
      let currentColWidth = 0;
      let currentColHeight = 0;
      let left2 = 0;
      let col = 0;
      this.legendItems.forEach((legendItem, i) => {
        const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
        if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
          totalWidth += currentColWidth + padding;
          columnSizes.push({
            width: currentColWidth,
            height: currentColHeight
          });
          left2 += currentColWidth + padding;
          col++;
          currentColWidth = currentColHeight = 0;
        }
        hitboxes[i] = {
          left: left2,
          top: currentColHeight,
          col,
          width: itemWidth,
          height: itemHeight
        };
        currentColWidth = Math.max(currentColWidth, itemWidth);
        currentColHeight += itemHeight + padding;
      });
      totalWidth += currentColWidth;
      columnSizes.push({
        width: currentColWidth,
        height: currentColHeight
      });
      return totalWidth;
    }
    adjustHitBoxes() {
      if (!this.options.display) {
        return;
      }
      const titleHeight = this._computeTitleHeight();
      const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
      const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
      if (this.isHorizontal()) {
        let row = 0;
        let left2 = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        for (const hitbox of hitboxes) {
          if (row !== hitbox.row) {
            row = hitbox.row;
            left2 = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
          }
          hitbox.top += this.top + titleHeight + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left2), hitbox.width);
          left2 += hitbox.width + padding;
        }
      } else {
        let col = 0;
        let top3 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        for (const hitbox of hitboxes) {
          if (hitbox.col !== col) {
            col = hitbox.col;
            top3 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
          }
          hitbox.top = top3;
          hitbox.left += this.left + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
          top3 += hitbox.height + padding;
        }
      }
    }
    isHorizontal() {
      return this.options.position === "top" || this.options.position === "bottom";
    }
    draw() {
      if (this.options.display) {
        const ctx = this.ctx;
        clipArea(ctx, this);
        this._draw();
        unclipArea(ctx);
      }
    }
    _draw() {
      const { options: opts, columnSizes, lineWidths, ctx } = this;
      const { align, labels: labelOpts } = opts;
      const defaultColor = defaults.color;
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const labelFont = toFont(labelOpts.font);
      const { padding } = labelOpts;
      const fontSize = labelFont.size;
      const halfFontSize = fontSize / 2;
      let cursor;
      this.drawTitle();
      ctx.textAlign = rtlHelper.textAlign("left");
      ctx.textBaseline = "middle";
      ctx.lineWidth = 0.5;
      ctx.font = labelFont.string;
      const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
      const drawLegendBox = function(x, y3, legendItem) {
        if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
          return;
        }
        ctx.save();
        const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
        ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
        ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
        ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
        ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
        if (labelOpts.usePointStyle) {
          const drawOptions = {
            radius: boxHeight * Math.SQRT2 / 2,
            pointStyle: legendItem.pointStyle,
            rotation: legendItem.rotation,
            borderWidth: lineWidth
          };
          const centerX = rtlHelper.xPlus(x, boxWidth / 2);
          const centerY = y3 + halfFontSize;
          drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
        } else {
          const yBoxTop = y3 + Math.max((fontSize - boxHeight) / 2, 0);
          const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
          const borderRadius = toTRBLCorners(legendItem.borderRadius);
          ctx.beginPath();
          if (Object.values(borderRadius).some((v) => v !== 0)) {
            addRoundedRectPath(ctx, {
              x: xBoxLeft,
              y: yBoxTop,
              w: boxWidth,
              h: boxHeight,
              radius: borderRadius
            });
          } else {
            ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
          }
          ctx.fill();
          if (lineWidth !== 0) {
            ctx.stroke();
          }
        }
        ctx.restore();
      };
      const fillText = function(x, y3, legendItem) {
        renderText(ctx, legendItem.text, x, y3 + itemHeight / 2, labelFont, {
          strikethrough: legendItem.hidden,
          textAlign: rtlHelper.textAlign(legendItem.textAlign)
        });
      };
      const isHorizontal = this.isHorizontal();
      const titleHeight = this._computeTitleHeight();
      if (isHorizontal) {
        cursor = {
          x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
          y: this.top + padding + titleHeight,
          line: 0
        };
      } else {
        cursor = {
          x: this.left + padding,
          y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
          line: 0
        };
      }
      overrideTextDirection(this.ctx, opts.textDirection);
      const lineHeight = itemHeight + padding;
      this.legendItems.forEach((legendItem, i) => {
        ctx.strokeStyle = legendItem.fontColor;
        ctx.fillStyle = legendItem.fontColor;
        const textWidth = ctx.measureText(legendItem.text).width;
        const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
        const width = boxWidth + halfFontSize + textWidth;
        let x = cursor.x;
        let y3 = cursor.y;
        rtlHelper.setWidth(this.width);
        if (isHorizontal) {
          if (i > 0 && x + width + padding > this.right) {
            y3 = cursor.y += lineHeight;
            cursor.line++;
            x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
          }
        } else if (i > 0 && y3 + lineHeight > this.bottom) {
          x = cursor.x = x + columnSizes[cursor.line].width + padding;
          cursor.line++;
          y3 = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
        }
        const realX = rtlHelper.x(x);
        drawLegendBox(realX, y3, legendItem);
        x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
        fillText(rtlHelper.x(x), y3, legendItem);
        if (isHorizontal) {
          cursor.x += width + padding;
        } else if (typeof legendItem.text !== "string") {
          const fontLineHeight = labelFont.lineHeight;
          cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
        } else {
          cursor.y += lineHeight;
        }
      });
      restoreTextDirection(this.ctx, opts.textDirection);
    }
    drawTitle() {
      const opts = this.options;
      const titleOpts = opts.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      if (!titleOpts.display) {
        return;
      }
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const ctx = this.ctx;
      const position = titleOpts.position;
      const halfFontSize = titleFont.size / 2;
      const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
      let y3;
      let left2 = this.left;
      let maxWidth = this.width;
      if (this.isHorizontal()) {
        maxWidth = Math.max(...this.lineWidths);
        y3 = this.top + topPaddingPlusHalfFontSize;
        left2 = _alignStartEnd(opts.align, left2, this.right - maxWidth);
      } else {
        const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
        y3 = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
      }
      const x = _alignStartEnd(position, left2, left2 + maxWidth);
      ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
      ctx.textBaseline = "middle";
      ctx.strokeStyle = titleOpts.color;
      ctx.fillStyle = titleOpts.color;
      ctx.font = titleFont.string;
      renderText(ctx, titleOpts.text, x, y3, titleFont);
    }
    _computeTitleHeight() {
      const titleOpts = this.options.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
    _getLegendItemAt(x, y3) {
      let i, hitBox, lh;
      if (_isBetween(x, this.left, this.right) && _isBetween(y3, this.top, this.bottom)) {
        lh = this.legendHitBoxes;
        for (i = 0; i < lh.length; ++i) {
          hitBox = lh[i];
          if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y3, hitBox.top, hitBox.top + hitBox.height)) {
            return this.legendItems[i];
          }
        }
      }
      return null;
    }
    handleEvent(e) {
      const opts = this.options;
      if (!isListened(e.type, opts)) {
        return;
      }
      const hoveredItem = this._getLegendItemAt(e.x, e.y);
      if (e.type === "mousemove" || e.type === "mouseout") {
        const previous = this._hoveredItem;
        const sameItem = itemsEqual(previous, hoveredItem);
        if (previous && !sameItem) {
          callback(opts.onLeave, [
            e,
            previous,
            this
          ], this);
        }
        this._hoveredItem = hoveredItem;
        if (hoveredItem && !sameItem) {
          callback(opts.onHover, [
            e,
            hoveredItem,
            this
          ], this);
        }
      } else if (hoveredItem) {
        callback(opts.onClick, [
          e,
          hoveredItem,
          this
        ], this);
      }
    }
  };
  function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
    return {
      itemWidth,
      itemHeight
    };
  }
  function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
    let legendItemText = legendItem.text;
    if (legendItemText && typeof legendItemText !== "string") {
      legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
    }
    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
  }
  function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
    let itemHeight = _itemHeight;
    if (typeof legendItem.text !== "string") {
      itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
    }
    return itemHeight;
  }
  function calculateLegendItemHeight(legendItem, fontLineHeight) {
    const labelHeight = legendItem.text ? legendItem.text.length : 0;
    return fontLineHeight * labelHeight;
  }
  function isListened(type, opts) {
    if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
      return true;
    }
    if (opts.onClick && (type === "click" || type === "mouseup")) {
      return true;
    }
    return false;
  }
  var plugin_legend = {
    id: "legend",
    _element: Legend,
    start(chart, _args, options) {
      const legend = chart.legend = new Legend({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, legend, options);
      layouts.addBox(chart, legend);
    },
    stop(chart) {
      layouts.removeBox(chart, chart.legend);
      delete chart.legend;
    },
    beforeUpdate(chart, _args, options) {
      const legend = chart.legend;
      layouts.configure(chart, legend, options);
      legend.options = options;
    },
    afterUpdate(chart) {
      const legend = chart.legend;
      legend.buildLabels();
      legend.adjustHitBoxes();
    },
    afterEvent(chart, args) {
      if (!args.replay) {
        chart.legend.handleEvent(args.event);
      }
    },
    defaults: {
      display: true,
      position: "top",
      align: "center",
      fullSize: true,
      reverse: false,
      weight: 1e3,
      onClick(e, legendItem, legend) {
        const index3 = legendItem.datasetIndex;
        const ci = legend.chart;
        if (ci.isDatasetVisible(index3)) {
          ci.hide(index3);
          legendItem.hidden = true;
        } else {
          ci.show(index3);
          legendItem.hidden = false;
        }
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: (ctx) => ctx.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(chart) {
          const datasets = chart.data.datasets;
          const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
          return chart._getSortedDatasetMetas().map((meta) => {
            const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
            const borderWidth = toPadding(style.borderWidth);
            return {
              text: datasets[meta.index].label,
              fillStyle: style.backgroundColor,
              fontColor: color2,
              hidden: !meta.visible,
              lineCap: style.borderCapStyle,
              lineDash: style.borderDash,
              lineDashOffset: style.borderDashOffset,
              lineJoin: style.borderJoinStyle,
              lineWidth: (borderWidth.width + borderWidth.height) / 4,
              strokeStyle: style.borderColor,
              pointStyle: pointStyle || style.pointStyle,
              rotation: style.rotation,
              textAlign: textAlign || style.textAlign,
              borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
              datasetIndex: meta.index
            };
          }, this);
        }
      },
      title: {
        color: (ctx) => ctx.chart.options.color,
        display: false,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: (name) => !name.startsWith("on"),
      labels: {
        _scriptable: (name) => ![
          "generateLabels",
          "filter",
          "sort"
        ].includes(name)
      }
    }
  };
  var Title = class extends Element2 {
    constructor(config) {
      super();
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this._padding = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight) {
      const opts = this.options;
      this.left = 0;
      this.top = 0;
      if (!opts.display) {
        this.width = this.height = this.right = this.bottom = 0;
        return;
      }
      this.width = this.right = maxWidth;
      this.height = this.bottom = maxHeight;
      const lineCount = isArray(opts.text) ? opts.text.length : 1;
      this._padding = toPadding(opts.padding);
      const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
      if (this.isHorizontal()) {
        this.height = textSize;
      } else {
        this.width = textSize;
      }
    }
    isHorizontal() {
      const pos = this.options.position;
      return pos === "top" || pos === "bottom";
    }
    _drawArgs(offset2) {
      const { top: top3, left: left2, bottom: bottom3, right: right2, options } = this;
      const align = options.align;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      if (this.isHorizontal()) {
        titleX = _alignStartEnd(align, left2, right2);
        titleY = top3 + offset2;
        maxWidth = right2 - left2;
      } else {
        if (options.position === "left") {
          titleX = left2 + offset2;
          titleY = _alignStartEnd(align, bottom3, top3);
          rotation = PI * -0.5;
        } else {
          titleX = right2 - offset2;
          titleY = _alignStartEnd(align, top3, bottom3);
          rotation = PI * 0.5;
        }
        maxWidth = bottom3 - top3;
      }
      return {
        titleX,
        titleY,
        maxWidth,
        rotation
      };
    }
    draw() {
      const ctx = this.ctx;
      const opts = this.options;
      if (!opts.display) {
        return;
      }
      const fontOpts = toFont(opts.font);
      const lineHeight = fontOpts.lineHeight;
      const offset2 = lineHeight / 2 + this._padding.top;
      const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset2);
      renderText(ctx, opts.text, 0, 0, fontOpts, {
        color: opts.color,
        maxWidth,
        rotation,
        textAlign: _toLeftRightCenter(opts.align),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
  };
  function createTitle(chart, titleOpts) {
    const title = new Title({
      ctx: chart.ctx,
      options: titleOpts,
      chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
  }
  var plugin_title = {
    id: "title",
    _element: Title,
    start(chart, _args, options) {
      createTitle(chart, options);
    },
    stop(chart) {
      const titleBlock = chart.titleBlock;
      layouts.removeBox(chart, titleBlock);
      delete chart.titleBlock;
    },
    beforeUpdate(chart, _args, options) {
      const title = chart.titleBlock;
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "bold"
      },
      fullSize: true,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var map2 = /* @__PURE__ */ new WeakMap();
  var plugin_subtitle = {
    id: "subtitle",
    start(chart, _args, options) {
      const title = new Title({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, title, options);
      layouts.addBox(chart, title);
      map2.set(chart, title);
    },
    stop(chart) {
      layouts.removeBox(chart, map2.get(chart));
      map2.delete(chart);
    },
    beforeUpdate(chart, _args, options) {
      const title = map2.get(chart);
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "normal"
      },
      fullSize: true,
      padding: 0,
      position: "top",
      text: "",
      weight: 1500
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var positioners = {
    average(items) {
      if (!items.length) {
        return false;
      }
      let i, len;
      let xSet = /* @__PURE__ */ new Set();
      let y3 = 0;
      let count = 0;
      for (i = 0, len = items.length; i < len; ++i) {
        const el2 = items[i].element;
        if (el2 && el2.hasValue()) {
          const pos = el2.tooltipPosition();
          xSet.add(pos.x);
          y3 += pos.y;
          ++count;
        }
      }
      if (count === 0 || xSet.size === 0) {
        return false;
      }
      const xAverage = [
        ...xSet
      ].reduce((a, b) => a + b) / xSet.size;
      return {
        x: xAverage,
        y: y3 / count
      };
    },
    nearest(items, eventPosition) {
      if (!items.length) {
        return false;
      }
      let x = eventPosition.x;
      let y3 = eventPosition.y;
      let minDistance = Number.POSITIVE_INFINITY;
      let i, len, nearestElement;
      for (i = 0, len = items.length; i < len; ++i) {
        const el2 = items[i].element;
        if (el2 && el2.hasValue()) {
          const center = el2.getCenterPoint();
          const d3 = distanceBetweenPoints(eventPosition, center);
          if (d3 < minDistance) {
            minDistance = d3;
            nearestElement = el2;
          }
        }
      }
      if (nearestElement) {
        const tp = nearestElement.tooltipPosition();
        x = tp.x;
        y3 = tp.y;
      }
      return {
        x,
        y: y3
      };
    }
  };
  function pushOrConcat(base, toPush) {
    if (toPush) {
      if (isArray(toPush)) {
        Array.prototype.push.apply(base, toPush);
      } else {
        base.push(toPush);
      }
    }
    return base;
  }
  function splitNewlines(str) {
    if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
      return str.split("\n");
    }
    return str;
  }
  function createTooltipItem(chart, item) {
    const { element, datasetIndex, index: index3 } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label, value } = controller.getLabelAndValue(index3);
    return {
      chart,
      label,
      parsed: controller.getParsed(index3),
      raw: chart.data.datasets[datasetIndex].data[index3],
      formattedValue: value,
      dataset: controller.getDataset(),
      dataIndex: index3,
      datasetIndex,
      element
    };
  }
  function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body, footer, title } = tooltip;
    const { boxWidth, boxHeight } = options;
    const bodyFont = toFont(options.bodyFont);
    const titleFont = toFont(options.titleFont);
    const footerFont = toFont(options.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = toPadding(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
      height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    }
    if (combinedBodyLength) {
      const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
      height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) {
      height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function(line) {
      width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    each(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    each(body, (bodyItem) => {
      each(bodyItem.before, maxLineWidth);
      each(bodyItem.lines, maxLineWidth);
      each(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    each(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return {
      width,
      height
    };
  }
  function determineYAlign(chart, size) {
    const { y: y3, height } = size;
    if (y3 < height / 2) {
      return "top";
    } else if (y3 > chart.height - height / 2) {
      return "bottom";
    }
    return "center";
  }
  function doesNotFitWithAlign(xAlign, chart, options, size) {
    const { x, width } = size;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === "left" && x + width + caret > chart.width) {
      return true;
    }
    if (xAlign === "right" && x - width - caret < 0) {
      return true;
    }
  }
  function determineXAlign(chart, options, size, yAlign) {
    const { x, width } = size;
    const { width: chartWidth, chartArea: { left: left2, right: right2 } } = chart;
    let xAlign = "center";
    if (yAlign === "center") {
      xAlign = x <= (left2 + right2) / 2 ? "left" : "right";
    } else if (x <= width / 2) {
      xAlign = "left";
    } else if (x >= chartWidth - width / 2) {
      xAlign = "right";
    }
    if (doesNotFitWithAlign(xAlign, chart, options, size)) {
      xAlign = "center";
    }
    return xAlign;
  }
  function determineAlignment(chart, options, size) {
    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
    return {
      xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
      yAlign
    };
  }
  function alignX(size, xAlign) {
    let { x, width } = size;
    if (xAlign === "right") {
      x -= width;
    } else if (xAlign === "center") {
      x -= width / 2;
    }
    return x;
  }
  function alignY(size, yAlign, paddingAndSize) {
    let { y: y3, height } = size;
    if (yAlign === "top") {
      y3 += paddingAndSize;
    } else if (yAlign === "bottom") {
      y3 -= height + paddingAndSize;
    } else {
      y3 -= height / 2;
    }
    return y3;
  }
  function getBackgroundPoint(options, size, alignment, chart) {
    const { caretSize, caretPadding, cornerRadius } = options;
    const { xAlign, yAlign } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    let x = alignX(size, xAlign);
    const y3 = alignY(size, yAlign, paddingAndSize);
    if (yAlign === "center") {
      if (xAlign === "left") {
        x += paddingAndSize;
      } else if (xAlign === "right") {
        x -= paddingAndSize;
      }
    } else if (xAlign === "left") {
      x -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === "right") {
      x += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
      x: _limitValue(x, 0, chart.width - size.width),
      y: _limitValue(y3, 0, chart.height - size.height)
    };
  }
  function getAlignedX(tooltip, align, options) {
    const padding = toPadding(options.padding);
    return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
  }
  function getBeforeAfterBodyLines(callback2) {
    return pushOrConcat([], splitNewlines(callback2));
  }
  function createTooltipContext(parent, tooltip, tooltipItems) {
    return createContext(parent, {
      tooltip,
      tooltipItems,
      type: "tooltip"
    });
  }
  function overrideCallbacks(callbacks, context) {
    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
  }
  var defaultCallbacks = {
    beforeTitle: noop2,
    title(tooltipItems) {
      if (tooltipItems.length > 0) {
        const item = tooltipItems[0];
        const labels = item.chart.data.labels;
        const labelCount = labels ? labels.length : 0;
        if (this && this.options && this.options.mode === "dataset") {
          return item.dataset.label || "";
        } else if (item.label) {
          return item.label;
        } else if (labelCount > 0 && item.dataIndex < labelCount) {
          return labels[item.dataIndex];
        }
      }
      return "";
    },
    afterTitle: noop2,
    beforeBody: noop2,
    beforeLabel: noop2,
    label(tooltipItem) {
      if (this && this.options && this.options.mode === "dataset") {
        return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
      }
      let label = tooltipItem.dataset.label || "";
      if (label) {
        label += ": ";
      }
      const value = tooltipItem.formattedValue;
      if (!isNullOrUndef(value)) {
        label += value;
      }
      return label;
    },
    labelColor(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        borderColor: options.borderColor,
        backgroundColor: options.backgroundColor,
        borderWidth: options.borderWidth,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderRadius: 0
      };
    },
    labelTextColor() {
      return this.options.bodyColor;
    },
    labelPointStyle(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        pointStyle: options.pointStyle,
        rotation: options.rotation
      };
    },
    afterLabel: noop2,
    afterBody: noop2,
    beforeFooter: noop2,
    footer: noop2,
    afterFooter: noop2
  };
  function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
    const result = callbacks[name].call(ctx, arg);
    if (typeof result === "undefined") {
      return defaultCallbacks[name].call(ctx, arg);
    }
    return result;
  }
  var Tooltip = class extends Element2 {
    constructor(config) {
      super();
      this.opacity = 0;
      this._active = [];
      this._eventPosition = void 0;
      this._size = void 0;
      this._cachedAnimations = void 0;
      this._tooltipItems = [];
      this.$animations = void 0;
      this.$context = void 0;
      this.chart = config.chart;
      this.options = config.options;
      this.dataPoints = void 0;
      this.title = void 0;
      this.beforeBody = void 0;
      this.body = void 0;
      this.afterBody = void 0;
      this.footer = void 0;
      this.xAlign = void 0;
      this.yAlign = void 0;
      this.x = void 0;
      this.y = void 0;
      this.height = void 0;
      this.width = void 0;
      this.caretX = void 0;
      this.caretY = void 0;
      this.labelColors = void 0;
      this.labelPointStyles = void 0;
      this.labelTextColors = void 0;
    }
    initialize(options) {
      this.options = options;
      this._cachedAnimations = void 0;
      this.$context = void 0;
    }
    _resolveAnimations() {
      const cached = this._cachedAnimations;
      if (cached) {
        return cached;
      }
      const chart = this.chart;
      const options = this.options.setContext(this.getContext());
      const opts = options.enabled && chart.options.animation && options.animations;
      const animations = new Animations(this.chart, opts);
      if (opts._cacheable) {
        this._cachedAnimations = Object.freeze(animations);
      }
      return animations;
    }
    getContext() {
      return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context, options) {
      const { callbacks } = options;
      const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
      const title = invokeCallbackWithFallback(callbacks, "title", this, context);
      const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeTitle));
      lines = pushOrConcat(lines, splitNewlines(title));
      lines = pushOrConcat(lines, splitNewlines(afterTitle));
      return lines;
    }
    getBeforeBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
    }
    getBody(tooltipItems, options) {
      const { callbacks } = options;
      const bodyItems = [];
      each(tooltipItems, (context) => {
        const bodyItem = {
          before: [],
          lines: [],
          after: []
        };
        const scoped = overrideCallbacks(callbacks, context);
        pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
        pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
        pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
        bodyItems.push(bodyItem);
      });
      return bodyItems;
    }
    getAfterBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
    }
    getFooter(tooltipItems, options) {
      const { callbacks } = options;
      const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
      const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
      const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeFooter));
      lines = pushOrConcat(lines, splitNewlines(footer));
      lines = pushOrConcat(lines, splitNewlines(afterFooter));
      return lines;
    }
    _createItems(options) {
      const active = this._active;
      const data = this.chart.data;
      const labelColors = [];
      const labelPointStyles = [];
      const labelTextColors = [];
      let tooltipItems = [];
      let i, len;
      for (i = 0, len = active.length; i < len; ++i) {
        tooltipItems.push(createTooltipItem(this.chart, active[i]));
      }
      if (options.filter) {
        tooltipItems = tooltipItems.filter((element, index3, array) => options.filter(element, index3, array, data));
      }
      if (options.itemSort) {
        tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
      }
      each(tooltipItems, (context) => {
        const scoped = overrideCallbacks(options.callbacks, context);
        labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
        labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
        labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
      });
      this.labelColors = labelColors;
      this.labelPointStyles = labelPointStyles;
      this.labelTextColors = labelTextColors;
      this.dataPoints = tooltipItems;
      return tooltipItems;
    }
    update(changed, replay) {
      const options = this.options.setContext(this.getContext());
      const active = this._active;
      let properties;
      let tooltipItems = [];
      if (!active.length) {
        if (this.opacity !== 0) {
          properties = {
            opacity: 0
          };
        }
      } else {
        const position = positioners[options.position].call(this, active, this._eventPosition);
        tooltipItems = this._createItems(options);
        this.title = this.getTitle(tooltipItems, options);
        this.beforeBody = this.getBeforeBody(tooltipItems, options);
        this.body = this.getBody(tooltipItems, options);
        this.afterBody = this.getAfterBody(tooltipItems, options);
        this.footer = this.getFooter(tooltipItems, options);
        const size = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, size);
        const alignment = determineAlignment(this.chart, options, positionAndSize);
        const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        properties = {
          opacity: 1,
          x: backgroundPoint.x,
          y: backgroundPoint.y,
          width: size.width,
          height: size.height,
          caretX: position.x,
          caretY: position.y
        };
      }
      this._tooltipItems = tooltipItems;
      this.$context = void 0;
      if (properties) {
        this._resolveAnimations().update(this, properties);
      }
      if (changed && options.external) {
        options.external.call(this, {
          chart: this.chart,
          tooltip: this,
          replay
        });
      }
    }
    drawCaret(tooltipPoint, ctx, size, options) {
      const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
      ctx.lineTo(caretPosition.x1, caretPosition.y1);
      ctx.lineTo(caretPosition.x2, caretPosition.y2);
      ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size, options) {
      const { xAlign, yAlign } = this;
      const { caretSize, cornerRadius } = options;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
      const { x: ptX, y: ptY } = tooltipPoint;
      const { width, height } = size;
      let x1, x2, x3, y1, y22, y3;
      if (yAlign === "center") {
        y22 = ptY + height / 2;
        if (xAlign === "left") {
          x1 = ptX;
          x2 = x1 - caretSize;
          y1 = y22 + caretSize;
          y3 = y22 - caretSize;
        } else {
          x1 = ptX + width;
          x2 = x1 + caretSize;
          y1 = y22 - caretSize;
          y3 = y22 + caretSize;
        }
        x3 = x1;
      } else {
        if (xAlign === "left") {
          x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
        } else if (xAlign === "right") {
          x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
        } else {
          x2 = this.caretX;
        }
        if (yAlign === "top") {
          y1 = ptY;
          y22 = y1 - caretSize;
          x1 = x2 - caretSize;
          x3 = x2 + caretSize;
        } else {
          y1 = ptY + height;
          y22 = y1 + caretSize;
          x1 = x2 + caretSize;
          x3 = x2 - caretSize;
        }
        y3 = y1;
      }
      return {
        x1,
        x2,
        x3,
        y1,
        y2: y22,
        y3
      };
    }
    drawTitle(pt, ctx, options) {
      const title = this.title;
      const length = title.length;
      let titleFont, titleSpacing, i;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options.titleAlign, options);
        ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
        ctx.textBaseline = "middle";
        titleFont = toFont(options.titleFont);
        titleSpacing = options.titleSpacing;
        ctx.fillStyle = options.titleColor;
        ctx.font = titleFont.string;
        for (i = 0; i < length; ++i) {
          ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
          pt.y += titleFont.lineHeight + titleSpacing;
          if (i + 1 === length) {
            pt.y += options.titleMarginBottom - titleSpacing;
          }
        }
      }
    }
    _drawColorBox(ctx, pt, i, rtlHelper, options) {
      const labelColor = this.labelColors[i];
      const labelPointStyle = this.labelPointStyles[i];
      const { boxHeight, boxWidth } = options;
      const bodyFont = toFont(options.bodyFont);
      const colorX = getAlignedX(this, "left", options);
      const rtlColorX = rtlHelper.x(colorX);
      const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
      const colorY = pt.y + yOffSet;
      if (options.usePointStyle) {
        const drawOptions = {
          radius: Math.min(boxWidth, boxHeight) / 2,
          pointStyle: labelPointStyle.pointStyle,
          rotation: labelPointStyle.rotation,
          borderWidth: 1
        };
        const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
        const centerY = colorY + boxHeight / 2;
        ctx.strokeStyle = options.multiKeyBackground;
        ctx.fillStyle = options.multiKeyBackground;
        drawPoint(ctx, drawOptions, centerX, centerY);
        ctx.strokeStyle = labelColor.borderColor;
        ctx.fillStyle = labelColor.backgroundColor;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        ctx.lineWidth = isObject2(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
        ctx.strokeStyle = labelColor.borderColor;
        ctx.setLineDash(labelColor.borderDash || []);
        ctx.lineDashOffset = labelColor.borderDashOffset || 0;
        const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
        const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
        const borderRadius = toTRBLCorners(labelColor.borderRadius);
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          ctx.beginPath();
          ctx.fillStyle = options.multiKeyBackground;
          addRoundedRectPath(ctx, {
            x: outerX,
            y: colorY,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = labelColor.backgroundColor;
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: innerX,
            y: colorY + 1,
            w: boxWidth - 2,
            h: boxHeight - 2,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillStyle = options.multiKeyBackground;
          ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
          ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
          ctx.fillStyle = labelColor.backgroundColor;
          ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
        }
      }
      ctx.fillStyle = this.labelTextColors[i];
    }
    drawBody(pt, ctx, options) {
      const { body } = this;
      const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
      const bodyFont = toFont(options.bodyFont);
      let bodyLineHeight = bodyFont.lineHeight;
      let xLinePadding = 0;
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      const fillLineOfText = function(line) {
        ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
        pt.y += bodyLineHeight + bodySpacing;
      };
      const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
      let bodyItem, textColor, lines, i, j, ilen, jlen;
      ctx.textAlign = bodyAlign;
      ctx.textBaseline = "middle";
      ctx.font = bodyFont.string;
      pt.x = getAlignedX(this, bodyAlignForCalculation, options);
      ctx.fillStyle = options.bodyColor;
      each(this.beforeBody, fillLineOfText);
      xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
      for (i = 0, ilen = body.length; i < ilen; ++i) {
        bodyItem = body[i];
        textColor = this.labelTextColors[i];
        ctx.fillStyle = textColor;
        each(bodyItem.before, fillLineOfText);
        lines = bodyItem.lines;
        if (displayColors && lines.length) {
          this._drawColorBox(ctx, pt, i, rtlHelper, options);
          bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
        }
        for (j = 0, jlen = lines.length; j < jlen; ++j) {
          fillLineOfText(lines[j]);
          bodyLineHeight = bodyFont.lineHeight;
        }
        each(bodyItem.after, fillLineOfText);
      }
      xLinePadding = 0;
      bodyLineHeight = bodyFont.lineHeight;
      each(this.afterBody, fillLineOfText);
      pt.y -= bodySpacing;
    }
    drawFooter(pt, ctx, options) {
      const footer = this.footer;
      const length = footer.length;
      let footerFont, i;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options.footerAlign, options);
        pt.y += options.footerMarginTop;
        ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
        ctx.textBaseline = "middle";
        footerFont = toFont(options.footerFont);
        ctx.fillStyle = options.footerColor;
        ctx.font = footerFont.string;
        for (i = 0; i < length; ++i) {
          ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
          pt.y += footerFont.lineHeight + options.footerSpacing;
        }
      }
    }
    drawBackground(pt, ctx, tooltipSize, options) {
      const { xAlign, yAlign } = this;
      const { x, y: y3 } = pt;
      const { width, height } = tooltipSize;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.beginPath();
      ctx.moveTo(x + topLeft, y3);
      if (yAlign === "top") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + width - topRight, y3);
      ctx.quadraticCurveTo(x + width, y3, x + width, y3 + topRight);
      if (yAlign === "center" && xAlign === "right") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + width, y3 + height - bottomRight);
      ctx.quadraticCurveTo(x + width, y3 + height, x + width - bottomRight, y3 + height);
      if (yAlign === "bottom") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + bottomLeft, y3 + height);
      ctx.quadraticCurveTo(x, y3 + height, x, y3 + height - bottomLeft);
      if (yAlign === "center" && xAlign === "left") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x, y3 + topLeft);
      ctx.quadraticCurveTo(x, y3, x + topLeft, y3);
      ctx.closePath();
      ctx.fill();
      if (options.borderWidth > 0) {
        ctx.stroke();
      }
    }
    _updateAnimationTarget(options) {
      const chart = this.chart;
      const anims = this.$animations;
      const animX = anims && anims.x;
      const animY = anims && anims.y;
      if (animX || animY) {
        const position = positioners[options.position].call(this, this._active, this._eventPosition);
        if (!position) {
          return;
        }
        const size = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, this._size);
        const alignment = determineAlignment(chart, options, positionAndSize);
        const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
        if (animX._to !== point.x || animY._to !== point.y) {
          this.xAlign = alignment.xAlign;
          this.yAlign = alignment.yAlign;
          this.width = size.width;
          this.height = size.height;
          this.caretX = position.x;
          this.caretY = position.y;
          this._resolveAnimations().update(this, point);
        }
      }
    }
    _willRender() {
      return !!this.opacity;
    }
    draw(ctx) {
      const options = this.options.setContext(this.getContext());
      let opacity = this.opacity;
      if (!opacity) {
        return;
      }
      this._updateAnimationTarget(options);
      const tooltipSize = {
        width: this.width,
        height: this.height
      };
      const pt = {
        x: this.x,
        y: this.y
      };
      opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
      const padding = toPadding(options.padding);
      const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
      if (options.enabled && hasTooltipContent) {
        ctx.save();
        ctx.globalAlpha = opacity;
        this.drawBackground(pt, ctx, tooltipSize, options);
        overrideTextDirection(ctx, options.textDirection);
        pt.y += padding.top;
        this.drawTitle(pt, ctx, options);
        this.drawBody(pt, ctx, options);
        this.drawFooter(pt, ctx, options);
        restoreTextDirection(ctx, options.textDirection);
        ctx.restore();
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements, eventPosition) {
      const lastActive = this._active;
      const active = activeElements.map(({ datasetIndex, index: index3 }) => {
        const meta = this.chart.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("Cannot find a dataset at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index3],
          index: index3
        };
      });
      const changed = !_elementsEqual(lastActive, active);
      const positionChanged = this._positionChanged(active, eventPosition);
      if (changed || positionChanged) {
        this._active = active;
        this._eventPosition = eventPosition;
        this._ignoreReplayEvents = true;
        this.update(true);
      }
    }
    handleEvent(e, replay, inChartArea = true) {
      if (replay && this._ignoreReplayEvents) {
        return false;
      }
      this._ignoreReplayEvents = false;
      const options = this.options;
      const lastActive = this._active || [];
      const active = this._getActiveElements(e, lastActive, replay, inChartArea);
      const positionChanged = this._positionChanged(active, e);
      const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
      if (changed) {
        this._active = active;
        if (options.enabled || options.external) {
          this._eventPosition = {
            x: e.x,
            y: e.y
          };
          this.update(true, replay);
        }
      }
      return changed;
    }
    _getActiveElements(e, lastActive, replay, inChartArea) {
      const options = this.options;
      if (e.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);
      }
      const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
      if (options.reverse) {
        active.reverse();
      }
      return active;
    }
    _positionChanged(active, e) {
      const { caretX, caretY, options } = this;
      const position = positioners[options.position].call(this, active, e);
      return position !== false && (caretX !== position.x || caretY !== position.y);
    }
  };
  __publicField(Tooltip, "positioners", positioners);
  var plugin_tooltip = {
    id: "tooltip",
    _element: Tooltip,
    positioners,
    afterInit(chart, _args, options) {
      if (options) {
        chart.tooltip = new Tooltip({
          chart,
          options
        });
      }
    },
    beforeUpdate(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    reset(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    afterDraw(chart) {
      const tooltip = chart.tooltip;
      if (tooltip && tooltip._willRender()) {
        const args = {
          tooltip
        };
        if (chart.notifyPlugins("beforeTooltipDraw", __spreadProps(__spreadValues({}, args), {
          cancelable: true
        })) === false) {
          return;
        }
        tooltip.draw(chart.ctx);
        chart.notifyPlugins("afterTooltipDraw", args);
      }
    },
    afterEvent(chart, args) {
      if (chart.tooltip) {
        const useFinalPosition = args.replay;
        if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
          args.changed = true;
        }
      }
    },
    defaults: {
      enabled: true,
      external: null,
      position: "average",
      backgroundColor: "rgba(0,0,0,0.8)",
      titleColor: "#fff",
      titleFont: {
        weight: "bold"
      },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: "left",
      bodyColor: "#fff",
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: "left",
      footerColor: "#fff",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: {
        weight: "bold"
      },
      footerAlign: "left",
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (ctx, opts) => opts.bodyFont.size,
      boxWidth: (ctx, opts) => opts.bodyFont.size,
      multiKeyBackground: "#fff",
      displayColors: true,
      boxPadding: 0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      animation: {
        duration: 400,
        easing: "easeOutQuart"
      },
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "width",
            "height",
            "caretX",
            "caretY"
          ]
        },
        opacity: {
          easing: "linear",
          duration: 200
        }
      },
      callbacks: defaultCallbacks
    },
    defaultRoutes: {
      bodyFont: "font",
      footerFont: "font",
      titleFont: "font"
    },
    descriptors: {
      _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
      _indexable: false,
      callbacks: {
        _scriptable: false,
        _indexable: false
      },
      animation: {
        _fallback: false
      },
      animations: {
        _fallback: "animation"
      }
    },
    additionalOptionScopes: [
      "interaction"
    ]
  };
  var plugins = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Colors: plugin_colors,
    Decimation: plugin_decimation,
    Filler: index,
    Legend: plugin_legend,
    SubTitle: plugin_subtitle,
    Title: plugin_title,
    Tooltip: plugin_tooltip
  });
  var addIfString = (labels, raw, index3, addedLabels) => {
    if (typeof raw === "string") {
      index3 = labels.push(raw) - 1;
      addedLabels.unshift({
        index: index3,
        label: raw
      });
    } else if (isNaN(raw)) {
      index3 = null;
    }
    return index3;
  };
  function findOrAddLabel(labels, raw, index3, addedLabels) {
    const first = labels.indexOf(raw);
    if (first === -1) {
      return addIfString(labels, raw, index3, addedLabels);
    }
    const last = labels.lastIndexOf(raw);
    return first !== last ? index3 : first;
  }
  var validIndex = (index3, max2) => index3 === null ? null : _limitValue(Math.round(index3), 0, max2);
  function _getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  var CategoryScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this._startValue = void 0;
      this._valueRange = 0;
      this._addedLabels = [];
    }
    init(scaleOptions) {
      const added = this._addedLabels;
      if (added.length) {
        const labels = this.getLabels();
        for (const { index: index3, label } of added) {
          if (labels[index3] === label) {
            labels.splice(index3, 1);
          }
        }
        this._addedLabels = [];
      }
      super.init(scaleOptions);
    }
    parse(raw, index3) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      const labels = this.getLabels();
      index3 = isFinite(index3) && labels[index3] === raw ? index3 : findOrAddLabel(labels, raw, valueOrDefault(index3, raw), this._addedLabels);
      return validIndex(index3, labels.length - 1);
    }
    determineDataLimits() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min: min2, max: max2 } = this.getMinMax(true);
      if (this.options.bounds === "ticks") {
        if (!minDefined) {
          min2 = 0;
        }
        if (!maxDefined) {
          max2 = this.getLabels().length - 1;
        }
      }
      this.min = min2;
      this.max = max2;
    }
    buildTicks() {
      const min2 = this.min;
      const max2 = this.max;
      const offset2 = this.options.offset;
      const ticks = [];
      let labels = this.getLabels();
      labels = min2 === 0 && max2 === labels.length - 1 ? labels : labels.slice(min2, max2 + 1);
      this._valueRange = Math.max(labels.length - (offset2 ? 0 : 1), 1);
      this._startValue = this.min - (offset2 ? 0.5 : 0);
      for (let value = min2; value <= max2; value++) {
        ticks.push({
          value
        });
      }
      return ticks;
    }
    getLabelForValue(value) {
      return _getLabelForValue.call(this, value);
    }
    configure() {
      super.configure();
      if (!this.isHorizontal()) {
        this._reversePixels = !this._reversePixels;
      }
    }
    getPixelForValue(value) {
      if (typeof value !== "number") {
        value = this.parse(value);
      }
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index3) {
      const ticks = this.ticks;
      if (index3 < 0 || index3 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index3].value);
    }
    getValueForPixel(pixel) {
      return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
      return this.bottom;
    }
  };
  __publicField(CategoryScale, "id", "category");
  __publicField(CategoryScale, "defaults", {
    ticks: {
      callback: _getLabelForValue
    }
  });
  function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds, step, min: min2, max: max2, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin, max: rmax } = dataRange;
    const minDefined = !isNullOrUndef(min2);
    const maxDefined = !isNullOrUndef(max2);
    const countDefined = !isNullOrUndef(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
      return [
        {
          value: rmin
        },
        {
          value: rmax
        }
      ];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
      spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
    }
    if (!isNullOrUndef(precision)) {
      factor = Math.pow(10, precision);
      spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === "ticks") {
      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
      niceMin = rmin;
      niceMax = rmax;
    }
    if (minDefined && maxDefined && step && almostWhole((max2 - min2) / step, spacing / 1e3)) {
      numSpaces = Math.round(Math.min((max2 - min2) / spacing, maxTicks));
      spacing = (max2 - min2) / numSpaces;
      niceMin = min2;
      niceMax = max2;
    } else if (countDefined) {
      niceMin = minDefined ? min2 : niceMin;
      niceMax = maxDefined ? max2 : niceMax;
      numSpaces = count - 1;
      spacing = (niceMax - niceMin) / numSpaces;
    } else {
      numSpaces = (niceMax - niceMin) / spacing;
      if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }
    }
    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j = 0;
    if (minDefined) {
      if (includeBounds && niceMin !== min2) {
        ticks.push({
          value: min2
        });
        if (niceMin < min2) {
          j++;
        }
        if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min2, relativeLabelSize(min2, minSpacing, generationOptions))) {
          j++;
        }
      } else if (niceMin < min2) {
        j++;
      }
    }
    for (; j < numSpaces; ++j) {
      const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
      if (maxDefined && tickValue > max2) {
        break;
      }
      ticks.push({
        value: tickValue
      });
    }
    if (maxDefined && includeBounds && niceMax !== max2) {
      if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max2, relativeLabelSize(max2, minSpacing, generationOptions))) {
        ticks[ticks.length - 1].value = max2;
      } else {
        ticks.push({
          value: max2
        });
      }
    } else if (!maxDefined || niceMax === max2) {
      ticks.push({
        value: niceMax
      });
    }
    return ticks;
  }
  function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
    const rad = toRadians(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
    const length = 0.75 * minSpacing * ("" + value).length;
    return Math.min(minSpacing / ratio, length);
  }
  var LinearScaleBase = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._endValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index3) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
        return null;
      }
      return +raw;
    }
    handleTickRangeOptions() {
      const { beginAtZero } = this.options;
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min: min2, max: max2 } = this;
      const setMin = (v) => min2 = minDefined ? min2 : v;
      const setMax = (v) => max2 = maxDefined ? max2 : v;
      if (beginAtZero) {
        const minSign = sign(min2);
        const maxSign = sign(max2);
        if (minSign < 0 && maxSign < 0) {
          setMax(0);
        } else if (minSign > 0 && maxSign > 0) {
          setMin(0);
        }
      }
      if (min2 === max2) {
        let offset2 = max2 === 0 ? 1 : Math.abs(max2 * 0.05);
        setMax(max2 + offset2);
        if (!beginAtZero) {
          setMin(min2 - offset2);
        }
      }
      this.min = min2;
      this.max = max2;
    }
    getTickLimit() {
      const tickOpts = this.options.ticks;
      let { maxTicksLimit, stepSize } = tickOpts;
      let maxTicks;
      if (stepSize) {
        maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
        if (maxTicks > 1e3) {
          console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
          maxTicks = 1e3;
        }
      } else {
        maxTicks = this.computeTickLimit();
        maxTicksLimit = maxTicksLimit || 11;
      }
      if (maxTicksLimit) {
        maxTicks = Math.min(maxTicksLimit, maxTicks);
      }
      return maxTicks;
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
      const opts = this.options;
      const tickOpts = opts.ticks;
      let maxTicks = this.getTickLimit();
      maxTicks = Math.max(2, maxTicks);
      const numericGeneratorOptions = {
        maxTicks,
        bounds: opts.bounds,
        min: opts.min,
        max: opts.max,
        precision: tickOpts.precision,
        step: tickOpts.stepSize,
        count: tickOpts.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: tickOpts.minRotation || 0,
        includeBounds: tickOpts.includeBounds !== false
      };
      const dataRange = this._range || this;
      const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    configure() {
      const ticks = this.ticks;
      let start2 = this.min;
      let end2 = this.max;
      super.configure();
      if (this.options.offset && ticks.length) {
        const offset2 = (end2 - start2) / Math.max(ticks.length - 1, 1) / 2;
        start2 -= offset2;
        end2 += offset2;
      }
      this._startValue = start2;
      this._endValue = end2;
      this._valueRange = end2 - start2;
    }
    getLabelForValue(value) {
      return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
  };
  var LinearScale = class extends LinearScaleBase {
    determineDataLimits() {
      const { min: min2, max: max2 } = this.getMinMax(true);
      this.min = isNumberFinite(min2) ? min2 : 0;
      this.max = isNumberFinite(max2) ? max2 : 1;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      const horizontal = this.isHorizontal();
      const length = horizontal ? this.width : this.height;
      const minRotation = toRadians(this.options.ticks.minRotation);
      const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
      const tickFont = this._resolveTickFontOptions(0);
      return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
  };
  __publicField(LinearScale, "id", "linear");
  __publicField(LinearScale, "defaults", {
    ticks: {
      callback: Ticks.formatters.numeric
    }
  });
  var log10Floor = (v) => Math.floor(log10(v));
  var changeExponent = (v, m3) => Math.pow(10, log10Floor(v) + m3);
  function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, log10Floor(tickVal));
    return remain === 1;
  }
  function steps(min2, max2, rangeExp) {
    const rangeStep = Math.pow(10, rangeExp);
    const start2 = Math.floor(min2 / rangeStep);
    const end2 = Math.ceil(max2 / rangeStep);
    return end2 - start2;
  }
  function startExp(min2, max2) {
    const range3 = max2 - min2;
    let rangeExp = log10Floor(range3);
    while (steps(min2, max2, rangeExp) > 10) {
      rangeExp++;
    }
    while (steps(min2, max2, rangeExp) < 10) {
      rangeExp--;
    }
    return Math.min(rangeExp, log10Floor(min2));
  }
  function generateTicks(generationOptions, { min: min2, max: max2 }) {
    min2 = finiteOrDefault(generationOptions.min, min2);
    const ticks = [];
    const minExp = log10Floor(min2);
    let exp = startExp(min2, max2);
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    const stepSize = Math.pow(10, exp);
    const base = minExp > exp ? Math.pow(10, minExp) : 0;
    const start2 = Math.round((min2 - base) * precision) / precision;
    const offset2 = Math.floor((min2 - base) / stepSize / 10) * stepSize * 10;
    let significand = Math.floor((start2 - offset2) / Math.pow(10, exp));
    let value = finiteOrDefault(generationOptions.min, Math.round((base + offset2 + significand * Math.pow(10, exp)) * precision) / precision);
    while (value < max2) {
      ticks.push({
        value,
        major: isMajor(value),
        significand
      });
      if (significand >= 10) {
        significand = significand < 15 ? 15 : 20;
      } else {
        significand++;
      }
      if (significand >= 20) {
        exp++;
        significand = 2;
        precision = exp >= 0 ? 1 : precision;
      }
      value = Math.round((base + offset2 + significand * Math.pow(10, exp)) * precision) / precision;
    }
    const lastTick = finiteOrDefault(generationOptions.max, value);
    ticks.push({
      value: lastTick,
      major: isMajor(lastTick),
      significand
    });
    return ticks;
  }
  var LogarithmicScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index3) {
      const value = LinearScaleBase.prototype.parse.apply(this, [
        raw,
        index3
      ]);
      if (value === 0) {
        this._zero = true;
        return void 0;
      }
      return isNumberFinite(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
      const { min: min2, max: max2 } = this.getMinMax(true);
      this.min = isNumberFinite(min2) ? Math.max(0, min2) : null;
      this.max = isNumberFinite(max2) ? Math.max(0, max2) : null;
      if (this.options.beginAtZero) {
        this._zero = true;
      }
      if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
        this.min = min2 === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
      }
      this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let min2 = this.min;
      let max2 = this.max;
      const setMin = (v) => min2 = minDefined ? min2 : v;
      const setMax = (v) => max2 = maxDefined ? max2 : v;
      if (min2 === max2) {
        if (min2 <= 0) {
          setMin(1);
          setMax(10);
        } else {
          setMin(changeExponent(min2, -1));
          setMax(changeExponent(max2, 1));
        }
      }
      if (min2 <= 0) {
        setMin(changeExponent(max2, -1));
      }
      if (max2 <= 0) {
        setMax(changeExponent(min2, 1));
      }
      this.min = min2;
      this.max = max2;
    }
    buildTicks() {
      const opts = this.options;
      const generationOptions = {
        min: this._userMin,
        max: this._userMax
      };
      const ticks = generateTicks(generationOptions, this);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    getLabelForValue(value) {
      return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
      const start2 = this.min;
      super.configure();
      this._startValue = log10(start2);
      this._valueRange = log10(this.max) - log10(start2);
    }
    getPixelForValue(value) {
      if (value === void 0 || value === 0) {
        value = this.min;
      }
      if (value === null || isNaN(value)) {
        return NaN;
      }
      return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      const decimal = this.getDecimalForPixel(pixel);
      return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
  };
  __publicField(LogarithmicScale, "id", "logarithmic");
  __publicField(LogarithmicScale, "defaults", {
    ticks: {
      callback: Ticks.formatters.logarithmic,
      major: {
        enabled: true
      }
    }
  });
  function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
      const padding = toPadding(tickOpts.backdropPadding);
      return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
    }
    return 0;
  }
  function measureLabelSize(ctx, font, label) {
    label = isArray(label) ? label : [
      label
    ];
    return {
      w: _longestText(ctx, font.string, label),
      h: label.length * font.lineHeight
    };
  }
  function determineLimits(angle, pos, size, min2, max2) {
    if (angle === min2 || angle === max2) {
      return {
        start: pos - size / 2,
        end: pos + size / 2
      };
    } else if (angle < min2 || angle > max2) {
      return {
        start: pos - size,
        end: pos
      };
    }
    return {
      start: pos,
      end: pos + size
    };
  }
  function fitWithPointLabels(scale) {
    const orig = {
      l: scale.left + scale._padding.left,
      r: scale.right - scale._padding.right,
      t: scale.top + scale._padding.top,
      b: scale.bottom - scale._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
    for (let i = 0; i < valueCount; i++) {
      const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
      padding[i] = opts.padding;
      const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
      const plFont = toFont(opts.font);
      const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
      labelSizes[i] = textSize;
      const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
      const angle = Math.round(toDegrees(angleRadians));
      const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
      const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
      updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
  }
  function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x = 0;
    let y3 = 0;
    if (hLimits.start < orig.l) {
      x = (orig.l - hLimits.start) / sin;
      limits.l = Math.min(limits.l, orig.l - x);
    } else if (hLimits.end > orig.r) {
      x = (hLimits.end - orig.r) / sin;
      limits.r = Math.max(limits.r, orig.r + x);
    }
    if (vLimits.start < orig.t) {
      y3 = (orig.t - vLimits.start) / cos;
      limits.t = Math.min(limits.t, orig.t - y3);
    } else if (vLimits.end > orig.b) {
      y3 = (vLimits.end - orig.b) / cos;
      limits.b = Math.max(limits.b, orig.b + y3);
    }
  }
  function createPointLabelItem(scale, index3, itemOpts) {
    const outerDistance = scale.drawingArea;
    const { extra, additionalAngle, padding, size } = itemOpts;
    const pointLabelPosition = scale.getPointPosition(index3, outerDistance + extra + padding, additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const y3 = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left2 = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    return {
      visible: true,
      x: pointLabelPosition.x,
      y: y3,
      textAlign,
      left: left2,
      top: y3,
      right: left2 + size.w,
      bottom: y3 + size.h
    };
  }
  function isNotOverlapped(item, area) {
    if (!area) {
      return true;
    }
    const { left: left2, top: top3, right: right2, bottom: bottom3 } = item;
    const apexesInArea = _isPointInArea({
      x: left2,
      y: top3
    }, area) || _isPointInArea({
      x: left2,
      y: bottom3
    }, area) || _isPointInArea({
      x: right2,
      y: top3
    }, area) || _isPointInArea({
      x: right2,
      y: bottom3
    }, area);
    return !apexesInArea;
  }
  function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const { centerPointLabels, display } = opts.pointLabels;
    const itemOpts = {
      extra: getTickBackdropHeight(opts) / 2,
      additionalAngle: centerPointLabels ? PI / valueCount : 0
    };
    let area;
    for (let i = 0; i < valueCount; i++) {
      itemOpts.padding = padding[i];
      itemOpts.size = labelSizes[i];
      const item = createPointLabelItem(scale, i, itemOpts);
      items.push(item);
      if (display === "auto") {
        item.visible = isNotOverlapped(item, area);
        if (item.visible) {
          area = item;
        }
      }
    }
    return items;
  }
  function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
      return "center";
    } else if (angle < 180) {
      return "left";
    }
    return "right";
  }
  function leftForTextAlign(x, w, align) {
    if (align === "right") {
      x -= w;
    } else if (align === "center") {
      x -= w / 2;
    }
    return x;
  }
  function yForAngle(y3, h, angle) {
    if (angle === 90 || angle === 270) {
      y3 -= h / 2;
    } else if (angle > 270 || angle < 90) {
      y3 -= h;
    }
    return y3;
  }
  function drawPointLabelBox(ctx, opts, item) {
    const { left: left2, top: top3, right: right2, bottom: bottom3 } = item;
    const { backdropColor } = opts;
    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(opts.borderRadius);
      const padding = toPadding(opts.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left2 - padding.left;
      const backdropTop = top3 - padding.top;
      const backdropWidth = right2 - left2 + padding.width;
      const backdropHeight = bottom3 - top3 + padding.height;
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
  }
  function drawPointLabels(scale, labelCount) {
    const { ctx, options: { pointLabels } } = scale;
    for (let i = labelCount - 1; i >= 0; i--) {
      const item = scale._pointLabelItems[i];
      if (!item.visible) {
        continue;
      }
      const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
      drawPointLabelBox(ctx, optsAtIndex, item);
      const plFont = toFont(optsAtIndex.font);
      const { x, y: y3, textAlign } = item;
      renderText(ctx, scale._pointLabels[i], x, y3 + plFont.lineHeight / 2, plFont, {
        color: optsAtIndex.color,
        textAlign,
        textBaseline: "middle"
      });
    }
  }
  function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx } = scale;
    if (circular) {
      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
    } else {
      let pointPosition = scale.getPointPosition(0, radius);
      ctx.moveTo(pointPosition.x, pointPosition.y);
      for (let i = 1; i < labelCount; i++) {
        pointPosition = scale.getPointPosition(i, radius);
        ctx.lineTo(pointPosition.x, pointPosition.y);
      }
    }
  }
  function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color: color2, lineWidth } = gridLineOpts;
    if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
      return;
    }
    ctx.save();
    ctx.strokeStyle = color2;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(borderOpts.dash || []);
    ctx.lineDashOffset = borderOpts.dashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  function createPointLabelContext(parent, index3, label) {
    return createContext(parent, {
      label,
      index: index3,
      type: "pointLabel"
    });
  }
  var RadialLinearScale = class extends LinearScaleBase {
    constructor(cfg) {
      super(cfg);
      this.xCenter = void 0;
      this.yCenter = void 0;
      this.drawingArea = void 0;
      this._pointLabels = [];
      this._pointLabelItems = [];
    }
    setDimensions() {
      const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
      const w = this.width = this.maxWidth - padding.width;
      const h = this.height = this.maxHeight - padding.height;
      this.xCenter = Math.floor(this.left + w / 2 + padding.left);
      this.yCenter = Math.floor(this.top + h / 2 + padding.top);
      this.drawingArea = Math.floor(Math.min(w, h) / 2);
    }
    determineDataLimits() {
      const { min: min2, max: max2 } = this.getMinMax(false);
      this.min = isNumberFinite(min2) && !isNaN(min2) ? min2 : 0;
      this.max = isNumberFinite(max2) && !isNaN(max2) ? max2 : 0;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
      LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
      this._pointLabels = this.getLabels().map((value, index3) => {
        const label = callback(this.options.pointLabels.callback, [
          value,
          index3
        ], this);
        return label || label === 0 ? label : "";
      }).filter((v, i) => this.chart.getDataVisibility(i));
    }
    fit() {
      const opts = this.options;
      if (opts.display && opts.pointLabels.display) {
        fitWithPointLabels(this);
      } else {
        this.setCenterPoint(0, 0, 0, 0);
      }
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
      this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
      this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
      this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index3) {
      const angleMultiplier = TAU / (this._pointLabels.length || 1);
      const startAngle = this.options.startAngle || 0;
      return _normalizeAngle(index3 * angleMultiplier + toRadians(startAngle));
    }
    getDistanceFromCenterForValue(value) {
      if (isNullOrUndef(value)) {
        return NaN;
      }
      const scalingFactor = this.drawingArea / (this.max - this.min);
      if (this.options.reverse) {
        return (this.max - value) * scalingFactor;
      }
      return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
      if (isNullOrUndef(distance)) {
        return NaN;
      }
      const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
      return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index3) {
      const pointLabels = this._pointLabels || [];
      if (index3 >= 0 && index3 < pointLabels.length) {
        const pointLabel = pointLabels[index3];
        return createPointLabelContext(this.getContext(), index3, pointLabel);
      }
    }
    getPointPosition(index3, distanceFromCenter, additionalAngle = 0) {
      const angle = this.getIndexAngle(index3) - HALF_PI + additionalAngle;
      return {
        x: Math.cos(angle) * distanceFromCenter + this.xCenter,
        y: Math.sin(angle) * distanceFromCenter + this.yCenter,
        angle
      };
    }
    getPointPositionForValue(index3, value) {
      return this.getPointPosition(index3, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index3) {
      return this.getPointPositionForValue(index3 || 0, this.getBaseValue());
    }
    getPointLabelPosition(index3) {
      const { left: left2, top: top3, right: right2, bottom: bottom3 } = this._pointLabelItems[index3];
      return {
        left: left2,
        top: top3,
        right: right2,
        bottom: bottom3
      };
    }
    drawBackground() {
      const { backgroundColor, grid: { circular } } = this.options;
      if (backgroundColor) {
        const ctx = this.ctx;
        ctx.save();
        ctx.beginPath();
        pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
        ctx.closePath();
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
      }
    }
    drawGrid() {
      const ctx = this.ctx;
      const opts = this.options;
      const { angleLines, grid, border } = opts;
      const labelCount = this._pointLabels.length;
      let i, offset2, position;
      if (opts.pointLabels.display) {
        drawPointLabels(this, labelCount);
      }
      if (grid.display) {
        this.ticks.forEach((tick, index3) => {
          if (index3 !== 0 || index3 === 0 && this.min < 0) {
            offset2 = this.getDistanceFromCenterForValue(tick.value);
            const context = this.getContext(index3);
            const optsAtIndex = grid.setContext(context);
            const optsAtIndexBorder = border.setContext(context);
            drawRadiusLine(this, optsAtIndex, offset2, labelCount, optsAtIndexBorder);
          }
        });
      }
      if (angleLines.display) {
        ctx.save();
        for (i = labelCount - 1; i >= 0; i--) {
          const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
          const { color: color2, lineWidth } = optsAtIndex;
          if (!lineWidth || !color2) {
            continue;
          }
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = color2;
          ctx.setLineDash(optsAtIndex.borderDash);
          ctx.lineDashOffset = optsAtIndex.borderDashOffset;
          offset2 = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
          position = this.getPointPosition(i, offset2);
          ctx.beginPath();
          ctx.moveTo(this.xCenter, this.yCenter);
          ctx.lineTo(position.x, position.y);
          ctx.stroke();
        }
        ctx.restore();
      }
    }
    drawBorder() {
    }
    drawLabels() {
      const ctx = this.ctx;
      const opts = this.options;
      const tickOpts = opts.ticks;
      if (!tickOpts.display) {
        return;
      }
      const startAngle = this.getIndexAngle(0);
      let offset2, width;
      ctx.save();
      ctx.translate(this.xCenter, this.yCenter);
      ctx.rotate(startAngle);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      this.ticks.forEach((tick, index3) => {
        if (index3 === 0 && this.min >= 0 && !opts.reverse) {
          return;
        }
        const optsAtIndex = tickOpts.setContext(this.getContext(index3));
        const tickFont = toFont(optsAtIndex.font);
        offset2 = this.getDistanceFromCenterForValue(this.ticks[index3].value);
        if (optsAtIndex.showLabelBackdrop) {
          ctx.font = tickFont.string;
          width = ctx.measureText(tick.label).width;
          ctx.fillStyle = optsAtIndex.backdropColor;
          const padding = toPadding(optsAtIndex.backdropPadding);
          ctx.fillRect(-width / 2 - padding.left, -offset2 - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
        }
        renderText(ctx, tick.label, 0, -offset2, tickFont, {
          color: optsAtIndex.color,
          strokeColor: optsAtIndex.textStrokeColor,
          strokeWidth: optsAtIndex.textStrokeWidth
        });
      });
      ctx.restore();
    }
    drawTitle() {
    }
  };
  __publicField(RadialLinearScale, "id", "radialLinear");
  __publicField(RadialLinearScale, "defaults", {
    display: true,
    animate: true,
    position: "chartArea",
    angleLines: {
      display: true,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    grid: {
      circular: false
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: true,
      callback: Ticks.formatters.numeric
    },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: true,
      font: {
        size: 10
      },
      callback(label) {
        return label;
      },
      padding: 5,
      centerPointLabels: false
    }
  });
  __publicField(RadialLinearScale, "defaultRoutes", {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
  });
  __publicField(RadialLinearScale, "descriptors", {
    angleLines: {
      _fallback: "grid"
    }
  });
  var INTERVALS = {
    millisecond: {
      common: true,
      size: 1,
      steps: 1e3
    },
    second: {
      common: true,
      size: 1e3,
      steps: 60
    },
    minute: {
      common: true,
      size: 6e4,
      steps: 60
    },
    hour: {
      common: true,
      size: 36e5,
      steps: 24
    },
    day: {
      common: true,
      size: 864e5,
      steps: 30
    },
    week: {
      common: false,
      size: 6048e5,
      steps: 4
    },
    month: {
      common: true,
      size: 2628e6,
      steps: 12
    },
    quarter: {
      common: false,
      size: 7884e6,
      steps: 4
    },
    year: {
      common: true,
      size: 3154e7
    }
  };
  var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
  function sorter(a, b) {
    return a - b;
  }
  function parse(scale, input) {
    if (isNullOrUndef(input)) {
      return null;
    }
    const adapter = scale._adapter;
    const { parser, round: round3, isoWeekday } = scale._parseOpts;
    let value = input;
    if (typeof parser === "function") {
      value = parser(value);
    }
    if (!isNumberFinite(value)) {
      value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
    }
    if (value === null) {
      return null;
    }
    if (round3) {
      value = round3 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round3);
    }
    return +value;
  }
  function determineUnitForAutoTicks(minUnit, min2, max2, capacity) {
    const ilen = UNITS.length;
    for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
      const interval = INTERVALS[UNITS[i]];
      const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
      if (interval.common && Math.ceil((max2 - min2) / (factor * interval.size)) <= capacity) {
        return UNITS[i];
      }
    }
    return UNITS[ilen - 1];
  }
  function determineUnitForFormatting(scale, numTicks, minUnit, min2, max2) {
    for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
      const unit = UNITS[i];
      if (INTERVALS[unit].common && scale._adapter.diff(max2, min2, unit) >= numTicks - 1) {
        return unit;
      }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
  }
  function determineMajorUnit(unit) {
    for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
      if (INTERVALS[UNITS[i]].common) {
        return UNITS[i];
      }
    }
  }
  function addTick(ticks, time, timestamps) {
    if (!timestamps) {
      ticks[time] = true;
    } else if (timestamps.length) {
      const { lo, hi } = _lookup(timestamps, time);
      const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
      ticks[timestamp] = true;
    }
  }
  function setMajorTicks(scale, ticks, map3, majorUnit) {
    const adapter = scale._adapter;
    const first = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index3;
    for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
      index3 = map3[major];
      if (index3 >= 0) {
        ticks[index3].major = true;
      }
    }
    return ticks;
  }
  function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
    const map3 = {};
    const ilen = values.length;
    let i, value;
    for (i = 0; i < ilen; ++i) {
      value = values[i];
      map3[value] = i;
      ticks.push({
        value,
        major: false
      });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
  }
  var TimeScale = class extends Scale {
    constructor(props) {
      super(props);
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
      this._unit = "day";
      this._majorUnit = void 0;
      this._offsets = {};
      this._normalized = false;
      this._parseOpts = void 0;
    }
    init(scaleOpts, opts = {}) {
      const time = scaleOpts.time || (scaleOpts.time = {});
      const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
      adapter.init(opts);
      mergeIf(time.displayFormats, adapter.formats());
      this._parseOpts = {
        parser: time.parser,
        round: time.round,
        isoWeekday: time.isoWeekday
      };
      super.init(scaleOpts);
      this._normalized = opts.normalized;
    }
    parse(raw, index3) {
      if (raw === void 0) {
        return null;
      }
      return parse(this, raw);
    }
    beforeLayout() {
      super.beforeLayout();
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
    }
    determineDataLimits() {
      const options = this.options;
      const adapter = this._adapter;
      const unit = options.time.unit || "day";
      let { min: min2, max: max2, minDefined, maxDefined } = this.getUserBounds();
      function _applyBounds(bounds) {
        if (!minDefined && !isNaN(bounds.min)) {
          min2 = Math.min(min2, bounds.min);
        }
        if (!maxDefined && !isNaN(bounds.max)) {
          max2 = Math.max(max2, bounds.max);
        }
      }
      if (!minDefined || !maxDefined) {
        _applyBounds(this._getLabelBounds());
        if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
          _applyBounds(this.getMinMax(false));
        }
      }
      min2 = isNumberFinite(min2) && !isNaN(min2) ? min2 : +adapter.startOf(Date.now(), unit);
      max2 = isNumberFinite(max2) && !isNaN(max2) ? max2 : +adapter.endOf(Date.now(), unit) + 1;
      this.min = Math.min(min2, max2 - 1);
      this.max = Math.max(min2 + 1, max2);
    }
    _getLabelBounds() {
      const arr = this.getLabelTimestamps();
      let min2 = Number.POSITIVE_INFINITY;
      let max2 = Number.NEGATIVE_INFINITY;
      if (arr.length) {
        min2 = arr[0];
        max2 = arr[arr.length - 1];
      }
      return {
        min: min2,
        max: max2
      };
    }
    buildTicks() {
      const options = this.options;
      const timeOpts = options.time;
      const tickOpts = options.ticks;
      const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
      if (options.bounds === "ticks" && timestamps.length) {
        this.min = this._userMin || timestamps[0];
        this.max = this._userMax || timestamps[timestamps.length - 1];
      }
      const min2 = this.min;
      const max2 = this.max;
      const ticks = _filterBetween(timestamps, min2, max2);
      this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min2)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
      this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
      this.initOffsets(timestamps);
      if (options.reverse) {
        ticks.reverse();
      }
      return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
      if (this.options.offsetAfterAutoskip) {
        this.initOffsets(this.ticks.map((tick) => +tick.value));
      }
    }
    initOffsets(timestamps = []) {
      let start2 = 0;
      let end2 = 0;
      let first, last;
      if (this.options.offset && timestamps.length) {
        first = this.getDecimalForValue(timestamps[0]);
        if (timestamps.length === 1) {
          start2 = 1 - first;
        } else {
          start2 = (this.getDecimalForValue(timestamps[1]) - first) / 2;
        }
        last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
        if (timestamps.length === 1) {
          end2 = last;
        } else {
          end2 = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
        }
      }
      const limit = timestamps.length < 3 ? 0.5 : 0.25;
      start2 = _limitValue(start2, 0, limit);
      end2 = _limitValue(end2, 0, limit);
      this._offsets = {
        start: start2,
        end: end2,
        factor: 1 / (start2 + 1 + end2)
      };
    }
    _generate() {
      const adapter = this._adapter;
      const min2 = this.min;
      const max2 = this.max;
      const options = this.options;
      const timeOpts = options.time;
      const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min2, max2, this._getLabelCapacity(min2));
      const stepSize = valueOrDefault(options.ticks.stepSize, 1);
      const weekday = minor === "week" ? timeOpts.isoWeekday : false;
      const hasWeekday = isNumber(weekday) || weekday === true;
      const ticks = {};
      let first = min2;
      let time, count;
      if (hasWeekday) {
        first = +adapter.startOf(first, "isoWeek", weekday);
      }
      first = +adapter.startOf(first, hasWeekday ? "day" : minor);
      if (adapter.diff(max2, min2, minor) > 1e5 * stepSize) {
        throw new Error(min2 + " and " + max2 + " are too far apart with stepSize of " + stepSize + " " + minor);
      }
      const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
      for (time = first, count = 0; time < max2; time = +adapter.add(time, stepSize, minor), count++) {
        addTick(ticks, time, timestamps);
      }
      if (time === max2 || options.bounds === "ticks" || count === 1) {
        addTick(ticks, time, timestamps);
      }
      return Object.keys(ticks).sort(sorter).map((x) => +x);
    }
    getLabelForValue(value) {
      const adapter = this._adapter;
      const timeOpts = this.options.time;
      if (timeOpts.tooltipFormat) {
        return adapter.format(value, timeOpts.tooltipFormat);
      }
      return adapter.format(value, timeOpts.displayFormats.datetime);
    }
    format(value, format) {
      const options = this.options;
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const fmt = format || formats[unit];
      return this._adapter.format(value, fmt);
    }
    _tickFormatFunction(time, index3, ticks, format) {
      const options = this.options;
      const formatter = options.ticks.callback;
      if (formatter) {
        return callback(formatter, [
          time,
          index3,
          ticks
        ], this);
      }
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const majorUnit = this._majorUnit;
      const minorFormat = unit && formats[unit];
      const majorFormat = majorUnit && formats[majorUnit];
      const tick = ticks[index3];
      const major = majorUnit && majorFormat && tick && tick.major;
      return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    }
    generateTickLabels(ticks) {
      let i, ilen, tick;
      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        tick = ticks[i];
        tick.label = this._tickFormatFunction(tick.value, i, ticks);
      }
    }
    getDecimalForValue(value) {
      return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
    getPixelForValue(value) {
      const offsets = this._offsets;
      const pos = this.getDecimalForValue(value);
      return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return this.min + pos * (this.max - this.min);
    }
    _getLabelSize(label) {
      const ticksOpts = this.options.ticks;
      const tickLabelWidth = this.ctx.measureText(label).width;
      const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
      const cosRotation = Math.cos(angle);
      const sinRotation = Math.sin(angle);
      const tickFontSize = this._resolveTickFontOptions(0).size;
      return {
        w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
        h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
      };
    }
    _getLabelCapacity(exampleTime) {
      const timeOpts = this.options.time;
      const displayFormats = timeOpts.displayFormats;
      const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
      const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
        exampleTime
      ], this._majorUnit), format);
      const size = this._getLabelSize(exampleLabel);
      const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
      return capacity > 0 ? capacity : 1;
    }
    getDataTimestamps() {
      let timestamps = this._cache.data || [];
      let i, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const metas = this.getMatchingVisibleMetas();
      if (this._normalized && metas.length) {
        return this._cache.data = metas[0].controller.getAllParsedValues(this);
      }
      for (i = 0, ilen = metas.length; i < ilen; ++i) {
        timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
      }
      return this._cache.data = this.normalize(timestamps);
    }
    getLabelTimestamps() {
      const timestamps = this._cache.labels || [];
      let i, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const labels = this.getLabels();
      for (i = 0, ilen = labels.length; i < ilen; ++i) {
        timestamps.push(parse(this, labels[i]));
      }
      return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
    normalize(values) {
      return _arrayUnique(values.sort(sorter));
    }
  };
  __publicField(TimeScale, "id", "time");
  __publicField(TimeScale, "defaults", {
    bounds: "data",
    adapters: {},
    time: {
      parser: false,
      unit: false,
      round: false,
      isoWeekday: false,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: false,
      major: {
        enabled: false
      }
    }
  });
  function interpolate2(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
      if (val >= table[lo].pos && val <= table[hi].pos) {
        ({ lo, hi } = _lookupByKey(table, "pos", val));
      }
      ({ pos: prevSource, time: prevTarget } = table[lo]);
      ({ pos: nextSource, time: nextTarget } = table[hi]);
    } else {
      if (val >= table[lo].time && val <= table[hi].time) {
        ({ lo, hi } = _lookupByKey(table, "time", val));
      }
      ({ time: prevSource, pos: prevTarget } = table[lo]);
      ({ time: nextSource, pos: nextTarget } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
  }
  var TimeSeriesScale = class extends TimeScale {
    constructor(props) {
      super(props);
      this._table = [];
      this._minPos = void 0;
      this._tableRange = void 0;
    }
    initOffsets() {
      const timestamps = this._getTimestampsForTable();
      const table = this._table = this.buildLookupTable(timestamps);
      this._minPos = interpolate2(table, this.min);
      this._tableRange = interpolate2(table, this.max) - this._minPos;
      super.initOffsets(timestamps);
    }
    buildLookupTable(timestamps) {
      const { min: min2, max: max2 } = this;
      const items = [];
      const table = [];
      let i, ilen, prev, curr, next;
      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        curr = timestamps[i];
        if (curr >= min2 && curr <= max2) {
          items.push(curr);
        }
      }
      if (items.length < 2) {
        return [
          {
            time: min2,
            pos: 0
          },
          {
            time: max2,
            pos: 1
          }
        ];
      }
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        next = items[i + 1];
        prev = items[i - 1];
        curr = items[i];
        if (Math.round((next + prev) / 2) !== curr) {
          table.push({
            time: curr,
            pos: i / (ilen - 1)
          });
        }
      }
      return table;
    }
    _generate() {
      const min2 = this.min;
      const max2 = this.max;
      let timestamps = super.getDataTimestamps();
      if (!timestamps.includes(min2) || !timestamps.length) {
        timestamps.splice(0, 0, min2);
      }
      if (!timestamps.includes(max2) || timestamps.length === 1) {
        timestamps.push(max2);
      }
      return timestamps.sort((a, b) => a - b);
    }
    _getTimestampsForTable() {
      let timestamps = this._cache.all || [];
      if (timestamps.length) {
        return timestamps;
      }
      const data = this.getDataTimestamps();
      const label = this.getLabelTimestamps();
      if (data.length && label.length) {
        timestamps = this.normalize(data.concat(label));
      } else {
        timestamps = data.length ? data : label;
      }
      timestamps = this._cache.all = timestamps;
      return timestamps;
    }
    getDecimalForValue(value) {
      return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
    }
  };
  __publicField(TimeSeriesScale, "id", "timeseries");
  __publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
  var scales = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    CategoryScale,
    LinearScale,
    LogarithmicScale,
    RadialLinearScale,
    TimeScale,
    TimeSeriesScale
  });
  var registerables = [
    controllers,
    elements,
    plugins,
    scales
  ];

  // node_modules/chart.js/auto/auto.js
  Chart.register(...registerables);
  var auto_default = Chart;

  // node_modules/sortablejs/modular/sortable.esm.js
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) {
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  var version2 = "1.15.6";
  function userAgent(pattern) {
    if (typeof window !== "undefined" && window.navigator) {
      return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
    }
  }
  var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
  var Edge = userAgent(/Edge/i);
  var FireFox = userAgent(/firefox/i);
  var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
  var IOS = userAgent(/iP(ad|od|hone)/i);
  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
  var captureMode = {
    capture: false,
    passive: false
  };
  function on(el2, event, fn2) {
    el2.addEventListener(event, fn2, !IE11OrLess && captureMode);
  }
  function off(el2, event, fn2) {
    el2.removeEventListener(event, fn2, !IE11OrLess && captureMode);
  }
  function matches(el2, selector) {
    if (!selector)
      return;
    selector[0] === ">" && (selector = selector.substring(1));
    if (el2) {
      try {
        if (el2.matches) {
          return el2.matches(selector);
        } else if (el2.msMatchesSelector) {
          return el2.msMatchesSelector(selector);
        } else if (el2.webkitMatchesSelector) {
          return el2.webkitMatchesSelector(selector);
        }
      } catch (_) {
        return false;
      }
    }
    return false;
  }
  function getParentOrHost(el2) {
    return el2.host && el2 !== document && el2.host.nodeType ? el2.host : el2.parentNode;
  }
  function closest(el2, selector, ctx, includeCTX) {
    if (el2) {
      ctx = ctx || document;
      do {
        if (selector != null && (selector[0] === ">" ? el2.parentNode === ctx && matches(el2, selector) : matches(el2, selector)) || includeCTX && el2 === ctx) {
          return el2;
        }
        if (el2 === ctx)
          break;
      } while (el2 = getParentOrHost(el2));
    }
    return null;
  }
  var R_SPACE = /\s+/g;
  function toggleClass(el2, name, state) {
    if (el2 && name) {
      if (el2.classList) {
        el2.classList[state ? "add" : "remove"](name);
      } else {
        var className = (" " + el2.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
        el2.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
      }
    }
  }
  function css(el2, prop, val) {
    var style = el2 && el2.style;
    if (style) {
      if (val === void 0) {
        if (document.defaultView && document.defaultView.getComputedStyle) {
          val = document.defaultView.getComputedStyle(el2, "");
        } else if (el2.currentStyle) {
          val = el2.currentStyle;
        }
        return prop === void 0 ? val : val[prop];
      } else {
        if (!(prop in style) && prop.indexOf("webkit") === -1) {
          prop = "-webkit-" + prop;
        }
        style[prop] = val + (typeof val === "string" ? "" : "px");
      }
    }
  }
  function matrix(el2, selfOnly) {
    var appliedTransforms = "";
    if (typeof el2 === "string") {
      appliedTransforms = el2;
    } else {
      do {
        var transform = css(el2, "transform");
        if (transform && transform !== "none") {
          appliedTransforms = transform + " " + appliedTransforms;
        }
      } while (!selfOnly && (el2 = el2.parentNode));
    }
    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
    return matrixFn && new matrixFn(appliedTransforms);
  }
  function find(ctx, tagName, iterator) {
    if (ctx) {
      var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
      if (iterator) {
        for (; i < n; i++) {
          iterator(list[i], i);
        }
      }
      return list;
    }
    return [];
  }
  function getWindowScrollingElement() {
    var scrollingElement = document.scrollingElement;
    if (scrollingElement) {
      return scrollingElement;
    } else {
      return document.documentElement;
    }
  }
  function getRect(el2, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
    if (!el2.getBoundingClientRect && el2 !== window)
      return;
    var elRect, top3, left2, bottom3, right2, height, width;
    if (el2 !== window && el2.parentNode && el2 !== getWindowScrollingElement()) {
      elRect = el2.getBoundingClientRect();
      top3 = elRect.top;
      left2 = elRect.left;
      bottom3 = elRect.bottom;
      right2 = elRect.right;
      height = elRect.height;
      width = elRect.width;
    } else {
      top3 = 0;
      left2 = 0;
      bottom3 = window.innerHeight;
      right2 = window.innerWidth;
      height = window.innerHeight;
      width = window.innerWidth;
    }
    if ((relativeToContainingBlock || relativeToNonStaticParent) && el2 !== window) {
      container = container || el2.parentNode;
      if (!IE11OrLess) {
        do {
          if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
            var containerRect = container.getBoundingClientRect();
            top3 -= containerRect.top + parseInt(css(container, "border-top-width"));
            left2 -= containerRect.left + parseInt(css(container, "border-left-width"));
            bottom3 = top3 + elRect.height;
            right2 = left2 + elRect.width;
            break;
          }
        } while (container = container.parentNode);
      }
    }
    if (undoScale && el2 !== window) {
      var elMatrix = matrix(container || el2), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
      if (elMatrix) {
        top3 /= scaleY;
        left2 /= scaleX;
        width /= scaleX;
        height /= scaleY;
        bottom3 = top3 + height;
        right2 = left2 + width;
      }
    }
    return {
      top: top3,
      left: left2,
      bottom: bottom3,
      right: right2,
      width,
      height
    };
  }
  function isScrolledPast(el2, elSide, parentSide) {
    var parent = getParentAutoScrollElement(el2, true), elSideVal = getRect(el2)[elSide];
    while (parent) {
      var parentSideVal = getRect(parent)[parentSide], visible = void 0;
      if (parentSide === "top" || parentSide === "left") {
        visible = elSideVal >= parentSideVal;
      } else {
        visible = elSideVal <= parentSideVal;
      }
      if (!visible)
        return parent;
      if (parent === getWindowScrollingElement())
        break;
      parent = getParentAutoScrollElement(parent, false);
    }
    return false;
  }
  function getChild(el2, childNum, options, includeDragEl) {
    var currentChild = 0, i = 0, children = el2.children;
    while (i < children.length) {
      if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el2, false)) {
        if (currentChild === childNum) {
          return children[i];
        }
        currentChild++;
      }
      i++;
    }
    return null;
  }
  function lastChild(el2, selector) {
    var last = el2.lastElementChild;
    while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
      last = last.previousElementSibling;
    }
    return last || null;
  }
  function index2(el2, selector) {
    var index3 = 0;
    if (!el2 || !el2.parentNode) {
      return -1;
    }
    while (el2 = el2.previousElementSibling) {
      if (el2.nodeName.toUpperCase() !== "TEMPLATE" && el2 !== Sortable.clone && (!selector || matches(el2, selector))) {
        index3++;
      }
    }
    return index3;
  }
  function getRelativeScrollOffset(el2) {
    var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
    if (el2) {
      do {
        var elMatrix = matrix(el2), scaleX = elMatrix.a, scaleY = elMatrix.d;
        offsetLeft += el2.scrollLeft * scaleX;
        offsetTop += el2.scrollTop * scaleY;
      } while (el2 !== winScroller && (el2 = el2.parentNode));
    }
    return [offsetLeft, offsetTop];
  }
  function indexOfObject(arr, obj) {
    for (var i in arr) {
      if (!arr.hasOwnProperty(i))
        continue;
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key] === arr[i][key])
          return Number(i);
      }
    }
    return -1;
  }
  function getParentAutoScrollElement(el2, includeSelf) {
    if (!el2 || !el2.getBoundingClientRect)
      return getWindowScrollingElement();
    var elem = el2;
    var gotSelf = false;
    do {
      if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
        var elemCSS = css(elem);
        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
          if (!elem.getBoundingClientRect || elem === document.body)
            return getWindowScrollingElement();
          if (gotSelf || includeSelf)
            return elem;
          gotSelf = true;
        }
      }
    } while (elem = elem.parentNode);
    return getWindowScrollingElement();
  }
  function extend(dst, src) {
    if (dst && src) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          dst[key] = src[key];
        }
      }
    }
    return dst;
  }
  function isRectEqual(rect1, rect2) {
    return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
  }
  var _throttleTimeout;
  function throttle(callback2, ms) {
    return function() {
      if (!_throttleTimeout) {
        var args = arguments, _this = this;
        if (args.length === 1) {
          callback2.call(_this, args[0]);
        } else {
          callback2.apply(_this, args);
        }
        _throttleTimeout = setTimeout(function() {
          _throttleTimeout = void 0;
        }, ms);
      }
    };
  }
  function cancelThrottle() {
    clearTimeout(_throttleTimeout);
    _throttleTimeout = void 0;
  }
  function scrollBy(el2, x, y3) {
    el2.scrollLeft += x;
    el2.scrollTop += y3;
  }
  function clone4(el2) {
    var Polymer = window.Polymer;
    var $ = window.jQuery || window.Zepto;
    if (Polymer && Polymer.dom) {
      return Polymer.dom(el2).cloneNode(true);
    } else if ($) {
      return $(el2).clone(true)[0];
    } else {
      return el2.cloneNode(true);
    }
  }
  function getChildContainingRectFromElement(container, options, ghostEl2) {
    var rect = {};
    Array.from(container.children).forEach(function(child) {
      var _rect$left, _rect$top, _rect$right, _rect$bottom;
      if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl2)
        return;
      var childRect = getRect(child);
      rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
      rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
      rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
      rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
    });
    rect.width = rect.right - rect.left;
    rect.height = rect.bottom - rect.top;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  var expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
  function AnimationStateManager() {
    var animationStates = [], animationCallbackId;
    return {
      captureAnimationState: function captureAnimationState() {
        animationStates = [];
        if (!this.options.animation)
          return;
        var children = [].slice.call(this.el.children);
        children.forEach(function(child) {
          if (css(child, "display") === "none" || child === Sortable.ghost)
            return;
          animationStates.push({
            target: child,
            rect: getRect(child)
          });
          var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
          if (child.thisAnimationDuration) {
            var childMatrix = matrix(child, true);
            if (childMatrix) {
              fromRect.top -= childMatrix.f;
              fromRect.left -= childMatrix.e;
            }
          }
          child.fromRect = fromRect;
        });
      },
      addAnimationState: function addAnimationState(state) {
        animationStates.push(state);
      },
      removeAnimationState: function removeAnimationState(target) {
        animationStates.splice(indexOfObject(animationStates, {
          target
        }), 1);
      },
      animateAll: function animateAll(callback2) {
        var _this = this;
        if (!this.options.animation) {
          clearTimeout(animationCallbackId);
          if (typeof callback2 === "function")
            callback2();
          return;
        }
        var animating = false, animationTime = 0;
        animationStates.forEach(function(state) {
          var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
          if (targetMatrix) {
            toRect.top -= targetMatrix.f;
            toRect.left -= targetMatrix.e;
          }
          target.toRect = toRect;
          if (target.thisAnimationDuration) {
            if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
            (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
              time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
            }
          }
          if (!isRectEqual(toRect, fromRect)) {
            target.prevFromRect = fromRect;
            target.prevToRect = toRect;
            if (!time) {
              time = _this.options.animation;
            }
            _this.animate(target, animatingRect, toRect, time);
          }
          if (time) {
            animating = true;
            animationTime = Math.max(animationTime, time);
            clearTimeout(target.animationResetTimer);
            target.animationResetTimer = setTimeout(function() {
              target.animationTime = 0;
              target.prevFromRect = null;
              target.fromRect = null;
              target.prevToRect = null;
              target.thisAnimationDuration = null;
            }, time);
            target.thisAnimationDuration = time;
          }
        });
        clearTimeout(animationCallbackId);
        if (!animating) {
          if (typeof callback2 === "function")
            callback2();
        } else {
          animationCallbackId = setTimeout(function() {
            if (typeof callback2 === "function")
              callback2();
          }, animationTime);
        }
        animationStates = [];
      },
      animate: function animate(target, currentRect, toRect, duration) {
        if (duration) {
          css(target, "transition", "");
          css(target, "transform", "");
          var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
          target.animatingX = !!translateX;
          target.animatingY = !!translateY;
          css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
          this.forRepaintDummy = repaint(target);
          css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
          css(target, "transform", "translate3d(0,0,0)");
          typeof target.animated === "number" && clearTimeout(target.animated);
          target.animated = setTimeout(function() {
            css(target, "transition", "");
            css(target, "transform", "");
            target.animated = false;
            target.animatingX = false;
            target.animatingY = false;
          }, duration);
        }
      }
    };
  }
  function repaint(target) {
    return target.offsetWidth;
  }
  function calculateRealTime(animatingRect, fromRect, toRect, options) {
    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
  }
  var plugins2 = [];
  var defaults2 = {
    initializeByDefault: true
  };
  var PluginManager = {
    mount: function mount(plugin) {
      for (var option2 in defaults2) {
        if (defaults2.hasOwnProperty(option2) && !(option2 in plugin)) {
          plugin[option2] = defaults2[option2];
        }
      }
      plugins2.forEach(function(p) {
        if (p.pluginName === plugin.pluginName) {
          throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
        }
      });
      plugins2.push(plugin);
    },
    pluginEvent: function pluginEvent(eventName, sortable, evt) {
      var _this = this;
      this.eventCanceled = false;
      evt.cancel = function() {
        _this.eventCanceled = true;
      };
      var eventNameGlobal = eventName + "Global";
      plugins2.forEach(function(plugin) {
        if (!sortable[plugin.pluginName])
          return;
        if (sortable[plugin.pluginName][eventNameGlobal]) {
          sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
            sortable
          }, evt));
        }
        if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
          sortable[plugin.pluginName][eventName](_objectSpread2({
            sortable
          }, evt));
        }
      });
    },
    initializePlugins: function initializePlugins(sortable, el2, defaults3, options) {
      plugins2.forEach(function(plugin) {
        var pluginName = plugin.pluginName;
        if (!sortable.options[pluginName] && !plugin.initializeByDefault)
          return;
        var initialized = new plugin(sortable, el2, sortable.options);
        initialized.sortable = sortable;
        initialized.options = sortable.options;
        sortable[pluginName] = initialized;
        _extends(defaults3, initialized.defaults);
      });
      for (var option2 in sortable.options) {
        if (!sortable.options.hasOwnProperty(option2))
          continue;
        var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
        if (typeof modified !== "undefined") {
          sortable.options[option2] = modified;
        }
      }
    },
    getEventProperties: function getEventProperties(name, sortable) {
      var eventProperties = {};
      plugins2.forEach(function(plugin) {
        if (typeof plugin.eventProperties !== "function")
          return;
        _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
      });
      return eventProperties;
    },
    modifyOption: function modifyOption(sortable, name, value) {
      var modifiedValue;
      plugins2.forEach(function(plugin) {
        if (!sortable[plugin.pluginName])
          return;
        if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
          modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
        }
      });
      return modifiedValue;
    }
  };
  function dispatchEvent(_ref) {
    var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
    sortable = sortable || rootEl2 && rootEl2[expando];
    if (!sortable)
      return;
    var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent(name, {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent("Event");
      evt.initEvent(name, true, true);
    }
    evt.to = toEl || rootEl2;
    evt.from = fromEl || rootEl2;
    evt.item = targetEl || rootEl2;
    evt.clone = cloneEl2;
    evt.oldIndex = oldIndex2;
    evt.newIndex = newIndex2;
    evt.oldDraggableIndex = oldDraggableIndex2;
    evt.newDraggableIndex = newDraggableIndex2;
    evt.originalEvent = originalEvent;
    evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
    var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
    for (var option2 in allEventProperties) {
      evt[option2] = allEventProperties[option2];
    }
    if (rootEl2) {
      rootEl2.dispatchEvent(evt);
    }
    if (options[onName]) {
      options[onName].call(sortable, evt);
    }
  }
  var _excluded = ["evt"];
  var pluginEvent2 = function pluginEvent3(eventName, sortable) {
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
      dragEl,
      parentEl,
      ghostEl,
      rootEl,
      nextEl,
      lastDownEl,
      cloneEl,
      cloneHidden,
      dragStarted: moved,
      putSortable,
      activeSortable: Sortable.active,
      originalEvent,
      oldIndex,
      oldDraggableIndex,
      newIndex,
      newDraggableIndex,
      hideGhostForTarget: _hideGhostForTarget,
      unhideGhostForTarget: _unhideGhostForTarget,
      cloneNowHidden: function cloneNowHidden() {
        cloneHidden = true;
      },
      cloneNowShown: function cloneNowShown() {
        cloneHidden = false;
      },
      dispatchSortableEvent: function dispatchSortableEvent(name) {
        _dispatchEvent({
          sortable,
          name,
          originalEvent
        });
      }
    }, data));
  };
  function _dispatchEvent(info) {
    dispatchEvent(_objectSpread2({
      putSortable,
      cloneEl,
      targetEl: dragEl,
      rootEl,
      oldIndex,
      oldDraggableIndex,
      newIndex,
      newDraggableIndex
    }, info));
  }
  var dragEl;
  var parentEl;
  var ghostEl;
  var rootEl;
  var nextEl;
  var lastDownEl;
  var cloneEl;
  var cloneHidden;
  var oldIndex;
  var newIndex;
  var oldDraggableIndex;
  var newDraggableIndex;
  var activeGroup;
  var putSortable;
  var awaitingDragStarted = false;
  var ignoreNextClick = false;
  var sortables = [];
  var tapEvt;
  var touchEvt;
  var lastDx;
  var lastDy;
  var tapDistanceLeft;
  var tapDistanceTop;
  var moved;
  var lastTarget;
  var lastDirection;
  var pastFirstInvertThresh = false;
  var isCircumstantialInvert = false;
  var targetMoveDistance;
  var ghostRelativeParent;
  var ghostRelativeParentInitialScroll = [];
  var _silent = false;
  var savedInputChecked = [];
  var documentExists = typeof document !== "undefined";
  var PositionGhostAbsolutely = IOS;
  var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
  var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
  var supportCssPointerEvents = function() {
    if (!documentExists)
      return;
    if (IE11OrLess) {
      return false;
    }
    var el2 = document.createElement("x");
    el2.style.cssText = "pointer-events:auto";
    return el2.style.pointerEvents === "auto";
  }();
  var _detectDirection = function _detectDirection2(el2, options) {
    var elCSS = css(el2), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el2, 0, options), child2 = getChild(el2, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === "flex") {
      return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
    }
    if (elCSS.display === "grid") {
      return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
      var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
      return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
    }
    return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
  };
  var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  };
  var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y3) {
    var ret;
    sortables.some(function(sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable))
        return;
      var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y3 >= rect.top - threshold && y3 <= rect.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  };
  var _prepareGroup = function _prepareGroup2(options) {
    function toFn(value, pull) {
      return function(to2, from2, dragEl2, evt) {
        var sameGroup = to2.options.group.name && from2.options.group.name && to2.options.group.name === from2.options.group.name;
        if (value == null && (pull || sameGroup)) {
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === "clone") {
          return value;
        } else if (typeof value === "function") {
          return toFn(value(to2, from2, dragEl2, evt), pull)(to2, from2, dragEl2, evt);
        } else {
          var otherGroup = (pull ? to2 : from2).options.group.name;
          return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }
    var group = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof(originalGroup) != "object") {
      originalGroup = {
        name: originalGroup
      };
    }
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  };
  var _hideGhostForTarget = function _hideGhostForTarget2() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, "display", "none");
    }
  };
  var _unhideGhostForTarget = function _unhideGhostForTarget2() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, "display", "");
    }
  };
  if (documentExists && !ChromeForAndroid) {
    document.addEventListener("click", function(evt) {
      if (ignoreNextClick) {
        evt.preventDefault();
        evt.stopPropagation && evt.stopPropagation();
        evt.stopImmediatePropagation && evt.stopImmediatePropagation();
        ignoreNextClick = false;
        return false;
      }
    }, true);
  }
  var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
    if (dragEl) {
      evt = evt.touches ? evt.touches[0] : evt;
      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
      if (nearest) {
        var event = {};
        for (var i in evt) {
          if (evt.hasOwnProperty(i)) {
            event[i] = evt[i];
          }
        }
        event.target = event.rootEl = nearest;
        event.preventDefault = void 0;
        event.stopPropagation = void 0;
        nearest[expando]._onDragOver(event);
      }
    }
  };
  var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
    if (dragEl) {
      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
    }
  };
  function Sortable(el2, options) {
    if (!(el2 && el2.nodeType && el2.nodeType === 1)) {
      throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el2));
    }
    this.el = el2;
    this.options = options = _extends({}, options);
    el2[expando] = this;
    var defaults3 = {
      group: null,
      sort: true,
      disabled: false,
      store: null,
      handle: null,
      draggable: /^[uo]l$/i.test(el2.nodeName) ? ">li" : ">*",
      swapThreshold: 1,
      // percentage; 0 <= x <= 1
      invertSwap: false,
      // invert always
      invertedSwapThreshold: null,
      // will be set to same as swapThreshold if default
      removeCloneOnHide: true,
      direction: function direction() {
        return _detectDirection(el2, this.options);
      },
      ghostClass: "sortable-ghost",
      chosenClass: "sortable-chosen",
      dragClass: "sortable-drag",
      ignore: "a, img",
      filter: null,
      preventOnFilter: true,
      animation: 0,
      easing: null,
      setData: function setData(dataTransfer, dragEl2) {
        dataTransfer.setData("Text", dragEl2.textContent);
      },
      dropBubble: false,
      dragoverBubble: false,
      dataIdAttr: "data-id",
      delay: 0,
      delayOnTouchOnly: false,
      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
      forceFallback: false,
      fallbackClass: "sortable-fallback",
      fallbackOnBody: false,
      fallbackTolerance: 0,
      fallbackOffset: {
        x: 0,
        y: 0
      },
      // Disabled on Safari: #1571; Enabled on Safari IOS: #2244
      supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && (!Safari || IOS),
      emptyInsertThreshold: 5
    };
    PluginManager.initializePlugins(this, el2, defaults3);
    for (var name in defaults3) {
      !(name in options) && (options[name] = defaults3[name]);
    }
    _prepareGroup(options);
    for (var fn2 in this) {
      if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
        this[fn2] = this[fn2].bind(this);
      }
    }
    this.nativeDraggable = options.forceFallback ? false : supportDraggable;
    if (this.nativeDraggable) {
      this.options.touchStartThreshold = 1;
    }
    if (options.supportPointer) {
      on(el2, "pointerdown", this._onTapStart);
    } else {
      on(el2, "mousedown", this._onTapStart);
      on(el2, "touchstart", this._onTapStart);
    }
    if (this.nativeDraggable) {
      on(el2, "dragover", this);
      on(el2, "dragenter", this);
    }
    sortables.push(this.el);
    options.store && options.store.get && this.sort(options.store.get(this) || []);
    _extends(this, AnimationStateManager());
  }
  Sortable.prototype = /** @lends Sortable.prototype */
  {
    constructor: Sortable,
    _isOutsideThisEl: function _isOutsideThisEl(target) {
      if (!this.el.contains(target) && target !== this.el) {
        lastTarget = null;
      }
    },
    _getDirection: function _getDirection(evt, target) {
      return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
    },
    _onTapStart: function _onTapStart(evt) {
      if (!evt.cancelable)
        return;
      var _this = this, el2 = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
      _saveInputCheckedState(el2);
      if (dragEl) {
        return;
      }
      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
        return;
      }
      if (originalTarget.isContentEditable) {
        return;
      }
      if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
        return;
      }
      target = closest(target, options.draggable, el2, false);
      if (target && target.animated) {
        return;
      }
      if (lastDownEl === target) {
        return;
      }
      oldIndex = index2(target);
      oldDraggableIndex = index2(target, options.draggable);
      if (typeof filter === "function") {
        if (filter.call(this, evt, target, this)) {
          _dispatchEvent({
            sortable: _this,
            rootEl: originalTarget,
            name: "filter",
            targetEl: target,
            toEl: el2,
            fromEl: el2
          });
          pluginEvent2("filter", _this, {
            evt
          });
          preventOnFilter && evt.preventDefault();
          return;
        }
      } else if (filter) {
        filter = filter.split(",").some(function(criteria) {
          criteria = closest(originalTarget, criteria.trim(), el2, false);
          if (criteria) {
            _dispatchEvent({
              sortable: _this,
              rootEl: criteria,
              name: "filter",
              targetEl: target,
              fromEl: el2,
              toEl: el2
            });
            pluginEvent2("filter", _this, {
              evt
            });
            return true;
          }
        });
        if (filter) {
          preventOnFilter && evt.preventDefault();
          return;
        }
      }
      if (options.handle && !closest(originalTarget, options.handle, el2, false)) {
        return;
      }
      this._prepareDragStart(evt, touch, target);
    },
    _prepareDragStart: function _prepareDragStart(evt, touch, target) {
      var _this = this, el2 = _this.el, options = _this.options, ownerDocument = el2.ownerDocument, dragStartFn;
      if (target && !dragEl && target.parentNode === el2) {
        var dragRect = getRect(target);
        rootEl = el2;
        dragEl = target;
        parentEl = dragEl.parentNode;
        nextEl = dragEl.nextSibling;
        lastDownEl = target;
        activeGroup = options.group;
        Sortable.dragged = dragEl;
        tapEvt = {
          target: dragEl,
          clientX: (touch || evt).clientX,
          clientY: (touch || evt).clientY
        };
        tapDistanceLeft = tapEvt.clientX - dragRect.left;
        tapDistanceTop = tapEvt.clientY - dragRect.top;
        this._lastX = (touch || evt).clientX;
        this._lastY = (touch || evt).clientY;
        dragEl.style["will-change"] = "all";
        dragStartFn = function dragStartFn2() {
          pluginEvent2("delayEnded", _this, {
            evt
          });
          if (Sortable.eventCanceled) {
            _this._onDrop();
            return;
          }
          _this._disableDelayedDragEvents();
          if (!FireFox && _this.nativeDraggable) {
            dragEl.draggable = true;
          }
          _this._triggerDragStart(evt, touch);
          _dispatchEvent({
            sortable: _this,
            name: "choose",
            originalEvent: evt
          });
          toggleClass(dragEl, options.chosenClass, true);
        };
        options.ignore.split(",").forEach(function(criteria) {
          find(dragEl, criteria.trim(), _disableDraggable);
        });
        on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
        if (options.supportPointer) {
          on(ownerDocument, "pointerup", _this._onDrop);
          !this.nativeDraggable && on(ownerDocument, "pointercancel", _this._onDrop);
        } else {
          on(ownerDocument, "mouseup", _this._onDrop);
          on(ownerDocument, "touchend", _this._onDrop);
          on(ownerDocument, "touchcancel", _this._onDrop);
        }
        if (FireFox && this.nativeDraggable) {
          this.options.touchStartThreshold = 4;
          dragEl.draggable = true;
        }
        pluginEvent2("delayStart", this, {
          evt
        });
        if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
          if (Sortable.eventCanceled) {
            this._onDrop();
            return;
          }
          if (options.supportPointer) {
            on(ownerDocument, "pointerup", _this._disableDelayedDrag);
            on(ownerDocument, "pointercancel", _this._disableDelayedDrag);
          } else {
            on(ownerDocument, "mouseup", _this._disableDelayedDrag);
            on(ownerDocument, "touchend", _this._disableDelayedDrag);
            on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
          }
          on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
          on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
          options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
        } else {
          dragStartFn();
        }
      }
    },
    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
      var touch = e.touches ? e.touches[0] : e;
      if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
        this._disableDelayedDrag();
      }
    },
    _disableDelayedDrag: function _disableDelayedDrag() {
      dragEl && _disableDraggable(dragEl);
      clearTimeout(this._dragStartTimer);
      this._disableDelayedDragEvents();
    },
    _disableDelayedDragEvents: function _disableDelayedDragEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, "mouseup", this._disableDelayedDrag);
      off(ownerDocument, "touchend", this._disableDelayedDrag);
      off(ownerDocument, "touchcancel", this._disableDelayedDrag);
      off(ownerDocument, "pointerup", this._disableDelayedDrag);
      off(ownerDocument, "pointercancel", this._disableDelayedDrag);
      off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
      off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
      off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
    },
    _triggerDragStart: function _triggerDragStart(evt, touch) {
      touch = touch || evt.pointerType == "touch" && evt;
      if (!this.nativeDraggable || touch) {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._onTouchMove);
        } else if (touch) {
          on(document, "touchmove", this._onTouchMove);
        } else {
          on(document, "mousemove", this._onTouchMove);
        }
      } else {
        on(dragEl, "dragend", this);
        on(rootEl, "dragstart", this._onDragStart);
      }
      try {
        if (document.selection) {
          _nextTick(function() {
            document.selection.empty();
          });
        } else {
          window.getSelection().removeAllRanges();
        }
      } catch (err) {
      }
    },
    _dragStarted: function _dragStarted(fallback, evt) {
      awaitingDragStarted = false;
      if (rootEl && dragEl) {
        pluginEvent2("dragStarted", this, {
          evt
        });
        if (this.nativeDraggable) {
          on(document, "dragover", _checkOutsideTargetEl);
        }
        var options = this.options;
        !fallback && toggleClass(dragEl, options.dragClass, false);
        toggleClass(dragEl, options.ghostClass, true);
        Sortable.active = this;
        fallback && this._appendGhost();
        _dispatchEvent({
          sortable: this,
          name: "start",
          originalEvent: evt
        });
      } else {
        this._nulling();
      }
    },
    _emulateDragOver: function _emulateDragOver() {
      if (touchEvt) {
        this._lastX = touchEvt.clientX;
        this._lastY = touchEvt.clientY;
        _hideGhostForTarget();
        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        var parent = target;
        while (target && target.shadowRoot) {
          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          if (target === parent)
            break;
          parent = target;
        }
        dragEl.parentNode[expando]._isOutsideThisEl(target);
        if (parent) {
          do {
            if (parent[expando]) {
              var inserted = void 0;
              inserted = parent[expando]._onDragOver({
                clientX: touchEvt.clientX,
                clientY: touchEvt.clientY,
                target,
                rootEl: parent
              });
              if (inserted && !this.options.dragoverBubble) {
                break;
              }
            }
            target = parent;
          } while (parent = getParentOrHost(parent));
        }
        _unhideGhostForTarget();
      }
    },
    _onTouchMove: function _onTouchMove(evt) {
      if (tapEvt) {
        var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
        if (!Sortable.active && !awaitingDragStarted) {
          if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
            return;
          }
          this._onDragStart(evt, true);
        }
        if (ghostEl) {
          if (ghostMatrix) {
            ghostMatrix.e += dx - (lastDx || 0);
            ghostMatrix.f += dy - (lastDy || 0);
          } else {
            ghostMatrix = {
              a: 1,
              b: 0,
              c: 0,
              d: 1,
              e: dx,
              f: dy
            };
          }
          var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
          css(ghostEl, "webkitTransform", cssMatrix);
          css(ghostEl, "mozTransform", cssMatrix);
          css(ghostEl, "msTransform", cssMatrix);
          css(ghostEl, "transform", cssMatrix);
          lastDx = dx;
          lastDy = dy;
          touchEvt = touch;
        }
        evt.cancelable && evt.preventDefault();
      }
    },
    _appendGhost: function _appendGhost() {
      if (!ghostEl) {
        var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
        if (PositionGhostAbsolutely) {
          ghostRelativeParent = container;
          while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
            ghostRelativeParent = ghostRelativeParent.parentNode;
          }
          if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
            if (ghostRelativeParent === document)
              ghostRelativeParent = getWindowScrollingElement();
            rect.top += ghostRelativeParent.scrollTop;
            rect.left += ghostRelativeParent.scrollLeft;
          } else {
            ghostRelativeParent = getWindowScrollingElement();
          }
          ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
        }
        ghostEl = dragEl.cloneNode(true);
        toggleClass(ghostEl, options.ghostClass, false);
        toggleClass(ghostEl, options.fallbackClass, true);
        toggleClass(ghostEl, options.dragClass, true);
        css(ghostEl, "transition", "");
        css(ghostEl, "transform", "");
        css(ghostEl, "box-sizing", "border-box");
        css(ghostEl, "margin", 0);
        css(ghostEl, "top", rect.top);
        css(ghostEl, "left", rect.left);
        css(ghostEl, "width", rect.width);
        css(ghostEl, "height", rect.height);
        css(ghostEl, "opacity", "0.8");
        css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
        css(ghostEl, "zIndex", "100000");
        css(ghostEl, "pointerEvents", "none");
        Sortable.ghost = ghostEl;
        container.appendChild(ghostEl);
        css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
      }
    },
    _onDragStart: function _onDragStart(evt, fallback) {
      var _this = this;
      var dataTransfer = evt.dataTransfer;
      var options = _this.options;
      pluginEvent2("dragStart", this, {
        evt
      });
      if (Sortable.eventCanceled) {
        this._onDrop();
        return;
      }
      pluginEvent2("setupClone", this);
      if (!Sortable.eventCanceled) {
        cloneEl = clone4(dragEl);
        cloneEl.removeAttribute("id");
        cloneEl.draggable = false;
        cloneEl.style["will-change"] = "";
        this._hideClone();
        toggleClass(cloneEl, this.options.chosenClass, false);
        Sortable.clone = cloneEl;
      }
      _this.cloneId = _nextTick(function() {
        pluginEvent2("clone", _this);
        if (Sortable.eventCanceled)
          return;
        if (!_this.options.removeCloneOnHide) {
          rootEl.insertBefore(cloneEl, dragEl);
        }
        _this._hideClone();
        _dispatchEvent({
          sortable: _this,
          name: "clone"
        });
      });
      !fallback && toggleClass(dragEl, options.dragClass, true);
      if (fallback) {
        ignoreNextClick = true;
        _this._loopId = setInterval(_this._emulateDragOver, 50);
      } else {
        off(document, "mouseup", _this._onDrop);
        off(document, "touchend", _this._onDrop);
        off(document, "touchcancel", _this._onDrop);
        if (dataTransfer) {
          dataTransfer.effectAllowed = "move";
          options.setData && options.setData.call(_this, dataTransfer, dragEl);
        }
        on(document, "drop", _this);
        css(dragEl, "transform", "translateZ(0)");
      }
      awaitingDragStarted = true;
      _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
      on(document, "selectstart", _this);
      moved = true;
      window.getSelection().removeAllRanges();
      if (Safari) {
        css(document.body, "user-select", "none");
      }
    },
    // Returns true - if no further action is needed (either inserted or another condition)
    _onDragOver: function _onDragOver(evt) {
      var el2 = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
      if (_silent)
        return;
      function dragOverEvent(name, extra) {
        pluginEvent2(name, _this, _objectSpread2({
          evt,
          isOwner,
          axis: vertical ? "vertical" : "horizontal",
          revert,
          dragRect,
          targetRect,
          canSort,
          fromSortable,
          target,
          completed,
          onMove: function onMove(target2, after2) {
            return _onMove(rootEl, el2, dragEl, dragRect, target2, getRect(target2), evt, after2);
          },
          changed
        }, extra));
      }
      function capture() {
        dragOverEvent("dragOverAnimationCapture");
        _this.captureAnimationState();
        if (_this !== fromSortable) {
          fromSortable.captureAnimationState();
        }
      }
      function completed(insertion) {
        dragOverEvent("dragOverCompleted", {
          insertion
        });
        if (insertion) {
          if (isOwner) {
            activeSortable._hideClone();
          } else {
            activeSortable._showClone(_this);
          }
          if (_this !== fromSortable) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
            toggleClass(dragEl, options.ghostClass, true);
          }
          if (putSortable !== _this && _this !== Sortable.active) {
            putSortable = _this;
          } else if (_this === Sortable.active && putSortable) {
            putSortable = null;
          }
          if (fromSortable === _this) {
            _this._ignoreWhileAnimating = target;
          }
          _this.animateAll(function() {
            dragOverEvent("dragOverAnimationComplete");
            _this._ignoreWhileAnimating = null;
          });
          if (_this !== fromSortable) {
            fromSortable.animateAll();
            fromSortable._ignoreWhileAnimating = null;
          }
        }
        if (target === dragEl && !dragEl.animated || target === el2 && !target.animated) {
          lastTarget = null;
        }
        if (!options.dragoverBubble && !evt.rootEl && target !== document) {
          dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
          !insertion && nearestEmptyInsertDetectEvent(evt);
        }
        !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
        return completedFired = true;
      }
      function changed() {
        newIndex = index2(dragEl);
        newDraggableIndex = index2(dragEl, options.draggable);
        _dispatchEvent({
          sortable: _this,
          name: "change",
          toEl: el2,
          newIndex,
          newDraggableIndex,
          originalEvent: evt
        });
      }
      if (evt.preventDefault !== void 0) {
        evt.cancelable && evt.preventDefault();
      }
      target = closest(target, options.draggable, el2, true);
      dragOverEvent("dragOver");
      if (Sortable.eventCanceled)
        return completedFired;
      if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
        return completed(false);
      }
      ignoreNextClick = false;
      if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
        vertical = this._getDirection(evt, target) === "vertical";
        dragRect = getRect(dragEl);
        dragOverEvent("dragOverValid");
        if (Sortable.eventCanceled)
          return completedFired;
        if (revert) {
          parentEl = rootEl;
          capture();
          this._hideClone();
          dragOverEvent("revert");
          if (!Sortable.eventCanceled) {
            if (nextEl) {
              rootEl.insertBefore(dragEl, nextEl);
            } else {
              rootEl.appendChild(dragEl);
            }
          }
          return completed(true);
        }
        var elLastChild = lastChild(el2, options.draggable);
        if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
          if (elLastChild === dragEl) {
            return completed(false);
          }
          if (elLastChild && el2 === evt.target) {
            target = elLastChild;
          }
          if (target) {
            targetRect = getRect(target);
          }
          if (_onMove(rootEl, el2, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
            capture();
            if (elLastChild && elLastChild.nextSibling) {
              el2.insertBefore(dragEl, elLastChild.nextSibling);
            } else {
              el2.appendChild(dragEl);
            }
            parentEl = el2;
            changed();
            return completed(true);
          }
        } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
          var firstChild = getChild(el2, 0, options, true);
          if (firstChild === dragEl) {
            return completed(false);
          }
          target = firstChild;
          targetRect = getRect(target);
          if (_onMove(rootEl, el2, dragEl, dragRect, target, targetRect, evt, false) !== false) {
            capture();
            el2.insertBefore(dragEl, firstChild);
            parentEl = el2;
            changed();
            return completed(true);
          }
        } else if (target.parentNode === el2) {
          targetRect = getRect(target);
          var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el2, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
          if (lastTarget !== target) {
            targetBeforeFirstSwap = targetRect[side1];
            pastFirstInvertThresh = false;
            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
          }
          direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
          var sibling;
          if (direction !== 0) {
            var dragIndex = index2(dragEl);
            do {
              dragIndex -= direction;
              sibling = parentEl.children[dragIndex];
            } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
          }
          if (direction === 0 || sibling === target) {
            return completed(false);
          }
          lastTarget = target;
          lastDirection = direction;
          var nextSibling = target.nextElementSibling, after = false;
          after = direction === 1;
          var moveVector = _onMove(rootEl, el2, dragEl, dragRect, target, targetRect, evt, after);
          if (moveVector !== false) {
            if (moveVector === 1 || moveVector === -1) {
              after = moveVector === 1;
            }
            _silent = true;
            setTimeout(_unsilent, 30);
            capture();
            if (after && !nextSibling) {
              el2.appendChild(dragEl);
            } else {
              target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
            }
            if (scrolledPastTop) {
              scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
            }
            parentEl = dragEl.parentNode;
            if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
              targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
            }
            changed();
            return completed(true);
          }
        }
        if (el2.contains(dragEl)) {
          return completed(false);
        }
      }
      return false;
    },
    _ignoreWhileAnimating: null,
    _offMoveEvents: function _offMoveEvents() {
      off(document, "mousemove", this._onTouchMove);
      off(document, "touchmove", this._onTouchMove);
      off(document, "pointermove", this._onTouchMove);
      off(document, "dragover", nearestEmptyInsertDetectEvent);
      off(document, "mousemove", nearestEmptyInsertDetectEvent);
      off(document, "touchmove", nearestEmptyInsertDetectEvent);
    },
    _offUpEvents: function _offUpEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, "mouseup", this._onDrop);
      off(ownerDocument, "touchend", this._onDrop);
      off(ownerDocument, "pointerup", this._onDrop);
      off(ownerDocument, "pointercancel", this._onDrop);
      off(ownerDocument, "touchcancel", this._onDrop);
      off(document, "selectstart", this);
    },
    _onDrop: function _onDrop(evt) {
      var el2 = this.el, options = this.options;
      newIndex = index2(dragEl);
      newDraggableIndex = index2(dragEl, options.draggable);
      pluginEvent2("drop", this, {
        evt
      });
      parentEl = dragEl && dragEl.parentNode;
      newIndex = index2(dragEl);
      newDraggableIndex = index2(dragEl, options.draggable);
      if (Sortable.eventCanceled) {
        this._nulling();
        return;
      }
      awaitingDragStarted = false;
      isCircumstantialInvert = false;
      pastFirstInvertThresh = false;
      clearInterval(this._loopId);
      clearTimeout(this._dragStartTimer);
      _cancelNextTick(this.cloneId);
      _cancelNextTick(this._dragStartId);
      if (this.nativeDraggable) {
        off(document, "drop", this);
        off(el2, "dragstart", this._onDragStart);
      }
      this._offMoveEvents();
      this._offUpEvents();
      if (Safari) {
        css(document.body, "user-select", "");
      }
      css(dragEl, "transform", "");
      if (evt) {
        if (moved) {
          evt.cancelable && evt.preventDefault();
          !options.dropBubble && evt.stopPropagation();
        }
        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
        }
        if (dragEl) {
          if (this.nativeDraggable) {
            off(dragEl, "dragend", this);
          }
          _disableDraggable(dragEl);
          dragEl.style["will-change"] = "";
          if (moved && !awaitingDragStarted) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
          }
          toggleClass(dragEl, this.options.chosenClass, false);
          _dispatchEvent({
            sortable: this,
            name: "unchoose",
            toEl: parentEl,
            newIndex: null,
            newDraggableIndex: null,
            originalEvent: evt
          });
          if (rootEl !== parentEl) {
            if (newIndex >= 0) {
              _dispatchEvent({
                rootEl: parentEl,
                name: "add",
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "remove",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                rootEl: parentEl,
                name: "sort",
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
            putSortable && putSortable.save();
          } else {
            if (newIndex !== oldIndex) {
              if (newIndex >= 0) {
                _dispatchEvent({
                  sortable: this,
                  name: "update",
                  toEl: parentEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  sortable: this,
                  name: "sort",
                  toEl: parentEl,
                  originalEvent: evt
                });
              }
            }
          }
          if (Sortable.active) {
            if (newIndex == null || newIndex === -1) {
              newIndex = oldIndex;
              newDraggableIndex = oldDraggableIndex;
            }
            _dispatchEvent({
              sortable: this,
              name: "end",
              toEl: parentEl,
              originalEvent: evt
            });
            this.save();
          }
        }
      }
      this._nulling();
    },
    _nulling: function _nulling() {
      pluginEvent2("nulling", this);
      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
      savedInputChecked.forEach(function(el2) {
        el2.checked = true;
      });
      savedInputChecked.length = lastDx = lastDy = 0;
    },
    handleEvent: function handleEvent(evt) {
      switch (evt.type) {
        case "drop":
        case "dragend":
          this._onDrop(evt);
          break;
        case "dragenter":
        case "dragover":
          if (dragEl) {
            this._onDragOver(evt);
            _globalDragOver(evt);
          }
          break;
        case "selectstart":
          evt.preventDefault();
          break;
      }
    },
    /**
     * Serializes the item into an array of string.
     * @returns {String[]}
     */
    toArray: function toArray() {
      var order2 = [], el2, children = this.el.children, i = 0, n = children.length, options = this.options;
      for (; i < n; i++) {
        el2 = children[i];
        if (closest(el2, options.draggable, this.el, false)) {
          order2.push(el2.getAttribute(options.dataIdAttr) || _generateId(el2));
        }
      }
      return order2;
    },
    /**
     * Sorts the elements according to the array.
     * @param  {String[]}  order  order of the items
     */
    sort: function sort(order2, useAnimation) {
      var items = {}, rootEl2 = this.el;
      this.toArray().forEach(function(id, i) {
        var el2 = rootEl2.children[i];
        if (closest(el2, this.options.draggable, rootEl2, false)) {
          items[id] = el2;
        }
      }, this);
      useAnimation && this.captureAnimationState();
      order2.forEach(function(id) {
        if (items[id]) {
          rootEl2.removeChild(items[id]);
          rootEl2.appendChild(items[id]);
        }
      });
      useAnimation && this.animateAll();
    },
    /**
     * Save the current sorting
     */
    save: function save() {
      var store = this.options.store;
      store && store.set && store.set(this);
    },
    /**
     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
     * @param   {HTMLElement}  el
     * @param   {String}       [selector]  default: `options.draggable`
     * @returns {HTMLElement|null}
     */
    closest: function closest$1(el2, selector) {
      return closest(el2, selector || this.options.draggable, this.el, false);
    },
    /**
     * Set/get option
     * @param   {string} name
     * @param   {*}      [value]
     * @returns {*}
     */
    option: function option(name, value) {
      var options = this.options;
      if (value === void 0) {
        return options[name];
      } else {
        var modifiedValue = PluginManager.modifyOption(this, name, value);
        if (typeof modifiedValue !== "undefined") {
          options[name] = modifiedValue;
        } else {
          options[name] = value;
        }
        if (name === "group") {
          _prepareGroup(options);
        }
      }
    },
    /**
     * Destroy
     */
    destroy: function destroy() {
      pluginEvent2("destroy", this);
      var el2 = this.el;
      el2[expando] = null;
      off(el2, "mousedown", this._onTapStart);
      off(el2, "touchstart", this._onTapStart);
      off(el2, "pointerdown", this._onTapStart);
      if (this.nativeDraggable) {
        off(el2, "dragover", this);
        off(el2, "dragenter", this);
      }
      Array.prototype.forEach.call(el2.querySelectorAll("[draggable]"), function(el3) {
        el3.removeAttribute("draggable");
      });
      this._onDrop();
      this._disableDelayedDragEvents();
      sortables.splice(sortables.indexOf(this.el), 1);
      this.el = el2 = null;
    },
    _hideClone: function _hideClone() {
      if (!cloneHidden) {
        pluginEvent2("hideClone", this);
        if (Sortable.eventCanceled)
          return;
        css(cloneEl, "display", "none");
        if (this.options.removeCloneOnHide && cloneEl.parentNode) {
          cloneEl.parentNode.removeChild(cloneEl);
        }
        cloneHidden = true;
      }
    },
    _showClone: function _showClone(putSortable2) {
      if (putSortable2.lastPutMode !== "clone") {
        this._hideClone();
        return;
      }
      if (cloneHidden) {
        pluginEvent2("showClone", this);
        if (Sortable.eventCanceled)
          return;
        if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
          rootEl.insertBefore(cloneEl, dragEl);
        } else if (nextEl) {
          rootEl.insertBefore(cloneEl, nextEl);
        } else {
          rootEl.appendChild(cloneEl);
        }
        if (this.options.group.revertClone) {
          this.animate(dragEl, cloneEl);
        }
        css(cloneEl, "display", "");
        cloneHidden = false;
      }
    }
  };
  function _globalDragOver(evt) {
    if (evt.dataTransfer) {
      evt.dataTransfer.dropEffect = "move";
    }
    evt.cancelable && evt.preventDefault();
  }
  function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
    var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent("move", {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent("Event");
      evt.initEvent("move", true, true);
    }
    evt.to = toEl;
    evt.from = fromEl;
    evt.dragged = dragEl2;
    evt.draggedRect = dragRect;
    evt.related = targetEl || toEl;
    evt.relatedRect = targetRect || getRect(toEl);
    evt.willInsertAfter = willInsertAfter;
    evt.originalEvent = originalEvent;
    fromEl.dispatchEvent(evt);
    if (onMoveFn) {
      retVal = onMoveFn.call(sortable, evt, originalEvent);
    }
    return retVal;
  }
  function _disableDraggable(el2) {
    el2.draggable = false;
  }
  function _unsilent() {
    _silent = false;
  }
  function _ghostIsFirst(evt, vertical, sortable) {
    var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
    var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
    var spacer = 10;
    return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
  }
  function _ghostIsLast(evt, vertical, sortable) {
    var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
    var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
    var spacer = 10;
    return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
  }
  function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
    var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
    if (!invertSwap) {
      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
        if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
          pastFirstInvertThresh = true;
        }
        if (!pastFirstInvertThresh) {
          if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
            return -lastDirection;
          }
        } else {
          invert = true;
        }
      } else {
        if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
          return _getInsertDirection(target);
        }
      }
    }
    invert = invert || invertSwap;
    if (invert) {
      if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
      }
    }
    return 0;
  }
  function _getInsertDirection(target) {
    if (index2(dragEl) < index2(target)) {
      return 1;
    } else {
      return -1;
    }
  }
  function _generateId(el2) {
    var str = el2.tagName + el2.className + el2.src + el2.href + el2.textContent, i = str.length, sum = 0;
    while (i--) {
      sum += str.charCodeAt(i);
    }
    return sum.toString(36);
  }
  function _saveInputCheckedState(root) {
    savedInputChecked.length = 0;
    var inputs = root.getElementsByTagName("input");
    var idx = inputs.length;
    while (idx--) {
      var el2 = inputs[idx];
      el2.checked && savedInputChecked.push(el2);
    }
  }
  function _nextTick(fn2) {
    return setTimeout(fn2, 0);
  }
  function _cancelNextTick(id) {
    return clearTimeout(id);
  }
  if (documentExists) {
    on(document, "touchmove", function(evt) {
      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
        evt.preventDefault();
      }
    });
  }
  Sortable.utils = {
    on,
    off,
    css,
    find,
    is: function is(el2, selector) {
      return !!closest(el2, selector, el2, false);
    },
    extend,
    throttle,
    closest,
    toggleClass,
    clone: clone4,
    index: index2,
    nextTick: _nextTick,
    cancelNextTick: _cancelNextTick,
    detectDirection: _detectDirection,
    getChild,
    expando
  };
  Sortable.get = function(element) {
    return element[expando];
  };
  Sortable.mount = function() {
    for (var _len = arguments.length, plugins3 = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins3[_key] = arguments[_key];
    }
    if (plugins3[0].constructor === Array)
      plugins3 = plugins3[0];
    plugins3.forEach(function(plugin) {
      if (!plugin.prototype || !plugin.prototype.constructor) {
        throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
      }
      if (plugin.utils)
        Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
      PluginManager.mount(plugin);
    });
  };
  Sortable.create = function(el2, options) {
    return new Sortable(el2, options);
  };
  Sortable.version = version2;
  var autoScrolls = [];
  var scrollEl;
  var scrollRootEl;
  var scrolling = false;
  var lastAutoScrollX;
  var lastAutoScrollY;
  var touchEvt$1;
  var pointerElemChangedInterval;
  function AutoScrollPlugin() {
    function AutoScroll() {
      this.defaults = {
        scroll: true,
        forceAutoScrollFallback: false,
        scrollSensitivity: 30,
        scrollSpeed: 10,
        bubbleScroll: true
      };
      for (var fn2 in this) {
        if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
          this[fn2] = this[fn2].bind(this);
        }
      }
    }
    AutoScroll.prototype = {
      dragStarted: function dragStarted(_ref) {
        var originalEvent = _ref.originalEvent;
        if (this.sortable.nativeDraggable) {
          on(document, "dragover", this._handleAutoScroll);
        } else {
          if (this.options.supportPointer) {
            on(document, "pointermove", this._handleFallbackAutoScroll);
          } else if (originalEvent.touches) {
            on(document, "touchmove", this._handleFallbackAutoScroll);
          } else {
            on(document, "mousemove", this._handleFallbackAutoScroll);
          }
        }
      },
      dragOverCompleted: function dragOverCompleted(_ref2) {
        var originalEvent = _ref2.originalEvent;
        if (!this.options.dragOverBubble && !originalEvent.rootEl) {
          this._handleAutoScroll(originalEvent);
        }
      },
      drop: function drop3() {
        if (this.sortable.nativeDraggable) {
          off(document, "dragover", this._handleAutoScroll);
        } else {
          off(document, "pointermove", this._handleFallbackAutoScroll);
          off(document, "touchmove", this._handleFallbackAutoScroll);
          off(document, "mousemove", this._handleFallbackAutoScroll);
        }
        clearPointerElemChangedInterval();
        clearAutoScrolls();
        cancelThrottle();
      },
      nulling: function nulling() {
        touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
        autoScrolls.length = 0;
      },
      _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
        this._handleAutoScroll(evt, true);
      },
      _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
        var _this = this;
        var x = (evt.touches ? evt.touches[0] : evt).clientX, y3 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y3);
        touchEvt$1 = evt;
        if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
          autoScroll(evt, this.options, elem, fallback);
          var ogElemScroller = getParentAutoScrollElement(elem, true);
          if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y3 !== lastAutoScrollY)) {
            pointerElemChangedInterval && clearPointerElemChangedInterval();
            pointerElemChangedInterval = setInterval(function() {
              var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y3), true);
              if (newElem !== ogElemScroller) {
                ogElemScroller = newElem;
                clearAutoScrolls();
              }
              autoScroll(evt, _this.options, newElem, fallback);
            }, 10);
            lastAutoScrollX = x;
            lastAutoScrollY = y3;
          }
        } else {
          if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
            clearAutoScrolls();
            return;
          }
          autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
        }
      }
    };
    return _extends(AutoScroll, {
      pluginName: "scroll",
      initializeByDefault: true
    });
  }
  function clearAutoScrolls() {
    autoScrolls.forEach(function(autoScroll2) {
      clearInterval(autoScroll2.pid);
    });
    autoScrolls = [];
  }
  function clearPointerElemChangedInterval() {
    clearInterval(pointerElemChangedInterval);
  }
  var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
    if (!options.scroll)
      return;
    var x = (evt.touches ? evt.touches[0] : evt).clientX, y3 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
    var scrollThisInstance = false, scrollCustomFn;
    if (scrollRootEl !== rootEl2) {
      scrollRootEl = rootEl2;
      clearAutoScrolls();
      scrollEl = options.scroll;
      scrollCustomFn = options.scrollFn;
      if (scrollEl === true) {
        scrollEl = getParentAutoScrollElement(rootEl2, true);
      }
    }
    var layersOut = 0;
    var currentParent = scrollEl;
    do {
      var el2 = currentParent, rect = getRect(el2), top3 = rect.top, bottom3 = rect.bottom, left2 = rect.left, right2 = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el2.scrollWidth, scrollHeight = el2.scrollHeight, elCSS = css(el2), scrollPosX = el2.scrollLeft, scrollPosY = el2.scrollTop;
      if (el2 === winScroller) {
        canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
        canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
      } else {
        canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
        canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
      }
      var vx = canScrollX && (Math.abs(right2 - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left2 - x) <= sens && !!scrollPosX);
      var vy = canScrollY && (Math.abs(bottom3 - y3) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top3 - y3) <= sens && !!scrollPosY);
      if (!autoScrolls[layersOut]) {
        for (var i = 0; i <= layersOut; i++) {
          if (!autoScrolls[i]) {
            autoScrolls[i] = {};
          }
        }
      }
      if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el2) {
        autoScrolls[layersOut].el = el2;
        autoScrolls[layersOut].vx = vx;
        autoScrolls[layersOut].vy = vy;
        clearInterval(autoScrolls[layersOut].pid);
        if (vx != 0 || vy != 0) {
          scrollThisInstance = true;
          autoScrolls[layersOut].pid = setInterval(function() {
            if (isFallback && this.layer === 0) {
              Sortable.active._onTouchMove(touchEvt$1);
            }
            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
            if (typeof scrollCustomFn === "function") {
              if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
                return;
              }
            }
            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
          }.bind({
            layer: layersOut
          }), 24);
        }
      }
      layersOut++;
    } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
    scrolling = scrollThisInstance;
  }, 30);
  var drop = function drop2(_ref) {
    var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
    if (!originalEvent)
      return;
    var toSortable = putSortable2 || activeSortable;
    hideGhostForTarget();
    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
    var target = document.elementFromPoint(touch.clientX, touch.clientY);
    unhideGhostForTarget();
    if (toSortable && !toSortable.el.contains(target)) {
      dispatchSortableEvent("spill");
      this.onSpill({
        dragEl: dragEl2,
        putSortable: putSortable2
      });
    }
  };
  function Revert() {
  }
  Revert.prototype = {
    startIndex: null,
    dragStart: function dragStart(_ref2) {
      var oldDraggableIndex2 = _ref2.oldDraggableIndex;
      this.startIndex = oldDraggableIndex2;
    },
    onSpill: function onSpill(_ref3) {
      var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
      this.sortable.captureAnimationState();
      if (putSortable2) {
        putSortable2.captureAnimationState();
      }
      var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
      if (nextSibling) {
        this.sortable.el.insertBefore(dragEl2, nextSibling);
      } else {
        this.sortable.el.appendChild(dragEl2);
      }
      this.sortable.animateAll();
      if (putSortable2) {
        putSortable2.animateAll();
      }
    },
    drop
  };
  _extends(Revert, {
    pluginName: "revertOnSpill"
  });
  function Remove() {
  }
  Remove.prototype = {
    onSpill: function onSpill2(_ref4) {
      var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
      var parentSortable = putSortable2 || this.sortable;
      parentSortable.captureAnimationState();
      dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
      parentSortable.animateAll();
    },
    drop
  };
  _extends(Remove, {
    pluginName: "removeOnSpill"
  });
  Sortable.mount(new AutoScrollPlugin());
  Sortable.mount(Remove, Revert);
  var sortable_esm_default = Sortable;

  // js/drag_hook.js
  var DragHook = {
    mounted() {
      this.sortable = sortable_esm_default.create(this.el, {
        animation: 150,
        onEnd: (event) => {
          let ids = Array.from(this.el.children).map((el2) => {
            return el2.dataset.id;
          });
          this.pushEvent("reorder", { ids });
        }
      });
    },
    destroyed() {
      if (this.sortable) {
        this.sortable.destroy();
      }
    }
  };
  var drag_hook_default = DragHook;

  // node_modules/flowbite/lib/esm/dom/events.js
  var Events = (
    /** @class */
    function() {
      function Events2(eventType, eventFunctions) {
        if (eventFunctions === void 0) {
          eventFunctions = [];
        }
        this._eventType = eventType;
        this._eventFunctions = eventFunctions;
      }
      Events2.prototype.init = function() {
        var _this = this;
        this._eventFunctions.forEach(function(eventFunction) {
          if (typeof window !== "undefined") {
            window.addEventListener(_this._eventType, eventFunction);
          }
        });
      };
      return Events2;
    }()
  );
  var events_default = Events;

  // node_modules/flowbite/lib/esm/dom/instances.js
  var Instances = (
    /** @class */
    function() {
      function Instances2() {
        this._instances = {
          Accordion: {},
          Carousel: {},
          Collapse: {},
          Dial: {},
          Dismiss: {},
          Drawer: {},
          Dropdown: {},
          Modal: {},
          Popover: {},
          Tabs: {},
          Tooltip: {},
          InputCounter: {},
          CopyClipboard: {},
          Datepicker: {}
        };
      }
      Instances2.prototype.addInstance = function(component, instance, id, override) {
        if (override === void 0) {
          override = false;
        }
        if (!this._instances[component]) {
          console.warn("Flowbite: Component ".concat(component, " does not exist."));
          return false;
        }
        if (this._instances[component][id] && !override) {
          console.warn("Flowbite: Instance with ID ".concat(id, " already exists."));
          return;
        }
        if (override && this._instances[component][id]) {
          this._instances[component][id].destroyAndRemoveInstance();
        }
        this._instances[component][id ? id : this._generateRandomId()] = instance;
      };
      Instances2.prototype.getAllInstances = function() {
        return this._instances;
      };
      Instances2.prototype.getInstances = function(component) {
        if (!this._instances[component]) {
          console.warn("Flowbite: Component ".concat(component, " does not exist."));
          return false;
        }
        return this._instances[component];
      };
      Instances2.prototype.getInstance = function(component, id) {
        if (!this._componentAndInstanceCheck(component, id)) {
          return;
        }
        if (!this._instances[component][id]) {
          console.warn("Flowbite: Instance with ID ".concat(id, " does not exist."));
          return;
        }
        return this._instances[component][id];
      };
      Instances2.prototype.destroyAndRemoveInstance = function(component, id) {
        if (!this._componentAndInstanceCheck(component, id)) {
          return;
        }
        this.destroyInstanceObject(component, id);
        this.removeInstance(component, id);
      };
      Instances2.prototype.removeInstance = function(component, id) {
        if (!this._componentAndInstanceCheck(component, id)) {
          return;
        }
        delete this._instances[component][id];
      };
      Instances2.prototype.destroyInstanceObject = function(component, id) {
        if (!this._componentAndInstanceCheck(component, id)) {
          return;
        }
        this._instances[component][id].destroy();
      };
      Instances2.prototype.instanceExists = function(component, id) {
        if (!this._instances[component]) {
          return false;
        }
        if (!this._instances[component][id]) {
          return false;
        }
        return true;
      };
      Instances2.prototype._generateRandomId = function() {
        return Math.random().toString(36).substr(2, 9);
      };
      Instances2.prototype._componentAndInstanceCheck = function(component, id) {
        if (!this._instances[component]) {
          console.warn("Flowbite: Component ".concat(component, " does not exist."));
          return false;
        }
        if (!this._instances[component][id]) {
          console.warn("Flowbite: Instance with ID ".concat(id, " does not exist."));
          return false;
        }
        return true;
      };
      return Instances2;
    }()
  );
  var instances2 = new Instances();
  var instances_default = instances2;
  if (typeof window !== "undefined") {
    window.FlowbiteInstances = instances2;
  }

  // node_modules/flowbite/lib/esm/components/accordion/index.js
  var __assign = function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  var Default = {
    alwaysOpen: false,
    activeClasses: "bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white",
    inactiveClasses: "text-gray-500 dark:text-gray-400",
    onOpen: function() {
    },
    onClose: function() {
    },
    onToggle: function() {
    }
  };
  var DefaultInstanceOptions = {
    id: null,
    override: true
  };
  var Accordion = (
    /** @class */
    function() {
      function Accordion2(accordionEl, items, options, instanceOptions) {
        if (accordionEl === void 0) {
          accordionEl = null;
        }
        if (items === void 0) {
          items = [];
        }
        if (options === void 0) {
          options = Default;
        }
        if (instanceOptions === void 0) {
          instanceOptions = DefaultInstanceOptions;
        }
        this._instanceId = instanceOptions.id ? instanceOptions.id : accordionEl.id;
        this._accordionEl = accordionEl;
        this._items = items;
        this._options = __assign(__assign({}, Default), options);
        this._initialized = false;
        this.init();
        instances_default.addInstance("Accordion", this, this._instanceId, instanceOptions.override);
      }
      Accordion2.prototype.init = function() {
        var _this = this;
        if (this._items.length && !this._initialized) {
          this._items.forEach(function(item) {
            if (item.active) {
              _this.open(item.id);
            }
            var clickHandler = function() {
              _this.toggle(item.id);
            };
            item.triggerEl.addEventListener("click", clickHandler);
            item.clickHandler = clickHandler;
          });
          this._initialized = true;
        }
      };
      Accordion2.prototype.destroy = function() {
        if (this._items.length && this._initialized) {
          this._items.forEach(function(item) {
            item.triggerEl.removeEventListener("click", item.clickHandler);
            delete item.clickHandler;
          });
          this._initialized = false;
        }
      };
      Accordion2.prototype.removeInstance = function() {
        instances_default.removeInstance("Accordion", this._instanceId);
      };
      Accordion2.prototype.destroyAndRemoveInstance = function() {
        this.destroy();
        this.removeInstance();
      };
      Accordion2.prototype.getItem = function(id) {
        return this._items.filter(function(item) {
          return item.id === id;
        })[0];
      };
      Accordion2.prototype.open = function(id) {
        var _a, _b;
        var _this = this;
        var item = this.getItem(id);
        if (!this._options.alwaysOpen) {
          this._items.map(function(i) {
            var _a2, _b2;
            if (i !== item) {
              (_a2 = i.triggerEl.classList).remove.apply(_a2, _this._options.activeClasses.split(" "));
              (_b2 = i.triggerEl.classList).add.apply(_b2, _this._options.inactiveClasses.split(" "));
              i.targetEl.classList.add("hidden");
              i.triggerEl.setAttribute("aria-expanded", "false");
              i.active = false;
              if (i.iconEl) {
                i.iconEl.classList.add("rotate-180");
              }
            }
          });
        }
        (_a = item.triggerEl.classList).add.apply(_a, this._options.activeClasses.split(" "));
        (_b = item.triggerEl.classList).remove.apply(_b, this._options.inactiveClasses.split(" "));
        item.triggerEl.setAttribute("aria-expanded", "true");
        item.targetEl.classList.remove("hidden");
        item.active = true;
        if (item.iconEl) {
          item.iconEl.classList.remove("rotate-180");
        }
        this._options.onOpen(this, item);
      };
      Accordion2.prototype.toggle = function(id) {
        var item = this.getItem(id);
        if (item.active) {
          this.close(id);
        } else {
          this.open(id);
        }
        this._options.onToggle(this, item);
      };
      Accordion2.prototype.close = function(id) {
        var _a, _b;
        var item = this.getItem(id);
        (_a = item.triggerEl.classList).remove.apply(_a, this._options.activeClasses.split(" "));
        (_b = item.triggerEl.classList).add.apply(_b, this._options.inactiveClasses.split(" "));
        item.targetEl.classList.add("hidden");
        item.triggerEl.setAttribute("aria-expanded", "false");
        item.active = false;
        if (item.iconEl) {
          item.iconEl.classList.add("rotate-180");
        }
        this._options.onClose(this, item);
      };
      Accordion2.prototype.updateOnOpen = function(callback2) {
        this._options.onOpen = callback2;
      };
      Accordion2.prototype.updateOnClose = function(callback2) {
        this._options.onClose = callback2;
      };
      Accordion2.prototype.updateOnToggle = function(callback2) {
        this._options.onToggle = callback2;
      };
      return Accordion2;
    }()
  );
  function initAccordions() {
    document.querySelectorAll("[data-accordion]").forEach(function($accordionEl) {
      var alwaysOpen = $accordionEl.getAttribute("data-accordion");
      var activeClasses = $accordionEl.getAttribute("data-active-classes");
      var inactiveClasses = $accordionEl.getAttribute("data-inactive-classes");
      var items = [];
      $accordionEl.querySelectorAll("[data-accordion-target]").forEach(function($triggerEl) {
        if ($triggerEl.closest("[data-accordion]") === $accordionEl) {
          var item = {
            id: $triggerEl.getAttribute("data-accordion-target"),
            triggerEl: $triggerEl,
            targetEl: document.querySelector($triggerEl.getAttribute("data-accordion-target")),
            iconEl: $triggerEl.querySelector("[data-accordion-icon]"),
            active: $triggerEl.getAttribute("aria-expanded") === "true" ? true : false
          };
          items.push(item);
        }
      });
      new Accordion($accordionEl, items, {
        alwaysOpen: alwaysOpen === "open" ? true : false,
        activeClasses: activeClasses ? activeClasses : Default.activeClasses,
        inactiveClasses: inactiveClasses ? inactiveClasses : Default.inactiveClasses
      });
    });
  }
  if (typeof window !== "undefined") {
    window.Accordion = Accordion;
    window.initAccordions = initAccordions;
  }

  // node_modules/flowbite/lib/esm/components/collapse/index.js
  var __assign2 = function() {
    __assign2 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign2.apply(this, arguments);
  };
  var Default2 = {
    onCollapse: function() {
    },
    onExpand: function() {
    },
    onToggle: function() {
    }
  };
  var DefaultInstanceOptions2 = {
    id: null,
    override: true
  };
  var Collapse = (
    /** @class */
    function() {
      function Collapse2(targetEl, triggerEl, options, instanceOptions) {
        if (targetEl === void 0) {
          targetEl = null;
        }
        if (triggerEl === void 0) {
          triggerEl = null;
        }
        if (options === void 0) {
          options = Default2;
        }
        if (instanceOptions === void 0) {
          instanceOptions = DefaultInstanceOptions2;
        }
        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
        this._targetEl = targetEl;
        this._triggerEl = triggerEl;
        this._options = __assign2(__assign2({}, Default2), options);
        this._visible = false;
        this._initialized = false;
        this.init();
        instances_default.addInstance("Collapse", this, this._instanceId, instanceOptions.override);
      }
      Collapse2.prototype.init = function() {
        var _this = this;
        if (this._triggerEl && this._targetEl && !this._initialized) {
          if (this._triggerEl.hasAttribute("aria-expanded")) {
            this._visible = this._triggerEl.getAttribute("aria-expanded") === "true";
          } else {
            this._visible = !this._targetEl.classList.contains("hidden");
          }
          this._clickHandler = function() {
            _this.toggle();
          };
          this._triggerEl.addEventListener("click", this._clickHandler);
          this._initialized = true;
        }
      };
      Collapse2.prototype.destroy = function() {
        if (this._triggerEl && this._initialized) {
          this._triggerEl.removeEventListener("click", this._clickHandler);
          this._initialized = false;
        }
      };
      Collapse2.prototype.removeInstance = function() {
        instances_default.removeInstance("Collapse", this._instanceId);
      };
      Collapse2.prototype.destroyAndRemoveInstance = function() {
        this.destroy();
        this.removeInstance();
      };
      Collapse2.prototype.collapse = function() {
        this._targetEl.classList.add("hidden");
        if (this._triggerEl) {
          this._triggerEl.setAttribute("aria-expanded", "false");
        }
        this._visible = false;
        this._options.onCollapse(this);
      };
      Collapse2.prototype.expand = function() {
        this._targetEl.classList.remove("hidden");
        if (this._triggerEl) {
          this._triggerEl.setAttribute("aria-expanded", "true");
        }
        this._visible = true;
        this._options.onExpand(this);
      };
      Collapse2.prototype.toggle = function() {
        if (this._visible) {
          this.collapse();
        } else {
          this.expand();
        }
        this._options.onToggle(this);
      };
      Collapse2.prototype.updateOnCollapse = function(callback2) {
        this._options.onCollapse = callback2;
      };
      Collapse2.prototype.updateOnExpand = function(callback2) {
        this._options.onExpand = callback2;
      };
      Collapse2.prototype.updateOnToggle = function(callback2) {
        this._options.onToggle = callback2;
      };
      return Collapse2;
    }()
  );
  function initCollapses() {
    document.querySelectorAll("[data-collapse-toggle]").forEach(function($triggerEl) {
      var targetId = $triggerEl.getAttribute("data-collapse-toggle");
      var $targetEl = document.getElementById(targetId);
      if ($targetEl) {
        if (!instances_default.instanceExists("Collapse", $targetEl.getAttribute("id"))) {
          new Collapse($targetEl, $triggerEl);
        } else {
          new Collapse($targetEl, $triggerEl, {}, {
            id: $targetEl.getAttribute("id") + "_" + instances_default._generateRandomId()
          });
        }
      } else {
        console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-collapse-toggle attribute.'));
      }
    });
  }
  if (typeof window !== "undefined") {
    window.Collapse = Collapse;
    window.initCollapses = initCollapses;
  }

  // node_modules/flowbite/lib/esm/components/carousel/index.js
  var __assign3 = function() {
    __assign3 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign3.apply(this, arguments);
  };
  var Default3 = {
    defaultPosition: 0,
    indicators: {
      items: [],
      activeClasses: "bg-white dark:bg-gray-800",
      inactiveClasses: "bg-white/50 dark:bg-gray-800/50 hover:bg-white dark:hover:bg-gray-800"
    },
    interval: 3e3,
    onNext: function() {
    },
    onPrev: function() {
    },
    onChange: function() {
    }
  };
  var DefaultInstanceOptions3 = {
    id: null,
    override: true
  };
  var Carousel = (
    /** @class */
    function() {
      function Carousel2(carouselEl, items, options, instanceOptions) {
        if (carouselEl === void 0) {
          carouselEl = null;
        }
        if (items === void 0) {
          items = [];
        }
        if (options === void 0) {
          options = Default3;
        }
        if (instanceOptions === void 0) {
          instanceOptions = DefaultInstanceOptions3;
        }
        this._instanceId = instanceOptions.id ? instanceOptions.id : carouselEl.id;
        this._carouselEl = carouselEl;
        this._items = items;
        this._options = __assign3(__assign3(__assign3({}, Default3), options), { indicators: __assign3(__assign3({}, Default3.indicators), options.indicators) });
        this._activeItem = this.getItem(this._options.defaultPosition);
        this._indicators = this._options.indicators.items;
        this._intervalDuration = this._options.interval;
        this._intervalInstance = null;
        this._initialized = false;
        this.init();
        instances_default.addInstance("Carousel", this, this._instanceId, instanceOptions.override);
      }
      Carousel2.prototype.init = function() {
        var _this = this;
        if (this._items.length && !this._initialized) {
          this._items.map(function(item) {
            item.el.classList.add("absolute", "inset-0", "transition-transform", "transform");
          });
          if (this.getActiveItem()) {
            this.slideTo(this.getActiveItem().position);
          } else {
            this.slideTo(0);
          }
          this._indicators.map(function(indicator, position) {
            indicator.el.addEventListener("click", function() {
              _this.slideTo(position);
            });
          });
          this._initialized = true;
        }
      };
      Carousel2.prototype.destroy = function() {
        if (this._initialized) {
          this._initialized = false;
        }
      };
      Carousel2.prototype.removeInstance = function() {
        instances_default.removeInstance("Carousel", this._instanceId);
      };
      Carousel2.prototype.destroyAndRemoveInstance = function() {
        this.destroy();
        this.removeInstance();
      };
      Carousel2.prototype.getItem = function(position) {
        return this._items[position];
      };
      Carousel2.prototype.slideTo = function(position) {
        var nextItem = this._items[position];
        var rotationItems = {
          left: nextItem.position === 0 ? this._items[this._items.length - 1] : this._items[nextItem.position - 1],
          middle: nextItem,
          right: nextItem.position === this._items.length - 1 ? this._items[0] : this._items[nextItem.position + 1]
        };
        this._rotate(rotationItems);
        this._setActiveItem(nextItem);
        if (this._intervalInstance) {
          this.pause();
          this.cycle();
        }
        this._options.onChange(this);
      };
      Carousel2.prototype.next = function() {
        var activeItem = this.getActiveItem();
        var nextItem = null;
        if (activeItem.position === this._items.length - 1) {
          nextItem = this._items[0];
        } else {
          nextItem = this._items[activeItem.position + 1];
        }
        this.slideTo(nextItem.position);
        this._options.onNext(this);
      };
      Carousel2.prototype.prev = function() {
        var activeItem = this.getActiveItem();
        var prevItem = null;
        if (activeItem.position === 0) {
          prevItem = this._items[this._items.length - 1];
        } else {
          prevItem = this._items[activeItem.position - 1];
        }
        this.slideTo(prevItem.position);
        this._options.onPrev(this);
      };
      Carousel2.prototype._rotate = function(rotationItems) {
        this._items.map(function(item) {
          item.el.classList.add("hidden");
        });
        if (this._items.length === 1) {
          rotationItems.middle.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-10");
          rotationItems.middle.el.classList.add("translate-x-0", "z-20");
          return;
        }
        rotationItems.left.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-20");
        rotationItems.left.el.classList.add("-translate-x-full", "z-10");
        rotationItems.middle.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-10");
        rotationItems.middle.el.classList.add("translate-x-0", "z-30");
        rotationItems.right.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-30");
        rotationItems.right.el.classList.add("translate-x-full", "z-20");
      };
      Carousel2.prototype.cycle = function() {
        var _this = this;
        if (typeof window !== "undefined") {
          this._intervalInstance = window.setInterval(function() {
            _this.next();
          }, this._intervalDuration);
        }
      };
      Carousel2.prototype.pause = function() {
        clearInterval(this._intervalInstance);
      };
      Carousel2.prototype.getActiveItem = function() {
        return this._activeItem;
      };
      Carousel2.prototype._setActiveItem = function(item) {
        var _a, _b;
        var _this = this;
        this._activeItem = item;
        var position = item.position;
        if (this._indicators.length) {
          this._indicators.map(function(indicator) {
            var _a2, _b2;
            indicator.el.setAttribute("aria-current", "false");
            (_a2 = indicator.el.classList).remove.apply(_a2, _this._options.indicators.activeClasses.split(" "));
            (_b2 = indicator.el.classList).add.apply(_b2, _this._options.indicators.inactiveClasses.split(" "));
          });
          (_a = this._indicators[position].el.classList).add.apply(_a, this._options.indicators.activeClasses.split(" "));
          (_b = this._indicators[position].el.classList).remove.apply(_b, this._options.indicators.inactiveClasses.split(" "));
          this._indicators[position].el.setAttribute("aria-current", "true");
        }
      };
      Carousel2.prototype.updateOnNext = function(callback2) {
        this._options.onNext = callback2;
      };
      Carousel2.prototype.updateOnPrev = function(callback2) {
        this._options.onPrev = callback2;
      };
      Carousel2.prototype.updateOnChange = function(callback2) {
        this._options.onChange = callback2;
      };
      return Carousel2;
    }()
  );
  function initCarousels() {
    document.querySelectorAll("[data-carousel]").forEach(function($carouselEl) {
      var interval = $carouselEl.getAttribute("data-carousel-interval");
      var slide = $carouselEl.getAttribute("data-carousel") === "slide" ? true : false;
      var items = [];
      var defaultPosition = 0;
      if ($carouselEl.querySelectorAll("[data-carousel-item]").length) {
        Array.from($carouselEl.querySelectorAll("[data-carousel-item]")).map(function($carouselItemEl, position) {
          items.push({
            position,
            el: $carouselItemEl
          });
          if ($carouselItemEl.getAttribute("data-carousel-item") === "active") {
            defaultPosition = position;
          }
        });
      }
      var indicators = [];
      if ($carouselEl.querySelectorAll("[data-carousel-slide-to]").length) {
        Array.from($carouselEl.querySelectorAll("[data-carousel-slide-to]")).map(function($indicatorEl) {
          indicators.push({
            position: parseInt($indicatorEl.getAttribute("data-carousel-slide-to")),
            el: $indicatorEl
          });
        });
      }
      var carousel = new Carousel($carouselEl, items, {
        defaultPosition,
        indicators: {
          items: indicators
        },
        interval: interval ? interval : Default3.interval
      });
      if (slide) {
        carousel.cycle();
      }
      var carouselNextEl = $carouselEl.querySelector("[data-carousel-next]");
      var carouselPrevEl = $carouselEl.querySelector("[data-carousel-prev]");
      if (carouselNextEl) {
        carouselNextEl.addEventListener("click", function() {
          carousel.next();
        });
      }
      if (carouselPrevEl) {
        carouselPrevEl.addEventListener("click", function() {
          carousel.prev();
        });
      }
    });
  }
  if (typeof window !== "undefined") {
    window.Carousel = Carousel;
    window.initCarousels = initCarousels;
  }

  // node_modules/flowbite/lib/esm/components/dismiss/index.js
  var __assign4 = function() {
    __assign4 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign4.apply(this, arguments);
  };
  var Default4 = {
    transition: "transition-opacity",
    duration: 300,
    timing: "ease-out",
    onHide: function() {
    }
  };
  var DefaultInstanceOptions4 = {
    id: null,
    override: true
  };
  var Dismiss = (
    /** @class */
    function() {
      function Dismiss2(targetEl, triggerEl, options, instanceOptions) {
        if (targetEl === void 0) {
          targetEl = null;
        }
        if (triggerEl === void 0) {
          triggerEl = null;
        }
        if (options === void 0) {
          options = Default4;
        }
        if (instanceOptions === void 0) {
          instanceOptions = DefaultInstanceOptions4;
        }
        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
        this._targetEl = targetEl;
        this._triggerEl = triggerEl;
        this._options = __assign4(__assign4({}, Default4), options);
        this._initialized = false;
        this.init();
        instances_default.addInstance("Dismiss", this, this._instanceId, instanceOptions.override);
      }
      Dismiss2.prototype.init = function() {
        var _this = this;
        if (this._triggerEl && this._targetEl && !this._initialized) {
          this._clickHandler = function() {
            _this.hide();
          };
          this._triggerEl.addEventListener("click", this._clickHandler);
          this._initialized = true;
        }
      };
      Dismiss2.prototype.destroy = function() {
        if (this._triggerEl && this._initialized) {
          this._triggerEl.removeEventListener("click", this._clickHandler);
          this._initialized = false;
        }
      };
      Dismiss2.prototype.removeInstance = function() {
        instances_default.removeInstance("Dismiss", this._instanceId);
      };
      Dismiss2.prototype.destroyAndRemoveInstance = function() {
        this.destroy();
        this.removeInstance();
      };
      Dismiss2.prototype.hide = function() {
        var _this = this;
        this._targetEl.classList.add(this._options.transition, "duration-".concat(this._options.duration), this._options.timing, "opacity-0");
        setTimeout(function() {
          _this._targetEl.classList.add("hidden");
        }, this._options.duration);
        this._options.onHide(this, this._targetEl);
      };
      Dismiss2.prototype.updateOnHide = function(callback2) {
        this._options.onHide = callback2;
      };
      return Dismiss2;
    }()
  );
  function initDismisses() {
    document.querySelectorAll("[data-dismiss-target]").forEach(function($triggerEl) {
      var targetId = $triggerEl.getAttribute("data-dismiss-target");
      var $dismissEl = document.querySelector(targetId);
      if ($dismissEl) {
        new Dismiss($dismissEl, $triggerEl);
      } else {
        console.error('The dismiss element with id "'.concat(targetId, '" does not exist. Please check the data-dismiss-target attribute.'));
      }
    });
  }
  if (typeof window !== "undefined") {
    window.Dismiss = Dismiss;
    window.initDismisses = initDismisses;
  }

  // node_modules/@popperjs/core/lib/enums.js
  var top2 = "top";
  var bottom2 = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top2, bottom2, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  // node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }

  // node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style = styleProperties.reduce(function(style2, property) {
          style2[property] = "";
          return style2;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect,
    requires: ["computeStyles"]
  };

  // node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  // node_modules/@popperjs/core/lib/utils/math.js
  var max = Math.max;
  var min = Math.min;
  var round2 = Math.round;

  // node_modules/@popperjs/core/lib/utils/userAgent.js
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }

  // node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  // node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round2(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round2(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y3 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width,
      height,
      top: y3,
      right: x + width,
      bottom: y3 + height,
      left: x,
      x,
      y: y3
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle3(element) {
    return getWindow(element).getComputedStyle(element);
  }

  // node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }

  // node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle3(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle3(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css2 = getComputedStyle3(currentNode);
      if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle3(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle3(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }

  // node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  // node_modules/@popperjs/core/lib/utils/within.js
  function within(min2, value, max2) {
    return max(min2, min(value, max2));
  }
  function withinMaxClamp(min2, value, max2) {
    var v = within(min2, value, max2);
    return v > max2 ? max2 : v;
  }

  // node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  // node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  // node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top2 : left;
    var maxProp = axis === "y" ? bottom2 : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect2(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect2,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }

  // node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref, win) {
    var x = _ref.x, y3 = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round2(x * dpr) / dpr || 0,
      y: round2(y3 * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y3 = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x,
      y: y3
    }) : {
      x,
      y: y3
    };
    x = _ref3.x;
    y3 = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top2;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle3(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top2 || (placement === left || placement === right) && variation === end) {
        sideY = bottom2;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y3 -= offsetY - popperRect.height;
        y3 *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top2 || placement === bottom2) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x,
      y: y3
    }, getWindow(popper2)) : {
      x,
      y: y3
    };
    x = _ref4.x;
    y3 = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y3 + "px)" : "translate3d(" + x + "px, " + y3 + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y3 + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  var passive = {
    passive: true
  };
  function effect3(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect3,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }

  // node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  var hash2 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop2 = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop: scrollTop2
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y3 = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y3 = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x + getWindowScrollBarX(element),
      y: y3
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y3 = -winScroll.scrollTop;
    if (getComputedStyle3(body || html).direction === "rtl") {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x,
      y: y3
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle3(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }

  // node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }

  // node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle3(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  // node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top2:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom2:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }

  // node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom2].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top2, bottom2].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }

  // node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements2.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements2;
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
      return overflows[a] - overflows[b];
    });
  }

  // node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
      var placement = placements2[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top2, bottom2].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom2 : top2;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top2, right, bottom2, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top2].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y3 = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y3;
    }
    state.modifiersData[name] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };

  // node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  // node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top2 : left;
      var altSide = mainAxis === "y" ? bottom2 : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min2 = offset2 + overflow[mainSide];
      var max2 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top2 : left;
      var _altSide = mainAxis === "x" ? bottom2 : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top2, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  // node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round2(rect.width) / element.offsetWidth || 1;
    var scaleY = round2(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers) {
    var map3 = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map3.set(modifier.name, modifier);
    });
    function sort2(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map3.get(dep);
          if (depModifier) {
            sort2(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort2(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  // node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce2(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve2) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve2(fn2());
          });
        });
      }
      return pending;
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }

  // node_modules/@popperjs/core/lib/createPopper.js
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions2;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions2, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m3) {
            return m3.enabled;
          });
          runModifierEffects();
          return instance.update();
        },
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          for (var index3 = 0; index3 < state.orderedModifiers.length; index3++) {
            if (state.reset === true) {
              state.reset = false;
              index3 = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index3], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce2(function() {
          return new Promise(function(resolve2) {
            instance.forceUpdate();
            resolve2(state);
          });
        }),
        destroy: function destroy2() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref) {
          var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
          if (typeof effect4 === "function") {
            var cleanupFn = effect4({
              state,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }

  // node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // node_modules/flowbite/lib/esm/components/dropdown/index.js
  var __assign5 = function() {
    __assign5 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign5.apply(this, arguments);
  };
  var __spreadArray = function(to2, from2, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from2.length, ar; i < l; i++) {
        if (ar || !(i in from2)) {
          if (!ar)
            ar = Array.prototype.slice.call(from2, 0, i);
          ar[i] = from2[i];
        }
      }
    return to2.concat(ar || Array.prototype.slice.call(from2));
  };
  var Default5 = {
    placement: "bottom",
    triggerType: "click",
    offsetSkidding: 0,
    offsetDistance: 10,
    delay: 300,
    ignoreClickOutsideClass: false,
    onShow: function() {
    },
    onHide: function() {
    },
    onToggle: function() {
    }
  };
  var DefaultInstanceOptions5 = {
    id: null,
    override: true
  };
  var Dropdown = (
    /** @class */
    function() {
      function Dropdown2(targetElement, triggerElement, options, instanceOptions) {
        if (targetElement === void 0) {
          targetElement = null;
        }
        if (triggerElement === void 0) {
          triggerElement = null;
        }
        if (options === void 0) {
          options = Default5;
        }
        if (instanceOptions === void 0) {
          instanceOptions = DefaultInstanceOptions5;
        }
        this._instanceId = instanceOptions.id ? instanceOptions.id : targetElement.id;
        this._targetEl = targetElement;
        this._triggerEl = triggerElement;
        this._options = __assign5(__assign5({}, Default5), options);
        this._popperInstance = null;
        this._visible = false;
        this._initialized = false;
        this.init();
        instances_default.addInstance("Dropdown", this, this._instanceId, instanceOptions.override);
      }
      Dropdown2.prototype.init = function() {
        if (this._triggerEl && this._targetEl && !this._initialized) {
          this._popperInstance = this._createPopperInstance();
          this._setupEventListeners();
          this._initialized = true;
        }
      };
      Dropdown2.prototype.destroy = function() {
        var _this = this;
        var triggerEvents = this._getTriggerEvents();
        if (this._options.triggerType === "click") {
          triggerEvents.showEvents.forEach(function(ev) {
            _this._triggerEl.removeEventListener(ev, _this._clickHandler);
          });
        }
        if (this._options.triggerType === "hover") {
          triggerEvents.showEvents.forEach(function(ev) {
            _this._triggerEl.removeEventListener(ev, _this._hoverShowTriggerElHandler);
            _this._targetEl.removeEventListener(ev, _this._hoverShowTargetElHandler);
          });
          triggerEvents.hideEvents.forEach(function(ev) {
            _this._triggerEl.removeEventListener(ev, _this._hoverHideHandler);
            _this._targetEl.removeEventListener(ev, _this._hoverHideHandler);
          });
        }
        this._popperInstance.destroy();
        this._initialized = false;
      };
      Dropdown2.prototype.removeInstance = function() {
        instances_default.removeInstance("Dropdown", this._instanceId);
      };
      Dropdown2.prototype.destroyAndRemoveInstance = function() {
        this.destroy();
        this.removeInstance();
      };
      Dropdown2.prototype._setupEventListeners = function() {
        var _this = this;
        var triggerEvents = this._getTriggerEvents();
        this._clickHandler = function() {
          _this.toggle();
        };
        if (this._options.triggerType === "click") {
          triggerEvents.showEvents.forEach(function(ev) {
            _this._triggerEl.addEventListener(ev, _this._clickHandler);
          });
        }
        this._hoverShowTriggerElHandler = function(ev) {
          if (ev.type === "click") {
            _this.toggle();
          } else {
            setTimeout(function() {
              _this.show();
            }, _this._options.delay);
          }
        };
        this._hoverShowTargetElHandler = function() {
          _this.show();
        };
        this._hoverHideHandler = function() {
          setTimeout(function() {
            if (!_this._targetEl.matches(":hover")) {
              _this.hide();
            }
          }, _this._options.delay);
        };
        if (this._options.triggerType === "hover") {
          triggerEvents.showEvents.forEach(function(ev) {
            _this._triggerEl.addEventListener(ev, _this._hoverShowTriggerElHandler);
            _this._targetEl.addEventListener(ev, _this._hoverShowTargetElHandler);
          });
          triggerEvents.hideEvents.forEach(function(ev) {
            _this._triggerEl.addEventListener(ev, _this._hoverHideHandler);
            _this._targetEl.addEventListener(ev, _this._hoverHideHandler);
          });
        }
      };
      Dropdown2.prototype._createPopperInstance = function() {
        return createPopper(this._triggerEl, this._targetEl, {
          placement: this._options.placement,
          modifiers: [
            {
              name: "offset",
              options: {
                offset: [
                  this._options.offsetSkidding,
                  this._options.offsetDistance
                ]
              }
            }
          ]
        });
      };
      Dropdown2.prototype._setupClickOutsideListener = function() {
        var _this = this;
        this._clickOutsideEventListener = function(ev) {
          _this._handleClickOutside(ev, _this._targetEl);
        };
        document.body.addEventListener("click", this._clickOutsideEventListener, true);
      };
      Dropdown2.prototype._removeClickOutsideListener = function() {
        document.body.removeEventListener("click", this._clickOutsideEventListener, true);
      };
      Dropdown2.prototype._handleClickOutside = function(ev, targetEl) {
        var clickedEl = ev.target;
        var ignoreClickOutsideClass = this._options.ignoreClickOutsideClass;
        var isIgnored = false;
        if (ignoreClickOutsideClass) {
          var ignoredClickOutsideEls = document.querySelectorAll(".".concat(ignoreClickOutsideClass));
          ignoredClickOutsideEls.forEach(function(el2) {
            if (el2.contains(clickedEl)) {
              isIgnored = true;
              return;
            }
          });
        }
        if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && !isIgnored && this.isVisible()) {
          this.hide();
        }
      };
      Dropdown2.prototype._getTriggerEvents = function() {
        switch (this._options.triggerType) {
          case "hover":
            return {
              showEvents: ["mouseenter", "click"],
              hideEvents: ["mouseleave"]
            };
          case "click":
            return {
              showEvents: ["click"],
              hideEvents: []
            };
          case "none":
            return {
              showEvents: [],
              hideEvents: []
            };
          default:
            return {
              showEvents: ["click"],
              hideEvents: []
            };
        }
      };
      Dropdown2.prototype.toggle = function() {
        if (this.isVisible()) {
          this.hide();
        } else {
          this.show();
        }
        this._options.onToggle(this);
      };
      Dropdown2.prototype.isVisible = function() {
        return this._visible;
      };
      Dropdown2.prototype.show = function() {
        this._targetEl.classList.remove("hidden");
        this._targetEl.classList.add("block");
        this._targetEl.removeAttribute("aria-hidden");
        this._popperInstance.setOptions(function(options) {
          return __assign5(__assign5({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
            { name: "eventListeners", enabled: true }
          ], false) });
        });
        this._setupClickOutsideListener();
        this._popperInstance.update();
        this._visible = true;
        this._options.onShow(this);
      };
      Dropdown2.prototype.hide = function() {
        this._targetEl.classList.remove("block");
        this._targetEl.classList.add("hidden");
        this._targetEl.setAttribute("aria-hidden", "true");
        this._popperInstance.setOptions(function(options) {
          return __assign5(__assign5({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
            { name: "eventListeners", enabled: false }
          ], false) });
        });
        this._visible = false;
        this._removeClickOutsideListener();
        this._options.onHide(this);
      };
      Dropdown2.prototype.updateOnShow = function(callback2) {
        this._options.onShow = callback2;
      };
      Dropdown2.prototype.updateOnHide = function(callback2) {
        this._options.onHide = callback2;
      };
      Dropdown2.prototype.updateOnToggle = function(callback2) {
        this._options.onToggle = callback2;
      };
      return Dropdown2;
    }()
  );
  function initDropdowns() {
    document.querySelectorAll("[data-dropdown-toggle]").forEach(function($triggerEl) {
      var dropdownId = $triggerEl.getAttribute("data-dropdown-toggle");
      var $dropdownEl = document.getElementById(dropdownId);
      if ($dropdownEl) {
        var placement = $triggerEl.getAttribute("data-dropdown-placement");
        var offsetSkidding = $triggerEl.getAttribute("data-dropdown-offset-skidding");
        var offsetDistance = $triggerEl.getAttribute("data-dropdown-offset-distance");
        var triggerType = $triggerEl.getAttribute("data-dropdown-trigger");
        var delay = $triggerEl.getAttribute("data-dropdown-delay");
        var ignoreClickOutsideClass = $triggerEl.getAttribute("data-dropdown-ignore-click-outside-class");
        new Dropdown($dropdownEl, $triggerEl, {
          placement: placement ? placement : Default5.placement,
          triggerType: triggerType ? triggerType : Default5.triggerType,
          offsetSkidding: offsetSkidding ? parseInt(offsetSkidding) : Default5.offsetSkidding,
          offsetDistance: offsetDistance ? parseInt(offsetDistance) : Default5.offsetDistance,
          delay: delay ? parseInt(delay) : Default5.delay,
          ignoreClickOutsideClass: ignoreClickOutsideClass ? ignoreClickOutsideClass : Default5.ignoreClickOutsideClass
        });
      } else {
        console.error('The dropdown element with id "'.concat(dropdownId, '" does not exist. Please check the data-dropdown-toggle attribute.'));
      }
    });
  }
  if (typeof window !== "undefined") {
    window.Dropdown = Dropdown;
    window.initDropdowns = initDropdowns;
  }

  // node_modules/flowbite/lib/esm/components/modal/index.js
  var __assign6 = function() {
    __assign6 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign6.apply(this, arguments);
  };
  var Default6 = {
    placement: "center",
    backdropClasses: "bg-gray-900/50 dark:bg-gray-900/80 fixed inset-0 z-40",
    backdrop: "dynamic",
    closable: true,
    onHide: function() {
    },
    onShow: function() {
    },
    onToggle: function() {
    }
  };
  var DefaultInstanceOptions6 = {
    id: null,
    override: true
  };
  var Modal = (
    /** @class */
    function() {
      function Modal2(targetEl, options, instanceOptions) {
        if (targetEl === void 0) {
          targetEl = null;
        }
        if (options === void 0) {
          options = Default6;
        }
        if (instanceOptions === void 0) {
          instanceOptions = DefaultInstanceOptions6;
        }
        this._eventListenerInstances = [];
        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
        this._targetEl = targetEl;
        this._options = __assign6(__assign6({}, Default6), options);
        this._isHidden = true;
        this._backdropEl = null;
        this._initialized = false;
        this.init();
        instances_default.addInstance("Modal", this, this._instanceId, instanceOptions.override);
      }
      Modal2.prototype.init = function() {
        var _this = this;
        if (this._targetEl && !this._initialized) {
          this._getPlacementClasses().map(function(c) {
            _this._targetEl.classList.add(c);
          });
          this._initialized = true;
        }
      };
      Modal2.prototype.destroy = function() {
        if (this._initialized) {
          this.removeAllEventListenerInstances();
          this._destroyBackdropEl();
          this._initialized = false;
        }
      };
      Modal2.prototype.removeInstance = function() {
        instances_default.removeInstance("Modal", this._instanceId);
      };
      Modal2.prototype.destroyAndRemoveInstance = function() {
        this.destroy();
        this.removeInstance();
      };
      Modal2.prototype._createBackdrop = function() {
        var _a;
        if (this._isHidden) {
          var backdropEl = document.createElement("div");
          (_a = backdropEl.classList).add.apply(_a, this._options.backdropClasses.split(" "));
          document.querySelector("body").append(backdropEl);
          this._backdropEl = backdropEl;
        }
      };
      Modal2.prototype._destroyBackdropEl = function() {
        if (!this._isHidden && this._backdropEl) {
          this._backdropEl.remove();
          this._backdropEl = null;
        }
      };
      Modal2.prototype._setupModalCloseEventListeners = function() {
        var _this = this;
        if (this._options.backdrop === "dynamic") {
          this._clickOutsideEventListener = function(ev) {
            _this._handleOutsideClick(ev.target);
          };
          this._targetEl.addEventListener("click", this._clickOutsideEventListener, true);
        }
        this._keydownEventListener = function(ev) {
          if (ev.key === "Escape") {
            _this.hide();
          }
        };
        document.body.addEventListener("keydown", this._keydownEventListener, true);
      };
      Modal2.prototype._removeModalCloseEventListeners = function() {
        if (this._options.backdrop === "dynamic") {
          this._targetEl.removeEventListener("click", this._clickOutsideEventListener, true);
        }
        document.body.removeEventListener("keydown", this._keydownEventListener, true);
      };
      Modal2.prototype._handleOutsideClick = function(target) {
        if (target === this._targetEl || target === this._backdropEl && this.isVisible()) {
          this.hide();
        }
      };
      Modal2.prototype._getPlacementClasses = function() {
        switch (this._options.placement) {
          case "top-left":
            return ["justify-start", "items-start"];
          case "top-center":
            return ["justify-center", "items-start"];
          case "top-right":
            return ["justify-end", "items-start"];
          case "center-left":
            return ["justify-start", "items-center"];
          case "center":
            return ["justify-center", "items-center"];
          case "center-right":
            return ["justify-end", "items-center"];
          case "bottom-left":
            return ["justify-start", "items-end"];
          case "bottom-center":
            return ["justify-center", "items-end"];
          case "bottom-right":
            return ["justify-end", "items-end"];
          default:
            return ["justify-center", "items-center"];
        }
      };
      Modal2.prototype.toggle = function() {
        if (this._isHidden) {
          this.show();
        } else {
          this.hide();
        }
        this._options.onToggle(this);
      };
      Modal2.prototype.show = function() {
        if (this.isHidden) {
          this._targetEl.classList.add("flex");
          this._targetEl.classList.remove("hidden");
          this._targetEl.setAttribute("aria-modal", "true");
          this._targetEl.setAttribute("role", "dialog");
          this._targetEl.removeAttribute("aria-hidden");
          this._createBackdrop();
          this._isHidden = false;
          if (this._options.closable) {
            this._setupModalCloseEventListeners();
          }
          document.body.classList.add("overflow-hidden");
          this._options.onShow(this);
        }
      };
      Modal2.prototype.hide = function() {
        if (this.isVisible) {
          this._targetEl.classList.add("hidden");
          this._targetEl.classList.remove("flex");
          this._targetEl.setAttribute("aria-hidden", "true");
          this._targetEl.removeAttribute("aria-modal");
          this._targetEl.removeAttribute("role");
          this._destroyBackdropEl();
          this._isHidden = true;
          document.body.classList.remove("overflow-hidden");
          if (this._options.closable) {
            this._removeModalCloseEventListeners();
          }
          this._options.onHide(this);
        }
      };
      Modal2.prototype.isVisible = function() {
        return !this._isHidden;
      };
      Modal2.prototype.isHidden = function() {
        return this._isHidden;
      };
      Modal2.prototype.addEventListenerInstance = function(element, type, handler) {
        this._eventListenerInstances.push({
          element,
          type,
          handler
        });
      };
      Modal2.prototype.removeAllEventListenerInstances = function() {
        this._eventListenerInstances.map(function(eventListenerInstance) {
          eventListenerInstance.element.removeEventListener(eventListenerInstance.type, eventListenerInstance.handler);
        });
        this._eventListenerInstances = [];
      };
      Modal2.prototype.getAllEventListenerInstances = function() {
        return this._eventListenerInstances;
      };
      Modal2.prototype.updateOnShow = function(callback2) {
        this._options.onShow = callback2;
      };
      Modal2.prototype.updateOnHide = function(callback2) {
        this._options.onHide = callback2;
      };
      Modal2.prototype.updateOnToggle = function(callback2) {
        this._options.onToggle = callback2;
      };
      return Modal2;
    }()
  );
  function initModals() {
    document.querySelectorAll("[data-modal-target]").forEach(function($triggerEl) {
      var modalId = $triggerEl.getAttribute("data-modal-target");
      var $modalEl = document.getElementById(modalId);
      if ($modalEl) {
        var placement = $modalEl.getAttribute("data-modal-placement");
        var backdrop = $modalEl.getAttribute("data-modal-backdrop");
        new Modal($modalEl, {
          placement: placement ? placement : Default6.placement,
          backdrop: backdrop ? backdrop : Default6.backdrop
        });
      } else {
        console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-target attribute points to the correct modal id?."));
      }
    });
    document.querySelectorAll("[data-modal-toggle]").forEach(function($triggerEl) {
      var modalId = $triggerEl.getAttribute("data-modal-toggle");
      var $modalEl = document.getElementById(modalId);
      if ($modalEl) {
        var modal_1 = instances_default.getInstance("Modal", modalId);
        if (modal_1) {
          var toggleModal = function() {
            modal_1.toggle();
          };
          $triggerEl.addEventListener("click", toggleModal);
          modal_1.addEventListenerInstance($triggerEl, "click", toggleModal);
        } else {
          console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
        }
      } else {
        console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-toggle attribute points to the correct modal id?"));
      }
    });
    document.querySelectorAll("[data-modal-show]").forEach(function($triggerEl) {
      var modalId = $triggerEl.getAttribute("data-modal-show");
      var $modalEl = document.getElementById(modalId);
      if ($modalEl) {
        var modal_2 = instances_default.getInstance("Modal", modalId);
        if (modal_2) {
          var showModal = function() {
            modal_2.show();
          };
          $triggerEl.addEventListener("click", showModal);
          modal_2.addEventListenerInstance($triggerEl, "click", showModal);
        } else {
          console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
        }
      } else {
        console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-show attribute points to the correct modal id?"));
      }
    });
    document.querySelectorAll("[data-modal-hide]").forEach(function($triggerEl) {
      var modalId = $triggerEl.getAttribute("data-modal-hide");
      var $modalEl = document.getElementById(modalId);
      if ($modalEl) {
        var modal_3 = instances_default.getInstance("Modal", modalId);
        if (modal_3) {
          var hideModal = function() {
            modal_3.hide();
          };
          $triggerEl.addEventListener("click", hideModal);
          modal_3.addEventListenerInstance($triggerEl, "click", hideModal);
        } else {
          console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
        }
      } else {
        console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-hide attribute points to the correct modal id?"));
      }
    });
  }
  if (typeof window !== "undefined") {
    window.Modal = Modal;
    window.initModals = initModals;
  }

  // node_modules/flowbite/lib/esm/components/drawer/index.js
  var __assign7 = function() {
    __assign7 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign7.apply(this, arguments);
  };
  var Default7 = {
    placement: "left",
    bodyScrolling: false,
    backdrop: true,
    edge: false,
    edgeOffset: "bottom-[60px]",
    backdropClasses: "bg-gray-900/50 dark:bg-gray-900/80 fixed inset-0 z-30",
    onShow: function() {
    },
    onHide: function() {
    },
    onToggle: function() {
    }
  };
  var DefaultInstanceOptions7 = {
    id: null,
    override: true
  };
  var Drawer = (
    /** @class */
    function() {
      function Drawer2(targetEl, options, instanceOptions) {
        if (targetEl === void 0) {
          targetEl = null;
        }
        if (options === void 0) {
          options = Default7;
        }
        if (instanceOptions === void 0) {
          instanceOptions = DefaultInstanceOptions7;
        }
        this._eventListenerInstances = [];
        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
        this._targetEl = targetEl;
        this._options = __assign7(__assign7({}, Default7), options);
        this._visible = false;
        this._initialized = false;
        this.init();
        instances_default.addInstance("Drawer", this, this._instanceId, instanceOptions.override);
      }
      Drawer2.prototype.init = function() {
        var _this = this;
        if (this._targetEl && !this._initialized) {
          this._targetEl.setAttribute("aria-hidden", "true");
          this._targetEl.classList.add("transition-transform");
          this._getPlacementClasses(this._options.placement).base.map(function(c) {
            _this._targetEl.classList.add(c);
          });
          this._handleEscapeKey = function(event) {
            if (event.key === "Escape") {
              if (_this.isVisible()) {
                _this.hide();
              }
            }
          };
          document.addEventListener("keydown", this._handleEscapeKey);
          this._initialized = true;
        }
      };
      Drawer2.prototype.destroy = function() {
        if (this._initialized) {
          this.removeAllEventListenerInstances();
          this._destroyBackdropEl();
          document.removeEventListener("keydown", this._handleEscapeKey);
          this._initialized = false;
        }
      };
      Drawer2.prototype.removeInstance = function() {
        instances_default.removeInstance("Drawer", this._instanceId);
      };
      Drawer2.prototype.destroyAndRemoveInstance = function() {
        this.destroy();
        this.removeInstance();
      };
      Drawer2.prototype.hide = function() {
        var _this = this;
        if (this._options.edge) {
          this._getPlacementClasses(this._options.placement + "-edge").active.map(function(c) {
            _this._targetEl.classList.remove(c);
          });
          this._getPlacementClasses(this._options.placement + "-edge").inactive.map(function(c) {
            _this._targetEl.classList.add(c);
          });
        } else {
          this._getPlacementClasses(this._options.placement).active.map(function(c) {
            _this._targetEl.classList.remove(c);
          });
          this._getPlacementClasses(this._options.placement).inactive.map(function(c) {
            _this._targetEl.classList.add(c);
          });
        }
        this._targetEl.setAttribute("aria-hidden", "true");
        this._targetEl.removeAttribute("aria-modal");
        this._targetEl.removeAttribute("role");
        if (!this._options.bodyScrolling) {
          document.body.classList.remove("overflow-hidden");
        }
        if (this._options.backdrop) {
          this._destroyBackdropEl();
        }
        this._visible = false;
        this._options.onHide(this);
      };
      Drawer2.prototype.show = function() {
        var _this = this;
        if (this._options.edge) {
          this._getPlacementClasses(this._options.placement + "-edge").active.map(function(c) {
            _this._targetEl.classList.add(c);
          });
          this._getPlacementClasses(this._options.placement + "-edge").inactive.map(function(c) {
            _this._targetEl.classList.remove(c);
          });
        } else {
          this._getPlacementClasses(this._options.placement).active.map(function(c) {
            _this._targetEl.classList.add(c);
          });
          this._getPlacementClasses(this._options.placement).inactive.map(function(c) {
            _this._targetEl.classList.remove(c);
          });
        }
        this._targetEl.setAttribute("aria-modal", "true");
        this._targetEl.setAttribute("role", "dialog");
        this._targetEl.removeAttribute("aria-hidden");
        if (!this._options.bodyScrolling) {
          document.body.classList.add("overflow-hidden");
        }
        if (this._options.backdrop) {
          this._createBackdrop();
        }
        this._visible = true;
        this._options.onShow(this);
      };
      Drawer2.prototype.toggle = function() {
        if (this.isVisible()) {
          this.hide();
        } else {
          this.show();
        }
      };
      Drawer2.prototype._createBackdrop = function() {
        var _a;
        var _this = this;
        if (!this._visible) {
          var backdropEl = document.createElement("div");
          backdropEl.setAttribute("drawer-backdrop", "");
          (_a = backdropEl.classList).add.apply(_a, this._options.backdropClasses.split(" "));
          document.querySelector("body").append(backdropEl);
          backdropEl.addEventListener("click", function() {
            _this.hide();
          });
        }
      };
      Drawer2.prototype._destroyBackdropEl = function() {
        if (this._visible && document.querySelector("[drawer-backdrop]") !== null) {
          document.querySelector("[drawer-backdrop]").remove();
        }
      };
      Drawer2.prototype._getPlacementClasses = function(placement) {
        switch (placement) {
          case "top":
            return {
              base: ["top-0", "left-0", "right-0"],
              active: ["transform-none"],
              inactive: ["-translate-y-full"]
            };
          case "right":
            return {
              base: ["right-0", "top-0"],
              active: ["transform-none"],
              inactive: ["translate-x-full"]
            };
          case "bottom":
            return {
              base: ["bottom-0", "left-0", "right-0"],
              active: ["transform-none"],
              inactive: ["translate-y-full"]
            };
          case "left":
            return {
              base: ["left-0", "top-0"],
              active: ["transform-none"],
              inactive: ["-translate-x-full"]
            };
          case "bottom-edge":
            return {
              base: ["left-0", "top-0"],
              active: ["transform-none"],
              inactive: ["translate-y-full", this._options.edgeOffset]
            };
          default:
            return {
              base: ["left-0", "top-0"],
              active: ["transform-none"],
              inactive: ["-translate-x-full"]
            };
        }
      };
      Drawer2.prototype.isHidden = function() {
        return !this._visible;
      };
      Drawer2.prototype.isVisible = function() {
        return this._visible;
      };
      Drawer2.prototype.addEventListenerInstance = function(element, type, handler) {
        this._eventListenerInstances.push({
          element,
          type,
          handler
        });
      };
      Drawer2.prototype.removeAllEventListenerInstances = function() {
        this._eventListenerInstances.map(function(eventListenerInstance) {
          eventListenerInstance.element.removeEventListener(eventListenerInstance.type, eventListenerInstance.handler);
        });
        this._eventListenerInstances = [];
      };
      Drawer2.prototype.getAllEventListenerInstances = function() {
        return this._eventListenerInstances;
      };
      Drawer2.prototype.updateOnShow = function(callback2) {
        this._options.onShow = callback2;
      };
      Drawer2.prototype.updateOnHide = function(callback2) {
        this._options.onHide = callback2;
      };
      Drawer2.prototype.updateOnToggle = function(callback2) {
        this._options.onToggle = callback2;
      };
      return Drawer2;
    }()
  );
  function initDrawers() {
    document.querySelectorAll("[data-drawer-target]").forEach(function($triggerEl) {
      var drawerId = $triggerEl.getAttribute("data-drawer-target");
      var $drawerEl = document.getElementById(drawerId);
      if ($drawerEl) {
        var placement = $triggerEl.getAttribute("data-drawer-placement");
        var bodyScrolling = $triggerEl.getAttribute("data-drawer-body-scrolling");
        var backdrop = $triggerEl.getAttribute("data-drawer-backdrop");
        var edge = $triggerEl.getAttribute("data-drawer-edge");
        var edgeOffset = $triggerEl.getAttribute("data-drawer-edge-offset");
        new Drawer($drawerEl, {
          placement: placement ? placement : Default7.placement,
          bodyScrolling: bodyScrolling ? bodyScrolling === "true" ? true : false : Default7.bodyScrolling,
          backdrop: backdrop ? backdrop === "true" ? true : false : Default7.backdrop,
          edge: edge ? edge === "true" ? true : false : Default7.edge,
          edgeOffset: edgeOffset ? edgeOffset : Default7.edgeOffset
        });
      } else {
        console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
      }
    });
    document.querySelectorAll("[data-drawer-toggle]").forEach(function($triggerEl) {
      var drawerId = $triggerEl.getAttribute("data-drawer-toggle");
      var $drawerEl = document.getElementById(drawerId);
      if ($drawerEl) {
        var drawer_1 = instances_default.getInstance("Drawer", drawerId);
        if (drawer_1) {
          var toggleDrawer = function() {
            drawer_1.toggle();
          };
          $triggerEl.addEventListener("click", toggleDrawer);
          drawer_1.addEventListenerInstance($triggerEl, "click", toggleDrawer);
        } else {
          console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
        }
      } else {
        console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
      }
    });
    document.querySelectorAll("[data-drawer-dismiss], [data-drawer-hide]").forEach(function($triggerEl) {
      var drawerId = $triggerEl.getAttribute("data-drawer-dismiss") ? $triggerEl.getAttribute("data-drawer-dismiss") : $triggerEl.getAttribute("data-drawer-hide");
      var $drawerEl = document.getElementById(drawerId);
      if ($drawerEl) {
        var drawer_2 = instances_default.getInstance("Drawer", drawerId);
        if (drawer_2) {
          var hideDrawer = function() {
            drawer_2.hide();
          };
          $triggerEl.addEventListener("click", hideDrawer);
          drawer_2.addEventListenerInstance($triggerEl, "click", hideDrawer);
        } else {
          console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
        }
      } else {
        console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id"));
      }
    });
    document.querySelectorAll("[data-drawer-show]").forEach(function($triggerEl) {
      var drawerId = $triggerEl.getAttribute("data-drawer-show");
      var $drawerEl = document.getElementById(drawerId);
      if ($drawerEl) {
        var drawer_3 = instances_default.getInstance("Drawer", drawerId);
        if (drawer_3) {
          var showDrawer = function() {
            drawer_3.show();
          };
          $triggerEl.addEventListener("click", showDrawer);
          drawer_3.addEventListenerInstance($triggerEl, "click", showDrawer);
        } else {
          console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
        }
      } else {
        console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
      }
    });
  }
  if (typeof window !== "undefined") {
    window.Drawer = Drawer;
    window.initDrawers = initDrawers;
  }

  // node_modules/flowbite/lib/esm/components/tabs/index.js
  var __assign8 = function() {
    __assign8 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign8.apply(this, arguments);
  };
  var Default8 = {
    defaultTabId: null,
    activeClasses: "text-blue-600 hover:text-blue-600 dark:text-blue-500 dark:hover:text-blue-500 border-blue-600 dark:border-blue-500",
    inactiveClasses: "dark:border-transparent text-gray-500 hover:text-gray-600 dark:text-gray-400 border-gray-100 hover:border-gray-300 dark:border-gray-700 dark:hover:text-gray-300",
    onShow: function() {
    }
  };
  var DefaultInstanceOptions8 = {
    id: null,
    override: true
  };
  var Tabs = (
    /** @class */
    function() {
      function Tabs2(tabsEl, items, options, instanceOptions) {
        if (tabsEl === void 0) {
          tabsEl = null;
        }
        if (items === void 0) {
          items = [];
        }
        if (options === void 0) {
          options = Default8;
        }
        if (instanceOptions === void 0) {
          instanceOptions = DefaultInstanceOptions8;
        }
        this._instanceId = instanceOptions.id ? instanceOptions.id : tabsEl.id;
        this._tabsEl = tabsEl;
        this._items = items;
        this._activeTab = options ? this.getTab(options.defaultTabId) : null;
        this._options = __assign8(__assign8({}, Default8), options);
        this._initialized = false;
        this.init();
        instances_default.addInstance("Tabs", this, this._instanceId, instanceOptions.override);
      }
      Tabs2.prototype.init = function() {
        var _this = this;
        if (this._items.length && !this._initialized) {
          if (!this._activeTab) {
            this.setActiveTab(this._items[0]);
          }
          this.show(this._activeTab.id, true);
          this._items.map(function(tab) {
            tab.triggerEl.addEventListener("click", function(event) {
              event.preventDefault();
              _this.show(tab.id);
            });
          });
        }
      };
      Tabs2.prototype.destroy = function() {
        if (this._initialized) {
          this._initialized = false;
        }
      };
      Tabs2.prototype.removeInstance = function() {
        this.destroy();
        instances_default.removeInstance("Tabs", this._instanceId);
      };
      Tabs2.prototype.destroyAndRemoveInstance = function() {
        this.destroy();
        this.removeInstance();
      };
      Tabs2.prototype.getActiveTab = function() {
        return this._activeTab;
      };
      Tabs2.prototype.setActiveTab = function(tab) {
        this._activeTab = tab;
      };
      Tabs2.prototype.getTab = function(id) {
        return this._items.filter(function(t) {
          return t.id === id;
        })[0];
      };
      Tabs2.prototype.show = function(id, forceShow) {
        var _a, _b;
        var _this = this;
        if (forceShow === void 0) {
          forceShow = false;
        }
        var tab = this.getTab(id);
        if (tab === this._activeTab && !forceShow) {
          return;
        }
        this._items.map(function(t) {
          var _a2, _b2;
          if (t !== tab) {
            (_a2 = t.triggerEl.classList).remove.apply(_a2, _this._options.activeClasses.split(" "));
            (_b2 = t.triggerEl.classList).add.apply(_b2, _this._options.inactiveClasses.split(" "));
            t.targetEl.classList.add("hidden");
            t.triggerEl.setAttribute("aria-selected", "false");
          }
        });
        (_a = tab.triggerEl.classList).add.apply(_a, this._options.activeClasses.split(" "));
        (_b = tab.triggerEl.classList).remove.apply(_b, this._options.inactiveClasses.split(" "));
        tab.triggerEl.setAttribute("aria-selected", "true");
        tab.targetEl.classList.remove("hidden");
        this.setActiveTab(tab);
        this._options.onShow(this, tab);
      };
      Tabs2.prototype.updateOnShow = function(callback2) {
        this._options.onShow = callback2;
      };
      return Tabs2;
    }()
  );
  function initTabs() {
    document.querySelectorAll("[data-tabs-toggle]").forEach(function($parentEl) {
      var tabItems = [];
      var activeClasses = $parentEl.getAttribute("data-tabs-active-classes");
      var inactiveClasses = $parentEl.getAttribute("data-tabs-inactive-classes");
      var defaultTabId = null;
      $parentEl.querySelectorAll('[role="tab"]').forEach(function($triggerEl) {
        var isActive = $triggerEl.getAttribute("aria-selected") === "true";
        var tab = {
          id: $triggerEl.getAttribute("data-tabs-target"),
          triggerEl: $triggerEl,
          targetEl: document.querySelector($triggerEl.getAttribute("data-tabs-target"))
        };
        tabItems.push(tab);
        if (isActive) {
          defaultTabId = tab.id;
        }
      });
      new Tabs($parentEl, tabItems, {
        defaultTabId,
        activeClasses: activeClasses ? activeClasses : Default8.activeClasses,
        inactiveClasses: inactiveClasses ? inactiveClasses : Default8.inactiveClasses
      });
    });
  }
  if (typeof window !== "undefined") {
    window.Tabs = Tabs;
    window.initTabs = initTabs;
  }

  // node_modules/flowbite/lib/esm/components/tooltip/index.js
  var __assign9 = function() {
    __assign9 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign9.apply(this, arguments);
  };
  var __spreadArray2 = function(to2, from2, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from2.length, ar; i < l; i++) {
        if (ar || !(i in from2)) {
          if (!ar)
            ar = Array.prototype.slice.call(from2, 0, i);
          ar[i] = from2[i];
        }
      }
    return to2.concat(ar || Array.prototype.slice.call(from2));
  };
  var Default9 = {
    placement: "top",
    triggerType: "hover",
    onShow: function() {
    },
    onHide: function() {
    },
    onToggle: function() {
    }
  };
  var DefaultInstanceOptions9 = {
    id: null,
    override: true
  };
  var Tooltip2 = (
    /** @class */
    function() {
      function Tooltip3(targetEl, triggerEl, options, instanceOptions) {
        if (targetEl === void 0) {
          targetEl = null;
        }
        if (triggerEl === void 0) {
          triggerEl = null;
        }
        if (options === void 0) {
          options = Default9;
        }
        if (instanceOptions === void 0) {
          instanceOptions = DefaultInstanceOptions9;
        }
        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
        this._targetEl = targetEl;
        this._triggerEl = triggerEl;
        this._options = __assign9(__assign9({}, Default9), options);
        this._popperInstance = null;
        this._visible = false;
        this._initialized = false;
        this.init();
        instances_default.addInstance("Tooltip", this, this._instanceId, instanceOptions.override);
      }
      Tooltip3.prototype.init = function() {
        if (this._triggerEl && this._targetEl && !this._initialized) {
          this._setupEventListeners();
          this._popperInstance = this._createPopperInstance();
          this._initialized = true;
        }
      };
      Tooltip3.prototype.destroy = function() {
        var _this = this;
        if (this._initialized) {
          var triggerEvents = this._getTriggerEvents();
          triggerEvents.showEvents.forEach(function(ev) {
            _this._triggerEl.removeEventListener(ev, _this._showHandler);
          });
          triggerEvents.hideEvents.forEach(function(ev) {
            _this._triggerEl.removeEventListener(ev, _this._hideHandler);
          });
          this._removeKeydownListener();
          this._removeClickOutsideListener();
          if (this._popperInstance) {
            this._popperInstance.destroy();
          }
          this._initialized = false;
        }
      };
      Tooltip3.prototype.removeInstance = function() {
        instances_default.removeInstance("Tooltip", this._instanceId);
      };
      Tooltip3.prototype.destroyAndRemoveInstance = function() {
        this.destroy();
        this.removeInstance();
      };
      Tooltip3.prototype._setupEventListeners = function() {
        var _this = this;
        var triggerEvents = this._getTriggerEvents();
        this._showHandler = function() {
          _this.show();
        };
        this._hideHandler = function() {
          _this.hide();
        };
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.addEventListener(ev, _this._showHandler);
        });
        triggerEvents.hideEvents.forEach(function(ev) {
          _this._triggerEl.addEventListener(ev, _this._hideHandler);
        });
      };
      Tooltip3.prototype._createPopperInstance = function() {
        return createPopper(this._triggerEl, this._targetEl, {
          placement: this._options.placement,
          modifiers: [
            {
              name: "offset",
              options: {
                offset: [0, 8]
              }
            }
          ]
        });
      };
      Tooltip3.prototype._getTriggerEvents = function() {
        switch (this._options.triggerType) {
          case "hover":
            return {
              showEvents: ["mouseenter", "focus"],
              hideEvents: ["mouseleave", "blur"]
            };
          case "click":
            return {
              showEvents: ["click", "focus"],
              hideEvents: ["focusout", "blur"]
            };
          case "none":
            return {
              showEvents: [],
              hideEvents: []
            };
          default:
            return {
              showEvents: ["mouseenter", "focus"],
              hideEvents: ["mouseleave", "blur"]
            };
        }
      };
      Tooltip3.prototype._setupKeydownListener = function() {
        var _this = this;
        this._keydownEventListener = function(ev) {
          if (ev.key === "Escape") {
            _this.hide();
          }
        };
        document.body.addEventListener("keydown", this._keydownEventListener, true);
      };
      Tooltip3.prototype._removeKeydownListener = function() {
        document.body.removeEventListener("keydown", this._keydownEventListener, true);
      };
      Tooltip3.prototype._setupClickOutsideListener = function() {
        var _this = this;
        this._clickOutsideEventListener = function(ev) {
          _this._handleClickOutside(ev, _this._targetEl);
        };
        document.body.addEventListener("click", this._clickOutsideEventListener, true);
      };
      Tooltip3.prototype._removeClickOutsideListener = function() {
        document.body.removeEventListener("click", this._clickOutsideEventListener, true);
      };
      Tooltip3.prototype._handleClickOutside = function(ev, targetEl) {
        var clickedEl = ev.target;
        if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && this.isVisible()) {
          this.hide();
        }
      };
      Tooltip3.prototype.isVisible = function() {
        return this._visible;
      };
      Tooltip3.prototype.toggle = function() {
        if (this.isVisible()) {
          this.hide();
        } else {
          this.show();
        }
      };
      Tooltip3.prototype.show = function() {
        this._targetEl.classList.remove("opacity-0", "invisible");
        this._targetEl.classList.add("opacity-100", "visible");
        this._popperInstance.setOptions(function(options) {
          return __assign9(__assign9({}, options), { modifiers: __spreadArray2(__spreadArray2([], options.modifiers, true), [
            { name: "eventListeners", enabled: true }
          ], false) });
        });
        this._setupClickOutsideListener();
        this._setupKeydownListener();
        this._popperInstance.update();
        this._visible = true;
        this._options.onShow(this);
      };
      Tooltip3.prototype.hide = function() {
        this._targetEl.classList.remove("opacity-100", "visible");
        this._targetEl.classList.add("opacity-0", "invisible");
        this._popperInstance.setOptions(function(options) {
          return __assign9(__assign9({}, options), { modifiers: __spreadArray2(__spreadArray2([], options.modifiers, true), [
            { name: "eventListeners", enabled: false }
          ], false) });
        });
        this._removeClickOutsideListener();
        this._removeKeydownListener();
        this._visible = false;
        this._options.onHide(this);
      };
      Tooltip3.prototype.updateOnShow = function(callback2) {
        this._options.onShow = callback2;
      };
      Tooltip3.prototype.updateOnHide = function(callback2) {
        this._options.onHide = callback2;
      };
      Tooltip3.prototype.updateOnToggle = function(callback2) {
        this._options.onToggle = callback2;
      };
      return Tooltip3;
    }()
  );
  function initTooltips() {
    document.querySelectorAll("[data-tooltip-target]").forEach(function($triggerEl) {
      var tooltipId = $triggerEl.getAttribute("data-tooltip-target");
      var $tooltipEl = document.getElementById(tooltipId);
      if ($tooltipEl) {
        var triggerType = $triggerEl.getAttribute("data-tooltip-trigger");
        var placement = $triggerEl.getAttribute("data-tooltip-placement");
        new Tooltip2($tooltipEl, $triggerEl, {
          placement: placement ? placement : Default9.placement,
          triggerType: triggerType ? triggerType : Default9.triggerType
        });
      } else {
        console.error('The tooltip element with id "'.concat(tooltipId, '" does not exist. Please check the data-tooltip-target attribute.'));
      }
    });
  }
  if (typeof window !== "undefined") {
    window.Tooltip = Tooltip2;
    window.initTooltips = initTooltips;
  }

  // node_modules/flowbite/lib/esm/components/popover/index.js
  var __assign10 = function() {
    __assign10 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign10.apply(this, arguments);
  };
  var __spreadArray3 = function(to2, from2, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from2.length, ar; i < l; i++) {
        if (ar || !(i in from2)) {
          if (!ar)
            ar = Array.prototype.slice.call(from2, 0, i);
          ar[i] = from2[i];
        }
      }
    return to2.concat(ar || Array.prototype.slice.call(from2));
  };
  var Default10 = {
    placement: "top",
    offset: 10,
    triggerType: "hover",
    onShow: function() {
    },
    onHide: function() {
    },
    onToggle: function() {
    }
  };
  var DefaultInstanceOptions10 = {
    id: null,
    override: true
  };
  var Popover = (
    /** @class */
    function() {
      function Popover2(targetEl, triggerEl, options, instanceOptions) {
        if (targetEl === void 0) {
          targetEl = null;
        }
        if (triggerEl === void 0) {
          triggerEl = null;
        }
        if (options === void 0) {
          options = Default10;
        }
        if (instanceOptions === void 0) {
          instanceOptions = DefaultInstanceOptions10;
        }
        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
        this._targetEl = targetEl;
        this._triggerEl = triggerEl;
        this._options = __assign10(__assign10({}, Default10), options);
        this._popperInstance = null;
        this._visible = false;
        this._initialized = false;
        this.init();
        instances_default.addInstance("Popover", this, instanceOptions.id ? instanceOptions.id : this._targetEl.id, instanceOptions.override);
      }
      Popover2.prototype.init = function() {
        if (this._triggerEl && this._targetEl && !this._initialized) {
          this._setupEventListeners();
          this._popperInstance = this._createPopperInstance();
          this._initialized = true;
        }
      };
      Popover2.prototype.destroy = function() {
        var _this = this;
        if (this._initialized) {
          var triggerEvents = this._getTriggerEvents();
          triggerEvents.showEvents.forEach(function(ev) {
            _this._triggerEl.removeEventListener(ev, _this._showHandler);
            _this._targetEl.removeEventListener(ev, _this._showHandler);
          });
          triggerEvents.hideEvents.forEach(function(ev) {
            _this._triggerEl.removeEventListener(ev, _this._hideHandler);
            _this._targetEl.removeEventListener(ev, _this._hideHandler);
          });
          this._removeKeydownListener();
          this._removeClickOutsideListener();
          if (this._popperInstance) {
            this._popperInstance.destroy();
          }
          this._initialized = false;
        }
      };
      Popover2.prototype.removeInstance = function() {
        instances_default.removeInstance("Popover", this._instanceId);
      };
      Popover2.prototype.destroyAndRemoveInstance = function() {
        this.destroy();
        this.removeInstance();
      };
      Popover2.prototype._setupEventListeners = function() {
        var _this = this;
        var triggerEvents = this._getTriggerEvents();
        this._showHandler = function() {
          _this.show();
        };
        this._hideHandler = function() {
          setTimeout(function() {
            if (!_this._targetEl.matches(":hover")) {
              _this.hide();
            }
          }, 100);
        };
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.addEventListener(ev, _this._showHandler);
          _this._targetEl.addEventListener(ev, _this._showHandler);
        });
        triggerEvents.hideEvents.forEach(function(ev) {
          _this._triggerEl.addEventListener(ev, _this._hideHandler);
          _this._targetEl.addEventListener(ev, _this._hideHandler);
        });
      };
      Popover2.prototype._createPopperInstance = function() {
        return createPopper(this._triggerEl, this._targetEl, {
          placement: this._options.placement,
          modifiers: [
            {
              name: "offset",
              options: {
                offset: [0, this._options.offset]
              }
            }
          ]
        });
      };
      Popover2.prototype._getTriggerEvents = function() {
        switch (this._options.triggerType) {
          case "hover":
            return {
              showEvents: ["mouseenter", "focus"],
              hideEvents: ["mouseleave", "blur"]
            };
          case "click":
            return {
              showEvents: ["click", "focus"],
              hideEvents: ["focusout", "blur"]
            };
          case "none":
            return {
              showEvents: [],
              hideEvents: []
            };
          default:
            return {
              showEvents: ["mouseenter", "focus"],
              hideEvents: ["mouseleave", "blur"]
            };
        }
      };
      Popover2.prototype._setupKeydownListener = function() {
        var _this = this;
        this._keydownEventListener = function(ev) {
          if (ev.key === "Escape") {
            _this.hide();
          }
        };
        document.body.addEventListener("keydown", this._keydownEventListener, true);
      };
      Popover2.prototype._removeKeydownListener = function() {
        document.body.removeEventListener("keydown", this._keydownEventListener, true);
      };
      Popover2.prototype._setupClickOutsideListener = function() {
        var _this = this;
        this._clickOutsideEventListener = function(ev) {
          _this._handleClickOutside(ev, _this._targetEl);
        };
        document.body.addEventListener("click", this._clickOutsideEventListener, true);
      };
      Popover2.prototype._removeClickOutsideListener = function() {
        document.body.removeEventListener("click", this._clickOutsideEventListener, true);
      };
      Popover2.prototype._handleClickOutside = function(ev, targetEl) {
        var clickedEl = ev.target;
        if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && this.isVisible()) {
          this.hide();
        }
      };
      Popover2.prototype.isVisible = function() {
        return this._visible;
      };
      Popover2.prototype.toggle = function() {
        if (this.isVisible()) {
          this.hide();
        } else {
          this.show();
        }
        this._options.onToggle(this);
      };
      Popover2.prototype.show = function() {
        this._targetEl.classList.remove("opacity-0", "invisible");
        this._targetEl.classList.add("opacity-100", "visible");
        this._popperInstance.setOptions(function(options) {
          return __assign10(__assign10({}, options), { modifiers: __spreadArray3(__spreadArray3([], options.modifiers, true), [
            { name: "eventListeners", enabled: true }
          ], false) });
        });
        this._setupClickOutsideListener();
        this._setupKeydownListener();
        this._popperInstance.update();
        this._visible = true;
        this._options.onShow(this);
      };
      Popover2.prototype.hide = function() {
        this._targetEl.classList.remove("opacity-100", "visible");
        this._targetEl.classList.add("opacity-0", "invisible");
        this._popperInstance.setOptions(function(options) {
          return __assign10(__assign10({}, options), { modifiers: __spreadArray3(__spreadArray3([], options.modifiers, true), [
            { name: "eventListeners", enabled: false }
          ], false) });
        });
        this._removeClickOutsideListener();
        this._removeKeydownListener();
        this._visible = false;
        this._options.onHide(this);
      };
      Popover2.prototype.updateOnShow = function(callback2) {
        this._options.onShow = callback2;
      };
      Popover2.prototype.updateOnHide = function(callback2) {
        this._options.onHide = callback2;
      };
      Popover2.prototype.updateOnToggle = function(callback2) {
        this._options.onToggle = callback2;
      };
      return Popover2;
    }()
  );
  function initPopovers() {
    document.querySelectorAll("[data-popover-target]").forEach(function($triggerEl) {
      var popoverID = $triggerEl.getAttribute("data-popover-target");
      var $popoverEl = document.getElementById(popoverID);
      if ($popoverEl) {
        var triggerType = $triggerEl.getAttribute("data-popover-trigger");
        var placement = $triggerEl.getAttribute("data-popover-placement");
        var offset2 = $triggerEl.getAttribute("data-popover-offset");
        new Popover($popoverEl, $triggerEl, {
          placement: placement ? placement : Default10.placement,
          offset: offset2 ? parseInt(offset2) : Default10.offset,
          triggerType: triggerType ? triggerType : Default10.triggerType
        });
      } else {
        console.error('The popover element with id "'.concat(popoverID, '" does not exist. Please check the data-popover-target attribute.'));
      }
    });
  }
  if (typeof window !== "undefined") {
    window.Popover = Popover;
    window.initPopovers = initPopovers;
  }

  // node_modules/flowbite/lib/esm/components/dial/index.js
  var __assign11 = function() {
    __assign11 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign11.apply(this, arguments);
  };
  var Default11 = {
    triggerType: "hover",
    onShow: function() {
    },
    onHide: function() {
    },
    onToggle: function() {
    }
  };
  var DefaultInstanceOptions11 = {
    id: null,
    override: true
  };
  var Dial = (
    /** @class */
    function() {
      function Dial2(parentEl2, triggerEl, targetEl, options, instanceOptions) {
        if (parentEl2 === void 0) {
          parentEl2 = null;
        }
        if (triggerEl === void 0) {
          triggerEl = null;
        }
        if (targetEl === void 0) {
          targetEl = null;
        }
        if (options === void 0) {
          options = Default11;
        }
        if (instanceOptions === void 0) {
          instanceOptions = DefaultInstanceOptions11;
        }
        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
        this._parentEl = parentEl2;
        this._triggerEl = triggerEl;
        this._targetEl = targetEl;
        this._options = __assign11(__assign11({}, Default11), options);
        this._visible = false;
        this._initialized = false;
        this.init();
        instances_default.addInstance("Dial", this, this._instanceId, instanceOptions.override);
      }
      Dial2.prototype.init = function() {
        var _this = this;
        if (this._triggerEl && this._targetEl && !this._initialized) {
          var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);
          this._showEventHandler = function() {
            _this.show();
          };
          triggerEventTypes.showEvents.forEach(function(ev) {
            _this._triggerEl.addEventListener(ev, _this._showEventHandler);
            _this._targetEl.addEventListener(ev, _this._showEventHandler);
          });
          this._hideEventHandler = function() {
            if (!_this._parentEl.matches(":hover")) {
              _this.hide();
            }
          };
          triggerEventTypes.hideEvents.forEach(function(ev) {
            _this._parentEl.addEventListener(ev, _this._hideEventHandler);
          });
          this._initialized = true;
        }
      };
      Dial2.prototype.destroy = function() {
        var _this = this;
        if (this._initialized) {
          var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);
          triggerEventTypes.showEvents.forEach(function(ev) {
            _this._triggerEl.removeEventListener(ev, _this._showEventHandler);
            _this._targetEl.removeEventListener(ev, _this._showEventHandler);
          });
          triggerEventTypes.hideEvents.forEach(function(ev) {
            _this._parentEl.removeEventListener(ev, _this._hideEventHandler);
          });
          this._initialized = false;
        }
      };
      Dial2.prototype.removeInstance = function() {
        instances_default.removeInstance("Dial", this._instanceId);
      };
      Dial2.prototype.destroyAndRemoveInstance = function() {
        this.destroy();
        this.removeInstance();
      };
      Dial2.prototype.hide = function() {
        this._targetEl.classList.add("hidden");
        if (this._triggerEl) {
          this._triggerEl.setAttribute("aria-expanded", "false");
        }
        this._visible = false;
        this._options.onHide(this);
      };
      Dial2.prototype.show = function() {
        this._targetEl.classList.remove("hidden");
        if (this._triggerEl) {
          this._triggerEl.setAttribute("aria-expanded", "true");
        }
        this._visible = true;
        this._options.onShow(this);
      };
      Dial2.prototype.toggle = function() {
        if (this._visible) {
          this.hide();
        } else {
          this.show();
        }
      };
      Dial2.prototype.isHidden = function() {
        return !this._visible;
      };
      Dial2.prototype.isVisible = function() {
        return this._visible;
      };
      Dial2.prototype._getTriggerEventTypes = function(triggerType) {
        switch (triggerType) {
          case "hover":
            return {
              showEvents: ["mouseenter", "focus"],
              hideEvents: ["mouseleave", "blur"]
            };
          case "click":
            return {
              showEvents: ["click", "focus"],
              hideEvents: ["focusout", "blur"]
            };
          case "none":
            return {
              showEvents: [],
              hideEvents: []
            };
          default:
            return {
              showEvents: ["mouseenter", "focus"],
              hideEvents: ["mouseleave", "blur"]
            };
        }
      };
      Dial2.prototype.updateOnShow = function(callback2) {
        this._options.onShow = callback2;
      };
      Dial2.prototype.updateOnHide = function(callback2) {
        this._options.onHide = callback2;
      };
      Dial2.prototype.updateOnToggle = function(callback2) {
        this._options.onToggle = callback2;
      };
      return Dial2;
    }()
  );
  function initDials() {
    document.querySelectorAll("[data-dial-init]").forEach(function($parentEl) {
      var $triggerEl = $parentEl.querySelector("[data-dial-toggle]");
      if ($triggerEl) {
        var dialId = $triggerEl.getAttribute("data-dial-toggle");
        var $dialEl = document.getElementById(dialId);
        if ($dialEl) {
          var triggerType = $triggerEl.getAttribute("data-dial-trigger");
          new Dial($parentEl, $triggerEl, $dialEl, {
            triggerType: triggerType ? triggerType : Default11.triggerType
          });
        } else {
          console.error("Dial with id ".concat(dialId, " does not exist. Are you sure that the data-dial-toggle attribute points to the correct modal id?"));
        }
      } else {
        console.error("Dial with id ".concat($parentEl.id, " does not have a trigger element. Are you sure that the data-dial-toggle attribute exists?"));
      }
    });
  }
  if (typeof window !== "undefined") {
    window.Dial = Dial;
    window.initDials = initDials;
  }

  // node_modules/flowbite/lib/esm/components/input-counter/index.js
  var __assign12 = function() {
    __assign12 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign12.apply(this, arguments);
  };
  var Default12 = {
    minValue: null,
    maxValue: null,
    onIncrement: function() {
    },
    onDecrement: function() {
    }
  };
  var DefaultInstanceOptions12 = {
    id: null,
    override: true
  };
  var InputCounter = (
    /** @class */
    function() {
      function InputCounter2(targetEl, incrementEl, decrementEl, options, instanceOptions) {
        if (targetEl === void 0) {
          targetEl = null;
        }
        if (incrementEl === void 0) {
          incrementEl = null;
        }
        if (decrementEl === void 0) {
          decrementEl = null;
        }
        if (options === void 0) {
          options = Default12;
        }
        if (instanceOptions === void 0) {
          instanceOptions = DefaultInstanceOptions12;
        }
        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
        this._targetEl = targetEl;
        this._incrementEl = incrementEl;
        this._decrementEl = decrementEl;
        this._options = __assign12(__assign12({}, Default12), options);
        this._initialized = false;
        this.init();
        instances_default.addInstance("InputCounter", this, this._instanceId, instanceOptions.override);
      }
      InputCounter2.prototype.init = function() {
        var _this = this;
        if (this._targetEl && !this._initialized) {
          this._inputHandler = function(event) {
            {
              var target = event.target;
              if (!/^\d*$/.test(target.value)) {
                target.value = target.value.replace(/[^\d]/g, "");
              }
              if (_this._options.maxValue !== null && parseInt(target.value) > _this._options.maxValue) {
                target.value = _this._options.maxValue.toString();
              }
              if (_this._options.minValue !== null && parseInt(target.value) < _this._options.minValue) {
                target.value = _this._options.minValue.toString();
              }
            }
          };
          this._incrementClickHandler = function() {
            _this.increment();
          };
          this._decrementClickHandler = function() {
            _this.decrement();
          };
          this._targetEl.addEventListener("input", this._inputHandler);
          if (this._incrementEl) {
            this._incrementEl.addEventListener("click", this._incrementClickHandler);
          }
          if (this._decrementEl) {
            this._decrementEl.addEventListener("click", this._decrementClickHandler);
          }
          this._initialized = true;
        }
      };
      InputCounter2.prototype.destroy = function() {
        if (this._targetEl && this._initialized) {
          this._targetEl.removeEventListener("input", this._inputHandler);
          if (this._incrementEl) {
            this._incrementEl.removeEventListener("click", this._incrementClickHandler);
          }
          if (this._decrementEl) {
            this._decrementEl.removeEventListener("click", this._decrementClickHandler);
          }
          this._initialized = false;
        }
      };
      InputCounter2.prototype.removeInstance = function() {
        instances_default.removeInstance("InputCounter", this._instanceId);
      };
      InputCounter2.prototype.destroyAndRemoveInstance = function() {
        this.destroy();
        this.removeInstance();
      };
      InputCounter2.prototype.getCurrentValue = function() {
        return parseInt(this._targetEl.value) || 0;
      };
      InputCounter2.prototype.increment = function() {
        if (this._options.maxValue !== null && this.getCurrentValue() >= this._options.maxValue) {
          return;
        }
        this._targetEl.value = (this.getCurrentValue() + 1).toString();
        this._options.onIncrement(this);
      };
      InputCounter2.prototype.decrement = function() {
        if (this._options.minValue !== null && this.getCurrentValue() <= this._options.minValue) {
          return;
        }
        this._targetEl.value = (this.getCurrentValue() - 1).toString();
        this._options.onDecrement(this);
      };
      InputCounter2.prototype.updateOnIncrement = function(callback2) {
        this._options.onIncrement = callback2;
      };
      InputCounter2.prototype.updateOnDecrement = function(callback2) {
        this._options.onDecrement = callback2;
      };
      return InputCounter2;
    }()
  );
  function initInputCounters() {
    document.querySelectorAll("[data-input-counter]").forEach(function($targetEl) {
      var targetId = $targetEl.id;
      var $incrementEl = document.querySelector('[data-input-counter-increment="' + targetId + '"]');
      var $decrementEl = document.querySelector('[data-input-counter-decrement="' + targetId + '"]');
      var minValue = $targetEl.getAttribute("data-input-counter-min");
      var maxValue = $targetEl.getAttribute("data-input-counter-max");
      if ($targetEl) {
        if (!instances_default.instanceExists("InputCounter", $targetEl.getAttribute("id"))) {
          new InputCounter($targetEl, $incrementEl ? $incrementEl : null, $decrementEl ? $decrementEl : null, {
            minValue: minValue ? parseInt(minValue) : null,
            maxValue: maxValue ? parseInt(maxValue) : null
          });
        }
      } else {
        console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-input-counter attribute.'));
      }
    });
  }
  if (typeof window !== "undefined") {
    window.InputCounter = InputCounter;
    window.initInputCounters = initInputCounters;
  }

  // node_modules/flowbite/lib/esm/components/clipboard/index.js
  var __assign13 = function() {
    __assign13 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign13.apply(this, arguments);
  };
  var Default13 = {
    htmlEntities: false,
    contentType: "input",
    onCopy: function() {
    }
  };
  var DefaultInstanceOptions13 = {
    id: null,
    override: true
  };
  var CopyClipboard = (
    /** @class */
    function() {
      function CopyClipboard2(triggerEl, targetEl, options, instanceOptions) {
        if (triggerEl === void 0) {
          triggerEl = null;
        }
        if (targetEl === void 0) {
          targetEl = null;
        }
        if (options === void 0) {
          options = Default13;
        }
        if (instanceOptions === void 0) {
          instanceOptions = DefaultInstanceOptions13;
        }
        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
        this._triggerEl = triggerEl;
        this._targetEl = targetEl;
        this._options = __assign13(__assign13({}, Default13), options);
        this._initialized = false;
        this.init();
        instances_default.addInstance("CopyClipboard", this, this._instanceId, instanceOptions.override);
      }
      CopyClipboard2.prototype.init = function() {
        var _this = this;
        if (this._targetEl && this._triggerEl && !this._initialized) {
          this._triggerElClickHandler = function() {
            _this.copy();
          };
          if (this._triggerEl) {
            this._triggerEl.addEventListener("click", this._triggerElClickHandler);
          }
          this._initialized = true;
        }
      };
      CopyClipboard2.prototype.destroy = function() {
        if (this._triggerEl && this._targetEl && this._initialized) {
          if (this._triggerEl) {
            this._triggerEl.removeEventListener("click", this._triggerElClickHandler);
          }
          this._initialized = false;
        }
      };
      CopyClipboard2.prototype.removeInstance = function() {
        instances_default.removeInstance("CopyClipboard", this._instanceId);
      };
      CopyClipboard2.prototype.destroyAndRemoveInstance = function() {
        this.destroy();
        this.removeInstance();
      };
      CopyClipboard2.prototype.getTargetValue = function() {
        if (this._options.contentType === "input") {
          return this._targetEl.value;
        }
        if (this._options.contentType === "innerHTML") {
          return this._targetEl.innerHTML;
        }
        if (this._options.contentType === "textContent") {
          return this._targetEl.textContent.replace(/\s+/g, " ").trim();
        }
      };
      CopyClipboard2.prototype.copy = function() {
        var textToCopy = this.getTargetValue();
        if (this._options.htmlEntities) {
          textToCopy = this.decodeHTML(textToCopy);
        }
        var tempTextArea = document.createElement("textarea");
        tempTextArea.value = textToCopy;
        document.body.appendChild(tempTextArea);
        tempTextArea.select();
        document.execCommand("copy");
        document.body.removeChild(tempTextArea);
        this._options.onCopy(this);
        return textToCopy;
      };
      CopyClipboard2.prototype.decodeHTML = function(html) {
        var textarea = document.createElement("textarea");
        textarea.innerHTML = html;
        return textarea.textContent;
      };
      CopyClipboard2.prototype.updateOnCopyCallback = function(callback2) {
        this._options.onCopy = callback2;
      };
      return CopyClipboard2;
    }()
  );
  function initCopyClipboards() {
    document.querySelectorAll("[data-copy-to-clipboard-target]").forEach(function($triggerEl) {
      var targetId = $triggerEl.getAttribute("data-copy-to-clipboard-target");
      var $targetEl = document.getElementById(targetId);
      var contentType = $triggerEl.getAttribute("data-copy-to-clipboard-content-type");
      var htmlEntities = $triggerEl.getAttribute("data-copy-to-clipboard-html-entities");
      if ($targetEl) {
        if (!instances_default.instanceExists("CopyClipboard", $targetEl.getAttribute("id"))) {
          new CopyClipboard($triggerEl, $targetEl, {
            htmlEntities: htmlEntities && htmlEntities === "true" ? true : Default13.htmlEntities,
            contentType: contentType ? contentType : Default13.contentType
          });
        }
      } else {
        console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-copy-to-clipboard-target attribute.'));
      }
    });
  }
  if (typeof window !== "undefined") {
    window.CopyClipboard = CopyClipboard;
    window.initClipboards = initCopyClipboards;
  }

  // node_modules/flowbite-datepicker/dist/main.esm.js
  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++)
      n[e] = r[e];
    return n;
  }
  function _arrayWithHoles(r) {
    if (Array.isArray(r))
      return r;
  }
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r))
      return _arrayLikeToArray(r);
  }
  function _assertThisInitialized(e) {
    if (void 0 === e)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
  }
  function _classCallCheck(a, n) {
    if (!(a instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
      writable: false
    }), e;
  }
  function _get() {
    return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
      var p = _superPropBase(e, t);
      if (p) {
        var n = Object.getOwnPropertyDescriptor(p, t);
        return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
      }
    }, _get.apply(null, arguments);
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, _getPrototypeOf(t);
  }
  function _inherits(t, e) {
    if ("function" != typeof e && null !== e)
      throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: true,
        configurable: true
      }
    }), Object.defineProperty(t, "prototype", {
      writable: false
    }), e && _setPrototypeOf(t, e);
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t2) {
    }
    return (_isNativeReflectConstruct = function() {
      return !!t;
    })();
  }
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"])
      return Array.from(r);
  }
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e, n, i, u, a = [], f = true, o = false;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t)
            return;
          f = false;
        } else
          for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true)
            ;
      } catch (r2) {
        o = true, n = r2;
      } finally {
        try {
          if (!f && null != t.return && (u = t.return(), Object(u) !== u))
            return;
        } finally {
          if (o)
            throw n;
        }
      }
      return a;
    }
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _possibleConstructorReturn(t, e) {
    if (e && ("object" == typeof e || "function" == typeof e))
      return e;
    if (void 0 !== e)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
      return t2.__proto__ = e2, t2;
    }, _setPrototypeOf(t, e);
  }
  function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
  }
  function _superPropBase(t, o) {
    for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); )
      ;
    return t;
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i)
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _typeof2(o) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof2(o);
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r)
        return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }
  function hasProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  function lastItemOf(arr) {
    return arr[arr.length - 1];
  }
  function pushUnique(arr) {
    for (var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      items[_key - 1] = arguments[_key];
    }
    items.forEach(function(item) {
      if (arr.includes(item)) {
        return;
      }
      arr.push(item);
    });
    return arr;
  }
  function stringToArray(str, separator) {
    return str ? str.split(separator) : [];
  }
  function isInRange(testVal, min2, max2) {
    var minOK = min2 === void 0 || testVal >= min2;
    var maxOK = max2 === void 0 || testVal <= max2;
    return minOK && maxOK;
  }
  function limitToRange(val, min2, max2) {
    if (val < min2) {
      return min2;
    }
    if (val > max2) {
      return max2;
    }
    return val;
  }
  function createTagRepeat(tagName, repeat) {
    var attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var index3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    var html = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "";
    var openTagSrc = Object.keys(attributes).reduce(function(src, attr) {
      var val = attributes[attr];
      if (typeof val === "function") {
        val = val(index3);
      }
      return "".concat(src, " ").concat(attr, '="').concat(val, '"');
    }, tagName);
    html += "<".concat(openTagSrc, "></").concat(tagName, ">");
    var next = index3 + 1;
    return next < repeat ? createTagRepeat(tagName, repeat, attributes, next, html) : html;
  }
  function optimizeTemplateHTML(html) {
    return html.replace(/>\s+/g, ">").replace(/\s+</, "<");
  }
  function stripTime(timeValue) {
    return new Date(timeValue).setHours(0, 0, 0, 0);
  }
  function today() {
    return (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0);
  }
  function dateValue() {
    switch (arguments.length) {
      case 0:
        return today();
      case 1:
        return stripTime(arguments.length <= 0 ? void 0 : arguments[0]);
    }
    var newDate = /* @__PURE__ */ new Date(0);
    newDate.setFullYear.apply(newDate, arguments);
    return newDate.setHours(0, 0, 0, 0);
  }
  function addDays(date, amount) {
    var newDate = new Date(date);
    return newDate.setDate(newDate.getDate() + amount);
  }
  function addWeeks(date, amount) {
    return addDays(date, amount * 7);
  }
  function addMonths(date, amount) {
    var newDate = new Date(date);
    var monthsToSet = newDate.getMonth() + amount;
    var expectedMonth = monthsToSet % 12;
    if (expectedMonth < 0) {
      expectedMonth += 12;
    }
    var time = newDate.setMonth(monthsToSet);
    return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time;
  }
  function addYears(date, amount) {
    var newDate = new Date(date);
    var expectedMonth = newDate.getMonth();
    var time = newDate.setFullYear(newDate.getFullYear() + amount);
    return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time;
  }
  function dayDiff(day, from2) {
    return (day - from2 + 7) % 7;
  }
  function dayOfTheWeekOf(baseDate, dayOfWeek) {
    var weekStart = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var baseDay = new Date(baseDate).getDay();
    return addDays(baseDate, dayDiff(dayOfWeek, weekStart) - dayDiff(baseDay, weekStart));
  }
  function getWeek(date) {
    var thuOfTheWeek = dayOfTheWeekOf(date, 4, 1);
    var firstThu = dayOfTheWeekOf(new Date(thuOfTheWeek).setMonth(0, 4), 4, 1);
    return Math.round((thuOfTheWeek - firstThu) / 6048e5) + 1;
  }
  function startOfYearPeriod(date, years) {
    var year = new Date(date).getFullYear();
    return Math.floor(year / years) * years;
  }
  var reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;
  var reNonDateParts = /[\s!-/:-@[-`{-~]+/;
  var knownFormats = {};
  var parseFns = {
    y: function y(date, year) {
      return new Date(date).setFullYear(parseInt(year, 10));
    },
    m: function m(date, month, locale) {
      var newDate = new Date(date);
      var monthIndex = parseInt(month, 10) - 1;
      if (isNaN(monthIndex)) {
        if (!month) {
          return NaN;
        }
        var monthName = month.toLowerCase();
        var compareNames = function compareNames2(name) {
          return name.toLowerCase().startsWith(monthName);
        };
        monthIndex = locale.monthsShort.findIndex(compareNames);
        if (monthIndex < 0) {
          monthIndex = locale.months.findIndex(compareNames);
        }
        if (monthIndex < 0) {
          return NaN;
        }
      }
      newDate.setMonth(monthIndex);
      return newDate.getMonth() !== normalizeMonth(monthIndex) ? newDate.setDate(0) : newDate.getTime();
    },
    d: function d(date, day) {
      return new Date(date).setDate(parseInt(day, 10));
    }
  };
  var formatFns = {
    d: function d2(date) {
      return date.getDate();
    },
    dd: function dd(date) {
      return padZero(date.getDate(), 2);
    },
    D: function D(date, locale) {
      return locale.daysShort[date.getDay()];
    },
    DD: function DD(date, locale) {
      return locale.days[date.getDay()];
    },
    m: function m2(date) {
      return date.getMonth() + 1;
    },
    mm: function mm(date) {
      return padZero(date.getMonth() + 1, 2);
    },
    M: function M(date, locale) {
      return locale.monthsShort[date.getMonth()];
    },
    MM: function MM(date, locale) {
      return locale.months[date.getMonth()];
    },
    y: function y2(date) {
      return date.getFullYear();
    },
    yy: function yy(date) {
      return padZero(date.getFullYear(), 2).slice(-2);
    },
    yyyy: function yyyy(date) {
      return padZero(date.getFullYear(), 4);
    }
  };
  function normalizeMonth(monthIndex) {
    return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);
  }
  function padZero(num, length) {
    return num.toString().padStart(length, "0");
  }
  function parseFormatString(format) {
    if (typeof format !== "string") {
      throw new Error("Invalid date format.");
    }
    if (format in knownFormats) {
      return knownFormats[format];
    }
    var separators = format.split(reFormatTokens);
    var parts = format.match(new RegExp(reFormatTokens, "g"));
    if (separators.length === 0 || !parts) {
      throw new Error("Invalid date format.");
    }
    var partFormatters = parts.map(function(token) {
      return formatFns[token];
    });
    var partParserKeys = Object.keys(parseFns).reduce(function(keys, key) {
      var token = parts.find(function(part) {
        return part[0] !== "D" && part[0].toLowerCase() === key;
      });
      if (token) {
        keys.push(key);
      }
      return keys;
    }, []);
    return knownFormats[format] = {
      parser: function parser(dateStr, locale) {
        var dateParts = dateStr.split(reNonDateParts).reduce(function(dtParts, part, index3) {
          if (part.length > 0 && parts[index3]) {
            var token = parts[index3][0];
            if (token === "M") {
              dtParts.m = part;
            } else if (token !== "D") {
              dtParts[token] = part;
            }
          }
          return dtParts;
        }, {});
        return partParserKeys.reduce(function(origDate, key) {
          var newDate = parseFns[key](origDate, dateParts[key], locale);
          return isNaN(newDate) ? origDate : newDate;
        }, today());
      },
      formatter: function formatter(date, locale) {
        var dateStr = partFormatters.reduce(function(str, fn2, index3) {
          return str += "".concat(separators[index3]).concat(fn2(date, locale));
        }, "");
        return dateStr += lastItemOf(separators);
      }
    };
  }
  function parseDate(dateStr, format, locale) {
    if (dateStr instanceof Date || typeof dateStr === "number") {
      var date = stripTime(dateStr);
      return isNaN(date) ? void 0 : date;
    }
    if (!dateStr) {
      return void 0;
    }
    if (dateStr === "today") {
      return today();
    }
    if (format && format.toValue) {
      var _date = format.toValue(dateStr, format, locale);
      return isNaN(_date) ? void 0 : stripTime(_date);
    }
    return parseFormatString(format).parser(dateStr, locale);
  }
  function formatDate(date, format, locale) {
    if (isNaN(date) || !date && date !== 0) {
      return "";
    }
    var dateObj = typeof date === "number" ? new Date(date) : date;
    if (format.toDisplay) {
      return format.toDisplay(dateObj, format, locale);
    }
    return parseFormatString(format).formatter(dateObj, locale);
  }
  var listenerRegistry = /* @__PURE__ */ new WeakMap();
  var _EventTarget$prototyp = EventTarget.prototype;
  var addEventListener = _EventTarget$prototyp.addEventListener;
  var removeEventListener = _EventTarget$prototyp.removeEventListener;
  function registerListeners(keyObj, listeners) {
    var registered = listenerRegistry.get(keyObj);
    if (!registered) {
      registered = [];
      listenerRegistry.set(keyObj, registered);
    }
    listeners.forEach(function(listener) {
      addEventListener.call.apply(addEventListener, _toConsumableArray(listener));
      registered.push(listener);
    });
  }
  function unregisterListeners(keyObj) {
    var listeners = listenerRegistry.get(keyObj);
    if (!listeners) {
      return;
    }
    listeners.forEach(function(listener) {
      removeEventListener.call.apply(removeEventListener, _toConsumableArray(listener));
    });
    listenerRegistry["delete"](keyObj);
  }
  if (!Event.prototype.composedPath) {
    getComposedPath = function getComposedPath2(node) {
      var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      path.push(node);
      var parent;
      if (node.parentNode) {
        parent = node.parentNode;
      } else if (node.host) {
        parent = node.host;
      } else if (node.defaultView) {
        parent = node.defaultView;
      }
      return parent ? getComposedPath2(parent, path) : path;
    };
    Event.prototype.composedPath = function() {
      return getComposedPath(this.target);
    };
  }
  var getComposedPath;
  function findFromPath(path, criteria, currentTarget) {
    var index3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    var el2 = path[index3];
    if (criteria(el2)) {
      return el2;
    } else if (el2 === currentTarget || !el2.parentElement) {
      return;
    }
    return findFromPath(path, criteria, currentTarget, index3 + 1);
  }
  function findElementInEventPath(ev, selector) {
    var criteria = typeof selector === "function" ? selector : function(el2) {
      return el2.matches(selector);
    };
    return findFromPath(ev.composedPath(), criteria, ev.currentTarget);
  }
  var locales = {
    en: {
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      today: "Today",
      clear: "Clear",
      titleFormat: "MM y"
    }
  };
  var defaultOptions = {
    autohide: false,
    beforeShowDay: null,
    beforeShowDecade: null,
    beforeShowMonth: null,
    beforeShowYear: null,
    calendarWeeks: false,
    clearBtn: false,
    dateDelimiter: ",",
    datesDisabled: [],
    daysOfWeekDisabled: [],
    daysOfWeekHighlighted: [],
    defaultViewDate: void 0,
    // placeholder, defaults to today() by the program
    disableTouchKeyboard: false,
    format: "mm/dd/yyyy",
    language: "en",
    maxDate: null,
    maxNumberOfDates: 1,
    maxView: 3,
    minDate: null,
    nextArrow: '<svg class="w-4 h-4 rtl:rotate-180 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 10"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 5h12m0 0L9 1m4 4L9 9"/></svg>',
    orientation: "auto",
    pickLevel: 0,
    prevArrow: '<svg class="w-4 h-4 rtl:rotate-180 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 10"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5H1m0 0 4 4M1 5l4-4"/></svg>',
    showDaysOfWeek: true,
    showOnClick: true,
    showOnFocus: true,
    startView: 0,
    title: "",
    todayBtn: false,
    todayBtnMode: 0,
    todayHighlight: false,
    updateOnBlur: true,
    weekStart: 0
  };
  var range2 = null;
  function parseHTML(html) {
    if (range2 == null) {
      range2 = document.createRange();
    }
    return range2.createContextualFragment(html);
  }
  function hideElement(el2) {
    if (el2.style.display === "none") {
      return;
    }
    if (el2.style.display) {
      el2.dataset.styleDisplay = el2.style.display;
    }
    el2.style.display = "none";
  }
  function showElement(el2) {
    if (el2.style.display !== "none") {
      return;
    }
    if (el2.dataset.styleDisplay) {
      el2.style.display = el2.dataset.styleDisplay;
      delete el2.dataset.styleDisplay;
    } else {
      el2.style.display = "";
    }
  }
  function emptyChildNodes(el2) {
    if (el2.firstChild) {
      el2.removeChild(el2.firstChild);
      emptyChildNodes(el2);
    }
  }
  function replaceChildNodes(el2, newChildNodes) {
    emptyChildNodes(el2);
    if (newChildNodes instanceof DocumentFragment) {
      el2.appendChild(newChildNodes);
    } else if (typeof newChildNodes === "string") {
      el2.appendChild(parseHTML(newChildNodes));
    } else if (typeof newChildNodes.forEach === "function") {
      newChildNodes.forEach(function(node) {
        el2.appendChild(node);
      });
    }
  }
  var defaultLang = defaultOptions.language;
  var defaultFormat = defaultOptions.format;
  var defaultWeekStart = defaultOptions.weekStart;
  function sanitizeDOW(dow, day) {
    return dow.length < 6 && day >= 0 && day < 7 ? pushUnique(dow, day) : dow;
  }
  function calcEndOfWeek(startOfWeek) {
    return (startOfWeek + 6) % 7;
  }
  function validateDate(value, format, locale, origValue) {
    var date = parseDate(value, format, locale);
    return date !== void 0 ? date : origValue;
  }
  function validateViewId(value, origValue) {
    var max2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3;
    var viewId = parseInt(value, 10);
    return viewId >= 0 && viewId <= max2 ? viewId : origValue;
  }
  function processOptions(options, datepicker) {
    var inOpts = Object.assign({}, options);
    var config = {};
    var locales2 = datepicker.constructor.locales;
    var _ref = datepicker.config || {}, format = _ref.format, language = _ref.language, locale = _ref.locale, maxDate = _ref.maxDate, maxView = _ref.maxView, minDate = _ref.minDate, pickLevel = _ref.pickLevel, startView = _ref.startView, weekStart = _ref.weekStart;
    if (inOpts.language) {
      var lang;
      if (inOpts.language !== language) {
        if (locales2[inOpts.language]) {
          lang = inOpts.language;
        } else {
          lang = inOpts.language.split("-")[0];
          if (locales2[lang] === void 0) {
            lang = false;
          }
        }
      }
      delete inOpts.language;
      if (lang) {
        language = config.language = lang;
        var origLocale = locale || locales2[defaultLang];
        locale = Object.assign({
          format: defaultFormat,
          weekStart: defaultWeekStart
        }, locales2[defaultLang]);
        if (language !== defaultLang) {
          Object.assign(locale, locales2[language]);
        }
        config.locale = locale;
        if (format === origLocale.format) {
          format = config.format = locale.format;
        }
        if (weekStart === origLocale.weekStart) {
          weekStart = config.weekStart = locale.weekStart;
          config.weekEnd = calcEndOfWeek(locale.weekStart);
        }
      }
    }
    if (inOpts.format) {
      var hasToDisplay = typeof inOpts.format.toDisplay === "function";
      var hasToValue = typeof inOpts.format.toValue === "function";
      var validFormatString = reFormatTokens.test(inOpts.format);
      if (hasToDisplay && hasToValue || validFormatString) {
        format = config.format = inOpts.format;
      }
      delete inOpts.format;
    }
    var minDt = minDate;
    var maxDt = maxDate;
    if (inOpts.minDate !== void 0) {
      minDt = inOpts.minDate === null ? dateValue(0, 0, 1) : validateDate(inOpts.minDate, format, locale, minDt);
      delete inOpts.minDate;
    }
    if (inOpts.maxDate !== void 0) {
      maxDt = inOpts.maxDate === null ? void 0 : validateDate(inOpts.maxDate, format, locale, maxDt);
      delete inOpts.maxDate;
    }
    if (maxDt < minDt) {
      minDate = config.minDate = maxDt;
      maxDate = config.maxDate = minDt;
    } else {
      if (minDate !== minDt) {
        minDate = config.minDate = minDt;
      }
      if (maxDate !== maxDt) {
        maxDate = config.maxDate = maxDt;
      }
    }
    if (inOpts.datesDisabled) {
      config.datesDisabled = inOpts.datesDisabled.reduce(function(dates, dt) {
        var date = parseDate(dt, format, locale);
        return date !== void 0 ? pushUnique(dates, date) : dates;
      }, []);
      delete inOpts.datesDisabled;
    }
    if (inOpts.defaultViewDate !== void 0) {
      var viewDate = parseDate(inOpts.defaultViewDate, format, locale);
      if (viewDate !== void 0) {
        config.defaultViewDate = viewDate;
      }
      delete inOpts.defaultViewDate;
    }
    if (inOpts.weekStart !== void 0) {
      var wkStart = Number(inOpts.weekStart) % 7;
      if (!isNaN(wkStart)) {
        weekStart = config.weekStart = wkStart;
        config.weekEnd = calcEndOfWeek(wkStart);
      }
      delete inOpts.weekStart;
    }
    if (inOpts.daysOfWeekDisabled) {
      config.daysOfWeekDisabled = inOpts.daysOfWeekDisabled.reduce(sanitizeDOW, []);
      delete inOpts.daysOfWeekDisabled;
    }
    if (inOpts.daysOfWeekHighlighted) {
      config.daysOfWeekHighlighted = inOpts.daysOfWeekHighlighted.reduce(sanitizeDOW, []);
      delete inOpts.daysOfWeekHighlighted;
    }
    if (inOpts.maxNumberOfDates !== void 0) {
      var maxNumberOfDates = parseInt(inOpts.maxNumberOfDates, 10);
      if (maxNumberOfDates >= 0) {
        config.maxNumberOfDates = maxNumberOfDates;
        config.multidate = maxNumberOfDates !== 1;
      }
      delete inOpts.maxNumberOfDates;
    }
    if (inOpts.dateDelimiter) {
      config.dateDelimiter = String(inOpts.dateDelimiter);
      delete inOpts.dateDelimiter;
    }
    var newPickLevel = pickLevel;
    if (inOpts.pickLevel !== void 0) {
      newPickLevel = validateViewId(inOpts.pickLevel, 2);
      delete inOpts.pickLevel;
    }
    if (newPickLevel !== pickLevel) {
      pickLevel = config.pickLevel = newPickLevel;
    }
    var newMaxView = maxView;
    if (inOpts.maxView !== void 0) {
      newMaxView = validateViewId(inOpts.maxView, maxView);
      delete inOpts.maxView;
    }
    newMaxView = pickLevel > newMaxView ? pickLevel : newMaxView;
    if (newMaxView !== maxView) {
      maxView = config.maxView = newMaxView;
    }
    var newStartView = startView;
    if (inOpts.startView !== void 0) {
      newStartView = validateViewId(inOpts.startView, newStartView);
      delete inOpts.startView;
    }
    if (newStartView < pickLevel) {
      newStartView = pickLevel;
    } else if (newStartView > maxView) {
      newStartView = maxView;
    }
    if (newStartView !== startView) {
      config.startView = newStartView;
    }
    if (inOpts.prevArrow) {
      var prevArrow = parseHTML(inOpts.prevArrow);
      if (prevArrow.childNodes.length > 0) {
        config.prevArrow = prevArrow.childNodes;
      }
      delete inOpts.prevArrow;
    }
    if (inOpts.nextArrow) {
      var nextArrow = parseHTML(inOpts.nextArrow);
      if (nextArrow.childNodes.length > 0) {
        config.nextArrow = nextArrow.childNodes;
      }
      delete inOpts.nextArrow;
    }
    if (inOpts.disableTouchKeyboard !== void 0) {
      config.disableTouchKeyboard = "ontouchstart" in document && !!inOpts.disableTouchKeyboard;
      delete inOpts.disableTouchKeyboard;
    }
    if (inOpts.orientation) {
      var orientation = inOpts.orientation.toLowerCase().split(/\s+/g);
      config.orientation = {
        x: orientation.find(function(x) {
          return x === "left" || x === "right";
        }) || "auto",
        y: orientation.find(function(y3) {
          return y3 === "top" || y3 === "bottom";
        }) || "auto"
      };
      delete inOpts.orientation;
    }
    if (inOpts.todayBtnMode !== void 0) {
      switch (inOpts.todayBtnMode) {
        case 0:
        case 1:
          config.todayBtnMode = inOpts.todayBtnMode;
      }
      delete inOpts.todayBtnMode;
    }
    Object.keys(inOpts).forEach(function(key) {
      if (inOpts[key] !== void 0 && hasProperty(defaultOptions, key)) {
        config[key] = inOpts[key];
      }
    });
    return config;
  }
  var pickerTemplate = optimizeTemplateHTML('<div class="datepicker hidden">\n  <div class="datepicker-picker inline-block rounded-lg bg-white dark:bg-gray-700 shadow-lg p-4">\n    <div class="datepicker-header">\n      <div class="datepicker-title bg-white dark:bg-gray-700 dark:text-white px-2 py-3 text-center font-semibold"></div>\n      <div class="datepicker-controls flex justify-between mb-2">\n        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 prev-btn"></button>\n        <button type="button" class="text-sm rounded-lg text-gray-900 dark:text-white bg-white dark:bg-gray-700 font-semibold py-2.5 px-5 hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-200 view-switch"></button>\n        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 next-btn"></button>\n      </div>\n    </div>\n    <div class="datepicker-main p-1"></div>\n    <div class="datepicker-footer">\n      <div class="datepicker-controls flex space-x-2 rtl:space-x-reverse mt-2">\n        <button type="button" class="%buttonClass% today-btn text-white bg-blue-700 !bg-primary-700 dark:bg-blue-600 dark:!bg-primary-600 hover:bg-blue-800 hover:!bg-primary-800 dark:hover:bg-blue-700 dark:hover:!bg-primary-700 focus:ring-4 focus:ring-blue-300 focus:!ring-primary-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>\n        <button type="button" class="%buttonClass% clear-btn text-gray-900 dark:text-white bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-600 focus:ring-4 focus:ring-blue-300 focus:!ring-primary-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>\n      </div>\n    </div>\n  </div>\n</div>');
  var daysTemplate = optimizeTemplateHTML('<div class="days">\n  <div class="days-of-week grid grid-cols-7 mb-1">'.concat(createTagRepeat("span", 7, {
    "class": "dow block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm"
  }), '</div>\n  <div class="datepicker-grid w-64 grid grid-cols-7">').concat(createTagRepeat("span", 42, {
    "class": "block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400"
  }), "</div>\n</div>"));
  var calendarWeeksTemplate = optimizeTemplateHTML('<div class="calendar-weeks">\n  <div class="days-of-week flex"><span class="dow h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400"></span></div>\n  <div class="weeks">'.concat(createTagRepeat("span", 6, {
    "class": "week block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm"
  }), "</div>\n</div>"));
  var View2 = /* @__PURE__ */ function() {
    function View3(picker, config) {
      _classCallCheck(this, View3);
      Object.assign(this, config, {
        picker,
        element: parseHTML('<div class="datepicker-view flex"></div>').firstChild,
        selected: []
      });
      this.init(this.picker.datepicker.config);
    }
    return _createClass(View3, [{
      key: "init",
      value: function init(options) {
        if (options.pickLevel !== void 0) {
          this.isMinView = this.id === options.pickLevel;
        }
        this.setOptions(options);
        this.updateFocus();
        this.updateSelection();
      }
      // Execute beforeShow() callback and apply the result to the element
      // args:
      // - current - current value on the iteration on view rendering
      // - timeValue - time value of the date to pass to beforeShow()
    }, {
      key: "performBeforeHook",
      value: function performBeforeHook(el2, current, timeValue) {
        var result = this.beforeShow(new Date(timeValue));
        switch (_typeof2(result)) {
          case "boolean":
            result = {
              enabled: result
            };
            break;
          case "string":
            result = {
              classes: result
            };
        }
        if (result) {
          if (result.enabled === false) {
            el2.classList.add("disabled");
            pushUnique(this.disabled, current);
          }
          if (result.classes) {
            var _el$classList;
            var extraClasses = result.classes.split(/\s+/);
            (_el$classList = el2.classList).add.apply(_el$classList, _toConsumableArray(extraClasses));
            if (extraClasses.includes("disabled")) {
              pushUnique(this.disabled, current);
            }
          }
          if (result.content) {
            replaceChildNodes(el2, result.content);
          }
        }
      }
    }]);
  }();
  var DaysView = /* @__PURE__ */ function(_View2) {
    function DaysView2(picker) {
      _classCallCheck(this, DaysView2);
      return _callSuper(this, DaysView2, [picker, {
        id: 0,
        name: "days",
        cellClass: "day"
      }]);
    }
    _inherits(DaysView2, _View2);
    return _createClass(DaysView2, [{
      key: "init",
      value: function init(options) {
        var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        if (onConstruction) {
          var inner = parseHTML(daysTemplate).firstChild;
          this.dow = inner.firstChild;
          this.grid = inner.lastChild;
          this.element.appendChild(inner);
        }
        _get(_getPrototypeOf(DaysView2.prototype), "init", this).call(this, options);
      }
    }, {
      key: "setOptions",
      value: function setOptions(options) {
        var _this = this;
        var updateDOW;
        if (hasProperty(options, "minDate")) {
          this.minDate = options.minDate;
        }
        if (hasProperty(options, "maxDate")) {
          this.maxDate = options.maxDate;
        }
        if (options.datesDisabled) {
          this.datesDisabled = options.datesDisabled;
        }
        if (options.daysOfWeekDisabled) {
          this.daysOfWeekDisabled = options.daysOfWeekDisabled;
          updateDOW = true;
        }
        if (options.daysOfWeekHighlighted) {
          this.daysOfWeekHighlighted = options.daysOfWeekHighlighted;
        }
        if (options.todayHighlight !== void 0) {
          this.todayHighlight = options.todayHighlight;
        }
        if (options.weekStart !== void 0) {
          this.weekStart = options.weekStart;
          this.weekEnd = options.weekEnd;
          updateDOW = true;
        }
        if (options.locale) {
          var locale = this.locale = options.locale;
          this.dayNames = locale.daysMin;
          this.switchLabelFormat = locale.titleFormat;
          updateDOW = true;
        }
        if (options.beforeShowDay !== void 0) {
          this.beforeShow = typeof options.beforeShowDay === "function" ? options.beforeShowDay : void 0;
        }
        if (options.calendarWeeks !== void 0) {
          if (options.calendarWeeks && !this.calendarWeeks) {
            var weeksElem = parseHTML(calendarWeeksTemplate).firstChild;
            this.calendarWeeks = {
              element: weeksElem,
              dow: weeksElem.firstChild,
              weeks: weeksElem.lastChild
            };
            this.element.insertBefore(weeksElem, this.element.firstChild);
          } else if (this.calendarWeeks && !options.calendarWeeks) {
            this.element.removeChild(this.calendarWeeks.element);
            this.calendarWeeks = null;
          }
        }
        if (options.showDaysOfWeek !== void 0) {
          if (options.showDaysOfWeek) {
            showElement(this.dow);
            if (this.calendarWeeks) {
              showElement(this.calendarWeeks.dow);
            }
          } else {
            hideElement(this.dow);
            if (this.calendarWeeks) {
              hideElement(this.calendarWeeks.dow);
            }
          }
        }
        if (updateDOW) {
          Array.from(this.dow.children).forEach(function(el2, index3) {
            var dow = (_this.weekStart + index3) % 7;
            el2.textContent = _this.dayNames[dow];
            el2.className = _this.daysOfWeekDisabled.includes(dow) ? "dow disabled text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400 cursor-not-allowed" : "dow text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400";
          });
        }
      }
      // Apply update on the focused date to view's settings
    }, {
      key: "updateFocus",
      value: function updateFocus() {
        var viewDate = new Date(this.picker.viewDate);
        var viewYear = viewDate.getFullYear();
        var viewMonth = viewDate.getMonth();
        var firstOfMonth = dateValue(viewYear, viewMonth, 1);
        var start2 = dayOfTheWeekOf(firstOfMonth, this.weekStart, this.weekStart);
        this.first = firstOfMonth;
        this.last = dateValue(viewYear, viewMonth + 1, 0);
        this.start = start2;
        this.focused = this.picker.viewDate;
      }
      // Apply update on the selected dates to view's settings
    }, {
      key: "updateSelection",
      value: function updateSelection() {
        var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
        this.selected = dates;
        if (rangepicker) {
          this.range = rangepicker.dates;
        }
      }
      // Update the entire view UI
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        this.today = this.todayHighlight ? today() : void 0;
        this.disabled = _toConsumableArray(this.datesDisabled);
        var switchLabel = formatDate(this.focused, this.switchLabelFormat, this.locale);
        this.picker.setViewSwitchLabel(switchLabel);
        this.picker.setPrevBtnDisabled(this.first <= this.minDate);
        this.picker.setNextBtnDisabled(this.last >= this.maxDate);
        if (this.calendarWeeks) {
          var startOfWeek = dayOfTheWeekOf(this.first, 1, 1);
          Array.from(this.calendarWeeks.weeks.children).forEach(function(el2, index3) {
            el2.textContent = getWeek(addWeeks(startOfWeek, index3));
          });
        }
        Array.from(this.grid.children).forEach(function(el2, index3) {
          var classList = el2.classList;
          var current = addDays(_this2.start, index3);
          var date = new Date(current);
          var day = date.getDay();
          el2.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this2.cellClass);
          el2.dataset.date = current;
          el2.textContent = date.getDate();
          if (current < _this2.first) {
            classList.add("prev", "text-gray-500", "dark:text-white");
          } else if (current > _this2.last) {
            classList.add("next", "text-gray-500", "dark:text-white");
          }
          if (_this2.today === current) {
            classList.add("today", "bg-gray-100", "dark:bg-gray-600");
          }
          if (current < _this2.minDate || current > _this2.maxDate || _this2.disabled.includes(current)) {
            classList.add("disabled", "cursor-not-allowed", "text-gray-400", "dark:text-gray-500");
            classList.remove("hover:bg-gray-100", "dark:hover:bg-gray-600", "text-gray-900", "dark:text-white", "cursor-pointer");
          }
          if (_this2.daysOfWeekDisabled.includes(day)) {
            classList.add("disabled", "cursor-not-allowed", "text-gray-400", "dark:text-gray-500");
            classList.remove("hover:bg-gray-100", "dark:hover:bg-gray-600", "text-gray-900", "dark:text-white", "cursor-pointer");
            pushUnique(_this2.disabled, current);
          }
          if (_this2.daysOfWeekHighlighted.includes(day)) {
            classList.add("highlighted");
          }
          if (_this2.range) {
            var _this2$range = _slicedToArray(_this2.range, 2), rangeStart = _this2$range[0], rangeEnd = _this2$range[1];
            if (current > rangeStart && current < rangeEnd) {
              classList.add("range", "bg-gray-200", "dark:bg-gray-600");
              classList.remove("rounded-lg", "rounded-l-lg", "rounded-r-lg");
            }
            if (current === rangeStart) {
              classList.add("range-start", "bg-gray-100", "dark:bg-gray-600", "rounded-l-lg");
              classList.remove("rounded-lg", "rounded-r-lg");
            }
            if (current === rangeEnd) {
              classList.add("range-end", "bg-gray-100", "dark:bg-gray-600", "rounded-r-lg");
              classList.remove("rounded-lg", "rounded-l-lg");
            }
          }
          if (_this2.selected.includes(current)) {
            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
            classList.remove("text-gray-900", "text-gray-500", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600", "dark:bg-gray-600", "bg-gray-100", "bg-gray-200");
          }
          if (current === _this2.focused) {
            classList.add("focused");
          }
          if (_this2.beforeShow) {
            _this2.performBeforeHook(el2, current, current);
          }
        });
      }
      // Update the view UI by applying the changes of selected and focused items
    }, {
      key: "refresh",
      value: function refresh() {
        var _this3 = this;
        var _ref = this.range || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
        this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el2) {
          el2.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white", "focused");
          el2.classList.add("text-gray-900", "rounded-lg", "dark:text-white");
        });
        Array.from(this.grid.children).forEach(function(el2) {
          var current = Number(el2.dataset.date);
          var classList = el2.classList;
          classList.remove("bg-gray-200", "dark:bg-gray-600", "rounded-l-lg", "rounded-r-lg");
          if (current > rangeStart && current < rangeEnd) {
            classList.add("range", "bg-gray-200", "dark:bg-gray-600");
            classList.remove("rounded-lg");
          }
          if (current === rangeStart) {
            classList.add("range-start", "bg-gray-200", "dark:bg-gray-600", "rounded-l-lg");
            classList.remove("rounded-lg");
          }
          if (current === rangeEnd) {
            classList.add("range-end", "bg-gray-200", "dark:bg-gray-600", "rounded-r-lg");
            classList.remove("rounded-lg");
          }
          if (_this3.selected.includes(current)) {
            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
            classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600", "bg-gray-100", "bg-gray-200", "dark:bg-gray-600");
          }
          if (current === _this3.focused) {
            classList.add("focused");
          }
        });
      }
      // Update the view UI by applying the change of focused item
    }, {
      key: "refreshFocus",
      value: function refreshFocus() {
        var index3 = Math.round((this.focused - this.start) / 864e5);
        this.grid.querySelectorAll(".focused").forEach(function(el2) {
          el2.classList.remove("focused");
        });
        this.grid.children[index3].classList.add("focused");
      }
    }]);
  }(View2);
  function computeMonthRange(range3, thisYear) {
    if (!range3 || !range3[0] || !range3[1]) {
      return;
    }
    var _range = _slicedToArray(range3, 2), _range$ = _slicedToArray(_range[0], 2), startY = _range$[0], startM = _range$[1], _range$2 = _slicedToArray(_range[1], 2), endY = _range$2[0], endM = _range$2[1];
    if (startY > thisYear || endY < thisYear) {
      return;
    }
    return [startY === thisYear ? startM : -1, endY === thisYear ? endM : 12];
  }
  var MonthsView = /* @__PURE__ */ function(_View2) {
    function MonthsView2(picker) {
      _classCallCheck(this, MonthsView2);
      return _callSuper(this, MonthsView2, [picker, {
        id: 1,
        name: "months",
        cellClass: "month"
      }]);
    }
    _inherits(MonthsView2, _View2);
    return _createClass(MonthsView2, [{
      key: "init",
      value: function init(options) {
        var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        if (onConstruction) {
          this.grid = this.element;
          this.element.classList.add("months", "datepicker-grid", "w-64", "grid", "grid-cols-4");
          this.grid.appendChild(parseHTML(createTagRepeat("span", 12, {
            "data-month": function dataMonth(ix) {
              return ix;
            }
          })));
        }
        _get(_getPrototypeOf(MonthsView2.prototype), "init", this).call(this, options);
      }
    }, {
      key: "setOptions",
      value: function setOptions(options) {
        if (options.locale) {
          this.monthNames = options.locale.monthsShort;
        }
        if (hasProperty(options, "minDate")) {
          if (options.minDate === void 0) {
            this.minYear = this.minMonth = this.minDate = void 0;
          } else {
            var minDateObj = new Date(options.minDate);
            this.minYear = minDateObj.getFullYear();
            this.minMonth = minDateObj.getMonth();
            this.minDate = minDateObj.setDate(1);
          }
        }
        if (hasProperty(options, "maxDate")) {
          if (options.maxDate === void 0) {
            this.maxYear = this.maxMonth = this.maxDate = void 0;
          } else {
            var maxDateObj = new Date(options.maxDate);
            this.maxYear = maxDateObj.getFullYear();
            this.maxMonth = maxDateObj.getMonth();
            this.maxDate = dateValue(this.maxYear, this.maxMonth + 1, 0);
          }
        }
        if (options.beforeShowMonth !== void 0) {
          this.beforeShow = typeof options.beforeShowMonth === "function" ? options.beforeShowMonth : void 0;
        }
      }
      // Update view's settings to reflect the viewDate set on the picker
    }, {
      key: "updateFocus",
      value: function updateFocus() {
        var viewDate = new Date(this.picker.viewDate);
        this.year = viewDate.getFullYear();
        this.focused = viewDate.getMonth();
      }
      // Update view's settings to reflect the selected dates
    }, {
      key: "updateSelection",
      value: function updateSelection() {
        var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
        this.selected = dates.reduce(function(selected, timeValue) {
          var date = new Date(timeValue);
          var year = date.getFullYear();
          var month = date.getMonth();
          if (selected[year] === void 0) {
            selected[year] = [month];
          } else {
            pushUnique(selected[year], month);
          }
          return selected;
        }, {});
        if (rangepicker && rangepicker.dates) {
          this.range = rangepicker.dates.map(function(timeValue) {
            var date = new Date(timeValue);
            return isNaN(date) ? void 0 : [date.getFullYear(), date.getMonth()];
          });
        }
      }
      // Update the entire view UI
    }, {
      key: "render",
      value: function render() {
        var _this = this;
        this.disabled = [];
        this.picker.setViewSwitchLabel(this.year);
        this.picker.setPrevBtnDisabled(this.year <= this.minYear);
        this.picker.setNextBtnDisabled(this.year >= this.maxYear);
        var selected = this.selected[this.year] || [];
        var yrOutOfRange = this.year < this.minYear || this.year > this.maxYear;
        var isMinYear = this.year === this.minYear;
        var isMaxYear = this.year === this.maxYear;
        var range3 = computeMonthRange(this.range, this.year);
        Array.from(this.grid.children).forEach(function(el2, index3) {
          var classList = el2.classList;
          var date = dateValue(_this.year, index3, 1);
          el2.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this.cellClass);
          if (_this.isMinView) {
            el2.dataset.date = date;
          }
          el2.textContent = _this.monthNames[index3];
          if (yrOutOfRange || isMinYear && index3 < _this.minMonth || isMaxYear && index3 > _this.maxMonth) {
            classList.add("disabled");
          }
          if (range3) {
            var _range2 = _slicedToArray(range3, 2), rangeStart = _range2[0], rangeEnd = _range2[1];
            if (index3 > rangeStart && index3 < rangeEnd) {
              classList.add("range");
            }
            if (index3 === rangeStart) {
              classList.add("range-start");
            }
            if (index3 === rangeEnd) {
              classList.add("range-end");
            }
          }
          if (selected.includes(index3)) {
            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
            classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
          }
          if (index3 === _this.focused) {
            classList.add("focused");
          }
          if (_this.beforeShow) {
            _this.performBeforeHook(el2, index3, date);
          }
        });
      }
      // Update the view UI by applying the changes of selected and focused items
    }, {
      key: "refresh",
      value: function refresh() {
        var _this2 = this;
        var selected = this.selected[this.year] || [];
        var _ref = computeMonthRange(this.range, this.year) || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
        this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el2) {
          el2.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "dark:bg-blue-600", "dark:!bg-primary-700", "dark:text-white", "text-white", "focused");
          el2.classList.add("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
        });
        Array.from(this.grid.children).forEach(function(el2, index3) {
          var classList = el2.classList;
          if (index3 > rangeStart && index3 < rangeEnd) {
            classList.add("range");
          }
          if (index3 === rangeStart) {
            classList.add("range-start");
          }
          if (index3 === rangeEnd) {
            classList.add("range-end");
          }
          if (selected.includes(index3)) {
            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
            classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
          }
          if (index3 === _this2.focused) {
            classList.add("focused");
          }
        });
      }
      // Update the view UI by applying the change of focused item
    }, {
      key: "refreshFocus",
      value: function refreshFocus() {
        this.grid.querySelectorAll(".focused").forEach(function(el2) {
          el2.classList.remove("focused");
        });
        this.grid.children[this.focused].classList.add("focused");
      }
    }]);
  }(View2);
  function toTitleCase(word) {
    return _toConsumableArray(word).reduce(function(str, ch, ix) {
      return str += ix ? ch : ch.toUpperCase();
    }, "");
  }
  var YearsView = /* @__PURE__ */ function(_View2) {
    function YearsView2(picker, config) {
      _classCallCheck(this, YearsView2);
      return _callSuper(this, YearsView2, [picker, config]);
    }
    _inherits(YearsView2, _View2);
    return _createClass(YearsView2, [{
      key: "init",
      value: function init(options) {
        var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        if (onConstruction) {
          this.navStep = this.step * 10;
          this.beforeShowOption = "beforeShow".concat(toTitleCase(this.cellClass));
          this.grid = this.element;
          this.element.classList.add(this.name, "datepicker-grid", "w-64", "grid", "grid-cols-4");
          this.grid.appendChild(parseHTML(createTagRepeat("span", 12)));
        }
        _get(_getPrototypeOf(YearsView2.prototype), "init", this).call(this, options);
      }
    }, {
      key: "setOptions",
      value: function setOptions(options) {
        if (hasProperty(options, "minDate")) {
          if (options.minDate === void 0) {
            this.minYear = this.minDate = void 0;
          } else {
            this.minYear = startOfYearPeriod(options.minDate, this.step);
            this.minDate = dateValue(this.minYear, 0, 1);
          }
        }
        if (hasProperty(options, "maxDate")) {
          if (options.maxDate === void 0) {
            this.maxYear = this.maxDate = void 0;
          } else {
            this.maxYear = startOfYearPeriod(options.maxDate, this.step);
            this.maxDate = dateValue(this.maxYear, 11, 31);
          }
        }
        if (options[this.beforeShowOption] !== void 0) {
          var beforeShow = options[this.beforeShowOption];
          this.beforeShow = typeof beforeShow === "function" ? beforeShow : void 0;
        }
      }
      // Update view's settings to reflect the viewDate set on the picker
    }, {
      key: "updateFocus",
      value: function updateFocus() {
        var viewDate = new Date(this.picker.viewDate);
        var first = startOfYearPeriod(viewDate, this.navStep);
        var last = first + 9 * this.step;
        this.first = first;
        this.last = last;
        this.start = first - this.step;
        this.focused = startOfYearPeriod(viewDate, this.step);
      }
      // Update view's settings to reflect the selected dates
    }, {
      key: "updateSelection",
      value: function updateSelection() {
        var _this = this;
        var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
        this.selected = dates.reduce(function(years, timeValue) {
          return pushUnique(years, startOfYearPeriod(timeValue, _this.step));
        }, []);
        if (rangepicker && rangepicker.dates) {
          this.range = rangepicker.dates.map(function(timeValue) {
            if (timeValue !== void 0) {
              return startOfYearPeriod(timeValue, _this.step);
            }
          });
        }
      }
      // Update the entire view UI
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        this.disabled = [];
        this.picker.setViewSwitchLabel("".concat(this.first, "-").concat(this.last));
        this.picker.setPrevBtnDisabled(this.first <= this.minYear);
        this.picker.setNextBtnDisabled(this.last >= this.maxYear);
        Array.from(this.grid.children).forEach(function(el2, index3) {
          var classList = el2.classList;
          var current = _this2.start + index3 * _this2.step;
          var date = dateValue(current, 0, 1);
          el2.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this2.cellClass);
          if (_this2.isMinView) {
            el2.dataset.date = date;
          }
          el2.textContent = el2.dataset.year = current;
          if (index3 === 0) {
            classList.add("prev");
          } else if (index3 === 11) {
            classList.add("next");
          }
          if (current < _this2.minYear || current > _this2.maxYear) {
            classList.add("disabled");
          }
          if (_this2.range) {
            var _this2$range = _slicedToArray(_this2.range, 2), rangeStart = _this2$range[0], rangeEnd = _this2$range[1];
            if (current > rangeStart && current < rangeEnd) {
              classList.add("range");
            }
            if (current === rangeStart) {
              classList.add("range-start");
            }
            if (current === rangeEnd) {
              classList.add("range-end");
            }
          }
          if (_this2.selected.includes(current)) {
            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
            classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
          }
          if (current === _this2.focused) {
            classList.add("focused");
          }
          if (_this2.beforeShow) {
            _this2.performBeforeHook(el2, current, date);
          }
        });
      }
      // Update the view UI by applying the changes of selected and focused items
    }, {
      key: "refresh",
      value: function refresh() {
        var _this3 = this;
        var _ref = this.range || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
        this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el2) {
          el2.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark!bg-primary-600", "dark:text-white", "focused");
        });
        Array.from(this.grid.children).forEach(function(el2) {
          var current = Number(el2.textContent);
          var classList = el2.classList;
          if (current > rangeStart && current < rangeEnd) {
            classList.add("range");
          }
          if (current === rangeStart) {
            classList.add("range-start");
          }
          if (current === rangeEnd) {
            classList.add("range-end");
          }
          if (_this3.selected.includes(current)) {
            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
            classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
          }
          if (current === _this3.focused) {
            classList.add("focused");
          }
        });
      }
      // Update the view UI by applying the change of focused item
    }, {
      key: "refreshFocus",
      value: function refreshFocus() {
        var index3 = Math.round((this.focused - this.start) / this.step);
        this.grid.querySelectorAll(".focused").forEach(function(el2) {
          el2.classList.remove("focused");
        });
        this.grid.children[index3].classList.add("focused");
      }
    }]);
  }(View2);
  function triggerDatepickerEvent(datepicker, type) {
    var detail = {
      date: datepicker.getDate(),
      viewDate: new Date(datepicker.picker.viewDate),
      viewId: datepicker.picker.currentView.id,
      datepicker
    };
    datepicker.element.dispatchEvent(new CustomEvent(type, {
      detail
    }));
  }
  function goToPrevOrNext(datepicker, direction) {
    var _datepicker$config = datepicker.config, minDate = _datepicker$config.minDate, maxDate = _datepicker$config.maxDate;
    var _datepicker$picker = datepicker.picker, currentView = _datepicker$picker.currentView, viewDate = _datepicker$picker.viewDate;
    var newViewDate;
    switch (currentView.id) {
      case 0:
        newViewDate = addMonths(viewDate, direction);
        break;
      case 1:
        newViewDate = addYears(viewDate, direction);
        break;
      default:
        newViewDate = addYears(viewDate, direction * currentView.navStep);
    }
    newViewDate = limitToRange(newViewDate, minDate, maxDate);
    datepicker.picker.changeFocus(newViewDate).render();
  }
  function switchView(datepicker) {
    var viewId = datepicker.picker.currentView.id;
    if (viewId === datepicker.config.maxView) {
      return;
    }
    datepicker.picker.changeView(viewId + 1).render();
  }
  function unfocus(datepicker) {
    if (datepicker.config.updateOnBlur) {
      datepicker.update({
        autohide: true
      });
    } else {
      datepicker.refresh("input");
      datepicker.hide();
    }
  }
  function goToSelectedMonthOrYear(datepicker, selection) {
    var picker = datepicker.picker;
    var viewDate = new Date(picker.viewDate);
    var viewId = picker.currentView.id;
    var newDate = viewId === 1 ? addMonths(viewDate, selection - viewDate.getMonth()) : addYears(viewDate, selection - viewDate.getFullYear());
    picker.changeFocus(newDate).changeView(viewId - 1).render();
  }
  function onClickTodayBtn(datepicker) {
    var picker = datepicker.picker;
    var currentDate = today();
    if (datepicker.config.todayBtnMode === 1) {
      if (datepicker.config.autohide) {
        datepicker.setDate(currentDate);
        return;
      }
      datepicker.setDate(currentDate, {
        render: false
      });
      picker.update();
    }
    if (picker.viewDate !== currentDate) {
      picker.changeFocus(currentDate);
    }
    picker.changeView(0).render();
  }
  function onClickClearBtn(datepicker) {
    datepicker.setDate({
      clear: true
    });
  }
  function onClickViewSwitch(datepicker) {
    switchView(datepicker);
  }
  function onClickPrevBtn(datepicker) {
    goToPrevOrNext(datepicker, -1);
  }
  function onClickNextBtn(datepicker) {
    goToPrevOrNext(datepicker, 1);
  }
  function onClickView(datepicker, ev) {
    var target = findElementInEventPath(ev, ".datepicker-cell");
    if (!target || target.classList.contains("disabled")) {
      return;
    }
    var _datepicker$picker$cu = datepicker.picker.currentView, id = _datepicker$picker$cu.id, isMinView = _datepicker$picker$cu.isMinView;
    if (isMinView) {
      datepicker.setDate(Number(target.dataset.date));
    } else if (id === 1) {
      goToSelectedMonthOrYear(datepicker, Number(target.dataset.month));
    } else {
      goToSelectedMonthOrYear(datepicker, Number(target.dataset.year));
    }
  }
  function onClickPicker(datepicker) {
    if (!datepicker.inline && !datepicker.config.disableTouchKeyboard) {
      datepicker.inputField.focus();
    }
  }
  function processPickerOptions(picker, options) {
    if (options.title !== void 0) {
      if (options.title) {
        picker.controls.title.textContent = options.title;
        showElement(picker.controls.title);
      } else {
        picker.controls.title.textContent = "";
        hideElement(picker.controls.title);
      }
    }
    if (options.prevArrow) {
      var prevBtn = picker.controls.prevBtn;
      emptyChildNodes(prevBtn);
      options.prevArrow.forEach(function(node) {
        prevBtn.appendChild(node.cloneNode(true));
      });
    }
    if (options.nextArrow) {
      var nextBtn = picker.controls.nextBtn;
      emptyChildNodes(nextBtn);
      options.nextArrow.forEach(function(node) {
        nextBtn.appendChild(node.cloneNode(true));
      });
    }
    if (options.locale) {
      picker.controls.todayBtn.textContent = options.locale.today;
      picker.controls.clearBtn.textContent = options.locale.clear;
    }
    if (options.todayBtn !== void 0) {
      if (options.todayBtn) {
        showElement(picker.controls.todayBtn);
      } else {
        hideElement(picker.controls.todayBtn);
      }
    }
    if (hasProperty(options, "minDate") || hasProperty(options, "maxDate")) {
      var _picker$datepicker$co = picker.datepicker.config, minDate = _picker$datepicker$co.minDate, maxDate = _picker$datepicker$co.maxDate;
      picker.controls.todayBtn.disabled = !isInRange(today(), minDate, maxDate);
    }
    if (options.clearBtn !== void 0) {
      if (options.clearBtn) {
        showElement(picker.controls.clearBtn);
      } else {
        hideElement(picker.controls.clearBtn);
      }
    }
  }
  function computeResetViewDate(datepicker) {
    var dates = datepicker.dates, config = datepicker.config;
    var viewDate = dates.length > 0 ? lastItemOf(dates) : config.defaultViewDate;
    return limitToRange(viewDate, config.minDate, config.maxDate);
  }
  function setViewDate(picker, newDate) {
    var oldViewDate = new Date(picker.viewDate);
    var newViewDate = new Date(newDate);
    var _picker$currentView = picker.currentView, id = _picker$currentView.id, year = _picker$currentView.year, first = _picker$currentView.first, last = _picker$currentView.last;
    var viewYear = newViewDate.getFullYear();
    picker.viewDate = newDate;
    if (viewYear !== oldViewDate.getFullYear()) {
      triggerDatepickerEvent(picker.datepicker, "changeYear");
    }
    if (newViewDate.getMonth() !== oldViewDate.getMonth()) {
      triggerDatepickerEvent(picker.datepicker, "changeMonth");
    }
    switch (id) {
      case 0:
        return newDate < first || newDate > last;
      case 1:
        return viewYear !== year;
      default:
        return viewYear < first || viewYear > last;
    }
  }
  function getTextDirection(el2) {
    return window.getComputedStyle(el2).direction;
  }
  var Picker = /* @__PURE__ */ function() {
    function Picker2(datepicker) {
      _classCallCheck(this, Picker2);
      this.datepicker = datepicker;
      var template = pickerTemplate.replace(/%buttonClass%/g, datepicker.config.buttonClass);
      var element = this.element = parseHTML(template).firstChild;
      var _element$firstChild$c = _slicedToArray(element.firstChild.children, 3), header = _element$firstChild$c[0], main2 = _element$firstChild$c[1], footer = _element$firstChild$c[2];
      var title = header.firstElementChild;
      var _header$lastElementCh = _slicedToArray(header.lastElementChild.children, 3), prevBtn = _header$lastElementCh[0], viewSwitch = _header$lastElementCh[1], nextBtn = _header$lastElementCh[2];
      var _footer$firstChild$ch = _slicedToArray(footer.firstChild.children, 2), todayBtn = _footer$firstChild$ch[0], clearBtn = _footer$firstChild$ch[1];
      var controls = {
        title,
        prevBtn,
        viewSwitch,
        nextBtn,
        todayBtn,
        clearBtn
      };
      this.main = main2;
      this.controls = controls;
      var elementClass = datepicker.inline ? "inline" : "dropdown";
      element.classList.add("datepicker-".concat(elementClass));
      elementClass === "dropdown" ? element.classList.add("dropdown", "absolute", "top-0", "left-0", "z-50", "pt-2") : null;
      processPickerOptions(this, datepicker.config);
      this.viewDate = computeResetViewDate(datepicker);
      registerListeners(datepicker, [[element, "click", onClickPicker.bind(null, datepicker), {
        capture: true
      }], [main2, "click", onClickView.bind(null, datepicker)], [controls.viewSwitch, "click", onClickViewSwitch.bind(null, datepicker)], [controls.prevBtn, "click", onClickPrevBtn.bind(null, datepicker)], [controls.nextBtn, "click", onClickNextBtn.bind(null, datepicker)], [controls.todayBtn, "click", onClickTodayBtn.bind(null, datepicker)], [controls.clearBtn, "click", onClickClearBtn.bind(null, datepicker)]]);
      this.views = [new DaysView(this), new MonthsView(this), new YearsView(this, {
        id: 2,
        name: "years",
        cellClass: "year",
        step: 1
      }), new YearsView(this, {
        id: 3,
        name: "decades",
        cellClass: "decade",
        step: 10
      })];
      this.currentView = this.views[datepicker.config.startView];
      this.currentView.render();
      this.main.appendChild(this.currentView.element);
      datepicker.config.container.appendChild(this.element);
    }
    return _createClass(Picker2, [{
      key: "setOptions",
      value: function setOptions(options) {
        processPickerOptions(this, options);
        this.views.forEach(function(view) {
          view.init(options, false);
        });
        this.currentView.render();
      }
    }, {
      key: "detach",
      value: function detach() {
        this.datepicker.config.container.removeChild(this.element);
      }
    }, {
      key: "show",
      value: function show() {
        if (this.active) {
          return;
        }
        this.element.classList.add("active", "block");
        this.element.classList.remove("hidden");
        this.active = true;
        var datepicker = this.datepicker;
        if (!datepicker.inline) {
          var inputDirection = getTextDirection(datepicker.inputField);
          if (inputDirection !== getTextDirection(datepicker.config.container)) {
            this.element.dir = inputDirection;
          } else if (this.element.dir) {
            this.element.removeAttribute("dir");
          }
          this.place();
          if (datepicker.config.disableTouchKeyboard) {
            datepicker.inputField.blur();
          }
        }
        triggerDatepickerEvent(datepicker, "show");
      }
    }, {
      key: "hide",
      value: function hide2() {
        if (!this.active) {
          return;
        }
        this.datepicker.exitEditMode();
        this.element.classList.remove("active", "block");
        this.element.classList.add("active", "block", "hidden");
        this.active = false;
        triggerDatepickerEvent(this.datepicker, "hide");
      }
    }, {
      key: "place",
      value: function place() {
        var _this$element = this.element, classList = _this$element.classList, style = _this$element.style;
        var _this$datepicker = this.datepicker, config = _this$datepicker.config, inputField = _this$datepicker.inputField;
        var container = config.container;
        var _this$element$getBoun = this.element.getBoundingClientRect(), calendarWidth = _this$element$getBoun.width, calendarHeight = _this$element$getBoun.height;
        var _container$getBoundin = container.getBoundingClientRect(), containerLeft = _container$getBoundin.left, containerTop = _container$getBoundin.top, containerWidth = _container$getBoundin.width;
        var _inputField$getBoundi = inputField.getBoundingClientRect(), inputLeft = _inputField$getBoundi.left, inputTop = _inputField$getBoundi.top, inputWidth = _inputField$getBoundi.width, inputHeight = _inputField$getBoundi.height;
        var _config$orientation = config.orientation, orientX = _config$orientation.x, orientY = _config$orientation.y;
        var scrollTop2;
        var left2;
        var top3;
        if (container === document.body) {
          scrollTop2 = window.scrollY;
          left2 = inputLeft + window.scrollX;
          top3 = inputTop + scrollTop2;
        } else {
          scrollTop2 = container.scrollTop;
          left2 = inputLeft - containerLeft;
          top3 = inputTop - containerTop + scrollTop2;
        }
        if (orientX === "auto") {
          if (left2 < 0) {
            orientX = "left";
            left2 = 10;
          } else if (left2 + calendarWidth > containerWidth) {
            orientX = "right";
          } else {
            orientX = getTextDirection(inputField) === "rtl" ? "right" : "left";
          }
        }
        if (orientX === "right") {
          left2 -= calendarWidth - inputWidth;
        }
        if (orientY === "auto") {
          orientY = top3 - calendarHeight < scrollTop2 ? "bottom" : "top";
        }
        if (orientY === "top") {
          top3 -= calendarHeight;
        } else {
          top3 += inputHeight;
        }
        classList.remove("datepicker-orient-top", "datepicker-orient-bottom", "datepicker-orient-right", "datepicker-orient-left");
        classList.add("datepicker-orient-".concat(orientY), "datepicker-orient-".concat(orientX));
        style.top = top3 ? "".concat(top3, "px") : top3;
        style.left = left2 ? "".concat(left2, "px") : left2;
      }
    }, {
      key: "setViewSwitchLabel",
      value: function setViewSwitchLabel(labelText) {
        this.controls.viewSwitch.textContent = labelText;
      }
    }, {
      key: "setPrevBtnDisabled",
      value: function setPrevBtnDisabled(disabled) {
        this.controls.prevBtn.disabled = disabled;
      }
    }, {
      key: "setNextBtnDisabled",
      value: function setNextBtnDisabled(disabled) {
        this.controls.nextBtn.disabled = disabled;
      }
    }, {
      key: "changeView",
      value: function changeView(viewId) {
        var oldView = this.currentView;
        var newView = this.views[viewId];
        if (newView.id !== oldView.id) {
          this.currentView = newView;
          this._renderMethod = "render";
          triggerDatepickerEvent(this.datepicker, "changeView");
          this.main.replaceChild(newView.element, oldView.element);
        }
        return this;
      }
      // Change the focused date (view date)
    }, {
      key: "changeFocus",
      value: function changeFocus(newViewDate) {
        this._renderMethod = setViewDate(this, newViewDate) ? "render" : "refreshFocus";
        this.views.forEach(function(view) {
          view.updateFocus();
        });
        return this;
      }
      // Apply the change of the selected dates
    }, {
      key: "update",
      value: function update() {
        var newViewDate = computeResetViewDate(this.datepicker);
        this._renderMethod = setViewDate(this, newViewDate) ? "render" : "refresh";
        this.views.forEach(function(view) {
          view.updateFocus();
          view.updateSelection();
        });
        return this;
      }
      // Refresh the picker UI
    }, {
      key: "render",
      value: function render() {
        var quickRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        var renderMethod = quickRender && this._renderMethod || "render";
        delete this._renderMethod;
        this.currentView[renderMethod]();
      }
    }]);
  }();
  function findNextAvailableOne(date, addFn, increase, testFn, min2, max2) {
    if (!isInRange(date, min2, max2)) {
      return;
    }
    if (testFn(date)) {
      var newDate = addFn(date, increase);
      return findNextAvailableOne(newDate, addFn, increase, testFn, min2, max2);
    }
    return date;
  }
  function moveByArrowKey(datepicker, ev, direction, vertical) {
    var picker = datepicker.picker;
    var currentView = picker.currentView;
    var step = currentView.step || 1;
    var viewDate = picker.viewDate;
    var addFn;
    var testFn;
    switch (currentView.id) {
      case 0:
        if (vertical) {
          viewDate = addDays(viewDate, direction * 7);
        } else if (ev.ctrlKey || ev.metaKey) {
          viewDate = addYears(viewDate, direction);
        } else {
          viewDate = addDays(viewDate, direction);
        }
        addFn = addDays;
        testFn = function testFn2(date) {
          return currentView.disabled.includes(date);
        };
        break;
      case 1:
        viewDate = addMonths(viewDate, vertical ? direction * 4 : direction);
        addFn = addMonths;
        testFn = function testFn2(date) {
          var dt = new Date(date);
          var year = currentView.year, disabled = currentView.disabled;
          return dt.getFullYear() === year && disabled.includes(dt.getMonth());
        };
        break;
      default:
        viewDate = addYears(viewDate, direction * (vertical ? 4 : 1) * step);
        addFn = addYears;
        testFn = function testFn2(date) {
          return currentView.disabled.includes(startOfYearPeriod(date, step));
        };
    }
    viewDate = findNextAvailableOne(viewDate, addFn, direction < 0 ? -step : step, testFn, currentView.minDate, currentView.maxDate);
    if (viewDate !== void 0) {
      picker.changeFocus(viewDate).render();
    }
  }
  function onKeydown(datepicker, ev) {
    if (ev.key === "Tab") {
      unfocus(datepicker);
      return;
    }
    var picker = datepicker.picker;
    var _picker$currentView = picker.currentView, id = _picker$currentView.id, isMinView = _picker$currentView.isMinView;
    if (!picker.active) {
      switch (ev.key) {
        case "ArrowDown":
        case "Escape":
          picker.show();
          break;
        case "Enter":
          datepicker.update();
          break;
        default:
          return;
      }
    } else if (datepicker.editMode) {
      switch (ev.key) {
        case "Escape":
          picker.hide();
          break;
        case "Enter":
          datepicker.exitEditMode({
            update: true,
            autohide: datepicker.config.autohide
          });
          break;
        default:
          return;
      }
    } else {
      switch (ev.key) {
        case "Escape":
          picker.hide();
          break;
        case "ArrowLeft":
          if (ev.ctrlKey || ev.metaKey) {
            goToPrevOrNext(datepicker, -1);
          } else if (ev.shiftKey) {
            datepicker.enterEditMode();
            return;
          } else {
            moveByArrowKey(datepicker, ev, -1, false);
          }
          break;
        case "ArrowRight":
          if (ev.ctrlKey || ev.metaKey) {
            goToPrevOrNext(datepicker, 1);
          } else if (ev.shiftKey) {
            datepicker.enterEditMode();
            return;
          } else {
            moveByArrowKey(datepicker, ev, 1, false);
          }
          break;
        case "ArrowUp":
          if (ev.ctrlKey || ev.metaKey) {
            switchView(datepicker);
          } else if (ev.shiftKey) {
            datepicker.enterEditMode();
            return;
          } else {
            moveByArrowKey(datepicker, ev, -1, true);
          }
          break;
        case "ArrowDown":
          if (ev.shiftKey && !ev.ctrlKey && !ev.metaKey) {
            datepicker.enterEditMode();
            return;
          }
          moveByArrowKey(datepicker, ev, 1, true);
          break;
        case "Enter":
          if (isMinView) {
            datepicker.setDate(picker.viewDate);
          } else {
            picker.changeView(id - 1).render();
          }
          break;
        case "Backspace":
        case "Delete":
          datepicker.enterEditMode();
          return;
        default:
          if (ev.key.length === 1 && !ev.ctrlKey && !ev.metaKey) {
            datepicker.enterEditMode();
          }
          return;
      }
    }
    ev.preventDefault();
    ev.stopPropagation();
  }
  function onFocus(datepicker) {
    if (datepicker.config.showOnFocus && !datepicker._showing) {
      datepicker.show();
    }
  }
  function onMousedown(datepicker, ev) {
    var el2 = ev.target;
    if (datepicker.picker.active || datepicker.config.showOnClick) {
      el2._active = el2 === document.activeElement;
      el2._clicking = setTimeout(function() {
        delete el2._active;
        delete el2._clicking;
      }, 2e3);
    }
  }
  function onClickInput(datepicker, ev) {
    var el2 = ev.target;
    if (!el2._clicking) {
      return;
    }
    clearTimeout(el2._clicking);
    delete el2._clicking;
    if (el2._active) {
      datepicker.enterEditMode();
    }
    delete el2._active;
    if (datepicker.config.showOnClick) {
      datepicker.show();
    }
  }
  function onPaste(datepicker, ev) {
    if (ev.clipboardData.types.includes("text/plain")) {
      datepicker.enterEditMode();
    }
  }
  function onClickOutside(datepicker, ev) {
    var element = datepicker.element;
    if (element !== document.activeElement) {
      return;
    }
    var pickerElem = datepicker.picker.element;
    if (findElementInEventPath(ev, function(el2) {
      return el2 === element || el2 === pickerElem;
    })) {
      return;
    }
    unfocus(datepicker);
  }
  function stringifyDates(dates, config) {
    return dates.map(function(dt) {
      return formatDate(dt, config.format, config.locale);
    }).join(config.dateDelimiter);
  }
  function processInputDates(datepicker, inputDates) {
    var clear = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var config = datepicker.config, origDates = datepicker.dates, rangepicker = datepicker.rangepicker;
    if (inputDates.length === 0) {
      return clear ? [] : void 0;
    }
    var rangeEnd = rangepicker && datepicker === rangepicker.datepickers[1];
    var newDates = inputDates.reduce(function(dates, dt) {
      var date = parseDate(dt, config.format, config.locale);
      if (date === void 0) {
        return dates;
      }
      if (config.pickLevel > 0) {
        var _dt = new Date(date);
        if (config.pickLevel === 1) {
          date = rangeEnd ? _dt.setMonth(_dt.getMonth() + 1, 0) : _dt.setDate(1);
        } else {
          date = rangeEnd ? _dt.setFullYear(_dt.getFullYear() + 1, 0, 0) : _dt.setMonth(0, 1);
        }
      }
      if (isInRange(date, config.minDate, config.maxDate) && !dates.includes(date) && !config.datesDisabled.includes(date) && !config.daysOfWeekDisabled.includes(new Date(date).getDay())) {
        dates.push(date);
      }
      return dates;
    }, []);
    if (newDates.length === 0) {
      return;
    }
    if (config.multidate && !clear) {
      newDates = newDates.reduce(function(dates, date) {
        if (!origDates.includes(date)) {
          dates.push(date);
        }
        return dates;
      }, origDates.filter(function(date) {
        return !newDates.includes(date);
      }));
    }
    return config.maxNumberOfDates && newDates.length > config.maxNumberOfDates ? newDates.slice(config.maxNumberOfDates * -1) : newDates;
  }
  function refreshUI(datepicker) {
    var mode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
    var quickRender = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var config = datepicker.config, picker = datepicker.picker, inputField = datepicker.inputField;
    if (mode & 2) {
      var newView = picker.active ? config.pickLevel : config.startView;
      picker.update().changeView(newView).render(quickRender);
    }
    if (mode & 1 && inputField) {
      inputField.value = stringifyDates(datepicker.dates, config);
    }
  }
  function _setDate(datepicker, inputDates, options) {
    var clear = options.clear, render = options.render, autohide = options.autohide;
    if (render === void 0) {
      render = true;
    }
    if (!render) {
      autohide = false;
    } else if (autohide === void 0) {
      autohide = datepicker.config.autohide;
    }
    var newDates = processInputDates(datepicker, inputDates, clear);
    if (!newDates) {
      return;
    }
    if (newDates.toString() !== datepicker.dates.toString()) {
      datepicker.dates = newDates;
      refreshUI(datepicker, render ? 3 : 1);
      triggerDatepickerEvent(datepicker, "changeDate");
    } else {
      refreshUI(datepicker, 1);
    }
    if (autohide) {
      datepicker.hide();
    }
  }
  var Datepicker = /* @__PURE__ */ function() {
    function Datepicker3(element) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rangepicker = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
      _classCallCheck(this, Datepicker3);
      element.datepicker = this;
      this.element = element;
      var config = this.config = Object.assign({
        buttonClass: options.buttonClass && String(options.buttonClass) || "button",
        container: document.body,
        defaultViewDate: today(),
        maxDate: void 0,
        minDate: void 0
      }, processOptions(defaultOptions, this));
      this._options = options;
      Object.assign(config, processOptions(options, this));
      var inline = this.inline = element.tagName !== "INPUT";
      var inputField;
      var initialDates;
      if (inline) {
        config.container = element;
        initialDates = stringToArray(element.dataset.date, config.dateDelimiter);
        delete element.dataset.date;
      } else {
        var container = options.container ? document.querySelector(options.container) : null;
        if (container) {
          config.container = container;
        }
        inputField = this.inputField = element;
        inputField.classList.add("datepicker-input");
        initialDates = stringToArray(inputField.value, config.dateDelimiter);
      }
      if (rangepicker) {
        var index3 = rangepicker.inputs.indexOf(inputField);
        var datepickers = rangepicker.datepickers;
        if (index3 < 0 || index3 > 1 || !Array.isArray(datepickers)) {
          throw Error("Invalid rangepicker object.");
        }
        datepickers[index3] = this;
        Object.defineProperty(this, "rangepicker", {
          get: function get() {
            return rangepicker;
          }
        });
      }
      this.dates = [];
      var inputDateValues = processInputDates(this, initialDates);
      if (inputDateValues && inputDateValues.length > 0) {
        this.dates = inputDateValues;
      }
      if (inputField) {
        inputField.value = stringifyDates(this.dates, config);
      }
      var picker = this.picker = new Picker(this);
      if (inline) {
        this.show();
      } else {
        var onMousedownDocument = onClickOutside.bind(null, this);
        var listeners = [[inputField, "keydown", onKeydown.bind(null, this)], [inputField, "focus", onFocus.bind(null, this)], [inputField, "mousedown", onMousedown.bind(null, this)], [inputField, "click", onClickInput.bind(null, this)], [inputField, "paste", onPaste.bind(null, this)], [document, "mousedown", onMousedownDocument], [document, "touchstart", onMousedownDocument], [window, "resize", picker.place.bind(picker)]];
        registerListeners(this, listeners);
      }
    }
    return _createClass(Datepicker3, [{
      key: "active",
      get: (
        /**
         * @type {Boolean} - Whether the picker element is shown. `true` whne shown
         */
        function get() {
          return !!(this.picker && this.picker.active);
        }
      )
      /**
       * @type {HTMLDivElement} - DOM object of picker element
       */
    }, {
      key: "pickerElement",
      get: function get() {
        return this.picker ? this.picker.element : void 0;
      }
      /**
       * Set new values to the config options
       * @param {Object} options - config options to update
       */
    }, {
      key: "setOptions",
      value: function setOptions(options) {
        var picker = this.picker;
        var newOptions = processOptions(options, this);
        Object.assign(this._options, options);
        Object.assign(this.config, newOptions);
        picker.setOptions(newOptions);
        refreshUI(this, 3);
      }
      /**
       * Show the picker element
       */
    }, {
      key: "show",
      value: function show() {
        if (this.inputField) {
          if (this.inputField.disabled) {
            return;
          }
          if (this.inputField !== document.activeElement) {
            this._showing = true;
            this.inputField.focus();
            delete this._showing;
          }
        }
        this.picker.show();
      }
      /**
       * Hide the picker element
       * Not available on inline picker
       */
    }, {
      key: "hide",
      value: function hide2() {
        if (this.inline) {
          return;
        }
        this.picker.hide();
        this.picker.update().changeView(this.config.startView).render();
      }
      /**
       * Destroy the Datepicker instance
       * @return {Detepicker} - the instance destroyed
       */
    }, {
      key: "destroy",
      value: function destroy2() {
        this.hide();
        unregisterListeners(this);
        this.picker.detach();
        if (!this.inline) {
          this.inputField.classList.remove("datepicker-input");
        }
        delete this.element.datepicker;
        return this;
      }
      /**
       * Get the selected date(s)
       *
       * The method returns a Date object of selected date by default, and returns
       * an array of selected dates in multidate mode. If format string is passed,
       * it returns date string(s) formatted in given format.
       *
       * @param  {String} [format] - Format string to stringify the date(s)
       * @return {Date|String|Date[]|String[]} - selected date(s), or if none is
       * selected, empty array in multidate mode and untitled in sigledate mode
       */
    }, {
      key: "getDate",
      value: function getDate() {
        var _this = this;
        var format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        var callback2 = format ? function(date) {
          return formatDate(date, format, _this.config.locale);
        } : function(date) {
          return new Date(date);
        };
        if (this.config.multidate) {
          return this.dates.map(callback2);
        }
        if (this.dates.length > 0) {
          return callback2(this.dates[0]);
        }
      }
      /**
       * Set selected date(s)
       *
       * In multidate mode, you can pass multiple dates as a series of arguments
       * or an array. (Since each date is parsed individually, the type of the
       * dates doesn't have to be the same.)
       * The given dates are used to toggle the select status of each date. The
       * number of selected dates is kept from exceeding the length set to
       * maxNumberOfDates.
       *
       * With clear: true option, the method can be used to clear the selection
       * and to replace the selection instead of toggling in multidate mode.
       * If the option is passed with no date arguments or an empty dates array,
       * it works as "clear" (clear the selection then set nothing), and if the
       * option is passed with new dates to select, it works as "replace" (clear
       * the selection then set the given dates)
       *
       * When render: false option is used, the method omits re-rendering the
       * picker element. In this case, you need to call refresh() method later in
       * order for the picker element to reflect the changes. The input field is
       * refreshed always regardless of this option.
       *
       * When invalid (unparsable, repeated, disabled or out-of-range) dates are
       * passed, the method ignores them and applies only valid ones. In the case
       * that all the given dates are invalid, which is distinguished from passing
       * no dates, the method considers it as an error and leaves the selection
       * untouched.
       *
       * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date
       * objects, time values or mix of those for new selection
       * @param {Object} [options] - function options
       * - clear: {boolean} - Whether to clear the existing selection
       *     defualt: false
       * - render: {boolean} - Whether to re-render the picker element
       *     default: true
       * - autohide: {boolean} - Whether to hide the picker element after re-render
       *     Ignored when used with render: false
       *     default: config.autohide
       */
    }, {
      key: "setDate",
      value: function setDate() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var dates = [].concat(args);
        var opts = {};
        var lastArg = lastItemOf(args);
        if (_typeof2(lastArg) === "object" && !Array.isArray(lastArg) && !(lastArg instanceof Date) && lastArg) {
          Object.assign(opts, dates.pop());
        }
        var inputDates = Array.isArray(dates[0]) ? dates[0] : dates;
        _setDate(this, inputDates, opts);
      }
      /**
       * Update the selected date(s) with input field's value
       * Not available on inline picker
       *
       * The input field will be refreshed with properly formatted date string.
       *
       * @param  {Object} [options] - function options
       * - autohide: {boolean} - whether to hide the picker element after refresh
       *     default: false
       */
    }, {
      key: "update",
      value: function update() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        if (this.inline) {
          return;
        }
        var opts = {
          clear: true,
          autohide: !!(options && options.autohide)
        };
        var inputDates = stringToArray(this.inputField.value, this.config.dateDelimiter);
        _setDate(this, inputDates, opts);
      }
      /**
       * Refresh the picker element and the associated input field
       * @param {String} [target] - target item when refreshing one item only
       * 'picker' or 'input'
       * @param {Boolean} [forceRender] - whether to re-render the picker element
       * regardless of its state instead of optimized refresh
       */
    }, {
      key: "refresh",
      value: function refresh() {
        var target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (target && typeof target !== "string") {
          forceRender = target;
          target = void 0;
        }
        var mode;
        if (target === "picker") {
          mode = 2;
        } else if (target === "input") {
          mode = 1;
        } else {
          mode = 3;
        }
        refreshUI(this, mode, !forceRender);
      }
      /**
       * Enter edit mode
       * Not available on inline picker or when the picker element is hidden
       */
    }, {
      key: "enterEditMode",
      value: function enterEditMode() {
        if (this.inline || !this.picker.active || this.editMode) {
          return;
        }
        this.editMode = true;
        this.inputField.classList.add("in-edit", "border-blue-700", "!border-primary-700");
      }
      /**
       * Exit from edit mode
       * Not available on inline picker
       * @param  {Object} [options] - function options
       * - update: {boolean} - whether to call update() after exiting
       *     If false, input field is revert to the existing selection
       *     default: false
       */
    }, {
      key: "exitEditMode",
      value: function exitEditMode() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        if (this.inline || !this.editMode) {
          return;
        }
        var opts = Object.assign({
          update: false
        }, options);
        delete this.editMode;
        this.inputField.classList.remove("in-edit", "border-blue-700", "!border-primary-700");
        if (opts.update) {
          this.update(opts);
        }
      }
    }], [{
      key: "formatDate",
      value: function formatDate$1(date, format, lang) {
        return formatDate(date, format, lang && locales[lang] || locales.en);
      }
      /**
       * Parse date string
       * @param  {String|Date|Number} dateStr - date string, Date object or time
       * value to parse
       * @param  {String|Object} format - format string or object that contains
       * toValue() custom parser, whose signature is
       * - args:
       *   - dateStr: {String|Date|Number} - the dateStr passed to the method
       *   - format: {Object} - the format object passed to the method
       *   - locale: {Object} - locale for the language specified by `lang`
       * - return:
       *     {Date|Number} parsed date or its time value
       * @param  {String} [lang=en] - language code for the locale to use
       * @return {Number} time value of parsed date
       */
    }, {
      key: "parseDate",
      value: function parseDate$1(dateStr, format, lang) {
        return parseDate(dateStr, format, lang && locales[lang] || locales.en);
      }
      /**
       * @type {Object} - Installed locales in `[languageCode]: localeObject` format
       * en`:_English (US)_ is pre-installed.
       */
    }, {
      key: "locales",
      get: function get() {
        return locales;
      }
    }]);
  }();
  function filterOptions(options) {
    var newOpts = Object.assign({}, options);
    delete newOpts.inputs;
    delete newOpts.allowOneSidedRange;
    delete newOpts.maxNumberOfDates;
    return newOpts;
  }
  function setupDatepicker(rangepicker, changeDateListener, el2, options) {
    registerListeners(rangepicker, [[el2, "changeDate", changeDateListener]]);
    new Datepicker(el2, options, rangepicker);
  }
  function onChangeDate(rangepicker, ev) {
    if (rangepicker._updating) {
      return;
    }
    rangepicker._updating = true;
    var target = ev.target;
    if (target.datepicker === void 0) {
      return;
    }
    var datepickers = rangepicker.datepickers;
    var setDateOptions = {
      render: false
    };
    var changedSide = rangepicker.inputs.indexOf(target);
    var otherSide = changedSide === 0 ? 1 : 0;
    var changedDate = datepickers[changedSide].dates[0];
    var otherDate = datepickers[otherSide].dates[0];
    if (changedDate !== void 0 && otherDate !== void 0) {
      if (changedSide === 0 && changedDate > otherDate) {
        datepickers[0].setDate(otherDate, setDateOptions);
        datepickers[1].setDate(changedDate, setDateOptions);
      } else if (changedSide === 1 && changedDate < otherDate) {
        datepickers[0].setDate(changedDate, setDateOptions);
        datepickers[1].setDate(otherDate, setDateOptions);
      }
    } else if (!rangepicker.allowOneSidedRange) {
      if (changedDate !== void 0 || otherDate !== void 0) {
        setDateOptions.clear = true;
        datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);
      }
    }
    datepickers[0].picker.update().render();
    datepickers[1].picker.update().render();
    delete rangepicker._updating;
  }
  var DateRangePicker = /* @__PURE__ */ function() {
    function DateRangePicker2(element) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, DateRangePicker2);
      var inputs = Array.isArray(options.inputs) ? options.inputs : Array.from(element.querySelectorAll("input"));
      if (inputs.length < 2) {
        return;
      }
      element.rangepicker = this;
      this.element = element;
      this.inputs = inputs.slice(0, 2);
      this.allowOneSidedRange = !!options.allowOneSidedRange;
      var changeDateListener = onChangeDate.bind(null, this);
      var cleanOptions = filterOptions(options);
      var datepickers = [];
      Object.defineProperty(this, "datepickers", {
        get: function get() {
          return datepickers;
        }
      });
      setupDatepicker(this, changeDateListener, this.inputs[0], cleanOptions);
      setupDatepicker(this, changeDateListener, this.inputs[1], cleanOptions);
      Object.freeze(datepickers);
      if (datepickers[0].dates.length > 0) {
        onChangeDate(this, {
          target: this.inputs[0]
        });
      } else if (datepickers[1].dates.length > 0) {
        onChangeDate(this, {
          target: this.inputs[1]
        });
      }
    }
    return _createClass(DateRangePicker2, [{
      key: "dates",
      get: function get() {
        return this.datepickers.length === 2 ? [this.datepickers[0].dates[0], this.datepickers[1].dates[0]] : void 0;
      }
      /**
       * Set new values to the config options
       * @param {Object} options - config options to update
       */
    }, {
      key: "setOptions",
      value: function setOptions(options) {
        this.allowOneSidedRange = !!options.allowOneSidedRange;
        var cleanOptions = filterOptions(options);
        this.datepickers[0].setOptions(cleanOptions);
        this.datepickers[1].setOptions(cleanOptions);
      }
      /**
       * Destroy the DateRangePicker instance
       * @return {DateRangePicker} - the instance destroyed
       */
    }, {
      key: "destroy",
      value: function destroy2() {
        this.datepickers[0].destroy();
        this.datepickers[1].destroy();
        unregisterListeners(this);
        delete this.element.rangepicker;
      }
      /**
       * Get the start and end dates of the date range
       *
       * The method returns Date objects by default. If format string is passed,
       * it returns date strings formatted in given format.
       * The result array always contains 2 items (start date/end date) and
       * undefined is used for unselected side. (e.g. If none is selected,
       * the result will be [undefined, undefined]. If only the end date is set
       * when allowOneSidedRange config option is true, [undefined, endDate] will
       * be returned.)
       *
       * @param  {String} [format] - Format string to stringify the dates
       * @return {Array} - Start and end dates
       */
    }, {
      key: "getDates",
      value: function getDates() {
        var _this = this;
        var format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        var callback2 = format ? function(date) {
          return formatDate(date, format, _this.datepickers[0].config.locale);
        } : function(date) {
          return new Date(date);
        };
        return this.dates.map(function(date) {
          return date === void 0 ? date : callback2(date);
        });
      }
      /**
       * Set the start and end dates of the date range
       *
       * The method calls datepicker.setDate() internally using each of the
       * arguments in startend order.
       *
       * When a clear: true option object is passed instead of a date, the method
       * clears the date.
       *
       * If an invalid date, the same date as the current one or an option object
       * without clear: true is passed, the method considers that argument as an
       * "ineffective" argument because calling datepicker.setDate() with those
       * values makes no changes to the date selection.
       *
       * When the allowOneSidedRange config option is false, passing {clear: true}
       * to clear the range works only when it is done to the last effective
       * argument (in other words, passed to rangeEnd or to rangeStart along with
       * ineffective rangeEnd). This is because when the date range is changed,
       * it gets normalized based on the last change at the end of the changing
       * process.
       *
       * @param {Date|Number|String|Object} rangeStart - Start date of the range
       * or {clear: true} to clear the date
       * @param {Date|Number|String|Object} rangeEnd - End date of the range
       * or {clear: true} to clear the date
       */
    }, {
      key: "setDates",
      value: function setDates(rangeStart, rangeEnd) {
        var _this$datepickers = _slicedToArray(this.datepickers, 2), datepicker0 = _this$datepickers[0], datepicker1 = _this$datepickers[1];
        var origDates = this.dates;
        this._updating = true;
        datepicker0.setDate(rangeStart);
        datepicker1.setDate(rangeEnd);
        delete this._updating;
        if (datepicker1.dates[0] !== origDates[1]) {
          onChangeDate(this, {
            target: this.inputs[1]
          });
        } else if (datepicker0.dates[0] !== origDates[0]) {
          onChangeDate(this, {
            target: this.inputs[0]
          });
        }
      }
    }]);
  }();

  // node_modules/flowbite/lib/esm/components/datepicker/index.js
  var __assign14 = function() {
    __assign14 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign14.apply(this, arguments);
  };
  var Default14 = {
    defaultDatepickerId: null,
    autohide: false,
    format: "mm/dd/yyyy",
    maxDate: null,
    minDate: null,
    orientation: "bottom",
    buttons: false,
    autoSelectToday: 0,
    title: null,
    language: "en",
    rangePicker: false,
    onShow: function() {
    },
    onHide: function() {
    }
  };
  var DefaultInstanceOptions14 = {
    id: null,
    override: true
  };
  var Datepicker2 = (
    /** @class */
    function() {
      function Datepicker3(datepickerEl, options, instanceOptions) {
        if (datepickerEl === void 0) {
          datepickerEl = null;
        }
        if (options === void 0) {
          options = Default14;
        }
        if (instanceOptions === void 0) {
          instanceOptions = DefaultInstanceOptions14;
        }
        this._instanceId = instanceOptions.id ? instanceOptions.id : datepickerEl.id;
        this._datepickerEl = datepickerEl;
        this._datepickerInstance = null;
        this._options = __assign14(__assign14({}, Default14), options);
        this._initialized = false;
        this.init();
        instances_default.addInstance("Datepicker", this, this._instanceId, instanceOptions.override);
      }
      Datepicker3.prototype.init = function() {
        if (this._datepickerEl && !this._initialized) {
          if (this._options.rangePicker) {
            this._datepickerInstance = new DateRangePicker(this._datepickerEl, this._getDatepickerOptions(this._options));
          } else {
            this._datepickerInstance = new Datepicker(this._datepickerEl, this._getDatepickerOptions(this._options));
          }
          this._initialized = true;
        }
      };
      Datepicker3.prototype.destroy = function() {
        if (this._initialized) {
          this._initialized = false;
          this._datepickerInstance.destroy();
        }
      };
      Datepicker3.prototype.removeInstance = function() {
        this.destroy();
        instances_default.removeInstance("Datepicker", this._instanceId);
      };
      Datepicker3.prototype.destroyAndRemoveInstance = function() {
        this.destroy();
        this.removeInstance();
      };
      Datepicker3.prototype.getDatepickerInstance = function() {
        return this._datepickerInstance;
      };
      Datepicker3.prototype.getDate = function() {
        if (this._options.rangePicker && this._datepickerInstance instanceof DateRangePicker) {
          return this._datepickerInstance.getDates();
        }
        if (!this._options.rangePicker && this._datepickerInstance instanceof Datepicker) {
          return this._datepickerInstance.getDate();
        }
      };
      Datepicker3.prototype.setDate = function(date) {
        if (this._options.rangePicker && this._datepickerInstance instanceof DateRangePicker) {
          return this._datepickerInstance.setDates(date);
        }
        if (!this._options.rangePicker && this._datepickerInstance instanceof Datepicker) {
          return this._datepickerInstance.setDate(date);
        }
      };
      Datepicker3.prototype.show = function() {
        this._datepickerInstance.show();
        this._options.onShow(this);
      };
      Datepicker3.prototype.hide = function() {
        this._datepickerInstance.hide();
        this._options.onHide(this);
      };
      Datepicker3.prototype._getDatepickerOptions = function(options) {
        var datepickerOptions = {};
        if (options.buttons) {
          datepickerOptions.todayBtn = true;
          datepickerOptions.clearBtn = true;
          if (options.autoSelectToday) {
            datepickerOptions.todayBtnMode = 1;
          }
        }
        if (options.autohide) {
          datepickerOptions.autohide = true;
        }
        if (options.format) {
          datepickerOptions.format = options.format;
        }
        if (options.maxDate) {
          datepickerOptions.maxDate = options.maxDate;
        }
        if (options.minDate) {
          datepickerOptions.minDate = options.minDate;
        }
        if (options.orientation) {
          datepickerOptions.orientation = options.orientation;
        }
        if (options.title) {
          datepickerOptions.title = options.title;
        }
        if (options.language) {
          datepickerOptions.language = options.language;
        }
        return datepickerOptions;
      };
      Datepicker3.prototype.updateOnShow = function(callback2) {
        this._options.onShow = callback2;
      };
      Datepicker3.prototype.updateOnHide = function(callback2) {
        this._options.onHide = callback2;
      };
      return Datepicker3;
    }()
  );
  function initDatepickers() {
    document.querySelectorAll("[datepicker], [inline-datepicker], [date-rangepicker]").forEach(function($datepickerEl) {
      if ($datepickerEl) {
        var buttons = $datepickerEl.hasAttribute("datepicker-buttons");
        var autoselectToday = $datepickerEl.hasAttribute("datepicker-autoselect-today");
        var autohide = $datepickerEl.hasAttribute("datepicker-autohide");
        var format = $datepickerEl.getAttribute("datepicker-format");
        var maxDate = $datepickerEl.getAttribute("datepicker-max-date");
        var minDate = $datepickerEl.getAttribute("datepicker-min-date");
        var orientation_1 = $datepickerEl.getAttribute("datepicker-orientation");
        var title = $datepickerEl.getAttribute("datepicker-title");
        var language = $datepickerEl.getAttribute("datepicker-language");
        var rangePicker = $datepickerEl.hasAttribute("date-rangepicker");
        new Datepicker2($datepickerEl, {
          buttons: buttons ? buttons : Default14.buttons,
          autoSelectToday: autoselectToday ? autoselectToday : Default14.autoSelectToday,
          autohide: autohide ? autohide : Default14.autohide,
          format: format ? format : Default14.format,
          maxDate: maxDate ? maxDate : Default14.maxDate,
          minDate: minDate ? minDate : Default14.minDate,
          orientation: orientation_1 ? orientation_1 : Default14.orientation,
          title: title ? title : Default14.title,
          language: language ? language : Default14.language,
          rangePicker: rangePicker ? rangePicker : Default14.rangePicker
        });
      } else {
        console.error("The datepicker element does not exist. Please check the datepicker attribute.");
      }
    });
  }
  if (typeof window !== "undefined") {
    window.Datepicker = Datepicker2;
    window.initDatepickers = initDatepickers;
  }

  // node_modules/flowbite/lib/esm/components/index.js
  function initFlowbite() {
    initAccordions();
    initCollapses();
    initCarousels();
    initDismisses();
    initDropdowns();
    initModals();
    initDrawers();
    initTabs();
    initTooltips();
    initPopovers();
    initDials();
    initInputCounters();
    initCopyClipboards();
    initDatepickers();
  }
  if (typeof window !== "undefined") {
    window.initFlowbite = initFlowbite;
  }

  // node_modules/flowbite/lib/esm/index.js
  var events = new events_default("load", [
    initAccordions,
    initCollapses,
    initCarousels,
    initDismisses,
    initDropdowns,
    initModals,
    initDrawers,
    initTabs,
    initTooltips,
    initPopovers,
    initDials,
    initInputCounters,
    initCopyClipboards,
    initDatepickers
  ]);
  events.init();

  // js/app.js
  window.toggleDarkMode = () => {
    let currentTheme = localStorage.getItem("theme");
    let newTheme = currentTheme === "dark" ? "light" : "dark";
    localStorage.setItem("theme", newTheme);
    document.documentElement.classList.toggle("dark", newTheme === "dark");
    const event = new Event("classChange");
    document.documentElement.dispatchEvent(event);
  };
  document.addEventListener("DOMContentLoaded", () => {
    let savedTheme = localStorage.getItem("theme") || "light";
    document.documentElement.classList.toggle("dark", savedTheme === "dark");
  });
  var liveSocketPath = false ? "/csci379-25s-h/live" : "/live";
  var csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content");
  var Hooks2 = {};
  Hooks2.LogoutButton = {
    mounted() {
      this.handleEvent("logout", () => {
        let btn = document.getElementById("logout-button");
        if (btn)
          btn.click();
      });
    }
  };
  Hooks2.AutoScroll = {
    updated() {
      window.scrollTo({ top: document.body.scrollHeight, behavior: "smooth" });
    }
  };
  Hooks2.Chart = {
    mounted() {
      this.el._chart = new auto_default(this.el, JSON.parse(this.el.dataset.config));
      this.updateTheme();
      this.themeListener = () => {
        this.updateTheme();
      };
      document.documentElement.addEventListener("classChange", this.themeListener);
    },
    updated() {
      console.log("Chart updated - checking dataset.config:", this.el.dataset.config);
      const newConfig = JSON.parse(this.el.dataset.config);
      console.log("New chart configuration:", newConfig);
      if (this.el._chart) {
        console.log("Destroying old chart...");
        this.el._chart.destroy();
      }
      console.log("Creating new chart...");
      this.el._chart = new auto_default(this.el, newConfig);
      this.updateTheme();
    },
    updateTheme() {
      const isDarkMode = document.documentElement.classList.contains("dark");
      const color2 = isDarkMode ? "#fff" : "#000";
      const gridColor = isDarkMode ? "#444" : "#ccc";
      this.el._chart.options.plugins.legend.labels.color = color2;
      this.el._chart.options.plugins.title.color = color2;
      this.el._chart.options.scales.x.title.color = color2;
      this.el._chart.options.scales.x.ticks.color = color2;
      this.el._chart.options.scales.x.grid.color = gridColor;
      this.el._chart.options.scales.y.title.color = color2;
      this.el._chart.options.scales.y.ticks.color = color2;
      this.el._chart.options.scales.y.grid.color = gridColor;
      this.el._chart.update();
    },
    destroyed() {
      document.documentElement.removeEventListener("classChange", this.themeListener);
    }
  };
  Hooks2.ChartDeals = {
    mounted() {
      this.el._chart = new auto_default(this.el, JSON.parse(this.el.dataset.config));
      this.updateTheme();
      this.themeListener = () => {
        this.updateTheme();
      };
      document.documentElement.addEventListener("classChange", this.themeListener);
    },
    updated() {
      const newConfig = JSON.parse(this.el.dataset.config);
      if (this.el._chart) {
        this.el._chart.destroy();
      }
      this.el._chart = new auto_default(this.el, newConfig);
      this.updateTheme();
    },
    updateTheme() {
      const isDarkMode = document.documentElement.classList.contains("dark");
      const color2 = isDarkMode ? "#fff" : "#000";
      const gridColor = isDarkMode ? "#444" : "#ccc";
      this.el._chart.options.plugins.legend.labels.color = color2;
      this.el._chart.options.plugins.title.color = color2;
      this.el._chart.options.scales.x.title.color = color2;
      this.el._chart.options.scales.x.ticks.color = color2;
      this.el._chart.options.scales.x.grid.color = gridColor;
      this.el._chart.options.scales.y.title.color = color2;
      this.el._chart.options.scales.y.ticks.color = color2;
      this.el._chart.options.scales.y.grid.color = gridColor;
      this.el._chart.update();
    },
    destroyed() {
      document.documentElement.removeEventListener("classChange", this.themeListener);
    }
  };
  Hooks2.RatingValidator = {
    mounted() {
      this.el.addEventListener("input", (e) => {
        let value = e.target.value;
        let regex = /^(?:[0-9]|10)(?:\.\d{0,1})?$/;
        if (!regex.test(value) || parseFloat(value) > 10 || parseFloat(value) < 0) {
          e.target.value = value.slice(0, -1);
        }
      });
    }
  };
  Hooks2.Rating = {
    mounted() {
      this.el.addEventListener("rating-changed", (e) => {
        let newRating = e.detail.rating;
        this.pushEvent("rating_updated", { rating: newRating });
      });
    }
  };
  Hooks2.DragHook = drag_hook_default;
  Hooks2.Downloader = {
    mounted() {
      this.handleEvent("download_media_backup", ({ filename, content }) => {
        const blob = new Blob([content], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
    }
  };
  var liveSocket = new LiveSocket(liveSocketPath, Socket, {
    // longPollFallbackMs: 2500,
    params: { _csrf_token: csrfToken },
    hooks: Hooks2
  });
  window.addEventListener("phx:open-modal", (e) => {
    el = document.getElementById(e.detail.id);
    liveSocket.execJS(el, el.getAttribute("data-open"));
  });
  window.addEventListener("phx:close-modal", (e) => {
    el = document.getElementById(e.detail.id);
    liveSocket.execJS(el, el.getAttribute("data-close"));
  });
  import_topbar.default.config({ barColors: { 0: "#29d" }, shadowColor: "rgba(0, 0, 0, .3)" });
  window.addEventListener("phx:page-loading-start", (_info) => import_topbar.default.show(300));
  window.addEventListener("phx:page-loading-stop", (_info) => import_topbar.default.hide());
  liveSocket.connect();
  window.liveSocket = liveSocket;
})();
/**
 * @license MIT
 * topbar 2.0.0, 2023-02-04
 * https://buunguyen.github.io/topbar
 * Copyright (c) 2021 Buu Nguyen
 */
/*! Bundled license information:

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.4
   * https://github.com/kurkle/color#readme
   * (c) 2024 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.dataset.js:
  (*!
   * Chart.js v4.4.9
   * https://www.chartjs.org
   * (c) 2025 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.4.9
   * https://www.chartjs.org
   * (c) 2025 Chart.js Contributors
   * Released under the MIT License
   *)

sortablejs/modular/sortable.esm.js:
  (**!
   * Sortable 1.15.6
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vYXNzZXRzL3ZlbmRvci90b3BiYXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2h0bWwvcHJpdi9zdGF0aWMvcGhvZW5peF9odG1sLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC91dGlscy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9wdXNoLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC90aW1lci5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvY2hhbm5lbC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvYWpheC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvbG9uZ3BvbGwuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3ByZXNlbmNlLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9zZXJpYWxpemVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9zb2NrZXQuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2VudHJ5X3VwbG9hZGVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3V0aWxzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2Jyb3dzZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3VwbG9hZF9lbnRyeS5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9saXZlX3VwbG9hZGVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2FyaWEuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvaG9va3MuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZWxlbWVudF9yZWYuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tX3Bvc3RfbW9ycGhfcmVzdG9yZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvbm9kZV9tb2R1bGVzL21vcnBoZG9tL2Rpc3QvbW9ycGhkb20tZXNtLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2RvbV9wYXRjaC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9yZW5kZXJlZC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9qcy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy92aWV3X2hvb2suanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvdmlldy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9saXZlX3NvY2tldC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9pbmRleC5qcyIsICIuLi8uLi8uLi9hc3NldHMvanMvYXBwLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQGt1cmtsZS9jb2xvci9kaXN0L2NvbG9yLmVzbS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29yZS50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMubWF0aC50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5lYXNpbmcudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvbG9yLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb25zLmRlZmF1bHRzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5sYXlvdXRzLmRlZmF1bHRzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5pbnRsLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS50aWNrcy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuc2NhbGUuZGVmYXVsdHMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmRlZmF1bHRzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jYW52YXMudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLm9wdGlvbnMudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvbmZpZy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY3VydmUudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmRvbS50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuaW50ZXJwb2xhdGlvbi50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMucnRsLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5zZWdtZW50LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5kYXRhc2V0LnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRvci5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9uLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb25zLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmJhci5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmJ1YmJsZS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmRvdWdobnV0LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIubGluZS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnBvbGFyQXJlYS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnBpZS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnJhZGFyLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuc2NhdHRlci5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYWRhcHRlcnMudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmludGVyYWN0aW9uLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5sYXlvdXRzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2UuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uYmFzaWMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uZG9tLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL2luZGV4LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5lbGVtZW50LnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5zY2FsZS5hdXRvc2tpcC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuc2NhbGUuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnR5cGVkUmVnaXN0cnkuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnJlZ2lzdHJ5LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5wbHVnaW5zLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5jb25maWcuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmNvbnRyb2xsZXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5hcmMudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5saW5lLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5iYXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uY29sb3JzLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmRlY2ltYXRpb24uanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5zZWdtZW50LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuaGVscGVyLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIub3B0aW9ucy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLnRhcmdldC5zdGFjay5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvc2ltcGxlQXJjLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIudGFyZ2V0LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuZHJhd2luZy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvaW5kZXguanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4ubGVnZW5kLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLnRpdGxlLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLnN1YnRpdGxlLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLnRvb2x0aXAuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmNhdGVnb3J5LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5saW5lYXJiYXNlLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5saW5lYXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmxvZ2FyaXRobWljLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5yYWRpYWxMaW5lYXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLnRpbWUuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLnRpbWVzZXJpZXMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaW5kZXgudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9hdXRvL2F1dG8uanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zb3J0YWJsZWpzL21vZHVsYXIvc29ydGFibGUuZXNtLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9qcy9kcmFnX2hvb2suanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9zcmMvZG9tL2V2ZW50cy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2Zsb3diaXRlL3NyYy9kb20vaW5zdGFuY2VzLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZmxvd2JpdGUvc3JjL2NvbXBvbmVudHMvYWNjb3JkaW9uL2luZGV4LnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZmxvd2JpdGUvc3JjL2NvbXBvbmVudHMvY29sbGFwc2UvaW5kZXgudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9zcmMvY29tcG9uZW50cy9jYXJvdXNlbC9pbmRleC50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2Zsb3diaXRlL3NyYy9jb21wb25lbnRzL2Rpc21pc3MvaW5kZXgudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy91c2VyQWdlbnQuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzTGF5b3V0Vmlld3BvcnQuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvY29udGFpbnMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvd2l0aGluLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRWYXJpYXRpb24uanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbEJhclguanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFZpZXdwb3J0UmVjdC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0U2Nyb2xsUGFyZW50LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2hpZGUuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL29mZnNldC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRBbHRBeGlzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlQnlOYW1lLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9zcmMvY29tcG9uZW50cy9kcm9wZG93bi9pbmRleC50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2Zsb3diaXRlL3NyYy9jb21wb25lbnRzL21vZGFsL2luZGV4LnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZmxvd2JpdGUvc3JjL2NvbXBvbmVudHMvZHJhd2VyL2luZGV4LnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZmxvd2JpdGUvc3JjL2NvbXBvbmVudHMvdGFicy9pbmRleC50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2Zsb3diaXRlL3NyYy9jb21wb25lbnRzL3Rvb2x0aXAvaW5kZXgudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9zcmMvY29tcG9uZW50cy9wb3BvdmVyL2luZGV4LnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZmxvd2JpdGUvc3JjL2NvbXBvbmVudHMvZGlhbC9pbmRleC50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2Zsb3diaXRlL3NyYy9jb21wb25lbnRzL2lucHV0LWNvdW50ZXIvaW5kZXgudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9zcmMvY29tcG9uZW50cy9jbGlwYm9hcmQvaW5kZXgudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9mbG93Yml0ZS1kYXRlcGlja2VyL2Rpc3QvbWFpbi5lc20uanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9zcmMvY29tcG9uZW50cy9kYXRlcGlja2VyL2luZGV4LnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZmxvd2JpdGUvc3JjL2NvbXBvbmVudHMvaW5kZXgudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9zcmMvaW5kZXgudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogQGxpY2Vuc2UgTUlUXG4gKiB0b3BiYXIgMi4wLjAsIDIwMjMtMDItMDRcbiAqIGh0dHBzOi8vYnV1bmd1eWVuLmdpdGh1Yi5pby90b3BiYXJcbiAqIENvcHlyaWdodCAoYykgMjAyMSBCdXUgTmd1eWVuXG4gKi9cbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvMTU3OTY3MVxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgdmFyIHZlbmRvcnMgPSBbXCJtc1wiLCBcIm1velwiLCBcIndlYmtpdFwiLCBcIm9cIl07XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cbiAgICAgICAgd2luZG93W3ZlbmRvcnNbeF0gKyBcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9XG4gICAgICAgIHdpbmRvd1t2ZW5kb3JzW3hdICsgXCJDYW5jZWxBbmltYXRpb25GcmFtZVwiXSB8fFxuICAgICAgICB3aW5kb3dbdmVuZG9yc1t4XSArIFwiQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuICAgIH1cbiAgICBpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgICAgICAgdmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XG4gICAgICAgIH0sIHRpbWVUb0NhbGwpO1xuICAgICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfTtcbiAgICBpZiAoIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSlcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgfTtcbiAgfSkoKTtcblxuICB2YXIgY2FudmFzLFxuICAgIGN1cnJlbnRQcm9ncmVzcyxcbiAgICBzaG93aW5nLFxuICAgIHByb2dyZXNzVGltZXJJZCA9IG51bGwsXG4gICAgZmFkZVRpbWVySWQgPSBudWxsLFxuICAgIGRlbGF5VGltZXJJZCA9IG51bGwsXG4gICAgYWRkRXZlbnQgPSBmdW5jdGlvbiAoZWxlbSwgdHlwZSwgaGFuZGxlcikge1xuICAgICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcikgZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgIGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpIGVsZW0uYXR0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgaGFuZGxlcik7XG4gICAgICBlbHNlIGVsZW1bXCJvblwiICsgdHlwZV0gPSBoYW5kbGVyO1xuICAgIH0sXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGF1dG9SdW46IHRydWUsXG4gICAgICBiYXJUaGlja25lc3M6IDMsXG4gICAgICBiYXJDb2xvcnM6IHtcbiAgICAgICAgMDogXCJyZ2JhKDI2LCAgMTg4LCAxNTYsIC45KVwiLFxuICAgICAgICBcIi4yNVwiOiBcInJnYmEoNTIsICAxNTIsIDIxOSwgLjkpXCIsXG4gICAgICAgIFwiLjUwXCI6IFwicmdiYSgyNDEsIDE5NiwgMTUsICAuOSlcIixcbiAgICAgICAgXCIuNzVcIjogXCJyZ2JhKDIzMCwgMTI2LCAzNCwgIC45KVwiLFxuICAgICAgICBcIjEuMFwiOiBcInJnYmEoMjExLCA4NCwgIDAsICAgLjkpXCIsXG4gICAgICB9LFxuICAgICAgc2hhZG93Qmx1cjogMTAsXG4gICAgICBzaGFkb3dDb2xvcjogXCJyZ2JhKDAsICAgMCwgICAwLCAgIC42KVwiLFxuICAgICAgY2xhc3NOYW1lOiBudWxsLFxuICAgIH0sXG4gICAgcmVwYWludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzICogNTsgLy8gbmVlZCBzcGFjZSBmb3Igc2hhZG93XG5cbiAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSBvcHRpb25zLnNoYWRvd0JsdXI7XG4gICAgICBjdHguc2hhZG93Q29sb3IgPSBvcHRpb25zLnNoYWRvd0NvbG9yO1xuXG4gICAgICB2YXIgbGluZUdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIGNhbnZhcy53aWR0aCwgMCk7XG4gICAgICBmb3IgKHZhciBzdG9wIGluIG9wdGlvbnMuYmFyQ29sb3JzKVxuICAgICAgICBsaW5lR3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AsIG9wdGlvbnMuYmFyQ29sb3JzW3N0b3BdKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJhclRoaWNrbmVzcztcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oMCwgb3B0aW9ucy5iYXJUaGlja25lc3MgLyAyKTtcbiAgICAgIGN0eC5saW5lVG8oXG4gICAgICAgIE1hdGguY2VpbChjdXJyZW50UHJvZ3Jlc3MgKiBjYW52YXMud2lkdGgpLFxuICAgICAgICBvcHRpb25zLmJhclRoaWNrbmVzcyAvIDJcbiAgICAgICk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsaW5lR3JhZGllbnQ7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICBjcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgdmFyIHN0eWxlID0gY2FudmFzLnN0eWxlO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgICBzdHlsZS50b3AgPSBzdHlsZS5sZWZ0ID0gc3R5bGUucmlnaHQgPSBzdHlsZS5tYXJnaW4gPSBzdHlsZS5wYWRkaW5nID0gMDtcbiAgICAgIHN0eWxlLnpJbmRleCA9IDEwMDAwMTtcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIGlmIChvcHRpb25zLmNsYXNzTmFtZSkgY2FudmFzLmNsYXNzTGlzdC5hZGQob3B0aW9ucy5jbGFzc05hbWUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgYWRkRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCByZXBhaW50KTtcbiAgICB9LFxuICAgIHRvcGJhciA9IHtcbiAgICAgIGNvbmZpZzogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdHMpXG4gICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkgb3B0aW9uc1trZXldID0gb3B0c1trZXldO1xuICAgICAgfSxcbiAgICAgIHNob3c6IGZ1bmN0aW9uIChkZWxheSkge1xuICAgICAgICBpZiAoc2hvd2luZykgcmV0dXJuO1xuICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICBpZiAoZGVsYXlUaW1lcklkKSByZXR1cm47XG4gICAgICAgICAgZGVsYXlUaW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB0b3BiYXIuc2hvdygpLCBkZWxheSk7XG4gICAgICAgIH0gZWxzZSAge1xuICAgICAgICAgIHNob3dpbmcgPSB0cnVlO1xuICAgICAgICAgIGlmIChmYWRlVGltZXJJZCAhPT0gbnVsbCkgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGZhZGVUaW1lcklkKTtcbiAgICAgICAgICBpZiAoIWNhbnZhcykgY3JlYXRlQ2FudmFzKCk7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgIHRvcGJhci5wcm9ncmVzcygwKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hdXRvUnVuKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgICAgcHJvZ3Jlc3NUaW1lcklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgICAgICAgICAgdG9wYmFyLnByb2dyZXNzKFxuICAgICAgICAgICAgICAgIFwiK1wiICsgMC4wNSAqIE1hdGgucG93KDEgLSBNYXRoLnNxcnQoY3VycmVudFByb2dyZXNzKSwgMilcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uICh0bykge1xuICAgICAgICBpZiAodHlwZW9mIHRvID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gY3VycmVudFByb2dyZXNzO1xuICAgICAgICBpZiAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdG8gPVxuICAgICAgICAgICAgKHRvLmluZGV4T2YoXCIrXCIpID49IDAgfHwgdG8uaW5kZXhPZihcIi1cIikgPj0gMFxuICAgICAgICAgICAgICA/IGN1cnJlbnRQcm9ncmVzc1xuICAgICAgICAgICAgICA6IDApICsgcGFyc2VGbG9hdCh0byk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFByb2dyZXNzID0gdG8gPiAxID8gMSA6IHRvO1xuICAgICAgICByZXBhaW50KCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50UHJvZ3Jlc3M7XG4gICAgICB9LFxuICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoZGVsYXlUaW1lcklkKTtcbiAgICAgICAgZGVsYXlUaW1lcklkID0gbnVsbDtcbiAgICAgICAgaWYgKCFzaG93aW5nKSByZXR1cm47XG4gICAgICAgIHNob3dpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHByb2dyZXNzVGltZXJJZCAhPSBudWxsKSB7XG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHByb2dyZXNzVGltZXJJZCk7XG4gICAgICAgICAgcHJvZ3Jlc3NUaW1lcklkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAoZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICBpZiAodG9wYmFyLnByb2dyZXNzKFwiKy4xXCIpID49IDEpIHtcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5vcGFjaXR5IC09IDAuMDU7XG4gICAgICAgICAgICBpZiAoY2FudmFzLnN0eWxlLm9wYWNpdHkgPD0gMC4wNSkge1xuICAgICAgICAgICAgICBjYW52YXMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICBmYWRlVGltZXJJZCA9IG51bGw7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZmFkZVRpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgICB9KSgpO1xuICAgICAgfSxcbiAgICB9O1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gdG9wYmFyO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0b3BiYXI7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50b3BiYXIgPSB0b3BiYXI7XG4gIH1cbn0uY2FsbCh0aGlzLCB3aW5kb3csIGRvY3VtZW50KSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIFBvbHlmaWxsRXZlbnQgPSBldmVudENvbnN0cnVjdG9yKCk7XG5cbiAgZnVuY3Rpb24gZXZlbnRDb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gd2luZG93LkN1c3RvbUV2ZW50O1xuICAgIC8vIElFPD05IFN1cHBvcnRcbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge2J1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB1bmRlZmluZWR9O1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgIHJldHVybiBldnQ7XG4gICAgfVxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRIaWRkZW5JbnB1dChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcbiAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGVsZW1lbnQsIHRhcmdldE1vZGlmaWVyS2V5KSB7XG4gICAgdmFyIHRvID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRvXCIpLFxuICAgICAgICBtZXRob2QgPSBidWlsZEhpZGRlbklucHV0KFwiX21ldGhvZFwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpKSxcbiAgICAgICAgY3NyZiA9IGJ1aWxkSGlkZGVuSW5wdXQoXCJfY3NyZl90b2tlblwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY3NyZlwiKSksXG4gICAgICAgIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKSxcbiAgICAgICAgc3VibWl0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLFxuICAgICAgICB0YXJnZXQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKTtcblxuICAgIGZvcm0ubWV0aG9kID0gKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tZXRob2RcIikgPT09IFwiZ2V0XCIpID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICAgIGZvcm0uYWN0aW9uID0gdG87XG4gICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgICBpZiAodGFyZ2V0KSBmb3JtLnRhcmdldCA9IHRhcmdldDtcbiAgICBlbHNlIGlmICh0YXJnZXRNb2RpZmllcktleSkgZm9ybS50YXJnZXQgPSBcIl9ibGFua1wiO1xuXG4gICAgZm9ybS5hcHBlbmRDaGlsZChjc3JmKTtcbiAgICBmb3JtLmFwcGVuZENoaWxkKG1ldGhvZCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIC8vIEluc2VydCBhIGJ1dHRvbiBhbmQgY2xpY2sgaXQgaW5zdGVhZCBvZiB1c2luZyBgZm9ybS5zdWJtaXRgXG4gICAgLy8gYmVjYXVzZSB0aGUgYHN1Ym1pdGAgZnVuY3Rpb24gZG9lcyBub3QgZW1pdCBhIGBzdWJtaXRgIGV2ZW50LlxuICAgIHN1Ym1pdC50eXBlID0gXCJzdWJtaXRcIjtcbiAgICBmb3JtLmFwcGVuZENoaWxkKHN1Ym1pdCk7XG4gICAgc3VibWl0LmNsaWNrKCk7XG4gIH1cblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGUudGFyZ2V0O1xuICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKSB7XG4gICAgICB2YXIgcGhvZW5peExpbmtFdmVudCA9IG5ldyBQb2x5ZmlsbEV2ZW50KCdwaG9lbml4LmxpbmsuY2xpY2snLCB7XG4gICAgICAgIFwiYnViYmxlc1wiOiB0cnVlLCBcImNhbmNlbGFibGVcIjogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghZWxlbWVudC5kaXNwYXRjaEV2ZW50KHBob2VuaXhMaW5rRXZlbnQpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdG9cIikpIHtcbiAgICAgICAgaGFuZGxlQ2xpY2soZWxlbWVudCwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXkpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9LCBmYWxzZSk7XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Bob2VuaXgubGluay5jbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbmZpcm1cIik7XG4gICAgaWYobWVzc2FnZSAmJiAhd2luZG93LmNvbmZpcm0obWVzc2FnZSkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbn0pKCk7XG4iLCAiLy8gd3JhcHMgdmFsdWUgaW4gY2xvc3VyZSBvciByZXR1cm5zIGNsb3N1cmVcbmV4cG9ydCBsZXQgY2xvc3VyZSA9ICh2YWx1ZSkgPT4ge1xuICBpZih0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIil7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgbGV0IGNsb3N1cmUgPSBmdW5jdGlvbiAoKXsgcmV0dXJuIHZhbHVlIH1cbiAgICByZXR1cm4gY2xvc3VyZVxuICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGdsb2JhbFNlbGYgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiBudWxsXG5leHBvcnQgY29uc3QgcGh4V2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IG51bGxcbmV4cG9ydCBjb25zdCBnbG9iYWwgPSBnbG9iYWxTZWxmIHx8IHBoeFdpbmRvdyB8fCBnbG9iYWxcbmV4cG9ydCBjb25zdCBERUZBVUxUX1ZTTiA9IFwiMi4wLjBcIlxuZXhwb3J0IGNvbnN0IFNPQ0tFVF9TVEFURVMgPSB7Y29ubmVjdGluZzogMCwgb3BlbjogMSwgY2xvc2luZzogMiwgY2xvc2VkOiAzfVxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDEwMDAwXG5leHBvcnQgY29uc3QgV1NfQ0xPU0VfTk9STUFMID0gMTAwMFxuZXhwb3J0IGNvbnN0IENIQU5ORUxfU1RBVEVTID0ge1xuICBjbG9zZWQ6IFwiY2xvc2VkXCIsXG4gIGVycm9yZWQ6IFwiZXJyb3JlZFwiLFxuICBqb2luZWQ6IFwiam9pbmVkXCIsXG4gIGpvaW5pbmc6IFwiam9pbmluZ1wiLFxuICBsZWF2aW5nOiBcImxlYXZpbmdcIixcbn1cbmV4cG9ydCBjb25zdCBDSEFOTkVMX0VWRU5UUyA9IHtcbiAgY2xvc2U6IFwicGh4X2Nsb3NlXCIsXG4gIGVycm9yOiBcInBoeF9lcnJvclwiLFxuICBqb2luOiBcInBoeF9qb2luXCIsXG4gIHJlcGx5OiBcInBoeF9yZXBseVwiLFxuICBsZWF2ZTogXCJwaHhfbGVhdmVcIlxufVxuXG5leHBvcnQgY29uc3QgVFJBTlNQT1JUUyA9IHtcbiAgbG9uZ3BvbGw6IFwibG9uZ3BvbGxcIixcbiAgd2Vic29ja2V0OiBcIndlYnNvY2tldFwiXG59XG5leHBvcnQgY29uc3QgWEhSX1NUQVRFUyA9IHtcbiAgY29tcGxldGU6IDRcbn1cbiIsICIvKipcbiAqIEluaXRpYWxpemVzIHRoZSBQdXNoXG4gKiBAcGFyYW0ge0NoYW5uZWx9IGNoYW5uZWwgLSBUaGUgQ2hhbm5lbFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50LCBmb3IgZXhhbXBsZSBgXCJwaHhfam9pblwiYFxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgLSBUaGUgcGF5bG9hZCwgZm9yIGV4YW1wbGUgYHt1c2VyX2lkOiAxMjN9YFxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgLSBUaGUgcHVzaCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdXNoIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbCwgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpe1xuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWxcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnRcbiAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkIHx8IGZ1bmN0aW9uICgpeyByZXR1cm4ge30gfVxuICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbFxuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXRcbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IG51bGxcbiAgICB0aGlzLnJlY0hvb2tzID0gW11cbiAgICB0aGlzLnNlbnQgPSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gICAqL1xuICByZXNlbmQodGltZW91dCl7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgIHRoaXMucmVzZXQoKVxuICAgIHRoaXMuc2VuZCgpXG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIHNlbmQoKXtcbiAgICBpZih0aGlzLmhhc1JlY2VpdmVkKFwidGltZW91dFwiKSl7IHJldHVybiB9XG4gICAgdGhpcy5zdGFydFRpbWVvdXQoKVxuICAgIHRoaXMuc2VudCA9IHRydWVcbiAgICB0aGlzLmNoYW5uZWwuc29ja2V0LnB1c2goe1xuICAgICAgdG9waWM6IHRoaXMuY2hhbm5lbC50b3BpYyxcbiAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgcGF5bG9hZDogdGhpcy5wYXlsb2FkKCksXG4gICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgam9pbl9yZWY6IHRoaXMuY2hhbm5lbC5qb2luUmVmKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gc3RhdHVzXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICovXG4gIHJlY2VpdmUoc3RhdHVzLCBjYWxsYmFjayl7XG4gICAgaWYodGhpcy5oYXNSZWNlaXZlZChzdGF0dXMpKXtcbiAgICAgIGNhbGxiYWNrKHRoaXMucmVjZWl2ZWRSZXNwLnJlc3BvbnNlKVxuICAgIH1cblxuICAgIHRoaXMucmVjSG9va3MucHVzaCh7c3RhdHVzLCBjYWxsYmFja30pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVzZXQoKXtcbiAgICB0aGlzLmNhbmNlbFJlZkV2ZW50KClcbiAgICB0aGlzLnJlZiA9IG51bGxcbiAgICB0aGlzLnJlZkV2ZW50ID0gbnVsbFxuICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbFxuICAgIHRoaXMuc2VudCA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG1hdGNoUmVjZWl2ZSh7c3RhdHVzLCByZXNwb25zZSwgX3JlZn0pe1xuICAgIHRoaXMucmVjSG9va3MuZmlsdGVyKGggPT4gaC5zdGF0dXMgPT09IHN0YXR1cylcbiAgICAgIC5mb3JFYWNoKGggPT4gaC5jYWxsYmFjayhyZXNwb25zZSkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbmNlbFJlZkV2ZW50KCl7XG4gICAgaWYoIXRoaXMucmVmRXZlbnQpeyByZXR1cm4gfVxuICAgIHRoaXMuY2hhbm5lbC5vZmYodGhpcy5yZWZFdmVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FuY2VsVGltZW91dCgpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUaW1lcilcbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRUaW1lb3V0KCl7XG4gICAgaWYodGhpcy50aW1lb3V0VGltZXIpeyB0aGlzLmNhbmNlbFRpbWVvdXQoKSB9XG4gICAgdGhpcy5yZWYgPSB0aGlzLmNoYW5uZWwuc29ja2V0Lm1ha2VSZWYoKVxuICAgIHRoaXMucmVmRXZlbnQgPSB0aGlzLmNoYW5uZWwucmVwbHlFdmVudE5hbWUodGhpcy5yZWYpXG5cbiAgICB0aGlzLmNoYW5uZWwub24odGhpcy5yZWZFdmVudCwgcGF5bG9hZCA9PiB7XG4gICAgICB0aGlzLmNhbmNlbFJlZkV2ZW50KClcbiAgICAgIHRoaXMuY2FuY2VsVGltZW91dCgpXG4gICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IHBheWxvYWRcbiAgICAgIHRoaXMubWF0Y2hSZWNlaXZlKHBheWxvYWQpXG4gICAgfSlcblxuICAgIHRoaXMudGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJ0aW1lb3V0XCIsIHt9KVxuICAgIH0sIHRoaXMudGltZW91dClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFzUmVjZWl2ZWQoc3RhdHVzKXtcbiAgICByZXR1cm4gdGhpcy5yZWNlaXZlZFJlc3AgJiYgdGhpcy5yZWNlaXZlZFJlc3Auc3RhdHVzID09PSBzdGF0dXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlcihzdGF0dXMsIHJlc3BvbnNlKXtcbiAgICB0aGlzLmNoYW5uZWwudHJpZ2dlcih0aGlzLnJlZkV2ZW50LCB7c3RhdHVzLCByZXNwb25zZX0pXG4gIH1cbn1cbiIsICIvKipcbiAqXG4gKiBDcmVhdGVzIGEgdGltZXIgdGhhdCBhY2NlcHRzIGEgYHRpbWVyQ2FsY2AgZnVuY3Rpb24gdG8gcGVyZm9ybVxuICogY2FsY3VsYXRlZCB0aW1lb3V0IHJldHJpZXMsIHN1Y2ggYXMgZXhwb25lbnRpYWwgYmFja29mZi5cbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IHJlY29ubmVjdFRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHRoaXMuY29ubmVjdCgpLCBmdW5jdGlvbih0cmllcyl7XG4gKiAgIHJldHVybiBbMTAwMCwgNTAwMCwgMTAwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAqIH0pXG4gKiByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciAxMDAwXG4gKiByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciA1MDAwXG4gKiByZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gKiByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciAxMDAwXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRpbWVyQ2FsY1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCB0aW1lckNhbGMpe1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMudGltZXJDYWxjID0gdGltZXJDYWxjXG4gICAgdGhpcy50aW1lciA9IG51bGxcbiAgICB0aGlzLnRyaWVzID0gMFxuICB9XG5cbiAgcmVzZXQoKXtcbiAgICB0aGlzLnRyaWVzID0gMFxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYW55IHByZXZpb3VzIHNjaGVkdWxlVGltZW91dCBhbmQgc2NoZWR1bGVzIGNhbGxiYWNrXG4gICAqL1xuICBzY2hlZHVsZVRpbWVvdXQoKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcilcblxuICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJpZXMgPSB0aGlzLnRyaWVzICsgMVxuICAgICAgdGhpcy5jYWxsYmFjaygpXG4gICAgfSwgdGhpcy50aW1lckNhbGModGhpcy50cmllcyArIDEpKVxuICB9XG59XG4iLCAiaW1wb3J0IHtjbG9zdXJlfSBmcm9tIFwiLi91dGlsc1wiXG5pbXBvcnQge1xuICBDSEFOTkVMX0VWRU5UUyxcbiAgQ0hBTk5FTF9TVEFURVMsXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBQdXNoIGZyb20gXCIuL3B1c2hcIlxuaW1wb3J0IFRpbWVyIGZyb20gXCIuL3RpbWVyXCJcblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcGljXG4gKiBAcGFyYW0geyhPYmplY3R8ZnVuY3Rpb24pfSBwYXJhbXNcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhbm5lbCB7XG4gIGNvbnN0cnVjdG9yKHRvcGljLCBwYXJhbXMsIHNvY2tldCl7XG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICAgIHRoaXMudG9waWMgPSB0b3BpY1xuICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShwYXJhbXMgfHwge30pXG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgICB0aGlzLmJpbmRpbmdzID0gW11cbiAgICB0aGlzLmJpbmRpbmdSZWYgPSAwXG4gICAgdGhpcy50aW1lb3V0ID0gdGhpcy5zb2NrZXQudGltZW91dFxuICAgIHRoaXMuam9pbmVkT25jZSA9IGZhbHNlXG4gICAgdGhpcy5qb2luUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmpvaW4sIHRoaXMucGFyYW1zLCB0aGlzLnRpbWVvdXQpXG4gICAgdGhpcy5wdXNoQnVmZmVyID0gW11cbiAgICB0aGlzLnN0YXRlQ2hhbmdlUmVmcyA9IFtdXG5cbiAgICB0aGlzLnJlam9pblRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pbigpIH1cbiAgICB9LCB0aGlzLnNvY2tldC5yZWpvaW5BZnRlck1zKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25FcnJvcigoKSA9PiB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCkpKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25PcGVuKCgpID0+IHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgaWYodGhpcy5pc0Vycm9yZWQoKSl7IHRoaXMucmVqb2luKCkgfVxuICAgIH0pXG4gICAgKVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcIm9rXCIsICgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luZWRcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyLmZvckVhY2gocHVzaEV2ZW50ID0+IHB1c2hFdmVudC5zZW5kKCkpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXVxuICAgIH0pXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpIH1cbiAgICB9KVxuICAgIHRoaXMub25DbG9zZSgoKSA9PiB7XG4gICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBjbG9zZSAke3RoaXMudG9waWN9ICR7dGhpcy5qb2luUmVmKCl9YClcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgICAgIHRoaXMuc29ja2V0LnJlbW92ZSh0aGlzKVxuICAgIH0pXG4gICAgdGhpcy5vbkVycm9yKHJlYXNvbiA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgZXJyb3IgJHt0aGlzLnRvcGljfWAsIHJlYXNvbilcbiAgICAgIGlmKHRoaXMuaXNKb2luaW5nKCkpeyB0aGlzLmpvaW5QdXNoLnJlc2V0KCkgfVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpIH1cbiAgICB9KVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYHRpbWVvdXQgJHt0aGlzLnRvcGljfSAoJHt0aGlzLmpvaW5SZWYoKX0pYCwgdGhpcy5qb2luUHVzaC50aW1lb3V0KVxuICAgICAgbGV0IGxlYXZlUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmxlYXZlLCBjbG9zdXJlKHt9KSwgdGhpcy50aW1lb3V0KVxuICAgICAgbGVhdmVQdXNoLnNlbmQoKVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIHRoaXMuam9pblB1c2gucmVzZXQoKVxuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgfVxuICAgIH0pXG4gICAgdGhpcy5vbihDSEFOTkVMX0VWRU5UUy5yZXBseSwgKHBheWxvYWQsIHJlZikgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKHRoaXMucmVwbHlFdmVudE5hbWUocmVmKSwgcGF5bG9hZClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEpvaW4gdGhlIGNoYW5uZWxcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB0aW1lb3V0XG4gICAqIEByZXR1cm5zIHtQdXNofVxuICAgKi9cbiAgam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICBpZih0aGlzLmpvaW5lZE9uY2Upe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJpZWQgdG8gam9pbiBtdWx0aXBsZSB0aW1lcy4gJ2pvaW4nIGNhbiBvbmx5IGJlIGNhbGxlZCBhIHNpbmdsZSB0aW1lIHBlciBjaGFubmVsIGluc3RhbmNlXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXRcbiAgICAgIHRoaXMuam9pbmVkT25jZSA9IHRydWVcbiAgICAgIHRoaXMucmVqb2luKClcbiAgICAgIHJldHVybiB0aGlzLmpvaW5QdXNoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhvb2sgaW50byBjaGFubmVsIGNsb3NlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbkNsb3NlKGNhbGxiYWNrKXtcbiAgICB0aGlzLm9uKENIQU5ORUxfRVZFTlRTLmNsb3NlLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBIb29rIGludG8gY2hhbm5lbCBlcnJvcnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uRXJyb3IoY2FsbGJhY2spe1xuICAgIHJldHVybiB0aGlzLm9uKENIQU5ORUxfRVZFTlRTLmVycm9yLCByZWFzb24gPT4gY2FsbGJhY2socmVhc29uKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIG9uIGNoYW5uZWwgZXZlbnRzXG4gICAqXG4gICAqIFN1YnNjcmlwdGlvbiByZXR1cm5zIGEgcmVmIGNvdW50ZXIsIHdoaWNoIGNhbiBiZSB1c2VkIGxhdGVyIHRvXG4gICAqIHVuc3Vic2NyaWJlIHRoZSBleGFjdCBldmVudCBsaXN0ZW5lclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZWYxID0gY2hhbm5lbC5vbihcImV2ZW50XCIsIGRvX3N0dWZmKVxuICAgKiBjb25zdCByZWYyID0gY2hhbm5lbC5vbihcImV2ZW50XCIsIGRvX290aGVyX3N0dWZmKVxuICAgKiBjaGFubmVsLm9mZihcImV2ZW50XCIsIHJlZjEpXG4gICAqIC8vIFNpbmNlIHVuc3Vic2NyaXB0aW9uLCBkb19zdHVmZiB3b24ndCBmaXJlLFxuICAgKiAvLyB3aGlsZSBkb19vdGhlcl9zdHVmZiB3aWxsIGtlZXAgZmlyaW5nIG9uIHRoZSBcImV2ZW50XCJcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtpbnRlZ2VyfSByZWZcbiAgICovXG4gIG9uKGV2ZW50LCBjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMuYmluZGluZ1JlZisrXG4gICAgdGhpcy5iaW5kaW5ncy5wdXNoKHtldmVudCwgcmVmLCBjYWxsYmFja30pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlcyBvZmYgb2YgY2hhbm5lbCBldmVudHNcbiAgICpcbiAgICogVXNlIHRoZSByZWYgcmV0dXJuZWQgZnJvbSBhIGNoYW5uZWwub24oKSB0byB1bnN1YnNjcmliZSBvbmVcbiAgICogaGFuZGxlciwgb3IgcGFzcyBub3RoaW5nIGZvciB0aGUgcmVmIHRvIHVuc3Vic2NyaWJlIGFsbFxuICAgKiBoYW5kbGVycyBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBVbnN1YnNjcmliZSB0aGUgZG9fc3R1ZmYgaGFuZGxlclxuICAgKiBjb25zdCByZWYxID0gY2hhbm5lbC5vbihcImV2ZW50XCIsIGRvX3N0dWZmKVxuICAgKiBjaGFubmVsLm9mZihcImV2ZW50XCIsIHJlZjEpXG4gICAqXG4gICAqIC8vIFVuc3Vic2NyaWJlIGFsbCBoYW5kbGVycyBmcm9tIGV2ZW50XG4gICAqIGNoYW5uZWwub2ZmKFwiZXZlbnRcIilcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gcmVmXG4gICAqL1xuICBvZmYoZXZlbnQsIHJlZil7XG4gICAgdGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICByZXR1cm4gIShiaW5kLmV2ZW50ID09PSBldmVudCAmJiAodHlwZW9mIHJlZiA9PT0gXCJ1bmRlZmluZWRcIiB8fCByZWYgPT09IGJpbmQucmVmKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5QdXNoKCl7IHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuaXNKb2luZWQoKSB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgbWVzc2FnZSBgZXZlbnRgIHRvIHBob2VuaXggd2l0aCB0aGUgcGF5bG9hZCBgcGF5bG9hZGAuXG4gICAqIFBob2VuaXggcmVjZWl2ZXMgdGhpcyBpbiB0aGUgYGhhbmRsZV9pbihldmVudCwgcGF5bG9hZCwgc29ja2V0KWBcbiAgICogZnVuY3Rpb24uIGlmIHBob2VuaXggcmVwbGllcyBvciBpdCB0aW1lcyBvdXQgKGRlZmF1bHQgMTAwMDBtcyksXG4gICAqIHRoZW4gb3B0aW9uYWxseSB0aGUgcmVwbHkgY2FuIGJlIHJlY2VpdmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjaGFubmVsLnB1c2goXCJldmVudFwiKVxuICAgKiAgIC5yZWNlaXZlKFwib2tcIiwgcGF5bG9hZCA9PiBjb25zb2xlLmxvZyhcInBob2VuaXggcmVwbGllZDpcIiwgcGF5bG9hZCkpXG4gICAqICAgLnJlY2VpdmUoXCJlcnJvclwiLCBlcnIgPT4gY29uc29sZS5sb2coXCJwaG9lbml4IGVycm9yZWRcIiwgZXJyKSlcbiAgICogICAucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4gY29uc29sZS5sb2coXCJ0aW1lZCBvdXQgcHVzaGluZ1wiKSlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dF1cbiAgICogQHJldHVybnMge1B1c2h9XG4gICAqL1xuICBwdXNoKGV2ZW50LCBwYXlsb2FkLCB0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICBwYXlsb2FkID0gcGF5bG9hZCB8fCB7fVxuICAgIGlmKCF0aGlzLmpvaW5lZE9uY2Upe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0cmllZCB0byBwdXNoICcke2V2ZW50fScgdG8gJyR7dGhpcy50b3BpY30nIGJlZm9yZSBqb2luaW5nLiBVc2UgY2hhbm5lbC5qb2luKCkgYmVmb3JlIHB1c2hpbmcgZXZlbnRzYClcbiAgICB9XG4gICAgbGV0IHB1c2hFdmVudCA9IG5ldyBQdXNoKHRoaXMsIGV2ZW50LCBmdW5jdGlvbiAoKXsgcmV0dXJuIHBheWxvYWQgfSwgdGltZW91dClcbiAgICBpZih0aGlzLmNhblB1c2goKSl7XG4gICAgICBwdXNoRXZlbnQuc2VuZCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2hFdmVudC5zdGFydFRpbWVvdXQoKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KVxuICAgIH1cblxuICAgIHJldHVybiBwdXNoRXZlbnRcbiAgfVxuXG4gIC8qKiBMZWF2ZXMgdGhlIGNoYW5uZWxcbiAgICpcbiAgICogVW5zdWJzY3JpYmVzIGZyb20gc2VydmVyIGV2ZW50cywgYW5kXG4gICAqIGluc3RydWN0cyBjaGFubmVsIHRvIHRlcm1pbmF0ZSBvbiBzZXJ2ZXJcbiAgICpcbiAgICogVHJpZ2dlcnMgb25DbG9zZSgpIGhvb2tzXG4gICAqXG4gICAqIFRvIHJlY2VpdmUgbGVhdmUgYWNrbm93bGVkZ2VtZW50cywgdXNlIHRoZSBgcmVjZWl2ZWBcbiAgICogaG9vayB0byBiaW5kIHRvIHRoZSBzZXJ2ZXIgYWNrLCBpZTpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY2hhbm5lbC5sZWF2ZSgpLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBhbGVydChcImxlZnQhXCIpIClcbiAgICpcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB0aW1lb3V0XG4gICAqIEByZXR1cm5zIHtQdXNofVxuICAgKi9cbiAgbGVhdmUodGltZW91dCA9IHRoaXMudGltZW91dCl7XG4gICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgdGhpcy5qb2luUHVzaC5jYW5jZWxUaW1lb3V0KClcblxuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nXG4gICAgbGV0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgbGVhdmUgJHt0aGlzLnRvcGljfWApXG4gICAgICB0aGlzLnRyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIFwibGVhdmVcIilcbiAgICB9XG4gICAgbGV0IGxlYXZlUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmxlYXZlLCBjbG9zdXJlKHt9KSwgdGltZW91dClcbiAgICBsZWF2ZVB1c2gucmVjZWl2ZShcIm9rXCIsICgpID0+IG9uQ2xvc2UoKSlcbiAgICAgIC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiBvbkNsb3NlKCkpXG4gICAgbGVhdmVQdXNoLnNlbmQoKVxuICAgIGlmKCF0aGlzLmNhblB1c2goKSl7IGxlYXZlUHVzaC50cmlnZ2VyKFwib2tcIiwge30pIH1cblxuICAgIHJldHVybiBsZWF2ZVB1c2hcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkYWJsZSBtZXNzYWdlIGhvb2tcbiAgICpcbiAgICogUmVjZWl2ZXMgYWxsIGV2ZW50cyBmb3Igc3BlY2lhbGl6ZWQgbWVzc2FnZSBoYW5kbGluZ1xuICAgKiBiZWZvcmUgZGlzcGF0Y2hpbmcgdG8gdGhlIGNoYW5uZWwgY2FsbGJhY2tzLlxuICAgKlxuICAgKiBNdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSByZWZcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIG9uTWVzc2FnZShfZXZlbnQsIHBheWxvYWQsIF9yZWYpeyByZXR1cm4gcGF5bG9hZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc01lbWJlcih0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWYpe1xuICAgIGlmKHRoaXMudG9waWMgIT09IHRvcGljKXsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmKGpvaW5SZWYgJiYgam9pblJlZiAhPT0gdGhpcy5qb2luUmVmKCkpe1xuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgXCJkcm9wcGluZyBvdXRkYXRlZCBtZXNzYWdlXCIsIHt0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWZ9KVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBqb2luUmVmKCl7IHJldHVybiB0aGlzLmpvaW5QdXNoLnJlZiB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWpvaW4odGltZW91dCA9IHRoaXMudGltZW91dCl7XG4gICAgaWYodGhpcy5pc0xlYXZpbmcoKSl7IHJldHVybiB9XG4gICAgdGhpcy5zb2NrZXQubGVhdmVPcGVuVG9waWModGhpcy50b3BpYylcbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmluZ1xuICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pblJlZil7XG4gICAgbGV0IGhhbmRsZWRQYXlsb2FkID0gdGhpcy5vbk1lc3NhZ2UoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pblJlZilcbiAgICBpZihwYXlsb2FkICYmICFoYW5kbGVkUGF5bG9hZCl7IHRocm93IG5ldyBFcnJvcihcImNoYW5uZWwgb25NZXNzYWdlIGNhbGxiYWNrcyBtdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZFwiKSB9XG5cbiAgICBsZXQgZXZlbnRCaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuZmlsdGVyKGJpbmQgPT4gYmluZC5ldmVudCA9PT0gZXZlbnQpXG5cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZXZlbnRCaW5kaW5ncy5sZW5ndGg7IGkrKyl7XG4gICAgICBsZXQgYmluZCA9IGV2ZW50QmluZGluZ3NbaV1cbiAgICAgIGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZiwgam9pblJlZiB8fCB0aGlzLmpvaW5SZWYoKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlcGx5RXZlbnROYW1lKHJlZil7IHJldHVybiBgY2hhbl9yZXBseV8ke3JlZn1gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzQ2xvc2VkKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNFcnJvcmVkKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzSm9pbmVkKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luZWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNKb2luaW5nKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTGVhdmluZygpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMubGVhdmluZyB9XG59XG4iLCAiaW1wb3J0IHtcbiAgZ2xvYmFsLFxuICBYSFJfU1RBVEVTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFqYXgge1xuXG4gIHN0YXRpYyByZXF1ZXN0KG1ldGhvZCwgZW5kUG9pbnQsIGFjY2VwdCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayl7XG4gICAgaWYoZ2xvYmFsLlhEb21haW5SZXF1ZXN0KXtcbiAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCkgLy8gSUU4LCBJRTlcbiAgICAgIHJldHVybiB0aGlzLnhkb21haW5SZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJlcSA9IG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKSAvLyBJRTcrLCBGaXJlZm94LCBDaHJvbWUsIE9wZXJhLCBTYWZhcmlcbiAgICAgIHJldHVybiB0aGlzLnhoclJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBhY2NlcHQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHhkb21haW5SZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayl7XG4gICAgcmVxLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgcmVxLm9wZW4obWV0aG9kLCBlbmRQb2ludClcbiAgICByZXEub25sb2FkID0gKCkgPT4ge1xuICAgICAgbGV0IHJlc3BvbnNlID0gdGhpcy5wYXJzZUpTT04ocmVxLnJlc3BvbnNlVGV4dClcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3BvbnNlKVxuICAgIH1cbiAgICBpZihvbnRpbWVvdXQpeyByZXEub250aW1lb3V0ID0gb250aW1lb3V0IH1cblxuICAgIC8vIFdvcmsgYXJvdW5kIGJ1ZyBpbiBJRTkgdGhhdCByZXF1aXJlcyBhbiBhdHRhY2hlZCBvbnByb2dyZXNzIGhhbmRsZXJcbiAgICByZXEub25wcm9ncmVzcyA9ICgpID0+IHsgfVxuXG4gICAgcmVxLnNlbmQoYm9keSlcbiAgICByZXR1cm4gcmVxXG4gIH1cblxuICBzdGF0aWMgeGhyUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGFjY2VwdCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayl7XG4gICAgcmVxLm9wZW4obWV0aG9kLCBlbmRQb2ludCwgdHJ1ZSlcbiAgICByZXEudGltZW91dCA9IHRpbWVvdXRcbiAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBhY2NlcHQpXG4gICAgcmVxLm9uZXJyb3IgPSAoKSA9PiBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsKVxuICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZihyZXEucmVhZHlTdGF0ZSA9PT0gWEhSX1NUQVRFUy5jb21wbGV0ZSAmJiBjYWxsYmFjayl7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHRoaXMucGFyc2VKU09OKHJlcS5yZXNwb25zZVRleHQpXG4gICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihvbnRpbWVvdXQpeyByZXEub250aW1lb3V0ID0gb250aW1lb3V0IH1cblxuICAgIHJlcS5zZW5kKGJvZHkpXG4gICAgcmV0dXJuIHJlcVxuICB9XG5cbiAgc3RhdGljIHBhcnNlSlNPTihyZXNwKXtcbiAgICBpZighcmVzcCB8fCByZXNwID09PSBcIlwiKXsgcmV0dXJuIG51bGwgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3ApXG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICBjb25zb2xlICYmIGNvbnNvbGUubG9nKFwiZmFpbGVkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2VcIiwgcmVzcClcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHNlcmlhbGl6ZShvYmosIHBhcmVudEtleSl7XG4gICAgbGV0IHF1ZXJ5U3RyID0gW11cbiAgICBmb3IodmFyIGtleSBpbiBvYmope1xuICAgICAgaWYoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpeyBjb250aW51ZSB9XG4gICAgICBsZXQgcGFyYW1LZXkgPSBwYXJlbnRLZXkgPyBgJHtwYXJlbnRLZXl9WyR7a2V5fV1gIDoga2V5XG4gICAgICBsZXQgcGFyYW1WYWwgPSBvYmpba2V5XVxuICAgICAgaWYodHlwZW9mIHBhcmFtVmFsID09PSBcIm9iamVjdFwiKXtcbiAgICAgICAgcXVlcnlTdHIucHVzaCh0aGlzLnNlcmlhbGl6ZShwYXJhbVZhbCwgcGFyYW1LZXkpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnlTdHIucHVzaChlbmNvZGVVUklDb21wb25lbnQocGFyYW1LZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1WYWwpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcXVlcnlTdHIuam9pbihcIiZcIilcbiAgfVxuXG4gIHN0YXRpYyBhcHBlbmRQYXJhbXModXJsLCBwYXJhbXMpe1xuICAgIGlmKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKXsgcmV0dXJuIHVybCB9XG5cbiAgICBsZXQgcHJlZml4ID0gdXJsLm1hdGNoKC9cXD8vKSA/IFwiJlwiIDogXCI/XCJcbiAgICByZXR1cm4gYCR7dXJsfSR7cHJlZml4fSR7dGhpcy5zZXJpYWxpemUocGFyYW1zKX1gXG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBTT0NLRVRfU1RBVEVTLFxuICBUUkFOU1BPUlRTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBBamF4IGZyb20gXCIuL2FqYXhcIlxuXG5sZXQgYXJyYXlCdWZmZXJUb0Jhc2U2NCA9IChidWZmZXIpID0+IHtcbiAgbGV0IGJpbmFyeSA9IFwiXCJcbiAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKVxuICBsZXQgbGVuID0gYnl0ZXMuYnl0ZUxlbmd0aFxuICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspeyBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSkgfVxuICByZXR1cm4gYnRvYShiaW5hcnkpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvbmdQb2xsIHtcblxuICBjb25zdHJ1Y3RvcihlbmRQb2ludCl7XG4gICAgdGhpcy5lbmRQb2ludCA9IG51bGxcbiAgICB0aGlzLnRva2VuID0gbnVsbFxuICAgIHRoaXMuc2tpcEhlYXJ0YmVhdCA9IHRydWVcbiAgICB0aGlzLnJlcXMgPSBuZXcgU2V0KClcbiAgICB0aGlzLmF3YWl0aW5nQmF0Y2hBY2sgPSBmYWxzZVxuICAgIHRoaXMuY3VycmVudEJhdGNoID0gbnVsbFxuICAgIHRoaXMuY3VycmVudEJhdGNoVGltZXIgPSBudWxsXG4gICAgdGhpcy5iYXRjaEJ1ZmZlciA9IFtdXG4gICAgdGhpcy5vbm9wZW4gPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5vbmVycm9yID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMub25jbG9zZSA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICB0aGlzLnBvbGxFbmRwb2ludCA9IHRoaXMubm9ybWFsaXplRW5kcG9pbnQoZW5kUG9pbnQpXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nXG4gICAgLy8gd2UgbXVzdCB3YWl0IGZvciB0aGUgY2FsbGVyIHRvIGZpbmlzaCBzZXR0aW5nIHVwIG91ciBjYWxsYmFja3MgYW5kIHRpbWVvdXQgcHJvcGVydGllc1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5wb2xsKCksIDApXG4gIH1cblxuICBub3JtYWxpemVFbmRwb2ludChlbmRQb2ludCl7XG4gICAgcmV0dXJuIChlbmRQb2ludFxuICAgICAgLnJlcGxhY2UoXCJ3czovL1wiLCBcImh0dHA6Ly9cIilcbiAgICAgIC5yZXBsYWNlKFwid3NzOi8vXCIsIFwiaHR0cHM6Ly9cIilcbiAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoLiopXFwvXCIgKyBUUkFOU1BPUlRTLndlYnNvY2tldCksIFwiJDEvXCIgKyBUUkFOU1BPUlRTLmxvbmdwb2xsKSlcbiAgfVxuXG4gIGVuZHBvaW50VVJMKCl7XG4gICAgcmV0dXJuIEFqYXguYXBwZW5kUGFyYW1zKHRoaXMucG9sbEVuZHBvaW50LCB7dG9rZW46IHRoaXMudG9rZW59KVxuICB9XG5cbiAgY2xvc2VBbmRSZXRyeShjb2RlLCByZWFzb24sIHdhc0NsZWFuKXtcbiAgICB0aGlzLmNsb3NlKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nXG4gIH1cblxuICBvbnRpbWVvdXQoKXtcbiAgICB0aGlzLm9uZXJyb3IoXCJ0aW1lb3V0XCIpXG4gICAgdGhpcy5jbG9zZUFuZFJldHJ5KDEwMDUsIFwidGltZW91dFwiLCBmYWxzZSlcbiAgfVxuXG4gIGlzQWN0aXZlKCl7IHJldHVybiB0aGlzLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMub3BlbiB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZyB9XG5cbiAgcG9sbCgpe1xuICAgIHRoaXMuYWpheChcIkdFVFwiLCBcImFwcGxpY2F0aW9uL2pzb25cIiwgbnVsbCwgKCkgPT4gdGhpcy5vbnRpbWVvdXQoKSwgcmVzcCA9PiB7XG4gICAgICBpZihyZXNwKXtcbiAgICAgICAgdmFyIHtzdGF0dXMsIHRva2VuLCBtZXNzYWdlc30gPSByZXNwXG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gMFxuICAgICAgfVxuXG4gICAgICBzd2l0Y2goc3RhdHVzKXtcbiAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChtc2cgPT4ge1xuICAgICAgICAgICAgLy8gVGFza3MgYXJlIHdoYXQgdGhpbmdzIGxpa2UgZXZlbnQgaGFuZGxlcnMsIHNldFRpbWVvdXQgY2FsbGJhY2tzLFxuICAgICAgICAgICAgLy8gcHJvbWlzZSByZXNvbHZlcyBhbmQgbW9yZSBhcmUgcnVuIHdpdGhpbi5cbiAgICAgICAgICAgIC8vIEluIG1vZGVybiBicm93c2VycywgdGhlcmUgYXJlIHR3byBkaWZmZXJlbnQga2luZHMgb2YgdGFza3MsXG4gICAgICAgICAgICAvLyBtaWNyb3Rhc2tzIGFuZCBtYWNyb3Rhc2tzLlxuICAgICAgICAgICAgLy8gTWljcm90YXNrcyBhcmUgbWFpbmx5IHVzZWQgZm9yIFByb21pc2VzLCB3aGlsZSBtYWNyb3Rhc2tzIGFyZVxuICAgICAgICAgICAgLy8gdXNlZCBmb3IgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgICAgICAgLy8gTWljcm90YXNrcyBhbHdheXMgaGF2ZSBwcmlvcml0eSBvdmVyIG1hY3JvdGFza3MuIElmIHRoZSBKUyBlbmdpbmVcbiAgICAgICAgICAgIC8vIGlzIGxvb2tpbmcgZm9yIGEgdGFzayB0byBydW4sIGl0IHdpbGwgYWx3YXlzIHRyeSB0byBlbXB0eSB0aGVcbiAgICAgICAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byBydW4gYW55dGhpbmcgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIG1hY3JvdGFzayBxdWV1ZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGb3IgdGhlIFdlYlNvY2tldCB0cmFuc3BvcnQsIG1lc3NhZ2VzIGFsd2F5cyBhcnJpdmUgaW4gdGhlaXIgb3duXG4gICAgICAgICAgICAvLyBldmVudC4gVGhpcyBtZWFucyB0aGF0IGlmIGFueSBwcm9taXNlcyBhcmUgcmVzb2x2ZWQgZnJvbSB3aXRoaW4sXG4gICAgICAgICAgICAvLyB0aGVpciBjYWxsYmFja3Mgd2lsbCBhbHdheXMgZmluaXNoIGV4ZWN1dGlvbiBieSB0aGUgdGltZSB0aGVcbiAgICAgICAgICAgIC8vIG5leHQgbWVzc2FnZSBldmVudCBoYW5kbGVyIGlzIHJ1bi5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJbiBvcmRlciB0byBlbXVsYXRlIHRoaXMgYmVoYXZpb3VyLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBlYWNoXG4gICAgICAgICAgICAvLyBvbm1lc3NhZ2UgaGFuZGxlciBpcyBydW4gd2l0aGluIGl0cyBvd24gbWFjcm90YXNrLlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLm9ubWVzc2FnZSh7ZGF0YTogbXNnfSksIDApXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0aGlzLnBvbGwoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgIHRoaXMucG9sbCgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0MTA6XG4gICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5vcGVuXG4gICAgICAgICAgdGhpcy5vbm9wZW4oe30pXG4gICAgICAgICAgdGhpcy5wb2xsKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQwMzpcbiAgICAgICAgICB0aGlzLm9uZXJyb3IoNDAzKVxuICAgICAgICAgIHRoaXMuY2xvc2UoMTAwOCwgXCJmb3JiaWRkZW5cIiwgZmFsc2UpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDUwMDpcbiAgICAgICAgICB0aGlzLm9uZXJyb3IoNTAwKVxuICAgICAgICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgxMDExLCBcImludGVybmFsIHNlcnZlciBlcnJvclwiLCA1MDApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgcG9sbCBzdGF0dXMgJHtzdGF0dXN9YClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gd2UgY29sbGVjdCBhbGwgcHVzaGVzIHdpdGhpbiB0aGUgY3VycmVudCBldmVudCBsb29wIGJ5XG4gIC8vIHNldFRpbWVvdXQgMCwgd2hpY2ggb3B0aW1pemVzIGJhY2stdG8tYmFjayBwcm9jZWR1cmFsXG4gIC8vIHB1c2hlcyBhZ2FpbnN0IGFuIGVtcHR5IGJ1ZmZlclxuXG4gIHNlbmQoYm9keSl7XG4gICAgaWYodHlwZW9mKGJvZHkpICE9PSBcInN0cmluZ1wiKXsgYm9keSA9IGFycmF5QnVmZmVyVG9CYXNlNjQoYm9keSkgfVxuICAgIGlmKHRoaXMuY3VycmVudEJhdGNoKXtcbiAgICAgIHRoaXMuY3VycmVudEJhdGNoLnB1c2goYm9keSlcbiAgICB9IGVsc2UgaWYodGhpcy5hd2FpdGluZ0JhdGNoQWNrKXtcbiAgICAgIHRoaXMuYmF0Y2hCdWZmZXIucHVzaChib2R5KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRCYXRjaCA9IFtib2R5XVxuICAgICAgdGhpcy5jdXJyZW50QmF0Y2hUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmJhdGNoU2VuZCh0aGlzLmN1cnJlbnRCYXRjaClcbiAgICAgICAgdGhpcy5jdXJyZW50QmF0Y2ggPSBudWxsXG4gICAgICB9LCAwKVxuICAgIH1cbiAgfVxuXG4gIGJhdGNoU2VuZChtZXNzYWdlcyl7XG4gICAgdGhpcy5hd2FpdGluZ0JhdGNoQWNrID0gdHJ1ZVxuICAgIHRoaXMuYWpheChcIlBPU1RcIiwgXCJhcHBsaWNhdGlvbi94LW5kanNvblwiLCBtZXNzYWdlcy5qb2luKFwiXFxuXCIpLCAoKSA9PiB0aGlzLm9uZXJyb3IoXCJ0aW1lb3V0XCIpLCByZXNwID0+IHtcbiAgICAgIHRoaXMuYXdhaXRpbmdCYXRjaEFjayA9IGZhbHNlXG4gICAgICBpZighcmVzcCB8fCByZXNwLnN0YXR1cyAhPT0gMjAwKXtcbiAgICAgICAgdGhpcy5vbmVycm9yKHJlc3AgJiYgcmVzcC5zdGF0dXMpXG4gICAgICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgxMDExLCBcImludGVybmFsIHNlcnZlciBlcnJvclwiLCBmYWxzZSlcbiAgICAgIH0gZWxzZSBpZih0aGlzLmJhdGNoQnVmZmVyLmxlbmd0aCA+IDApe1xuICAgICAgICB0aGlzLmJhdGNoU2VuZCh0aGlzLmJhdGNoQnVmZmVyKVxuICAgICAgICB0aGlzLmJhdGNoQnVmZmVyID0gW11cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgY2xvc2UoY29kZSwgcmVhc29uLCB3YXNDbGVhbil7XG4gICAgZm9yKGxldCByZXEgb2YgdGhpcy5yZXFzKXsgcmVxLmFib3J0KCkgfVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMuY2xvc2VkXG4gICAgbGV0IG9wdHMgPSBPYmplY3QuYXNzaWduKHtjb2RlOiAxMDAwLCByZWFzb246IHVuZGVmaW5lZCwgd2FzQ2xlYW46IHRydWV9LCB7Y29kZSwgcmVhc29uLCB3YXNDbGVhbn0pXG4gICAgdGhpcy5iYXRjaEJ1ZmZlciA9IFtdXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY3VycmVudEJhdGNoVGltZXIpXG4gICAgdGhpcy5jdXJyZW50QmF0Y2hUaW1lciA9IG51bGxcbiAgICBpZih0eXBlb2YoQ2xvc2VFdmVudCkgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgdGhpcy5vbmNsb3NlKG5ldyBDbG9zZUV2ZW50KFwiY2xvc2VcIiwgb3B0cykpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25jbG9zZShvcHRzKVxuICAgIH1cbiAgfVxuXG4gIGFqYXgobWV0aG9kLCBjb250ZW50VHlwZSwgYm9keSwgb25DYWxsZXJUaW1lb3V0LCBjYWxsYmFjayl7XG4gICAgbGV0IHJlcVxuICAgIGxldCBvbnRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICB0aGlzLnJlcXMuZGVsZXRlKHJlcSlcbiAgICAgIG9uQ2FsbGVyVGltZW91dCgpXG4gICAgfVxuICAgIHJlcSA9IEFqYXgucmVxdWVzdChtZXRob2QsIHRoaXMuZW5kcG9pbnRVUkwoKSwgY29udGVudFR5cGUsIGJvZHksIHRoaXMudGltZW91dCwgb250aW1lb3V0LCByZXNwID0+IHtcbiAgICAgIHRoaXMucmVxcy5kZWxldGUocmVxKVxuICAgICAgaWYodGhpcy5pc0FjdGl2ZSgpKXsgY2FsbGJhY2socmVzcCkgfVxuICAgIH0pXG4gICAgdGhpcy5yZXFzLmFkZChyZXEpXG4gIH1cbn1cbiIsICIvKipcbiAqIEluaXRpYWxpemVzIHRoZSBQcmVzZW5jZVxuICogQHBhcmFtIHtDaGFubmVsfSBjaGFubmVsIC0gVGhlIENoYW5uZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIG9wdGlvbnMsXG4gKiAgICAgICAgZm9yIGV4YW1wbGUgYHtldmVudHM6IHtzdGF0ZTogXCJzdGF0ZVwiLCBkaWZmOiBcImRpZmZcIn19YFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVzZW5jZSB7XG5cbiAgY29uc3RydWN0b3IoY2hhbm5lbCwgb3B0cyA9IHt9KXtcbiAgICBsZXQgZXZlbnRzID0gb3B0cy5ldmVudHMgfHwge3N0YXRlOiBcInByZXNlbmNlX3N0YXRlXCIsIGRpZmY6IFwicHJlc2VuY2VfZGlmZlwifVxuICAgIHRoaXMuc3RhdGUgPSB7fVxuICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsXG4gICAgdGhpcy5qb2luUmVmID0gbnVsbFxuICAgIHRoaXMuY2FsbGVyID0ge1xuICAgICAgb25Kb2luOiBmdW5jdGlvbiAoKXsgfSxcbiAgICAgIG9uTGVhdmU6IGZ1bmN0aW9uICgpeyB9LFxuICAgICAgb25TeW5jOiBmdW5jdGlvbiAoKXsgfVxuICAgIH1cblxuICAgIHRoaXMuY2hhbm5lbC5vbihldmVudHMuc3RhdGUsIG5ld1N0YXRlID0+IHtcbiAgICAgIGxldCB7b25Kb2luLCBvbkxlYXZlLCBvblN5bmN9ID0gdGhpcy5jYWxsZXJcblxuICAgICAgdGhpcy5qb2luUmVmID0gdGhpcy5jaGFubmVsLmpvaW5SZWYoKVxuICAgICAgdGhpcy5zdGF0ZSA9IFByZXNlbmNlLnN5bmNTdGF0ZSh0aGlzLnN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKVxuXG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKGRpZmYgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKVxuICAgICAgfSlcbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cbiAgICAgIG9uU3luYygpXG4gICAgfSlcblxuICAgIHRoaXMuY2hhbm5lbC5vbihldmVudHMuZGlmZiwgZGlmZiA9PiB7XG4gICAgICBsZXQge29uSm9pbiwgb25MZWF2ZSwgb25TeW5jfSA9IHRoaXMuY2FsbGVyXG5cbiAgICAgIGlmKHRoaXMuaW5QZW5kaW5nU3luY1N0YXRlKCkpe1xuICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcy5wdXNoKGRpZmYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKVxuICAgICAgICBvblN5bmMoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBvbkpvaW4oY2FsbGJhY2speyB0aGlzLmNhbGxlci5vbkpvaW4gPSBjYWxsYmFjayB9XG5cbiAgb25MZWF2ZShjYWxsYmFjayl7IHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFjayB9XG5cbiAgb25TeW5jKGNhbGxiYWNrKXsgdGhpcy5jYWxsZXIub25TeW5jID0gY2FsbGJhY2sgfVxuXG4gIGxpc3QoYnkpeyByZXR1cm4gUHJlc2VuY2UubGlzdCh0aGlzLnN0YXRlLCBieSkgfVxuXG4gIGluUGVuZGluZ1N5bmNTdGF0ZSgpe1xuICAgIHJldHVybiAhdGhpcy5qb2luUmVmIHx8ICh0aGlzLmpvaW5SZWYgIT09IHRoaXMuY2hhbm5lbC5qb2luUmVmKCkpXG4gIH1cblxuICAvLyBsb3dlci1sZXZlbCBwdWJsaWMgc3RhdGljIEFQSVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHN5bmMgdGhlIGxpc3Qgb2YgcHJlc2VuY2VzIG9uIHRoZSBzZXJ2ZXJcbiAgICogd2l0aCB0aGUgY2xpZW50J3Mgc3RhdGUuIEFuIG9wdGlvbmFsIGBvbkpvaW5gIGFuZCBgb25MZWF2ZWAgY2FsbGJhY2sgY2FuXG4gICAqIGJlIHByb3ZpZGVkIHRvIHJlYWN0IHRvIGNoYW5nZXMgaW4gdGhlIGNsaWVudCdzIGxvY2FsIHByZXNlbmNlcyBhY3Jvc3NcbiAgICogZGlzY29ubmVjdHMgYW5kIHJlY29ubmVjdHMgd2l0aCB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJlc2VuY2V9XG4gICAqL1xuICBzdGF0aWMgc3luY1N0YXRlKGN1cnJlbnRTdGF0ZSwgbmV3U3RhdGUsIG9uSm9pbiwgb25MZWF2ZSl7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5jbG9uZShjdXJyZW50U3RhdGUpXG4gICAgbGV0IGpvaW5zID0ge31cbiAgICBsZXQgbGVhdmVzID0ge31cblxuICAgIHRoaXMubWFwKHN0YXRlLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgaWYoIW5ld1N0YXRlW2tleV0pe1xuICAgICAgICBsZWF2ZXNba2V5XSA9IHByZXNlbmNlXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLm1hcChuZXdTdGF0ZSwgKGtleSwgbmV3UHJlc2VuY2UpID0+IHtcbiAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldXG4gICAgICBpZihjdXJyZW50UHJlc2VuY2Upe1xuICAgICAgICBsZXQgbmV3UmVmcyA9IG5ld1ByZXNlbmNlLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgICAgbGV0IGN1clJlZnMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgICBsZXQgam9pbmVkTWV0YXMgPSBuZXdQcmVzZW5jZS5tZXRhcy5maWx0ZXIobSA9PiBjdXJSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApXG4gICAgICAgIGxldCBsZWZ0TWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKG0gPT4gbmV3UmVmcy5pbmRleE9mKG0ucGh4X3JlZikgPCAwKVxuICAgICAgICBpZihqb2luZWRNZXRhcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2VcbiAgICAgICAgICBqb2luc1trZXldLm1ldGFzID0gam9pbmVkTWV0YXNcbiAgICAgICAgfVxuICAgICAgICBpZihsZWZ0TWV0YXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgbGVhdmVzW2tleV0gPSB0aGlzLmNsb25lKGN1cnJlbnRQcmVzZW5jZSlcbiAgICAgICAgICBsZWF2ZXNba2V5XS5tZXRhcyA9IGxlZnRNZXRhc1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2VcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0aGlzLnN5bmNEaWZmKHN0YXRlLCB7am9pbnM6IGpvaW5zLCBsZWF2ZXM6IGxlYXZlc30sIG9uSm9pbiwgb25MZWF2ZSlcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBVc2VkIHRvIHN5bmMgYSBkaWZmIG9mIHByZXNlbmNlIGpvaW4gYW5kIGxlYXZlXG4gICAqIGV2ZW50cyBmcm9tIHRoZSBzZXJ2ZXIsIGFzIHRoZXkgaGFwcGVuLiBMaWtlIGBzeW5jU3RhdGVgLCBgc3luY0RpZmZgXG4gICAqIGFjY2VwdHMgb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFja3MgdG8gcmVhY3QgdG8gYSB1c2VyXG4gICAqIGpvaW5pbmcgb3IgbGVhdmluZyBmcm9tIGEgZGV2aWNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJlc2VuY2V9XG4gICAqL1xuICBzdGF0aWMgc3luY0RpZmYoc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSl7XG4gICAgbGV0IHtqb2lucywgbGVhdmVzfSA9IHRoaXMuY2xvbmUoZGlmZilcbiAgICBpZighb25Kb2luKXsgb25Kb2luID0gZnVuY3Rpb24gKCl7IH0gfVxuICAgIGlmKCFvbkxlYXZlKXsgb25MZWF2ZSA9IGZ1bmN0aW9uICgpeyB9IH1cblxuICAgIHRoaXMubWFwKGpvaW5zLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZSA9IHN0YXRlW2tleV1cbiAgICAgIHN0YXRlW2tleV0gPSB0aGlzLmNsb25lKG5ld1ByZXNlbmNlKVxuICAgICAgaWYoY3VycmVudFByZXNlbmNlKXtcbiAgICAgICAgbGV0IGpvaW5lZFJlZnMgPSBzdGF0ZVtrZXldLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgICAgbGV0IGN1ck1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcihtID0+IGpvaW5lZFJlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMClcbiAgICAgICAgc3RhdGVba2V5XS5tZXRhcy51bnNoaWZ0KC4uLmN1ck1ldGFzKVxuICAgICAgfVxuICAgICAgb25Kb2luKGtleSwgY3VycmVudFByZXNlbmNlLCBuZXdQcmVzZW5jZSlcbiAgICB9KVxuICAgIHRoaXMubWFwKGxlYXZlcywgKGtleSwgbGVmdFByZXNlbmNlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XVxuICAgICAgaWYoIWN1cnJlbnRQcmVzZW5jZSl7IHJldHVybiB9XG4gICAgICBsZXQgcmVmc1RvUmVtb3ZlID0gbGVmdFByZXNlbmNlLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgIGN1cnJlbnRQcmVzZW5jZS5tZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIocCA9PiB7XG4gICAgICAgIHJldHVybiByZWZzVG9SZW1vdmUuaW5kZXhPZihwLnBoeF9yZWYpIDwgMFxuICAgICAgfSlcbiAgICAgIG9uTGVhdmUoa2V5LCBjdXJyZW50UHJlc2VuY2UsIGxlZnRQcmVzZW5jZSlcbiAgICAgIGlmKGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5sZW5ndGggPT09IDApe1xuICAgICAgICBkZWxldGUgc3RhdGVba2V5XVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHN0YXRlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJlc2VuY2VzLCB3aXRoIHNlbGVjdGVkIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJlc2VuY2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNob29zZXJcbiAgICpcbiAgICogQHJldHVybnMge1ByZXNlbmNlfVxuICAgKi9cbiAgc3RhdGljIGxpc3QocHJlc2VuY2VzLCBjaG9vc2VyKXtcbiAgICBpZighY2hvb3Nlcil7IGNob29zZXIgPSBmdW5jdGlvbiAoa2V5LCBwcmVzKXsgcmV0dXJuIHByZXMgfSB9XG5cbiAgICByZXR1cm4gdGhpcy5tYXAocHJlc2VuY2VzLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgcmV0dXJuIGNob29zZXIoa2V5LCBwcmVzZW5jZSlcbiAgICB9KVxuICB9XG5cbiAgLy8gcHJpdmF0ZVxuXG4gIHN0YXRpYyBtYXAob2JqLCBmdW5jKXtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5tYXAoa2V5ID0+IGZ1bmMoa2V5LCBvYmpba2V5XSkpXG4gIH1cblxuICBzdGF0aWMgY2xvbmUob2JqKXsgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSkgfVxufVxuIiwgIi8qIFRoZSBkZWZhdWx0IHNlcmlhbGl6ZXIgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyBtZXNzYWdlcyAqL1xuaW1wb3J0IHtcbiAgQ0hBTk5FTF9FVkVOVFNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuZXhwb3J0IGRlZmF1bHQge1xuICBIRUFERVJfTEVOR1RIOiAxLFxuICBNRVRBX0xFTkdUSDogNCxcbiAgS0lORFM6IHtwdXNoOiAwLCByZXBseTogMSwgYnJvYWRjYXN0OiAyfSxcblxuICBlbmNvZGUobXNnLCBjYWxsYmFjayl7XG4gICAgaWYobXNnLnBheWxvYWQuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKXtcbiAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLmJpbmFyeUVuY29kZShtc2cpKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGF5bG9hZCA9IFttc2cuam9pbl9yZWYsIG1zZy5yZWYsIG1zZy50b3BpYywgbXNnLmV2ZW50LCBtc2cucGF5bG9hZF1cbiAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSlcbiAgICB9XG4gIH0sXG5cbiAgZGVjb2RlKHJhd1BheWxvYWQsIGNhbGxiYWNrKXtcbiAgICBpZihyYXdQYXlsb2FkLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcil7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5iaW5hcnlEZWNvZGUocmF3UGF5bG9hZCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBbam9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkXSA9IEpTT04ucGFyc2UocmF3UGF5bG9hZClcbiAgICAgIHJldHVybiBjYWxsYmFjayh7am9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkfSlcbiAgICB9XG4gIH0sXG5cbiAgLy8gcHJpdmF0ZVxuXG4gIGJpbmFyeUVuY29kZShtZXNzYWdlKXtcbiAgICBsZXQge2pvaW5fcmVmLCByZWYsIGV2ZW50LCB0b3BpYywgcGF5bG9hZH0gPSBtZXNzYWdlXG4gICAgbGV0IG1ldGFMZW5ndGggPSB0aGlzLk1FVEFfTEVOR1RIICsgam9pbl9yZWYubGVuZ3RoICsgcmVmLmxlbmd0aCArIHRvcGljLmxlbmd0aCArIGV2ZW50Lmxlbmd0aFxuICAgIGxldCBoZWFkZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5IRUFERVJfTEVOR1RIICsgbWV0YUxlbmd0aClcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhoZWFkZXIpXG4gICAgbGV0IG9mZnNldCA9IDBcblxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRoaXMuS0lORFMucHVzaCkgLy8ga2luZFxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGpvaW5fcmVmLmxlbmd0aClcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCByZWYubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRvcGljLmxlbmd0aClcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBldmVudC5sZW5ndGgpXG4gICAgQXJyYXkuZnJvbShqb2luX3JlZiwgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuICAgIEFycmF5LmZyb20ocmVmLCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG4gICAgQXJyYXkuZnJvbSh0b3BpYywgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuICAgIEFycmF5LmZyb20oZXZlbnQsIGNoYXIgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcblxuICAgIHZhciBjb21iaW5lZCA9IG5ldyBVaW50OEFycmF5KGhlYWRlci5ieXRlTGVuZ3RoICsgcGF5bG9hZC5ieXRlTGVuZ3RoKVxuICAgIGNvbWJpbmVkLnNldChuZXcgVWludDhBcnJheShoZWFkZXIpLCAwKVxuICAgIGNvbWJpbmVkLnNldChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgaGVhZGVyLmJ5dGVMZW5ndGgpXG5cbiAgICByZXR1cm4gY29tYmluZWQuYnVmZmVyXG4gIH0sXG5cbiAgYmluYXJ5RGVjb2RlKGJ1ZmZlcil7XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKVxuICAgIGxldCBraW5kID0gdmlldy5nZXRVaW50OCgwKVxuICAgIGxldCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIHRoaXMuS0lORFMucHVzaDogcmV0dXJuIHRoaXMuZGVjb2RlUHVzaChidWZmZXIsIHZpZXcsIGRlY29kZXIpXG4gICAgICBjYXNlIHRoaXMuS0lORFMucmVwbHk6IHJldHVybiB0aGlzLmRlY29kZVJlcGx5KGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgICAgIGNhc2UgdGhpcy5LSU5EUy5icm9hZGNhc3Q6IHJldHVybiB0aGlzLmRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpXG4gICAgfVxuICB9LFxuXG4gIGRlY29kZVB1c2goYnVmZmVyLCB2aWV3LCBkZWNvZGVyKXtcbiAgICBsZXQgam9pblJlZlNpemUgPSB2aWV3LmdldFVpbnQ4KDEpXG4gICAgbGV0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMilcbiAgICBsZXQgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCgzKVxuICAgIGxldCBvZmZzZXQgPSB0aGlzLkhFQURFUl9MRU5HVEggKyB0aGlzLk1FVEFfTEVOR1RIIC0gMSAvLyBwdXNoZXMgaGF2ZSBubyByZWZcbiAgICBsZXQgam9pblJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGpvaW5SZWZTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBqb2luUmVmU2l6ZVxuICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemVcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgIHJldHVybiB7am9pbl9yZWY6IGpvaW5SZWYsIHJlZjogbnVsbCwgdG9waWM6IHRvcGljLCBldmVudDogZXZlbnQsIHBheWxvYWQ6IGRhdGF9XG4gIH0sXG5cbiAgZGVjb2RlUmVwbHkoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKXtcbiAgICBsZXQgam9pblJlZlNpemUgPSB2aWV3LmdldFVpbnQ4KDEpXG4gICAgbGV0IHJlZlNpemUgPSB2aWV3LmdldFVpbnQ4KDIpXG4gICAgbGV0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMylcbiAgICBsZXQgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCg0KVxuICAgIGxldCBvZmZzZXQgPSB0aGlzLkhFQURFUl9MRU5HVEggKyB0aGlzLk1FVEFfTEVOR1RIXG4gICAgbGV0IGpvaW5SZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBqb2luUmVmU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgam9pblJlZlNpemVcbiAgICBsZXQgcmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgcmVmU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgcmVmU2l6ZVxuICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemVcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgIGxldCBwYXlsb2FkID0ge3N0YXR1czogZXZlbnQsIHJlc3BvbnNlOiBkYXRhfVxuICAgIHJldHVybiB7am9pbl9yZWY6IGpvaW5SZWYsIHJlZjogcmVmLCB0b3BpYzogdG9waWMsIGV2ZW50OiBDSEFOTkVMX0VWRU5UUy5yZXBseSwgcGF5bG9hZDogcGF5bG9hZH1cbiAgfSxcblxuICBkZWNvZGVCcm9hZGNhc3QoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKXtcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgxKVxuICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDIpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIDJcbiAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZVxuICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplXG4gICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aClcblxuICAgIHJldHVybiB7am9pbl9yZWY6IG51bGwsIHJlZjogbnVsbCwgdG9waWM6IHRvcGljLCBldmVudDogZXZlbnQsIHBheWxvYWQ6IGRhdGF9XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBnbG9iYWwsXG4gIHBoeFdpbmRvdyxcbiAgQ0hBTk5FTF9FVkVOVFMsXG4gIERFRkFVTFRfVElNRU9VVCxcbiAgREVGQVVMVF9WU04sXG4gIFNPQ0tFVF9TVEFURVMsXG4gIFRSQU5TUE9SVFMsXG4gIFdTX0NMT1NFX05PUk1BTFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBjbG9zdXJlXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IEFqYXggZnJvbSBcIi4vYWpheFwiXG5pbXBvcnQgQ2hhbm5lbCBmcm9tIFwiLi9jaGFubmVsXCJcbmltcG9ydCBMb25nUG9sbCBmcm9tIFwiLi9sb25ncG9sbFwiXG5pbXBvcnQgU2VyaWFsaXplciBmcm9tIFwiLi9zZXJpYWxpemVyXCJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi90aW1lclwiXG5cbi8qKiBJbml0aWFsaXplcyB0aGUgU29ja2V0ICpcbiAqXG4gKiBGb3IgSUU4IHN1cHBvcnQgdXNlIGFuIEVTNS1zaGltIChodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuZFBvaW50IC0gVGhlIHN0cmluZyBXZWJTb2NrZXQgZW5kcG9pbnQsIGllLCBgXCJ3czovL2V4YW1wbGUuY29tL3NvY2tldFwiYCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXCJ3c3M6Ly9leGFtcGxlLmNvbVwiYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcIi9zb2NrZXRcImAgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMudHJhbnNwb3J0XSAtIFRoZSBXZWJzb2NrZXQgVHJhbnNwb3J0LCBmb3IgZXhhbXBsZSBXZWJTb2NrZXQgb3IgUGhvZW5peC5Mb25nUG9sbC5cbiAqXG4gKiBEZWZhdWx0cyB0byBXZWJTb2NrZXQgd2l0aCBhdXRvbWF0aWMgTG9uZ1BvbGwgZmFsbGJhY2sgaWYgV2ViU29ja2V0IGlzIG5vdCBkZWZpbmVkLlxuICogVG8gZmFsbGJhY2sgdG8gTG9uZ1BvbGwgd2hlbiBXZWJTb2NrZXQgYXR0ZW1wdHMgZmFpbCwgdXNlIGBsb25nUG9sbEZhbGxiYWNrTXM6IDI1MDBgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmxvbmdQb2xsRmFsbGJhY2tNc10gLSBUaGUgbWlsbGlzZWNvbmQgdGltZSB0byBhdHRlbXB0IHRoZSBwcmltYXJ5IHRyYW5zcG9ydFxuICogYmVmb3JlIGZhbGxpbmcgYmFjayB0byB0aGUgTG9uZ1BvbGwgdHJhbnNwb3J0LiBEaXNhYmxlZCBieSBkZWZhdWx0LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmRlYnVnXSAtIFdoZW4gdHJ1ZSwgZW5hYmxlcyBkZWJ1ZyBsb2dnaW5nLiBEZWZhdWx0IGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmVuY29kZV0gLSBUaGUgZnVuY3Rpb24gdG8gZW5jb2RlIG91dGdvaW5nIG1lc3NhZ2VzLlxuICpcbiAqIERlZmF1bHRzIHRvIEpTT04gZW5jb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5kZWNvZGVdIC0gVGhlIGZ1bmN0aW9uIHRvIGRlY29kZSBpbmNvbWluZyBtZXNzYWdlcy5cbiAqXG4gKiBEZWZhdWx0cyB0byBKU09OOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIChwYXlsb2FkLCBjYWxsYmFjaykgPT4gY2FsbGJhY2soSlNPTi5wYXJzZShwYXlsb2FkKSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lb3V0XSAtIFRoZSBkZWZhdWx0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHRyaWdnZXIgcHVzaCB0aW1lb3V0cy5cbiAqXG4gKiBEZWZhdWx0cyBgREVGQVVMVF9USU1FT1VUYFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmhlYXJ0YmVhdEludGVydmFsTXNdIC0gVGhlIG1pbGxpc2VjIGludGVydmFsIHRvIHNlbmQgYSBoZWFydGJlYXQgbWVzc2FnZVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnJlY29ubmVjdEFmdGVyTXNdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWlsbGlzZWNcbiAqIHNvY2tldCByZWNvbm5lY3QgaW50ZXJ2YWwuXG4gKlxuICogRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMCwgNTAsIDEwMCwgMTUwLCAyMDAsIDI1MCwgNTAwLCAxMDAwLCAyMDAwXVt0cmllcyAtIDFdIHx8IDUwMDBcbiAqIH1cbiAqIGBgYGBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMucmVqb2luQWZ0ZXJNc10gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsaXNlY1xuICogcmVqb2luIGludGVydmFsIGZvciBpbmRpdmlkdWFsIGNoYW5uZWxzLlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMDAwLCAyMDAwLCA1MDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiB9XG4gKiBgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMubG9nZ2VyXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZywgaWU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZnVuY3Rpb24oa2luZCwgbXNnLCBkYXRhKSB7XG4gKiAgIGNvbnNvbGUubG9nKGAke2tpbmR9OiAke21zZ31gLCBkYXRhKVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmxvbmdwb2xsZXJUaW1lb3V0XSAtIFRoZSBtYXhpbXVtIHRpbWVvdXQgb2YgYSBsb25nIHBvbGwgQUpBWCByZXF1ZXN0LlxuICpcbiAqIERlZmF1bHRzIHRvIDIwcyAoZG91YmxlIHRoZSBzZXJ2ZXIgbG9uZyBwb2xsIHRpbWVyKS5cbiAqXG4gKiBAcGFyYW0geyhPYmplY3R8ZnVuY3Rpb24pfSBbb3B0cy5wYXJhbXNdIC0gVGhlIG9wdGlvbmFsIHBhcmFtcyB0byBwYXNzIHdoZW4gY29ubmVjdGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJpbmFyeVR5cGVdIC0gVGhlIGJpbmFyeSB0eXBlIHRvIHVzZSBmb3IgYmluYXJ5IFdlYlNvY2tldCBmcmFtZXMuXG4gKlxuICogRGVmYXVsdHMgdG8gXCJhcnJheWJ1ZmZlclwiXG4gKlxuICogQHBhcmFtIHt2c259IFtvcHRzLnZzbl0gLSBUaGUgc2VyaWFsaXplcidzIHByb3RvY29sIHZlcnNpb24gdG8gc2VuZCBvbiBjb25uZWN0LlxuICpcbiAqIERlZmF1bHRzIHRvIERFRkFVTFRfVlNOLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5zZXNzaW9uU3RvcmFnZV0gLSBBbiBvcHRpb25hbCBTdG9yYWdlIGNvbXBhdGlibGUgb2JqZWN0XG4gKiBQaG9lbml4IHVzZXMgc2Vzc2lvblN0b3JhZ2UgZm9yIGxvbmdwb2xsIGZhbGxiYWNrIGhpc3RvcnkuIE92ZXJyaWRpbmcgdGhlIHN0b3JlIGlzXG4gKiB1c2VmdWwgd2hlbiBQaG9lbml4IHdvbid0IGhhdmUgYWNjZXNzIHRvIGBzZXNzaW9uU3RvcmFnZWAuIEZvciBleGFtcGxlLCBUaGlzIGNvdWxkXG4gKiBoYXBwZW4gaWYgYSBzaXRlIGxvYWRzIGEgY3Jvc3MtZG9tYWluIGNoYW5uZWwgaW4gYW4gaWZyYW1lLiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgICBjbGFzcyBJbk1lbW9yeVN0b3JhZ2Uge1xuICogICAgICAgY29uc3RydWN0b3IoKSB7IHRoaXMuc3RvcmFnZSA9IHt9IH1cbiAqICAgICAgIGdldEl0ZW0oa2V5TmFtZSkgeyByZXR1cm4gdGhpcy5zdG9yYWdlW2tleU5hbWVdIHx8IG51bGwgfVxuICogICAgICAgcmVtb3ZlSXRlbShrZXlOYW1lKSB7IGRlbGV0ZSB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gfVxuICogICAgICAgc2V0SXRlbShrZXlOYW1lLCBrZXlWYWx1ZSkgeyB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gPSBrZXlWYWx1ZSB9XG4gKiAgICAgfVxuICpcbiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTb2NrZXQge1xuICBjb25zdHJ1Y3RvcihlbmRQb2ludCwgb3B0cyA9IHt9KXtcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0ge29wZW46IFtdLCBjbG9zZTogW10sIGVycm9yOiBbXSwgbWVzc2FnZTogW119XG4gICAgdGhpcy5jaGFubmVscyA9IFtdXG4gICAgdGhpcy5zZW5kQnVmZmVyID0gW11cbiAgICB0aGlzLnJlZiA9IDBcbiAgICB0aGlzLnRpbWVvdXQgPSBvcHRzLnRpbWVvdXQgfHwgREVGQVVMVF9USU1FT1VUXG4gICAgdGhpcy50cmFuc3BvcnQgPSBvcHRzLnRyYW5zcG9ydCB8fCBnbG9iYWwuV2ViU29ja2V0IHx8IExvbmdQb2xsXG4gICAgdGhpcy5wcmltYXJ5UGFzc2VkSGVhbHRoQ2hlY2sgPSBmYWxzZVxuICAgIHRoaXMubG9uZ1BvbGxGYWxsYmFja01zID0gb3B0cy5sb25nUG9sbEZhbGxiYWNrTXNcbiAgICB0aGlzLmZhbGxiYWNrVGltZXIgPSBudWxsXG4gICAgdGhpcy5zZXNzaW9uU3RvcmUgPSBvcHRzLnNlc3Npb25TdG9yYWdlIHx8IChnbG9iYWwgJiYgZ2xvYmFsLnNlc3Npb25TdG9yYWdlKVxuICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucyA9IDBcbiAgICB0aGlzLmRlZmF1bHRFbmNvZGVyID0gU2VyaWFsaXplci5lbmNvZGUuYmluZChTZXJpYWxpemVyKVxuICAgIHRoaXMuZGVmYXVsdERlY29kZXIgPSBTZXJpYWxpemVyLmRlY29kZS5iaW5kKFNlcmlhbGl6ZXIpXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2VcbiAgICB0aGlzLmJpbmFyeVR5cGUgPSBvcHRzLmJpbmFyeVR5cGUgfHwgXCJhcnJheWJ1ZmZlclwiXG4gICAgdGhpcy5jb25uZWN0Q2xvY2sgPSAxXG4gICAgaWYodGhpcy50cmFuc3BvcnQgIT09IExvbmdQb2xsKXtcbiAgICAgIHRoaXMuZW5jb2RlID0gb3B0cy5lbmNvZGUgfHwgdGhpcy5kZWZhdWx0RW5jb2RlclxuICAgICAgdGhpcy5kZWNvZGUgPSBvcHRzLmRlY29kZSB8fCB0aGlzLmRlZmF1bHREZWNvZGVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5jb2RlID0gdGhpcy5kZWZhdWx0RW5jb2RlclxuICAgICAgdGhpcy5kZWNvZGUgPSB0aGlzLmRlZmF1bHREZWNvZGVyXG4gICAgfVxuICAgIGxldCBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gbnVsbFxuICAgIGlmKHBoeFdpbmRvdyAmJiBwaHhXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcil7XG4gICAgICBwaHhXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIF9lID0+IHtcbiAgICAgICAgaWYodGhpcy5jb25uKXtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgIGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSB0aGlzLmNvbm5lY3RDbG9ja1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCBfZSA9PiB7XG4gICAgICAgIGlmKGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPT09IHRoaXMuY29ubmVjdENsb2NrKXtcbiAgICAgICAgICBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gbnVsbFxuICAgICAgICAgIHRoaXMuY29ubmVjdCgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9IG9wdHMuaGVhcnRiZWF0SW50ZXJ2YWxNcyB8fCAzMDAwMFxuICAgIHRoaXMucmVqb2luQWZ0ZXJNcyA9ICh0cmllcykgPT4ge1xuICAgICAgaWYob3B0cy5yZWpvaW5BZnRlck1zKXtcbiAgICAgICAgcmV0dXJuIG9wdHMucmVqb2luQWZ0ZXJNcyh0cmllcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMTAwMCwgMjAwMCwgNTAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgIGlmKG9wdHMucmVjb25uZWN0QWZ0ZXJNcyl7XG4gICAgICAgIHJldHVybiBvcHRzLnJlY29ubmVjdEFmdGVyTXModHJpZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzEwLCA1MCwgMTAwLCAxNTAsIDIwMCwgMjUwLCA1MDAsIDEwMDAsIDIwMDBdW3RyaWVzIC0gMV0gfHwgNTAwMFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvZ2dlciA9IG9wdHMubG9nZ2VyIHx8IG51bGxcbiAgICBpZighdGhpcy5sb2dnZXIgJiYgb3B0cy5kZWJ1Zyl7XG4gICAgICB0aGlzLmxvZ2dlciA9IChraW5kLCBtc2csIGRhdGEpID0+IHsgY29uc29sZS5sb2coYCR7a2luZH06ICR7bXNnfWAsIGRhdGEpIH1cbiAgICB9XG4gICAgdGhpcy5sb25ncG9sbGVyVGltZW91dCA9IG9wdHMubG9uZ3BvbGxlclRpbWVvdXQgfHwgMjAwMDBcbiAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUob3B0cy5wYXJhbXMgfHwge30pXG4gICAgdGhpcy5lbmRQb2ludCA9IGAke2VuZFBvaW50fS8ke1RSQU5TUE9SVFMud2Vic29ja2V0fWBcbiAgICB0aGlzLnZzbiA9IG9wdHMudnNuIHx8IERFRkFVTFRfVlNOXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lb3V0VGltZXIgPSBudWxsXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IG51bGxcbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB7XG4gICAgICB0aGlzLnRlYXJkb3duKCgpID0+IHRoaXMuY29ubmVjdCgpKVxuICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBMb25nUG9sbCB0cmFuc3BvcnQgcmVmZXJlbmNlXG4gICAqL1xuICBnZXRMb25nUG9sbFRyYW5zcG9ydCgpeyByZXR1cm4gTG9uZ1BvbGwgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyBhbmQgcmVwbGFjZXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnRcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV3VHJhbnNwb3J0IC0gVGhlIG5ldyB0cmFuc3BvcnQgY2xhc3MgdG8gaW5zdGFudGlhdGVcbiAgICpcbiAgICovXG4gIHJlcGxhY2VUcmFuc3BvcnQobmV3VHJhbnNwb3J0KXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gdHJ1ZVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgaWYodGhpcy5jb25uKXtcbiAgICAgIHRoaXMuY29ubi5jbG9zZSgpXG4gICAgICB0aGlzLmNvbm4gPSBudWxsXG4gICAgfVxuICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3VHJhbnNwb3J0XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc29ja2V0IHByb3RvY29sXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBwcm90b2NvbCgpeyByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wubWF0Y2goL15odHRwcy8pID8gXCJ3c3NcIiA6IFwid3NcIiB9XG5cbiAgLyoqXG4gICAqIFRoZSBmdWxseSBxdWFsaWZpZWQgc29ja2V0IHVybFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZW5kUG9pbnRVUkwoKXtcbiAgICBsZXQgdXJpID0gQWpheC5hcHBlbmRQYXJhbXMoXG4gICAgICBBamF4LmFwcGVuZFBhcmFtcyh0aGlzLmVuZFBvaW50LCB0aGlzLnBhcmFtcygpKSwge3ZzbjogdGhpcy52c259KVxuICAgIGlmKHVyaS5jaGFyQXQoMCkgIT09IFwiL1wiKXsgcmV0dXJuIHVyaSB9XG4gICAgaWYodXJpLmNoYXJBdCgxKSA9PT0gXCIvXCIpeyByZXR1cm4gYCR7dGhpcy5wcm90b2NvbCgpfToke3VyaX1gIH1cblxuICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9Oi8vJHtsb2NhdGlvbi5ob3N0fSR7dXJpfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0XG4gICAqXG4gICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2xvc2VFdmVudCNTdGF0dXNfY29kZXMgZm9yIHZhbGlkIHN0YXR1cyBjb2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgc29ja2V0IGlzIGRpc2Nvbm5lY3RlZC5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBjb2RlIC0gQSBzdGF0dXMgY29kZSBmb3IgZGlzY29ubmVjdGlvbiAoT3B0aW9uYWwpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gQSB0ZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHRoZSByZWFzb24gdG8gZGlzY29ubmVjdC4gKE9wdGlvbmFsKVxuICAgKi9cbiAgZGlzY29ubmVjdChjYWxsYmFjaywgY29kZSwgcmVhc29uKXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gdHJ1ZVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgdGhpcy50ZWFyZG93bihjYWxsYmFjaywgY29kZSwgcmVhc29uKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1zIHRvIHNlbmQgd2hlbiBjb25uZWN0aW5nLCBmb3IgZXhhbXBsZSBge3VzZXJfaWQ6IHVzZXJUb2tlbn1gXG4gICAqXG4gICAqIFBhc3NpbmcgcGFyYW1zIHRvIGNvbm5lY3QgaXMgZGVwcmVjYXRlZDsgcGFzcyB0aGVtIGluIHRoZSBTb2NrZXQgY29uc3RydWN0b3IgaW5zdGVhZDpcbiAgICogYG5ldyBTb2NrZXQoXCIvc29ja2V0XCIsIHtwYXJhbXM6IHt1c2VyX2lkOiB1c2VyVG9rZW59fSlgLlxuICAgKi9cbiAgY29ubmVjdChwYXJhbXMpe1xuICAgIGlmKHBhcmFtcyl7XG4gICAgICBjb25zb2xlICYmIGNvbnNvbGUubG9nKFwicGFzc2luZyBwYXJhbXMgdG8gY29ubmVjdCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHBhc3MgOnBhcmFtcyB0byB0aGUgU29ja2V0IGNvbnN0cnVjdG9yXCIpXG4gICAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUocGFyYW1zKVxuICAgIH1cbiAgICBpZih0aGlzLmNvbm4peyByZXR1cm4gfVxuICAgIGlmKHRoaXMubG9uZ1BvbGxGYWxsYmFja01zICYmIHRoaXMudHJhbnNwb3J0ICE9PSBMb25nUG9sbCl7XG4gICAgICB0aGlzLmNvbm5lY3RXaXRoRmFsbGJhY2soTG9uZ1BvbGwsIHRoaXMubG9uZ1BvbGxGYWxsYmFja01zKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zcG9ydENvbm5lY3QoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIHRoZSBtZXNzYWdlLiBPdmVycmlkZSBgdGhpcy5sb2dnZXJgIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLiBub29wcyBieSBkZWZhdWx0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBraW5kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG4gIGxvZyhraW5kLCBtc2csIGRhdGEpeyB0aGlzLmxvZ2dlciAmJiB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgbG9nZ2VyIGhhcyBiZWVuIHNldCBvbiB0aGlzIHNvY2tldC5cbiAgICovXG4gIGhhc0xvZ2dlcigpeyByZXR1cm4gdGhpcy5sb2dnZXIgIT09IG51bGwgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGZvciBjb25uZWN0aW9uIG9wZW4gZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlIHNvY2tldC5vbk9wZW4oZnVuY3Rpb24oKXsgY29uc29sZS5pbmZvKFwidGhlIHNvY2tldCB3YXMgb3BlbmVkXCIpIH0pXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbk9wZW4oY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBjbG9zZSBldmVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uQ2xvc2UoY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgZm9yIGNvbm5lY3Rpb24gZXJyb3IgZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlIHNvY2tldC5vbkVycm9yKGZ1bmN0aW9uKGVycm9yKXsgYWxlcnQoXCJBbiBlcnJvciBvY2N1cnJlZFwiKSB9KVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25FcnJvcihjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBtZXNzYWdlIGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25NZXNzYWdlKGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFBpbmdzIHRoZSBzZXJ2ZXIgYW5kIGludm9rZXMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIFJUVCBpbiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwaW5nIHdhcyBwdXNoZWQgb3IgZmFsc2UgaWYgdW5hYmxlIHRvIGJlIHB1c2hlZC5cbiAgICovXG4gIHBpbmcoY2FsbGJhY2spe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gZmFsc2UgfVxuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIGxldCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgdGhpcy5wdXNoKHt0b3BpYzogXCJwaG9lbml4XCIsIGV2ZW50OiBcImhlYXJ0YmVhdFwiLCBwYXlsb2FkOiB7fSwgcmVmOiByZWZ9KVxuICAgIGxldCBvbk1zZ1JlZiA9IHRoaXMub25NZXNzYWdlKG1zZyA9PiB7XG4gICAgICBpZihtc2cucmVmID09PSByZWYpe1xuICAgICAgICB0aGlzLm9mZihbb25Nc2dSZWZdKVxuICAgICAgICBjYWxsYmFjayhEYXRlLm5vdygpIC0gc3RhcnRUaW1lKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0cmFuc3BvcnRDb25uZWN0KCl7XG4gICAgdGhpcy5jb25uZWN0Q2xvY2srK1xuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgdGhpcy5jb25uID0gbmV3IHRoaXMudHJhbnNwb3J0KHRoaXMuZW5kUG9pbnRVUkwoKSlcbiAgICB0aGlzLmNvbm4uYmluYXJ5VHlwZSA9IHRoaXMuYmluYXJ5VHlwZVxuICAgIHRoaXMuY29ubi50aW1lb3V0ID0gdGhpcy5sb25ncG9sbGVyVGltZW91dFxuICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLm9uQ29ubk9wZW4oKVxuICAgIHRoaXMuY29ubi5vbmVycm9yID0gZXJyb3IgPT4gdGhpcy5vbkNvbm5FcnJvcihlcnJvcilcbiAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gZXZlbnQgPT4gdGhpcy5vbkNvbm5NZXNzYWdlKGV2ZW50KVxuICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZXZlbnQgPT4gdGhpcy5vbkNvbm5DbG9zZShldmVudClcbiAgfVxuXG4gIGdldFNlc3Npb24oa2V5KXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JlICYmIHRoaXMuc2Vzc2lvblN0b3JlLmdldEl0ZW0oa2V5KSB9XG5cbiAgc3RvcmVTZXNzaW9uKGtleSwgdmFsKXsgdGhpcy5zZXNzaW9uU3RvcmUgJiYgdGhpcy5zZXNzaW9uU3RvcmUuc2V0SXRlbShrZXksIHZhbCkgfVxuXG4gIGNvbm5lY3RXaXRoRmFsbGJhY2soZmFsbGJhY2tUcmFuc3BvcnQsIGZhbGxiYWNrVGhyZXNob2xkID0gMjUwMCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZmFsbGJhY2tUaW1lcilcbiAgICBsZXQgZXN0YWJsaXNoZWQgPSBmYWxzZVxuICAgIGxldCBwcmltYXJ5VHJhbnNwb3J0ID0gdHJ1ZVxuICAgIGxldCBvcGVuUmVmLCBlcnJvclJlZlxuICAgIGxldCBmYWxsYmFjayA9IChyZWFzb24pID0+IHtcbiAgICAgIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBmYWxsaW5nIGJhY2sgdG8gJHtmYWxsYmFja1RyYW5zcG9ydC5uYW1lfS4uLmAsIHJlYXNvbilcbiAgICAgIHRoaXMub2ZmKFtvcGVuUmVmLCBlcnJvclJlZl0pXG4gICAgICBwcmltYXJ5VHJhbnNwb3J0ID0gZmFsc2VcbiAgICAgIHRoaXMucmVwbGFjZVRyYW5zcG9ydChmYWxsYmFja1RyYW5zcG9ydClcbiAgICAgIHRoaXMudHJhbnNwb3J0Q29ubmVjdCgpXG4gICAgfVxuICAgIGlmKHRoaXMuZ2V0U2Vzc2lvbihgcGh4OmZhbGxiYWNrOiR7ZmFsbGJhY2tUcmFuc3BvcnQubmFtZX1gKSl7IHJldHVybiBmYWxsYmFjayhcIm1lbW9yaXplZFwiKSB9XG5cbiAgICB0aGlzLmZhbGxiYWNrVGltZXIgPSBzZXRUaW1lb3V0KGZhbGxiYWNrLCBmYWxsYmFja1RocmVzaG9sZClcblxuICAgIGVycm9yUmVmID0gdGhpcy5vbkVycm9yKHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImVycm9yXCIsIHJlYXNvbilcbiAgICAgIGlmKHByaW1hcnlUcmFuc3BvcnQgJiYgIWVzdGFibGlzaGVkKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZmFsbGJhY2tUaW1lcilcbiAgICAgICAgZmFsbGJhY2socmVhc29uKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5vbk9wZW4oKCkgPT4ge1xuICAgICAgZXN0YWJsaXNoZWQgPSB0cnVlXG4gICAgICBpZighcHJpbWFyeVRyYW5zcG9ydCl7XG4gICAgICAgIC8vIG9ubHkgbWVtb3JpemUgTFAgaWYgd2UgbmV2ZXIgY29ubmVjdGVkIHRvIHByaW1hcnlcbiAgICAgICAgaWYoIXRoaXMucHJpbWFyeVBhc3NlZEhlYWx0aENoZWNrKXsgdGhpcy5zdG9yZVNlc3Npb24oYHBoeDpmYWxsYmFjazoke2ZhbGxiYWNrVHJhbnNwb3J0Lm5hbWV9YCwgXCJ0cnVlXCIpIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBlc3RhYmxpc2hlZCAke2ZhbGxiYWNrVHJhbnNwb3J0Lm5hbWV9IGZhbGxiYWNrYClcbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlJ3ZlIGVzdGFibGlzaGVkIHByaW1hcnksIGdpdmUgdGhlIGZhbGxiYWNrIGEgbmV3IHBlcmlvZCB0byBhdHRlbXB0IHBpbmdcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgICB0aGlzLmZhbGxiYWNrVGltZXIgPSBzZXRUaW1lb3V0KGZhbGxiYWNrLCBmYWxsYmFja1RocmVzaG9sZClcbiAgICAgIHRoaXMucGluZyhydHQgPT4ge1xuICAgICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImNvbm5lY3RlZCB0byBwcmltYXJ5IGFmdGVyXCIsIHJ0dClcbiAgICAgICAgdGhpcy5wcmltYXJ5UGFzc2VkSGVhbHRoQ2hlY2sgPSB0cnVlXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy50cmFuc3BvcnRDb25uZWN0KClcbiAgfVxuXG4gIGNsZWFySGVhcnRiZWF0cygpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYXJ0YmVhdFRpbWVyKVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYXJ0YmVhdFRpbWVvdXRUaW1lcilcbiAgfVxuXG4gIG9uQ29ubk9wZW4oKXtcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBgJHt0aGlzLnRyYW5zcG9ydC5uYW1lfSBjb25uZWN0ZWQgdG8gJHt0aGlzLmVuZFBvaW50VVJMKCl9YClcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucysrXG4gICAgdGhpcy5mbHVzaFNlbmRCdWZmZXIoKVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIHRoaXMucmVzZXRIZWFydGJlYXQoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5mb3JFYWNoKChbLCBjYWxsYmFja10pID0+IGNhbGxiYWNrKCkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgaGVhcnRiZWF0VGltZW91dCgpe1xuICAgIGlmKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZil7XG4gICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgICBpZih0aGlzLmhhc0xvZ2dlcigpKXsgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJoZWFydGJlYXQgdGltZW91dC4gQXR0ZW1wdGluZyB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvblwiKSB9XG4gICAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2VcbiAgICAgIHRoaXMudGVhcmRvd24oKCkgPT4gdGhpcy5yZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSwgV1NfQ0xPU0VfTk9STUFMLCBcImhlYXJ0YmVhdCB0aW1lb3V0XCIpXG4gICAgfVxuICB9XG5cbiAgcmVzZXRIZWFydGJlYXQoKXtcbiAgICBpZih0aGlzLmNvbm4gJiYgdGhpcy5jb25uLnNraXBIZWFydGJlYXQpeyByZXR1cm4gfVxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICB0aGlzLmNsZWFySGVhcnRiZWF0cygpXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcylcbiAgfVxuXG4gIHRlYXJkb3duKGNhbGxiYWNrLCBjb2RlLCByZWFzb24pe1xuICAgIGlmKCF0aGlzLmNvbm4pe1xuICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICB0aGlzLndhaXRGb3JCdWZmZXJEb25lKCgpID0+IHtcbiAgICAgIGlmKHRoaXMuY29ubil7XG4gICAgICAgIGlmKGNvZGUpeyB0aGlzLmNvbm4uY2xvc2UoY29kZSwgcmVhc29uIHx8IFwiXCIpIH0gZWxzZSB7IHRoaXMuY29ubi5jbG9zZSgpIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy53YWl0Rm9yU29ja2V0Q2xvc2VkKCgpID0+IHtcbiAgICAgICAgaWYodGhpcy5jb25uKXtcbiAgICAgICAgICB0aGlzLmNvbm4ub25vcGVuID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgICAgICAgIHRoaXMuY29ubi5vbmVycm9yID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgICAgICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgICAgICAgdGhpcy5jb25uID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgd2FpdEZvckJ1ZmZlckRvbmUoY2FsbGJhY2ssIHRyaWVzID0gMSl7XG4gICAgaWYodHJpZXMgPT09IDUgfHwgIXRoaXMuY29ubiB8fCAhdGhpcy5jb25uLmJ1ZmZlcmVkQW1vdW50KXtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy53YWl0Rm9yQnVmZmVyRG9uZShjYWxsYmFjaywgdHJpZXMgKyAxKVxuICAgIH0sIDE1MCAqIHRyaWVzKVxuICB9XG5cbiAgd2FpdEZvclNvY2tldENsb3NlZChjYWxsYmFjaywgdHJpZXMgPSAxKXtcbiAgICBpZih0cmllcyA9PT0gNSB8fCAhdGhpcy5jb25uIHx8IHRoaXMuY29ubi5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLmNsb3NlZCl7XG4gICAgICBjYWxsYmFjaygpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMud2FpdEZvclNvY2tldENsb3NlZChjYWxsYmFjaywgdHJpZXMgKyAxKVxuICAgIH0sIDE1MCAqIHRyaWVzKVxuICB9XG5cbiAgb25Db25uQ2xvc2UoZXZlbnQpe1xuICAgIGxldCBjbG9zZUNvZGUgPSBldmVudCAmJiBldmVudC5jb2RlXG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJjbG9zZVwiLCBldmVudClcbiAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgIHRoaXMuY2xlYXJIZWFydGJlYXRzKClcbiAgICBpZighdGhpcy5jbG9zZVdhc0NsZWFuICYmIGNsb3NlQ29kZSAhPT0gMTAwMCl7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpXG4gICAgfVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UuZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiBjYWxsYmFjayhldmVudCkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uQ29ubkVycm9yKGVycm9yKXtcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBlcnJvcilcbiAgICBsZXQgdHJhbnNwb3J0QmVmb3JlID0gdGhpcy50cmFuc3BvcnRcbiAgICBsZXQgZXN0YWJsaXNoZWRCZWZvcmUgPSB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnNcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4ge1xuICAgICAgY2FsbGJhY2soZXJyb3IsIHRyYW5zcG9ydEJlZm9yZSwgZXN0YWJsaXNoZWRCZWZvcmUpXG4gICAgfSlcbiAgICBpZih0cmFuc3BvcnRCZWZvcmUgPT09IHRoaXMudHJhbnNwb3J0IHx8IGVzdGFibGlzaGVkQmVmb3JlID4gMCl7XG4gICAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlckNoYW5FcnJvcigpe1xuICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaChjaGFubmVsID0+IHtcbiAgICAgIGlmKCEoY2hhbm5lbC5pc0Vycm9yZWQoKSB8fCBjaGFubmVsLmlzTGVhdmluZygpIHx8IGNoYW5uZWwuaXNDbG9zZWQoKSkpe1xuICAgICAgICBjaGFubmVsLnRyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgY29ubmVjdGlvblN0YXRlKCl7XG4gICAgc3dpdGNoKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4ucmVhZHlTdGF0ZSl7XG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzogcmV0dXJuIFwiY29ubmVjdGluZ1wiXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMub3BlbjogcmV0dXJuIFwib3BlblwiXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY2xvc2luZzogcmV0dXJuIFwiY2xvc2luZ1wiXG4gICAgICBkZWZhdWx0OiByZXR1cm4gXCJjbG9zZWRcIlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ29ubmVjdGVkKCl7IHJldHVybiB0aGlzLmNvbm5lY3Rpb25TdGF0ZSgpID09PSBcIm9wZW5cIiB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Q2hhbm5lbH1cbiAgICovXG4gIHJlbW92ZShjaGFubmVsKXtcbiAgICB0aGlzLm9mZihjaGFubmVsLnN0YXRlQ2hhbmdlUmVmcylcbiAgICB0aGlzLmNoYW5uZWxzID0gdGhpcy5jaGFubmVscy5maWx0ZXIoYyA9PiBjICE9PSBjaGFubmVsKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYG9uT3BlbmAsIGBvbkNsb3NlYCwgYG9uRXJyb3IsYCBhbmQgYG9uTWVzc2FnZWAgcmVnaXN0cmF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtyZWZzfSAtIGxpc3Qgb2YgcmVmcyByZXR1cm5lZCBieSBjYWxscyB0b1xuICAgKiAgICAgICAgICAgICAgICAgYG9uT3BlbmAsIGBvbkNsb3NlYCwgYG9uRXJyb3IsYCBhbmQgYG9uTWVzc2FnZWBcbiAgICovXG4gIG9mZihyZWZzKXtcbiAgICBmb3IobGV0IGtleSBpbiB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzKXtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Nba2V5XSA9IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Nba2V5XS5maWx0ZXIoKFtyZWZdKSA9PiB7XG4gICAgICAgIHJldHVybiByZWZzLmluZGV4T2YocmVmKSA9PT0gLTFcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIG5ldyBjaGFubmVsIGZvciB0aGUgZ2l2ZW4gdG9waWNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuUGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgdGhlIGNoYW5uZWxcbiAgICogQHJldHVybnMge0NoYW5uZWx9XG4gICAqL1xuICBjaGFubmVsKHRvcGljLCBjaGFuUGFyYW1zID0ge30pe1xuICAgIGxldCBjaGFuID0gbmV3IENoYW5uZWwodG9waWMsIGNoYW5QYXJhbXMsIHRoaXMpXG4gICAgdGhpcy5jaGFubmVscy5wdXNoKGNoYW4pXG4gICAgcmV0dXJuIGNoYW5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cbiAgcHVzaChkYXRhKXtcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKXtcbiAgICAgIGxldCB7dG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5fcmVmfSA9IGRhdGFcbiAgICAgIHRoaXMubG9nKFwicHVzaFwiLCBgJHt0b3BpY30gJHtldmVudH0gKCR7am9pbl9yZWZ9LCAke3JlZn0pYCwgcGF5bG9hZClcbiAgICB9XG5cbiAgICBpZih0aGlzLmlzQ29ubmVjdGVkKCkpe1xuICAgICAgdGhpcy5lbmNvZGUoZGF0YSwgcmVzdWx0ID0+IHRoaXMuY29ubi5zZW5kKHJlc3VsdCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKCgpID0+IHRoaXMuZW5jb2RlKGRhdGEsIHJlc3VsdCA9PiB0aGlzLmNvbm4uc2VuZChyZXN1bHQpKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuZXh0IG1lc3NhZ2UgcmVmLCBhY2NvdW50aW5nIGZvciBvdmVyZmxvd3NcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIG1ha2VSZWYoKXtcbiAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYgKyAxXG4gICAgaWYobmV3UmVmID09PSB0aGlzLnJlZil7IHRoaXMucmVmID0gMCB9IGVsc2UgeyB0aGlzLnJlZiA9IG5ld1JlZiB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWYudG9TdHJpbmcoKVxuICB9XG5cbiAgc2VuZEhlYXJ0YmVhdCgpe1xuICAgIGlmKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiAmJiAhdGhpcy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMucHVzaCh7dG9waWM6IFwicGhvZW5peFwiLCBldmVudDogXCJoZWFydGJlYXRcIiwgcGF5bG9hZDoge30sIHJlZjogdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmfSlcbiAgICB0aGlzLmhlYXJ0YmVhdFRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oZWFydGJlYXRUaW1lb3V0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcylcbiAgfVxuXG4gIGZsdXNoU2VuZEJ1ZmZlcigpe1xuICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCl7XG4gICAgICB0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjaygpKVxuICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW11cbiAgICB9XG4gIH1cblxuICBvbkNvbm5NZXNzYWdlKHJhd01lc3NhZ2Upe1xuICAgIHRoaXMuZGVjb2RlKHJhd01lc3NhZ2UuZGF0YSwgbXNnID0+IHtcbiAgICAgIGxldCB7dG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5fcmVmfSA9IG1zZ1xuICAgICAgaWYocmVmICYmIHJlZiA9PT0gdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKXtcbiAgICAgICAgdGhpcy5jbGVhckhlYXJ0YmVhdHMoKVxuICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpXG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwicmVjZWl2ZVwiLCBgJHtwYXlsb2FkLnN0YXR1cyB8fCBcIlwifSAke3RvcGljfSAke2V2ZW50fSAke3JlZiAmJiBcIihcIiArIHJlZiArIFwiKVwiIHx8IFwiXCJ9YCwgcGF5bG9hZClcblxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXVxuICAgICAgICBpZighY2hhbm5lbC5pc01lbWJlcih0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5fcmVmKSl7IGNvbnRpbnVlIH1cbiAgICAgICAgY2hhbm5lbC50cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5fcmVmKVxuICAgICAgfVxuXG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgbGV0IFssIGNhbGxiYWNrXSA9IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZVtpXVxuICAgICAgICBjYWxsYmFjayhtc2cpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGxlYXZlT3BlblRvcGljKHRvcGljKXtcbiAgICBsZXQgZHVwQ2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZmluZChjID0+IGMudG9waWMgPT09IHRvcGljICYmIChjLmlzSm9pbmVkKCkgfHwgYy5pc0pvaW5pbmcoKSkpXG4gICAgaWYoZHVwQ2hhbm5lbCl7XG4gICAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBgbGVhdmluZyBkdXBsaWNhdGUgdG9waWMgXCIke3RvcGljfVwiYClcbiAgICAgIGR1cENoYW5uZWwubGVhdmUoKVxuICAgIH1cbiAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBDT05TRUNVVElWRV9SRUxPQURTID0gXCJjb25zZWN1dGl2ZS1yZWxvYWRzXCJcbmV4cG9ydCBjb25zdCBNQVhfUkVMT0FEUyA9IDEwXG5leHBvcnQgY29uc3QgUkVMT0FEX0pJVFRFUl9NSU4gPSA1MDAwXG5leHBvcnQgY29uc3QgUkVMT0FEX0pJVFRFUl9NQVggPSAxMDAwMFxuZXhwb3J0IGNvbnN0IEZBSUxTQUZFX0pJVFRFUiA9IDMwMDAwXG5leHBvcnQgY29uc3QgUEhYX0VWRU5UX0NMQVNTRVMgPSBbXG4gIFwicGh4LWNsaWNrLWxvYWRpbmdcIiwgXCJwaHgtY2hhbmdlLWxvYWRpbmdcIiwgXCJwaHgtc3VibWl0LWxvYWRpbmdcIixcbiAgXCJwaHgta2V5ZG93bi1sb2FkaW5nXCIsIFwicGh4LWtleXVwLWxvYWRpbmdcIiwgXCJwaHgtYmx1ci1sb2FkaW5nXCIsIFwicGh4LWZvY3VzLWxvYWRpbmdcIixcbiAgXCJwaHgtaG9vay1sb2FkaW5nXCJcbl1cbmV4cG9ydCBjb25zdCBQSFhfQ09NUE9ORU5UID0gXCJkYXRhLXBoeC1jb21wb25lbnRcIlxuZXhwb3J0IGNvbnN0IFBIWF9MSVZFX0xJTksgPSBcImRhdGEtcGh4LWxpbmtcIlxuZXhwb3J0IGNvbnN0IFBIWF9UUkFDS19TVEFUSUMgPSBcInRyYWNrLXN0YXRpY1wiXG5leHBvcnQgY29uc3QgUEhYX0xJTktfU1RBVEUgPSBcImRhdGEtcGh4LWxpbmstc3RhdGVcIlxuZXhwb3J0IGNvbnN0IFBIWF9SRUZfTE9BRElORyA9IFwiZGF0YS1waHgtcmVmLWxvYWRpbmdcIlxuZXhwb3J0IGNvbnN0IFBIWF9SRUZfU1JDID0gXCJkYXRhLXBoeC1yZWYtc3JjXCJcbmV4cG9ydCBjb25zdCBQSFhfUkVGX0xPQ0sgPSBcImRhdGEtcGh4LXJlZi1sb2NrXCJcbmV4cG9ydCBjb25zdCBQSFhfVFJBQ0tfVVBMT0FEUyA9IFwidHJhY2stdXBsb2Fkc1wiXG5leHBvcnQgY29uc3QgUEhYX1VQTE9BRF9SRUYgPSBcImRhdGEtcGh4LXVwbG9hZC1yZWZcIlxuZXhwb3J0IGNvbnN0IFBIWF9QUkVGTElHSFRFRF9SRUZTID0gXCJkYXRhLXBoeC1wcmVmbGlnaHRlZC1yZWZzXCJcbmV4cG9ydCBjb25zdCBQSFhfRE9ORV9SRUZTID0gXCJkYXRhLXBoeC1kb25lLXJlZnNcIlxuZXhwb3J0IGNvbnN0IFBIWF9EUk9QX1RBUkdFVCA9IFwiZHJvcC10YXJnZXRcIlxuZXhwb3J0IGNvbnN0IFBIWF9BQ1RJVkVfRU5UUllfUkVGUyA9IFwiZGF0YS1waHgtYWN0aXZlLXJlZnNcIlxuZXhwb3J0IGNvbnN0IFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCA9IFwicGh4OmxpdmUtZmlsZTp1cGRhdGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfU0tJUCA9IFwiZGF0YS1waHgtc2tpcFwiXG5leHBvcnQgY29uc3QgUEhYX01BR0lDX0lEID0gXCJkYXRhLXBoeC1pZFwiXG5leHBvcnQgY29uc3QgUEhYX1BSVU5FID0gXCJkYXRhLXBoeC1wcnVuZVwiXG5leHBvcnQgY29uc3QgUEhYX0NPTk5FQ1RFRF9DTEFTUyA9IFwicGh4LWNvbm5lY3RlZFwiXG5leHBvcnQgY29uc3QgUEhYX0xPQURJTkdfQ0xBU1MgPSBcInBoeC1sb2FkaW5nXCJcbmV4cG9ydCBjb25zdCBQSFhfRVJST1JfQ0xBU1MgPSBcInBoeC1lcnJvclwiXG5leHBvcnQgY29uc3QgUEhYX0NMSUVOVF9FUlJPUl9DTEFTUyA9IFwicGh4LWNsaWVudC1lcnJvclwiXG5leHBvcnQgY29uc3QgUEhYX1NFUlZFUl9FUlJPUl9DTEFTUyA9IFwicGh4LXNlcnZlci1lcnJvclwiXG5leHBvcnQgY29uc3QgUEhYX1BBUkVOVF9JRCA9IFwiZGF0YS1waHgtcGFyZW50LWlkXCJcbmV4cG9ydCBjb25zdCBQSFhfTUFJTiA9IFwiZGF0YS1waHgtbWFpblwiXG5leHBvcnQgY29uc3QgUEhYX1JPT1RfSUQgPSBcImRhdGEtcGh4LXJvb3QtaWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9WSUVXUE9SVF9UT1AgPSBcInZpZXdwb3J0LXRvcFwiXG5leHBvcnQgY29uc3QgUEhYX1ZJRVdQT1JUX0JPVFRPTSA9IFwidmlld3BvcnQtYm90dG9tXCJcbmV4cG9ydCBjb25zdCBQSFhfVFJJR0dFUl9BQ1RJT04gPSBcInRyaWdnZXItYWN0aW9uXCJcbmV4cG9ydCBjb25zdCBQSFhfSEFTX0ZPQ1VTRUQgPSBcInBoeC1oYXMtZm9jdXNlZFwiXG5leHBvcnQgY29uc3QgRk9DVVNBQkxFX0lOUFVUUyA9IFtcInRleHRcIiwgXCJ0ZXh0YXJlYVwiLCBcIm51bWJlclwiLCBcImVtYWlsXCIsIFwicGFzc3dvcmRcIiwgXCJzZWFyY2hcIiwgXCJ0ZWxcIiwgXCJ1cmxcIiwgXCJkYXRlXCIsIFwidGltZVwiLCBcImRhdGV0aW1lLWxvY2FsXCIsIFwiY29sb3JcIiwgXCJyYW5nZVwiXVxuZXhwb3J0IGNvbnN0IENIRUNLQUJMRV9JTlBVVFMgPSBbXCJjaGVja2JveFwiLCBcInJhZGlvXCJdXG5leHBvcnQgY29uc3QgUEhYX0hBU19TVUJNSVRURUQgPSBcInBoeC1oYXMtc3VibWl0dGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfU0VTU0lPTiA9IFwiZGF0YS1waHgtc2Vzc2lvblwiXG5leHBvcnQgY29uc3QgUEhYX1ZJRVdfU0VMRUNUT1IgPSBgWyR7UEhYX1NFU1NJT059XWBcbmV4cG9ydCBjb25zdCBQSFhfU1RJQ0tZID0gXCJkYXRhLXBoeC1zdGlja3lcIlxuZXhwb3J0IGNvbnN0IFBIWF9TVEFUSUMgPSBcImRhdGEtcGh4LXN0YXRpY1wiXG5leHBvcnQgY29uc3QgUEhYX1JFQURPTkxZID0gXCJkYXRhLXBoeC1yZWFkb25seVwiXG5leHBvcnQgY29uc3QgUEhYX0RJU0FCTEVEID0gXCJkYXRhLXBoeC1kaXNhYmxlZFwiXG5leHBvcnQgY29uc3QgUEhYX0RJU0FCTEVfV0lUSCA9IFwiZGlzYWJsZS13aXRoXCJcbmV4cG9ydCBjb25zdCBQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUgPSBcImRhdGEtcGh4LWRpc2FibGUtd2l0aC1yZXN0b3JlXCJcbmV4cG9ydCBjb25zdCBQSFhfSE9PSyA9IFwiaG9va1wiXG5leHBvcnQgY29uc3QgUEhYX0RFQk9VTkNFID0gXCJkZWJvdW5jZVwiXG5leHBvcnQgY29uc3QgUEhYX1RIUk9UVExFID0gXCJ0aHJvdHRsZVwiXG5leHBvcnQgY29uc3QgUEhYX1VQREFURSA9IFwidXBkYXRlXCJcbmV4cG9ydCBjb25zdCBQSFhfU1RSRUFNID0gXCJzdHJlYW1cIlxuZXhwb3J0IGNvbnN0IFBIWF9TVFJFQU1fUkVGID0gXCJkYXRhLXBoeC1zdHJlYW1cIlxuZXhwb3J0IGNvbnN0IFBIWF9LRVkgPSBcImtleVwiXG5leHBvcnQgY29uc3QgUEhYX1BSSVZBVEUgPSBcInBoeFByaXZhdGVcIlxuZXhwb3J0IGNvbnN0IFBIWF9BVVRPX1JFQ09WRVIgPSBcImF1dG8tcmVjb3ZlclwiXG5leHBvcnQgY29uc3QgUEhYX0xWX0RFQlVHID0gXCJwaHg6bGl2ZS1zb2NrZXQ6ZGVidWdcIlxuZXhwb3J0IGNvbnN0IFBIWF9MVl9QUk9GSUxFID0gXCJwaHg6bGl2ZS1zb2NrZXQ6cHJvZmlsaW5nXCJcbmV4cG9ydCBjb25zdCBQSFhfTFZfTEFURU5DWV9TSU0gPSBcInBoeDpsaXZlLXNvY2tldDpsYXRlbmN5LXNpbVwiXG5leHBvcnQgY29uc3QgUEhYX0xWX0hJU1RPUllfUE9TSVRJT04gPSBcInBoeDpuYXYtaGlzdG9yeS1wb3NpdGlvblwiXG5leHBvcnQgY29uc3QgUEhYX1BST0dSRVNTID0gXCJwcm9ncmVzc1wiXG5leHBvcnQgY29uc3QgUEhYX01PVU5URUQgPSBcIm1vdW50ZWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9SRUxPQURfU1RBVFVTID0gXCJfX3Bob2VuaXhfcmVsb2FkX3N0YXR1c19fXCJcbmV4cG9ydCBjb25zdCBMT0FERVJfVElNRU9VVCA9IDFcbmV4cG9ydCBjb25zdCBNQVhfQ0hJTERfSk9JTl9BVFRFTVBUUyA9IDNcbmV4cG9ydCBjb25zdCBCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VUID0gMjAwXG5leHBvcnQgY29uc3QgQklORElOR19QUkVGSVggPSBcInBoeC1cIlxuZXhwb3J0IGNvbnN0IFBVU0hfVElNRU9VVCA9IDMwMDAwXG5leHBvcnQgY29uc3QgTElOS19IRUFERVIgPSBcIngtcmVxdWVzdGVkLXdpdGhcIlxuZXhwb3J0IGNvbnN0IFJFU1BPTlNFX1VSTF9IRUFERVIgPSBcIngtcmVzcG9uc2UtdXJsXCJcbmV4cG9ydCBjb25zdCBERUJPVU5DRV9UUklHR0VSID0gXCJkZWJvdW5jZS10cmlnZ2VyXCJcbmV4cG9ydCBjb25zdCBUSFJPVFRMRUQgPSBcInRocm90dGxlZFwiXG5leHBvcnQgY29uc3QgREVCT1VOQ0VfUFJFVl9LRVkgPSBcImRlYm91bmNlLXByZXYta2V5XCJcbmV4cG9ydCBjb25zdCBERUZBVUxUUyA9IHtcbiAgZGVib3VuY2U6IDMwMCxcbiAgdGhyb3R0bGU6IDMwMFxufVxuZXhwb3J0IGNvbnN0IFBIWF9QRU5ESU5HX0FUVFJTID0gW1BIWF9SRUZfTE9BRElORywgUEhYX1JFRl9TUkMsIFBIWF9SRUZfTE9DS11cbi8vIFJlbmRlcmVkXG5leHBvcnQgY29uc3QgRFlOQU1JQ1MgPSBcImRcIlxuZXhwb3J0IGNvbnN0IFNUQVRJQyA9IFwic1wiXG5leHBvcnQgY29uc3QgUk9PVCA9IFwiclwiXG5leHBvcnQgY29uc3QgQ09NUE9ORU5UUyA9IFwiY1wiXG5leHBvcnQgY29uc3QgRVZFTlRTID0gXCJlXCJcbmV4cG9ydCBjb25zdCBSRVBMWSA9IFwiclwiXG5leHBvcnQgY29uc3QgVElUTEUgPSBcInRcIlxuZXhwb3J0IGNvbnN0IFRFTVBMQVRFUyA9IFwicFwiXG5leHBvcnQgY29uc3QgU1RSRUFNID0gXCJzdHJlYW1cIlxuIiwgImltcG9ydCB7XG4gIGxvZ0Vycm9yXG59IGZyb20gXCIuL3V0aWxzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50cnlVcGxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGVudHJ5LCBjb25maWcsIGxpdmVTb2NrZXQpe1xuICAgIGxldCB7Y2h1bmtfc2l6ZSwgY2h1bmtfdGltZW91dH0gPSBjb25maWdcbiAgICB0aGlzLmxpdmVTb2NrZXQgPSBsaXZlU29ja2V0XG4gICAgdGhpcy5lbnRyeSA9IGVudHJ5XG4gICAgdGhpcy5vZmZzZXQgPSAwXG4gICAgdGhpcy5jaHVua1NpemUgPSBjaHVua19zaXplXG4gICAgdGhpcy5jaHVua1RpbWVvdXQgPSBjaHVua190aW1lb3V0XG4gICAgdGhpcy5jaHVua1RpbWVyID0gbnVsbFxuICAgIHRoaXMuZXJyb3JlZCA9IGZhbHNlXG4gICAgdGhpcy51cGxvYWRDaGFubmVsID0gbGl2ZVNvY2tldC5jaGFubmVsKGBsdnU6JHtlbnRyeS5yZWZ9YCwge3Rva2VuOiBlbnRyeS5tZXRhZGF0YSgpfSlcbiAgfVxuXG4gIGVycm9yKHJlYXNvbil7XG4gICAgaWYodGhpcy5lcnJvcmVkKXsgcmV0dXJuIH1cbiAgICB0aGlzLnVwbG9hZENoYW5uZWwubGVhdmUoKVxuICAgIHRoaXMuZXJyb3JlZCA9IHRydWVcbiAgICBjbGVhclRpbWVvdXQodGhpcy5jaHVua1RpbWVyKVxuICAgIHRoaXMuZW50cnkuZXJyb3IocmVhc29uKVxuICB9XG5cbiAgdXBsb2FkKCl7XG4gICAgdGhpcy51cGxvYWRDaGFubmVsLm9uRXJyb3IocmVhc29uID0+IHRoaXMuZXJyb3IocmVhc29uKSlcbiAgICB0aGlzLnVwbG9hZENoYW5uZWwuam9pbigpXG4gICAgICAucmVjZWl2ZShcIm9rXCIsIF9kYXRhID0+IHRoaXMucmVhZE5leHRDaHVuaygpKVxuICAgICAgLnJlY2VpdmUoXCJlcnJvclwiLCByZWFzb24gPT4gdGhpcy5lcnJvcihyZWFzb24pKVxuICB9XG5cbiAgaXNEb25lKCl7IHJldHVybiB0aGlzLm9mZnNldCA+PSB0aGlzLmVudHJ5LmZpbGUuc2l6ZSB9XG5cbiAgcmVhZE5leHRDaHVuaygpe1xuICAgIGxldCByZWFkZXIgPSBuZXcgd2luZG93LkZpbGVSZWFkZXIoKVxuICAgIGxldCBibG9iID0gdGhpcy5lbnRyeS5maWxlLnNsaWNlKHRoaXMub2Zmc2V0LCB0aGlzLmNodW5rU2l6ZSArIHRoaXMub2Zmc2V0KVxuICAgIHJlYWRlci5vbmxvYWQgPSAoZSkgPT4ge1xuICAgICAgaWYoZS50YXJnZXQuZXJyb3IgPT09IG51bGwpe1xuICAgICAgICB0aGlzLm9mZnNldCArPSBlLnRhcmdldC5yZXN1bHQuYnl0ZUxlbmd0aFxuICAgICAgICB0aGlzLnB1c2hDaHVuayhlLnRhcmdldC5yZXN1bHQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9nRXJyb3IoXCJSZWFkIGVycm9yOiBcIiArIGUudGFyZ2V0LmVycm9yKVxuICAgICAgfVxuICAgIH1cbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgfVxuXG4gIHB1c2hDaHVuayhjaHVuayl7XG4gICAgaWYoIXRoaXMudXBsb2FkQ2hhbm5lbC5pc0pvaW5lZCgpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnVwbG9hZENoYW5uZWwucHVzaChcImNodW5rXCIsIGNodW5rLCB0aGlzLmNodW5rVGltZW91dClcbiAgICAgIC5yZWNlaXZlKFwib2tcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmVudHJ5LnByb2dyZXNzKCh0aGlzLm9mZnNldCAvIHRoaXMuZW50cnkuZmlsZS5zaXplKSAqIDEwMClcbiAgICAgICAgaWYoIXRoaXMuaXNEb25lKCkpe1xuICAgICAgICAgIHRoaXMuY2h1bmtUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZWFkTmV4dENodW5rKCksIHRoaXMubGl2ZVNvY2tldC5nZXRMYXRlbmN5U2ltKCkgfHwgMClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgKHtyZWFzb259KSA9PiB0aGlzLmVycm9yKHJlYXNvbikpXG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBQSFhfVklFV19TRUxFQ1RPUlxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQgRW50cnlVcGxvYWRlciBmcm9tIFwiLi9lbnRyeV91cGxvYWRlclwiXG5cbmV4cG9ydCBsZXQgbG9nRXJyb3IgPSAobXNnLCBvYmopID0+IGNvbnNvbGUuZXJyb3IgJiYgY29uc29sZS5lcnJvcihtc2csIG9iailcblxuZXhwb3J0IGxldCBpc0NpZCA9IChjaWQpID0+IHtcbiAgbGV0IHR5cGUgPSB0eXBlb2YoY2lkKVxuICByZXR1cm4gdHlwZSA9PT0gXCJudW1iZXJcIiB8fCAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAvXigwfFsxLTldXFxkKikkLy50ZXN0KGNpZCkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3REdXBsaWNhdGVJZHMoKXtcbiAgbGV0IGlkcyA9IG5ldyBTZXQoKVxuICBsZXQgZWxlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiKltpZF1cIilcbiAgZm9yKGxldCBpID0gMCwgbGVuID0gZWxlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgIGlmKGlkcy5oYXMoZWxlbXNbaV0uaWQpKXtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYE11bHRpcGxlIElEcyBkZXRlY3RlZDogJHtlbGVtc1tpXS5pZH0uIEVuc3VyZSB1bmlxdWUgZWxlbWVudCBpZHMuYClcbiAgICB9IGVsc2Uge1xuICAgICAgaWRzLmFkZChlbGVtc1tpXS5pZClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGxldCBkZWJ1ZyA9ICh2aWV3LCBraW5kLCBtc2csIG9iaikgPT4ge1xuICBpZih2aWV3LmxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSl7XG4gICAgY29uc29sZS5sb2coYCR7dmlldy5pZH0gJHtraW5kfTogJHttc2d9IC0gYCwgb2JqKVxuICB9XG59XG5cbi8vIHdyYXBzIHZhbHVlIGluIGNsb3N1cmUgb3IgcmV0dXJucyBjbG9zdXJlXG5leHBvcnQgbGV0IGNsb3N1cmUgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCIgPyB2YWwgOiBmdW5jdGlvbiAoKXsgcmV0dXJuIHZhbCB9XG5cbmV4cG9ydCBsZXQgY2xvbmUgPSAob2JqKSA9PiB7IHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpIH1cblxuZXhwb3J0IGxldCBjbG9zZXN0UGh4QmluZGluZyA9IChlbCwgYmluZGluZywgYm9yZGVyRWwpID0+IHtcbiAgZG8ge1xuICAgIGlmKGVsLm1hdGNoZXMoYFske2JpbmRpbmd9XWApICYmICFlbC5kaXNhYmxlZCl7IHJldHVybiBlbCB9XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGVcbiAgfSB3aGlsZShlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSAmJiAhKChib3JkZXJFbCAmJiBib3JkZXJFbC5pc1NhbWVOb2RlKGVsKSkgfHwgZWwubWF0Y2hlcyhQSFhfVklFV19TRUxFQ1RPUikpKVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgbGV0IGlzT2JqZWN0ID0gKG9iaikgPT4ge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgIShvYmogaW5zdGFuY2VvZiBBcnJheSlcbn1cblxuZXhwb3J0IGxldCBpc0VxdWFsT2JqID0gKG9iajEsIG9iajIpID0+IEpTT04uc3RyaW5naWZ5KG9iajEpID09PSBKU09OLnN0cmluZ2lmeShvYmoyKVxuXG5leHBvcnQgbGV0IGlzRW1wdHkgPSAob2JqKSA9PiB7XG4gIGZvcihsZXQgeCBpbiBvYmopeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgbGV0IG1heWJlID0gKGVsLCBjYWxsYmFjaykgPT4gZWwgJiYgY2FsbGJhY2soZWwpXG5cbmV4cG9ydCBsZXQgY2hhbm5lbFVwbG9hZGVyID0gZnVuY3Rpb24gKGVudHJpZXMsIG9uRXJyb3IsIHJlc3AsIGxpdmVTb2NrZXQpe1xuICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xuICAgIGxldCBlbnRyeVVwbG9hZGVyID0gbmV3IEVudHJ5VXBsb2FkZXIoZW50cnksIHJlc3AuY29uZmlnLCBsaXZlU29ja2V0KVxuICAgIGVudHJ5VXBsb2FkZXIudXBsb2FkKClcbiAgfSlcbn1cbiIsICJsZXQgQnJvd3NlciA9IHtcbiAgY2FuUHVzaFN0YXRlKCl7IHJldHVybiAodHlwZW9mIChoaXN0b3J5LnB1c2hTdGF0ZSkgIT09IFwidW5kZWZpbmVkXCIpIH0sXG5cbiAgZHJvcExvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXkpe1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KSlcbiAgfSxcblxuICB1cGRhdGVMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5LCBpbml0aWFsLCBmdW5jKXtcbiAgICBsZXQgY3VycmVudCA9IHRoaXMuZ2V0TG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSlcbiAgICBsZXQga2V5ID0gdGhpcy5sb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSlcbiAgICBsZXQgbmV3VmFsID0gY3VycmVudCA9PT0gbnVsbCA/IGluaXRpYWwgOiBmdW5jKGN1cnJlbnQpXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShuZXdWYWwpKVxuICAgIHJldHVybiBuZXdWYWxcbiAgfSxcblxuICBnZXRMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KXtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KSkpXG4gIH0sXG5cbiAgdXBkYXRlQ3VycmVudFN0YXRlKGNhbGxiYWNrKXtcbiAgICBpZighdGhpcy5jYW5QdXNoU3RhdGUoKSl7IHJldHVybiB9XG4gICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoY2FsbGJhY2soaGlzdG9yeS5zdGF0ZSB8fCB7fSksIFwiXCIsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICB9LFxuXG4gIHB1c2hTdGF0ZShraW5kLCBtZXRhLCB0byl7XG4gICAgaWYodGhpcy5jYW5QdXNoU3RhdGUoKSl7XG4gICAgICBpZih0byAhPT0gd2luZG93LmxvY2F0aW9uLmhyZWYpe1xuICAgICAgICBpZihtZXRhLnR5cGUgPT0gXCJyZWRpcmVjdFwiICYmIG1ldGEuc2Nyb2xsKXtcbiAgICAgICAgICAvLyBJZiB3ZSdyZSByZWRpcmVjdGluZyBzdG9yZSB0aGUgY3VycmVudCBzY3JvbGxZIGZvciB0aGUgY3VycmVudCBoaXN0b3J5IHN0YXRlLlxuICAgICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSBoaXN0b3J5LnN0YXRlIHx8IHt9XG4gICAgICAgICAgY3VycmVudFN0YXRlLnNjcm9sbCA9IG1ldGEuc2Nyb2xsXG4gICAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoY3VycmVudFN0YXRlLCBcIlwiLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBtZXRhLnNjcm9sbCAvLyBPbmx5IHN0b3JlIHRoZSBzY3JvbGwgaW4gdGhlIHJlZGlyZWN0IGNhc2UuXG4gICAgICAgIGhpc3Rvcnlba2luZCArIFwiU3RhdGVcIl0obWV0YSwgXCJcIiwgdG8gfHwgbnVsbCkgLy8gSUUgd2lsbCBjb2VyY2UgdW5kZWZpbmVkIHRvIHN0cmluZ1xuXG4gICAgICAgIC8vIHdoZW4gdXNpbmcgbmF2aWdhdGUsIHdlJ2QgY2FsbCBwdXNoU3RhdGUgaW1tZWRpYXRlbHkgYmVmb3JlIHBhdGNoaW5nIHRoZSBET00sXG4gICAgICAgIC8vIGp1bXBpbmcgYmFjayB0byB0aGUgdG9wIG9mIHRoZSBwYWdlLCBlZmZlY3RpdmVseSBpZ25vcmluZyB0aGUgc2Nyb2xsSW50b1ZpZXc7XG4gICAgICAgIC8vIHRoZXJlZm9yZSB3ZSB3YWl0IGZvciB0aGUgbmV4dCBmcmFtZSAoYWZ0ZXIgdGhlIERPTSBwYXRjaCkgYW5kIG9ubHkgdGhlbiB0cnlcbiAgICAgICAgLy8gdG8gc2Nyb2xsIHRvIHRoZSBoYXNoRWxcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgbGV0IGhhc2hFbCA9IHRoaXMuZ2V0SGFzaFRhcmdldEVsKHdpbmRvdy5sb2NhdGlvbi5oYXNoKVxuICBcbiAgICAgICAgICBpZihoYXNoRWwpe1xuICAgICAgICAgICAgaGFzaEVsLnNjcm9sbEludG9WaWV3KClcbiAgICAgICAgICB9IGVsc2UgaWYobWV0YS50eXBlID09PSBcInJlZGlyZWN0XCIpe1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbCgwLCAwKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWRpcmVjdCh0bylcbiAgICB9XG4gIH0sXG5cbiAgc2V0Q29va2llKG5hbWUsIHZhbHVlLCBtYXhBZ2VTZWNvbmRzKXtcbiAgICBsZXQgZXhwaXJlcyA9IHR5cGVvZihtYXhBZ2VTZWNvbmRzKSA9PT0gXCJudW1iZXJcIiA/IGAgbWF4LWFnZT0ke21heEFnZVNlY29uZHN9O2AgOiBcIlwiXG4gICAgZG9jdW1lbnQuY29va2llID0gYCR7bmFtZX09JHt2YWx1ZX07JHtleHBpcmVzfSBwYXRoPS9gXG4gIH0sXG5cbiAgZ2V0Q29va2llKG5hbWUpe1xuICAgIHJldHVybiBkb2N1bWVudC5jb29raWUucmVwbGFjZShuZXcgUmVnRXhwKGAoPzooPzpefC4qO1xccyopJHtuYW1lfVxccypcXD1cXHMqKFteO10qKS4qJCl8Xi4qJGApLCBcIiQxXCIpXG4gIH0sXG5cbiAgZGVsZXRlQ29va2llKG5hbWUpe1xuICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke25hbWV9PTsgbWF4LWFnZT0tMTsgcGF0aD0vYFxuICB9LFxuXG4gIHJlZGlyZWN0KHRvVVJMLCBmbGFzaCl7XG4gICAgaWYoZmxhc2gpeyB0aGlzLnNldENvb2tpZShcIl9fcGhvZW5peF9mbGFzaF9fXCIsIGZsYXNoLCA2MCkgfVxuICAgIHdpbmRvdy5sb2NhdGlvbiA9IHRvVVJMXG4gIH0sXG5cbiAgbG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpeyByZXR1cm4gYCR7bmFtZXNwYWNlfS0ke3N1YmtleX1gIH0sXG5cbiAgZ2V0SGFzaFRhcmdldEVsKG1heWJlSGFzaCl7XG4gICAgbGV0IGhhc2ggPSBtYXliZUhhc2gudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSlcbiAgICBpZihoYXNoID09PSBcIlwiKXsgcmV0dXJuIH1cbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaCkgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgYVtuYW1lPVwiJHtoYXNofVwiXWApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnJvd3NlclxuIiwgImltcG9ydCB7XG4gIENIRUNLQUJMRV9JTlBVVFMsXG4gIERFQk9VTkNFX1BSRVZfS0VZLFxuICBERUJPVU5DRV9UUklHR0VSLFxuICBGT0NVU0FCTEVfSU5QVVRTLFxuICBQSFhfQ09NUE9ORU5ULFxuICBQSFhfSEFTX0ZPQ1VTRUQsXG4gIFBIWF9IQVNfU1VCTUlUVEVELFxuICBQSFhfTUFJTixcbiAgUEhYX1BBUkVOVF9JRCxcbiAgUEhYX1BSSVZBVEUsXG4gIFBIWF9SRUZfU1JDLFxuICBQSFhfUEVORElOR19BVFRSUyxcbiAgUEhYX1JPT1RfSUQsXG4gIFBIWF9TRVNTSU9OLFxuICBQSFhfU1RBVElDLFxuICBQSFhfVVBMT0FEX1JFRixcbiAgUEhYX1ZJRVdfU0VMRUNUT1IsXG4gIFBIWF9TVElDS1ksXG4gIFBIWF9FVkVOVF9DTEFTU0VTLFxuICBUSFJPVFRMRUQsXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGxvZ0Vycm9yXG59IGZyb20gXCIuL3V0aWxzXCJcblxubGV0IERPTSA9IHtcbiAgYnlJZChpZCl7IHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgfHwgbG9nRXJyb3IoYG5vIGlkIGZvdW5kIGZvciAke2lkfWApIH0sXG5cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNsYXNzTmFtZSl7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpXG4gICAgaWYoZWwuY2xhc3NMaXN0Lmxlbmd0aCA9PT0gMCl7IGVsLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpIH1cbiAgfSxcblxuICBhbGwobm9kZSwgcXVlcnksIGNhbGxiYWNrKXtcbiAgICBpZighbm9kZSl7IHJldHVybiBbXSB9XG4gICAgbGV0IGFycmF5ID0gQXJyYXkuZnJvbShub2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKVxuICAgIHJldHVybiBjYWxsYmFjayA/IGFycmF5LmZvckVhY2goY2FsbGJhY2spIDogYXJyYXlcbiAgfSxcblxuICBjaGlsZE5vZGVMZW5ndGgoaHRtbCl7XG4gICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpXG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbFxuICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmNoaWxkRWxlbWVudENvdW50XG4gIH0sXG5cbiAgaXNVcGxvYWRJbnB1dChlbCl7IHJldHVybiBlbC50eXBlID09PSBcImZpbGVcIiAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpICE9PSBudWxsIH0sXG5cbiAgaXNBdXRvVXBsb2FkKGlucHV0RWwpeyByZXR1cm4gaW5wdXRFbC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXBoeC1hdXRvLXVwbG9hZFwiKSB9LFxuXG4gIGZpbmRVcGxvYWRJbnB1dHMobm9kZSl7XG4gICAgY29uc3QgZm9ybUlkID0gbm9kZS5pZFxuICAgIGNvbnN0IGlucHV0c091dHNpZGVGb3JtID0gdGhpcy5hbGwoZG9jdW1lbnQsIGBpbnB1dFt0eXBlPVwiZmlsZVwiXVske1BIWF9VUExPQURfUkVGfV1bZm9ybT1cIiR7Zm9ybUlkfVwiXWApXG4gICAgcmV0dXJuIHRoaXMuYWxsKG5vZGUsIGBpbnB1dFt0eXBlPVwiZmlsZVwiXVske1BIWF9VUExPQURfUkVGfV1gKS5jb25jYXQoaW5wdXRzT3V0c2lkZUZvcm0pXG4gIH0sXG5cbiAgZmluZENvbXBvbmVudE5vZGVMaXN0KG5vZGUsIGNpZCl7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyV2l0aGluU2FtZUxpdmVWaWV3KHRoaXMuYWxsKG5vZGUsIGBbJHtQSFhfQ09NUE9ORU5UfT1cIiR7Y2lkfVwiXWApLCBub2RlKVxuICB9LFxuXG4gIGlzUGh4RGVzdHJveWVkKG5vZGUpe1xuICAgIHJldHVybiBub2RlLmlkICYmIERPTS5wcml2YXRlKG5vZGUsIFwiZGVzdHJveWVkXCIpID8gdHJ1ZSA6IGZhbHNlXG4gIH0sXG5cbiAgd2FudHNOZXdUYWIoZSl7XG4gICAgbGV0IHdhbnRzTmV3VGFiID0gZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5IHx8IChlLmJ1dHRvbiAmJiBlLmJ1dHRvbiA9PT0gMSlcbiAgICBsZXQgaXNEb3dubG9hZCA9IChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50ICYmIGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRvd25sb2FkXCIpKVxuICAgIGxldCBpc1RhcmdldEJsYW5rID0gZS50YXJnZXQuaGFzQXR0cmlidXRlKFwidGFyZ2V0XCIpICYmIGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKS50b0xvd2VyQ2FzZSgpID09PSBcIl9ibGFua1wiXG4gICAgbGV0IGlzVGFyZ2V0TmFtZWRUYWIgPSBlLnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJ0YXJnZXRcIikgJiYgIWUudGFyZ2V0LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKS5zdGFydHNXaXRoKFwiX1wiKVxuICAgIHJldHVybiB3YW50c05ld1RhYiB8fCBpc1RhcmdldEJsYW5rIHx8IGlzRG93bmxvYWQgfHwgaXNUYXJnZXROYW1lZFRhYlxuICB9LFxuXG4gIGlzVW5sb2FkYWJsZUZvcm1TdWJtaXQoZSl7XG4gICAgLy8gSWdub3JlIGZvcm0gc3VibWlzc2lvbnMgaW50ZW5kZWQgdG8gY2xvc2UgYSBuYXRpdmUgPGRpYWxvZz4gZWxlbWVudFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9kaWFsb2cjdXNhZ2Vfbm90ZXNcbiAgICBsZXQgaXNEaWFsb2dTdWJtaXQgPSAoZS50YXJnZXQgJiYgZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpID09PSBcImRpYWxvZ1wiKSB8fFxuICAgICAgKGUuc3VibWl0dGVyICYmIGUuc3VibWl0dGVyLmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikgPT09IFwiZGlhbG9nXCIpXG5cbiAgICBpZihpc0RpYWxvZ1N1Ym1pdCl7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICFlLmRlZmF1bHRQcmV2ZW50ZWQgJiYgIXRoaXMud2FudHNOZXdUYWIoZSlcbiAgICB9XG4gIH0sXG5cbiAgaXNOZXdQYWdlQ2xpY2soZSwgY3VycmVudExvY2F0aW9uKXtcbiAgICBsZXQgaHJlZiA9IGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQgPyBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpIDogbnVsbFxuICAgIGxldCB1cmxcblxuICAgIGlmKGUuZGVmYXVsdFByZXZlbnRlZCB8fCBocmVmID09PSBudWxsIHx8IHRoaXMud2FudHNOZXdUYWIoZSkpeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmKGhyZWYuc3RhcnRzV2l0aChcIm1haWx0bzpcIikgfHwgaHJlZi5zdGFydHNXaXRoKFwidGVsOlwiKSl7IHJldHVybiBmYWxzZSB9XG4gICAgaWYoZS50YXJnZXQuaXNDb250ZW50RWRpdGFibGUpeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHVybCA9IG5ldyBVUkwoaHJlZilcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHVybCA9IG5ldyBVUkwoaHJlZiwgY3VycmVudExvY2F0aW9uKVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIGJhZCBVUkwsIGZhbGxiYWNrIHRvIGxldCBicm93c2VyIHRyeSBpdCBhcyBleHRlcm5hbFxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHVybC5ob3N0ID09PSBjdXJyZW50TG9jYXRpb24uaG9zdCAmJiB1cmwucHJvdG9jb2wgPT09IGN1cnJlbnRMb2NhdGlvbi5wcm90b2NvbCl7XG4gICAgICBpZih1cmwucGF0aG5hbWUgPT09IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSAmJiB1cmwuc2VhcmNoID09PSBjdXJyZW50TG9jYXRpb24uc2VhcmNoKXtcbiAgICAgICAgcmV0dXJuIHVybC5oYXNoID09PSBcIlwiICYmICF1cmwuaHJlZi5lbmRzV2l0aChcIiNcIilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVybC5wcm90b2NvbC5zdGFydHNXaXRoKFwiaHR0cFwiKVxuICB9LFxuXG4gIG1hcmtQaHhDaGlsZERlc3Ryb3llZChlbCl7XG4gICAgaWYodGhpcy5pc1BoeENoaWxkKGVsKSl7IGVsLnNldEF0dHJpYnV0ZShQSFhfU0VTU0lPTiwgXCJcIikgfVxuICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgXCJkZXN0cm95ZWRcIiwgdHJ1ZSlcbiAgfSxcblxuICBmaW5kUGh4Q2hpbGRyZW5JbkZyYWdtZW50KGh0bWwsIHBhcmVudElkKXtcbiAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIilcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sXG4gICAgcmV0dXJuIHRoaXMuZmluZFBoeENoaWxkcmVuKHRlbXBsYXRlLmNvbnRlbnQsIHBhcmVudElkKVxuICB9LFxuXG4gIGlzSWdub3JlZChlbCwgcGh4VXBkYXRlKXtcbiAgICByZXR1cm4gKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpIHx8IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXVwZGF0ZVwiKSkgPT09IFwiaWdub3JlXCJcbiAgfSxcblxuICBpc1BoeFVwZGF0ZShlbCwgcGh4VXBkYXRlLCB1cGRhdGVUeXBlcyl7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiB1cGRhdGVUeXBlcy5pbmRleE9mKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpKSA+PSAwXG4gIH0sXG5cbiAgZmluZFBoeFN0aWNreShlbCl7IHJldHVybiB0aGlzLmFsbChlbCwgYFske1BIWF9TVElDS1l9XWApIH0sXG5cbiAgZmluZFBoeENoaWxkcmVuKGVsLCBwYXJlbnRJZCl7XG4gICAgcmV0dXJuIHRoaXMuYWxsKGVsLCBgJHtQSFhfVklFV19TRUxFQ1RPUn1bJHtQSFhfUEFSRU5UX0lEfT1cIiR7cGFyZW50SWR9XCJdYClcbiAgfSxcblxuICBmaW5kRXhpc3RpbmdQYXJlbnRDSURzKG5vZGUsIGNpZHMpe1xuICAgIC8vIHdlIG9ubHkgd2FudCB0byBmaW5kIHBhcmVudHMgdGhhdCBleGlzdCBvbiB0aGUgcGFnZVxuICAgIC8vIGlmIGEgY2lkIGlzIG5vdCBvbiB0aGUgcGFnZSwgdGhlIG9ubHkgd2F5IGl0IGNhbiBiZSBhZGRlZCBiYWNrIHRvIHRoZSBwYWdlXG4gICAgLy8gaXMgaWYgYSBwYXJlbnQgYWRkcyBpdCBiYWNrLCB0aGVyZWZvcmUgaWYgYSBjaWQgZG9lcyBub3QgZXhpc3Qgb24gdGhlIHBhZ2UsXG4gICAgLy8gd2Ugc2hvdWxkIG5vdCB0cnkgdG8gcmVuZGVyIGl0IGJ5IGl0c2VsZiAoYmVjYXVzZSBpdCB3b3VsZCBiZSByZW5kZXJlZCB0d2ljZSxcbiAgICAvLyBvbmUgYnkgdGhlIHBhcmVudCwgYW5kIGEgc2Vjb25kIHRpbWUgYnkgaXRzZWxmKVxuICAgIGxldCBwYXJlbnRDaWRzID0gbmV3IFNldCgpXG4gICAgbGV0IGNoaWxkcmVuQ2lkcyA9IG5ldyBTZXQoKVxuXG4gICAgY2lkcy5mb3JFYWNoKGNpZCA9PiB7XG4gICAgICB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChub2RlLCBgWyR7UEhYX0NPTVBPTkVOVH09XCIke2NpZH1cIl1gKSwgbm9kZSkuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgICBwYXJlbnRDaWRzLmFkZChjaWQpXG4gICAgICAgIHRoaXMuYWxsKHBhcmVudCwgYFske1BIWF9DT01QT05FTlR9XWApXG4gICAgICAgICAgLm1hcChlbCA9PiBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkpKVxuICAgICAgICAgIC5mb3JFYWNoKGNoaWxkQ0lEID0+IGNoaWxkcmVuQ2lkcy5hZGQoY2hpbGRDSUQpKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgY2hpbGRyZW5DaWRzLmZvckVhY2goY2hpbGRDaWQgPT4gcGFyZW50Q2lkcy5kZWxldGUoY2hpbGRDaWQpKVxuXG4gICAgcmV0dXJuIHBhcmVudENpZHNcbiAgfSxcblxuICBmaWx0ZXJXaXRoaW5TYW1lTGl2ZVZpZXcobm9kZXMsIHBhcmVudCl7XG4gICAgaWYocGFyZW50LnF1ZXJ5U2VsZWN0b3IoUEhYX1ZJRVdfU0VMRUNUT1IpKXtcbiAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoZWwgPT4gdGhpcy53aXRoaW5TYW1lTGl2ZVZpZXcoZWwsIHBhcmVudCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2Rlc1xuICAgIH1cbiAgfSxcblxuICB3aXRoaW5TYW1lTGl2ZVZpZXcobm9kZSwgcGFyZW50KXtcbiAgICB3aGlsZShub2RlID0gbm9kZS5wYXJlbnROb2RlKXtcbiAgICAgIGlmKG5vZGUuaXNTYW1lTm9kZShwYXJlbnQpKXsgcmV0dXJuIHRydWUgfVxuICAgICAgaWYobm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pICE9PSBudWxsKXsgcmV0dXJuIGZhbHNlIH1cbiAgICB9XG4gIH0sXG5cbiAgcHJpdmF0ZShlbCwga2V5KXsgcmV0dXJuIGVsW1BIWF9QUklWQVRFXSAmJiBlbFtQSFhfUFJJVkFURV1ba2V5XSB9LFxuXG4gIGRlbGV0ZVByaXZhdGUoZWwsIGtleSl7IGVsW1BIWF9QUklWQVRFXSAmJiBkZWxldGUgKGVsW1BIWF9QUklWQVRFXVtrZXldKSB9LFxuXG4gIHB1dFByaXZhdGUoZWwsIGtleSwgdmFsdWUpe1xuICAgIGlmKCFlbFtQSFhfUFJJVkFURV0peyBlbFtQSFhfUFJJVkFURV0gPSB7fSB9XG4gICAgZWxbUEhYX1BSSVZBVEVdW2tleV0gPSB2YWx1ZVxuICB9LFxuXG4gIHVwZGF0ZVByaXZhdGUoZWwsIGtleSwgZGVmYXVsdFZhbCwgdXBkYXRlRnVuYyl7XG4gICAgbGV0IGV4aXN0aW5nID0gdGhpcy5wcml2YXRlKGVsLCBrZXkpXG4gICAgaWYoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCl7XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdXBkYXRlRnVuYyhkZWZhdWx0VmFsKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIHVwZGF0ZUZ1bmMoZXhpc3RpbmcpKVxuICAgIH1cbiAgfSxcblxuICBzeW5jUGVuZGluZ0F0dHJzKGZyb21FbCwgdG9FbCl7XG4gICAgaWYoIWZyb21FbC5oYXNBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpKXsgcmV0dXJuIH1cbiAgICBQSFhfRVZFTlRfQ0xBU1NFUy5mb3JFYWNoKGNsYXNzTmFtZSA9PiB7XG4gICAgICBmcm9tRWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkgJiYgdG9FbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSlcbiAgICB9KVxuICAgIFBIWF9QRU5ESU5HX0FUVFJTLmZpbHRlcihhdHRyID0+IGZyb21FbC5oYXNBdHRyaWJ1dGUoYXR0cikpLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICB0b0VsLnNldEF0dHJpYnV0ZShhdHRyLCBmcm9tRWwuZ2V0QXR0cmlidXRlKGF0dHIpKVxuICAgIH0pXG4gIH0sXG5cbiAgY29weVByaXZhdGVzKHRhcmdldCwgc291cmNlKXtcbiAgICBpZihzb3VyY2VbUEhYX1BSSVZBVEVdKXtcbiAgICAgIHRhcmdldFtQSFhfUFJJVkFURV0gPSBzb3VyY2VbUEhYX1BSSVZBVEVdXG4gICAgfVxuICB9LFxuXG4gIHB1dFRpdGxlKHN0cil7XG4gICAgbGV0IHRpdGxlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwidGl0bGVcIilcbiAgICBpZih0aXRsZUVsKXtcbiAgICAgIGxldCB7cHJlZml4LCBzdWZmaXgsIGRlZmF1bHQ6IGRlZmF1bHRUaXRsZX0gPSB0aXRsZUVsLmRhdGFzZXRcbiAgICAgIGxldCBpc0VtcHR5ID0gdHlwZW9mKHN0cikgIT09IFwic3RyaW5nXCIgfHwgc3RyLnRyaW0oKSA9PT0gXCJcIlxuICAgICAgaWYoaXNFbXB0eSAmJiB0eXBlb2YoZGVmYXVsdFRpdGxlKSAhPT0gXCJzdHJpbmdcIil7IHJldHVybiB9XG5cbiAgICAgIGxldCBpbm5lciA9IGlzRW1wdHkgPyBkZWZhdWx0VGl0bGUgOiBzdHJcbiAgICAgIGRvY3VtZW50LnRpdGxlID0gYCR7cHJlZml4IHx8IFwiXCJ9JHtpbm5lciB8fCBcIlwifSR7c3VmZml4IHx8IFwiXCJ9YFxuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC50aXRsZSA9IHN0clxuICAgIH1cbiAgfSxcblxuICBkZWJvdW5jZShlbCwgZXZlbnQsIHBoeERlYm91bmNlLCBkZWZhdWx0RGVib3VuY2UsIHBoeFRocm90dGxlLCBkZWZhdWx0VGhyb3R0bGUsIGFzeW5jRmlsdGVyLCBjYWxsYmFjayl7XG4gICAgbGV0IGRlYm91bmNlID0gZWwuZ2V0QXR0cmlidXRlKHBoeERlYm91bmNlKVxuICAgIGxldCB0aHJvdHRsZSA9IGVsLmdldEF0dHJpYnV0ZShwaHhUaHJvdHRsZSlcblxuICAgIGlmKGRlYm91bmNlID09PSBcIlwiKXsgZGVib3VuY2UgPSBkZWZhdWx0RGVib3VuY2UgfVxuICAgIGlmKHRocm90dGxlID09PSBcIlwiKXsgdGhyb3R0bGUgPSBkZWZhdWx0VGhyb3R0bGUgfVxuICAgIGxldCB2YWx1ZSA9IGRlYm91bmNlIHx8IHRocm90dGxlXG4gICAgc3dpdGNoKHZhbHVlKXtcbiAgICAgIGNhc2UgbnVsbDogcmV0dXJuIGNhbGxiYWNrKClcblxuICAgICAgY2FzZSBcImJsdXJcIjpcbiAgICAgICAgaWYodGhpcy5vbmNlKGVsLCBcImRlYm91bmNlLWJsdXJcIikpe1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IHtcbiAgICAgICAgICAgIGlmKGFzeW5jRmlsdGVyKCkpeyBjYWxsYmFjaygpIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZXQgdGltZW91dCA9IHBhcnNlSW50KHZhbHVlKVxuICAgICAgICBsZXQgdHJpZ2dlciA9ICgpID0+IHRocm90dGxlID8gdGhpcy5kZWxldGVQcml2YXRlKGVsLCBUSFJPVFRMRUQpIDogY2FsbGJhY2soKVxuICAgICAgICBsZXQgY3VycmVudEN5Y2xlID0gdGhpcy5pbmNDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUiwgdHJpZ2dlcilcbiAgICAgICAgaWYoaXNOYU4odGltZW91dCkpeyByZXR1cm4gbG9nRXJyb3IoYGludmFsaWQgdGhyb3R0bGUvZGVib3VuY2UgdmFsdWU6ICR7dmFsdWV9YCkgfVxuICAgICAgICBpZih0aHJvdHRsZSl7XG4gICAgICAgICAgbGV0IG5ld0tleURvd24gPSBmYWxzZVxuICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IFwia2V5ZG93blwiKXtcbiAgICAgICAgICAgIGxldCBwcmV2S2V5ID0gdGhpcy5wcml2YXRlKGVsLCBERUJPVU5DRV9QUkVWX0tFWSlcbiAgICAgICAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgREVCT1VOQ0VfUFJFVl9LRVksIGV2ZW50LmtleSlcbiAgICAgICAgICAgIG5ld0tleURvd24gPSBwcmV2S2V5ICE9PSBldmVudC5rZXlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZighbmV3S2V5RG93biAmJiB0aGlzLnByaXZhdGUoZWwsIFRIUk9UVExFRCkpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgICAgIGNvbnN0IHQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYoYXN5bmNGaWx0ZXIoKSl7IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSKSB9XG4gICAgICAgICAgICB9LCB0aW1lb3V0KVxuICAgICAgICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBUSFJPVFRMRUQsIHQpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYoYXN5bmNGaWx0ZXIoKSl7IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSLCBjdXJyZW50Q3ljbGUpIH1cbiAgICAgICAgICB9LCB0aW1lb3V0KVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZvcm0gPSBlbC5mb3JtXG4gICAgICAgIGlmKGZvcm0gJiYgdGhpcy5vbmNlKGZvcm0sIFwiYmluZC1kZWJvdW5jZVwiKSl7XG4gICAgICAgICAgZm9ybS5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsICgpID0+IHtcbiAgICAgICAgICAgIEFycmF5LmZyb20oKG5ldyBGb3JtRGF0YShmb3JtKSkuZW50cmllcygpLCAoW25hbWVdKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBpbnB1dCA9IGZvcm0ucXVlcnlTZWxlY3RvcihgW25hbWU9XCIke25hbWV9XCJdYClcbiAgICAgICAgICAgICAgdGhpcy5pbmNDeWNsZShpbnB1dCwgREVCT1VOQ0VfVFJJR0dFUilcbiAgICAgICAgICAgICAgdGhpcy5kZWxldGVQcml2YXRlKGlucHV0LCBUSFJPVFRMRUQpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5vbmNlKGVsLCBcImJpbmQtZGVib3VuY2VcIikpe1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IHtcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgdHJpZ2dlciB0aGUgY2FsbGJhY2sgaGVyZSxcbiAgICAgICAgICAgIC8vIHdlIGFsc28gY2xlYXIgdGhlIHRocm90dGxlIHRpbWVvdXQgdG8gcHJldmVudCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgIC8vIGZyb20gYmVpbmcgY2FsbGVkIGFnYWluIGFmdGVyIHRoZSB0aW1lb3V0IGZpcmVzXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wcml2YXRlKGVsLCBUSFJPVFRMRUQpKVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ3ljbGUoZWwsIERFQk9VTkNFX1RSSUdHRVIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB0cmlnZ2VyQ3ljbGUoZWwsIGtleSwgY3VycmVudEN5Y2xlKXtcbiAgICBsZXQgW2N5Y2xlLCB0cmlnZ2VyXSA9IHRoaXMucHJpdmF0ZShlbCwga2V5KVxuICAgIGlmKCFjdXJyZW50Q3ljbGUpeyBjdXJyZW50Q3ljbGUgPSBjeWNsZSB9XG4gICAgaWYoY3VycmVudEN5Y2xlID09PSBjeWNsZSl7XG4gICAgICB0aGlzLmluY0N5Y2xlKGVsLCBrZXkpXG4gICAgICB0cmlnZ2VyKClcbiAgICB9XG4gIH0sXG5cbiAgb25jZShlbCwga2V5KXtcbiAgICBpZih0aGlzLnByaXZhdGUoZWwsIGtleSkgPT09IHRydWUpeyByZXR1cm4gZmFsc2UgfVxuICAgIHRoaXMucHV0UHJpdmF0ZShlbCwga2V5LCB0cnVlKVxuICAgIHJldHVybiB0cnVlXG4gIH0sXG5cbiAgaW5jQ3ljbGUoZWwsIGtleSwgdHJpZ2dlciA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICBsZXQgW2N1cnJlbnRDeWNsZV0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSkgfHwgWzAsIHRyaWdnZXJdXG4gICAgY3VycmVudEN5Y2xlKytcbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgW2N1cnJlbnRDeWNsZSwgdHJpZ2dlcl0pXG4gICAgcmV0dXJuIGN1cnJlbnRDeWNsZVxuICB9LFxuXG4gIC8vIG1haW50YWlucyBvciBhZGRzIHByaXZhdGVseSB1c2VkIGhvb2sgaW5mb3JtYXRpb25cbiAgLy8gZnJvbUVsIGFuZCB0b0VsIGNhbiBiZSB0aGUgc2FtZSBlbGVtZW50IGluIHRoZSBjYXNlIG9mIGEgbmV3bHkgYWRkZWQgbm9kZVxuICAvLyBmcm9tRWwgYW5kIHRvRWwgY2FuIGJlIGFueSBIVE1MIG5vZGUgdHlwZSwgc28gd2UgbmVlZCB0byBjaGVjayBpZiBpdCdzIGFuIGVsZW1lbnQgbm9kZVxuICBtYWludGFpblByaXZhdGVIb29rcyhmcm9tRWwsIHRvRWwsIHBoeFZpZXdwb3J0VG9wLCBwaHhWaWV3cG9ydEJvdHRvbSl7XG4gICAgLy8gbWFpbnRhaW4gdGhlIGhvb2tzIGNyZWF0ZWQgd2l0aCBjcmVhdGVIb29rXG4gICAgaWYoZnJvbUVsLmhhc0F0dHJpYnV0ZSAmJiBmcm9tRWwuaGFzQXR0cmlidXRlKFwiZGF0YS1waHgtaG9va1wiKSAmJiAhdG9FbC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXBoeC1ob29rXCIpKXtcbiAgICAgIHRvRWwuc2V0QXR0cmlidXRlKFwiZGF0YS1waHgtaG9va1wiLCBmcm9tRWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtaG9va1wiKSlcbiAgICB9XG4gICAgLy8gYWRkIGhvb2tzIHRvIGVsZW1lbnRzIHdpdGggdmlld3BvcnQgYXR0cmlidXRlc1xuICAgIGlmKHRvRWwuaGFzQXR0cmlidXRlICYmICh0b0VsLmhhc0F0dHJpYnV0ZShwaHhWaWV3cG9ydFRvcCkgfHwgdG9FbC5oYXNBdHRyaWJ1dGUocGh4Vmlld3BvcnRCb3R0b20pKSl7XG4gICAgICB0b0VsLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LWhvb2tcIiwgXCJQaG9lbml4LkluZmluaXRlU2Nyb2xsXCIpXG4gICAgfVxuICB9LFxuXG4gIHB1dEN1c3RvbUVsSG9vayhlbCwgaG9vayl7XG4gICAgaWYoZWwuaXNDb25uZWN0ZWQpe1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1waHgtaG9va1wiLCBcIlwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBcbiAgICAgICAgaG9vayBhdHRhY2hlZCB0byBub24tY29ubmVjdGVkIERPTSBlbGVtZW50XG4gICAgICAgIGVuc3VyZSB5b3UgYXJlIGNhbGxpbmcgY3JlYXRlSG9vayB3aXRoaW4geW91ciBjb25uZWN0ZWRDYWxsYmFjay4gJHtlbC5vdXRlckhUTUx9XG4gICAgICBgKVxuICAgIH1cbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIFwiY3VzdG9tLWVsLWhvb2tcIiwgaG9vaylcbiAgfSxcblxuICBnZXRDdXN0b21FbEhvb2soZWwpeyByZXR1cm4gdGhpcy5wcml2YXRlKGVsLCBcImN1c3RvbS1lbC1ob29rXCIpIH0sXG5cbiAgaXNVc2VkSW5wdXQoZWwpe1xuICAgIHJldHVybiAoZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmXG4gICAgICAodGhpcy5wcml2YXRlKGVsLCBQSFhfSEFTX0ZPQ1VTRUQpIHx8IHRoaXMucHJpdmF0ZShlbCwgUEhYX0hBU19TVUJNSVRURUQpKSlcbiAgfSxcblxuICByZXNldEZvcm0oZm9ybSl7XG4gICAgQXJyYXkuZnJvbShmb3JtLmVsZW1lbnRzKS5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgIHRoaXMuZGVsZXRlUHJpdmF0ZShpbnB1dCwgUEhYX0hBU19GT0NVU0VEKVxuICAgICAgdGhpcy5kZWxldGVQcml2YXRlKGlucHV0LCBQSFhfSEFTX1NVQk1JVFRFRClcbiAgICB9KVxuICB9LFxuXG4gIGlzUGh4Q2hpbGQobm9kZSl7XG4gICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKFBIWF9QQVJFTlRfSUQpXG4gIH0sXG5cbiAgaXNQaHhTdGlja3kobm9kZSl7XG4gICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKFBIWF9TVElDS1kpICE9PSBudWxsXG4gIH0sXG5cbiAgaXNDaGlsZE9mQW55KGVsLCBwYXJlbnRzKXtcbiAgICByZXR1cm4gISFwYXJlbnRzLmZpbmQocGFyZW50ID0+IHBhcmVudC5jb250YWlucyhlbCkpXG4gIH0sXG5cbiAgZmlyc3RQaHhDaGlsZChlbCl7XG4gICAgcmV0dXJuIHRoaXMuaXNQaHhDaGlsZChlbCkgPyBlbCA6IHRoaXMuYWxsKGVsLCBgWyR7UEhYX1BBUkVOVF9JRH1dYClbMF1cbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50KHRhcmdldCwgbmFtZSwgb3B0cyA9IHt9KXtcbiAgICBsZXQgZGVmYXVsdEJ1YmJsZSA9IHRydWVcbiAgICBsZXQgaXNVcGxvYWRUYXJnZXQgPSB0YXJnZXQubm9kZU5hbWUgPT09IFwiSU5QVVRcIiAmJiB0YXJnZXQudHlwZSA9PT0gXCJmaWxlXCJcbiAgICBpZihpc1VwbG9hZFRhcmdldCAmJiBuYW1lID09PSBcImNsaWNrXCIpe1xuICAgICAgZGVmYXVsdEJ1YmJsZSA9IGZhbHNlXG4gICAgfVxuICAgIGxldCBidWJibGVzID0gb3B0cy5idWJibGVzID09PSB1bmRlZmluZWQgPyBkZWZhdWx0QnViYmxlIDogISFvcHRzLmJ1YmJsZXNcbiAgICBsZXQgZXZlbnRPcHRzID0ge2J1YmJsZXM6IGJ1YmJsZXMsIGNhbmNlbGFibGU6IHRydWUsIGRldGFpbDogb3B0cy5kZXRhaWwgfHwge319XG4gICAgbGV0IGV2ZW50ID0gbmFtZSA9PT0gXCJjbGlja1wiID8gbmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiLCBldmVudE9wdHMpIDogbmV3IEN1c3RvbUV2ZW50KG5hbWUsIGV2ZW50T3B0cylcbiAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudClcbiAgfSxcblxuICBjbG9uZU5vZGUobm9kZSwgaHRtbCl7XG4gICAgaWYodHlwZW9mIChodG1sKSA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICByZXR1cm4gbm9kZS5jbG9uZU5vZGUodHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNsb25lZCA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKVxuICAgICAgY2xvbmVkLmlubmVySFRNTCA9IGh0bWxcbiAgICAgIHJldHVybiBjbG9uZWRcbiAgICB9XG4gIH0sXG5cbiAgLy8gbWVyZ2UgYXR0cmlidXRlcyBmcm9tIHNvdXJjZSB0byB0YXJnZXRcbiAgLy8gaWYgYW4gZWxlbWVudCBpcyBpZ25vcmVkLCB3ZSBvbmx5IG1lcmdlIGRhdGEgYXR0cmlidXRlc1xuICAvLyBpbmNsdWRpbmcgcmVtb3ZpbmcgZGF0YSBhdHRyaWJ1dGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgc291cmNlXG4gIG1lcmdlQXR0cnModGFyZ2V0LCBzb3VyY2UsIG9wdHMgPSB7fSl7XG4gICAgbGV0IGV4Y2x1ZGUgPSBuZXcgU2V0KG9wdHMuZXhjbHVkZSB8fCBbXSlcbiAgICBsZXQgaXNJZ25vcmVkID0gb3B0cy5pc0lnbm9yZWRcbiAgICBsZXQgc291cmNlQXR0cnMgPSBzb3VyY2UuYXR0cmlidXRlc1xuICAgIGZvcihsZXQgaSA9IHNvdXJjZUF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcbiAgICAgIGxldCBuYW1lID0gc291cmNlQXR0cnNbaV0ubmFtZVxuICAgICAgaWYoIWV4Y2x1ZGUuaGFzKG5hbWUpKXtcbiAgICAgICAgY29uc3Qgc291cmNlVmFsdWUgPSBzb3VyY2UuZ2V0QXR0cmlidXRlKG5hbWUpXG4gICAgICAgIGlmKHRhcmdldC5nZXRBdHRyaWJ1dGUobmFtZSkgIT09IHNvdXJjZVZhbHVlICYmICghaXNJZ25vcmVkIHx8IChpc0lnbm9yZWQgJiYgbmFtZS5zdGFydHNXaXRoKFwiZGF0YS1cIikpKSl7XG4gICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShuYW1lLCBzb3VyY2VWYWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgZXhjbHVkZSB0aGUgdmFsdWUgZnJvbSBiZWluZyBtZXJnZWQgb24gZm9jdXNlZCBpbnB1dHMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIHVzZXIncyBpbnB1dCBzaG91bGQgYWx3YXlzIHdpbi5cbiAgICAgICAgLy8gV2UgY2FuIHN0aWxsIGFzc2lnbiBpdCBhcyBsb25nIGFzIHRoZSB2YWx1ZSBwcm9wZXJ0eSBpcyB0aGUgc2FtZSwgdGhvdWdoLlxuICAgICAgICAvLyBUaGlzIHByZXZlbnRzIGEgc2l0dWF0aW9uIHdoZXJlIHRoZSB1cGRhdGVkIGhvb2sgaXMgbm90IGJlaW5nIHRyaWdnZXJlZFxuICAgICAgICAvLyB3aGVuIGFuIGlucHV0IGlzIGJhY2sgaW4gaXRzIFwib3JpZ2luYWwgc3RhdGVcIiwgYmVjYXVzZSB0aGUgYXR0cmlidXRlXG4gICAgICAgIC8vIHdhcyBuZXZlciBjaGFuZ2VkLCBzZWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L2lzc3Vlcy8yMTYzXG4gICAgICAgIGlmKG5hbWUgPT09IFwidmFsdWVcIiAmJiB0YXJnZXQudmFsdWUgPT09IHNvdXJjZS52YWx1ZSl7XG4gICAgICAgICAgLy8gYWN0dWFsbHkgc2V0IHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gc3luYyBpdCB3aXRoIHRoZSB2YWx1ZSBwcm9wZXJ0eVxuICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBzb3VyY2UuZ2V0QXR0cmlidXRlKG5hbWUpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHRhcmdldEF0dHJzID0gdGFyZ2V0LmF0dHJpYnV0ZXNcbiAgICBmb3IobGV0IGkgPSB0YXJnZXRBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG4gICAgICBsZXQgbmFtZSA9IHRhcmdldEF0dHJzW2ldLm5hbWVcbiAgICAgIGlmKGlzSWdub3JlZCl7XG4gICAgICAgIGlmKG5hbWUuc3RhcnRzV2l0aChcImRhdGEtXCIpICYmICFzb3VyY2UuaGFzQXR0cmlidXRlKG5hbWUpICYmICFQSFhfUEVORElOR19BVFRSUy5pbmNsdWRlcyhuYW1lKSl7IHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUobmFtZSkgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoIXNvdXJjZS5oYXNBdHRyaWJ1dGUobmFtZSkpeyB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbWVyZ2VGb2N1c2VkSW5wdXQodGFyZ2V0LCBzb3VyY2Upe1xuICAgIC8vIHNraXAgc2VsZWN0cyBiZWNhdXNlIEZGIHdpbGwgcmVzZXQgaGlnaGxpZ2h0ZWQgaW5kZXggZm9yIGFueSBzZXRBdHRyaWJ1dGVcbiAgICBpZighKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50KSl7IERPTS5tZXJnZUF0dHJzKHRhcmdldCwgc291cmNlLCB7ZXhjbHVkZTogW1widmFsdWVcIl19KSB9XG5cbiAgICBpZihzb3VyY2UucmVhZE9ubHkpe1xuICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInJlYWRvbmx5XCIsIHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJyZWFkb25seVwiKVxuICAgIH1cbiAgfSxcblxuICBoYXNTZWxlY3Rpb25SYW5nZShlbCl7XG4gICAgcmV0dXJuIGVsLnNldFNlbGVjdGlvblJhbmdlICYmIChlbC50eXBlID09PSBcInRleHRcIiB8fCBlbC50eXBlID09PSBcInRleHRhcmVhXCIpXG4gIH0sXG5cbiAgcmVzdG9yZUZvY3VzKGZvY3VzZWQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpe1xuICAgIGlmKGZvY3VzZWQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCl7IGZvY3VzZWQuZm9jdXMoKSB9XG4gICAgaWYoIURPTS5pc1RleHR1YWxJbnB1dChmb2N1c2VkKSl7IHJldHVybiB9XG5cbiAgICBsZXQgd2FzRm9jdXNlZCA9IGZvY3VzZWQubWF0Y2hlcyhcIjpmb2N1c1wiKVxuICAgIGlmKCF3YXNGb2N1c2VkKXsgZm9jdXNlZC5mb2N1cygpIH1cbiAgICBpZih0aGlzLmhhc1NlbGVjdGlvblJhbmdlKGZvY3VzZWQpKXtcbiAgICAgIGZvY3VzZWQuc2V0U2VsZWN0aW9uUmFuZ2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZClcbiAgICB9XG4gIH0sXG5cbiAgaXNGb3JtSW5wdXQoZWwpeyByZXR1cm4gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWEpJC9pLnRlc3QoZWwudGFnTmFtZSkgJiYgZWwudHlwZSAhPT0gXCJidXR0b25cIiB9LFxuXG4gIHN5bmNBdHRyc1RvUHJvcHMoZWwpe1xuICAgIGlmKGVsIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCAmJiBDSEVDS0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpKSA+PSAwKXtcbiAgICAgIGVsLmNoZWNrZWQgPSBlbC5nZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIpICE9PSBudWxsXG4gICAgfVxuICB9LFxuXG4gIGlzVGV4dHVhbElucHV0KGVsKXsgcmV0dXJuIEZPQ1VTQUJMRV9JTlBVVFMuaW5kZXhPZihlbC50eXBlKSA+PSAwIH0sXG5cbiAgaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKGVsLCBwaHhUcmlnZ2VyRXh0ZXJuYWwpe1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKHBoeFRyaWdnZXJFeHRlcm5hbCkgIT09IG51bGwgJiYgZG9jdW1lbnQuYm9keS5jb250YWlucyhlbClcbiAgfSxcblxuICBjbGVhbkNoaWxkTm9kZXMoY29udGFpbmVyLCBwaHhVcGRhdGUpe1xuICAgIGlmKERPTS5pc1BoeFVwZGF0ZShjb250YWluZXIsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkpe1xuICAgICAgbGV0IHRvUmVtb3ZlID0gW11cbiAgICAgIGNvbnRhaW5lci5jaGlsZE5vZGVzLmZvckVhY2goY2hpbGROb2RlID0+IHtcbiAgICAgICAgaWYoIWNoaWxkTm9kZS5pZCl7XG4gICAgICAgICAgLy8gU2tpcCB3YXJuaW5nIGlmIGl0J3MgYW4gZW1wdHkgdGV4dCBub2RlIChlLmcuIGEgbmV3LWxpbmUpXG4gICAgICAgICAgbGV0IGlzRW1wdHlUZXh0Tm9kZSA9IGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgY2hpbGROb2RlLm5vZGVWYWx1ZS50cmltKCkgPT09IFwiXCJcbiAgICAgICAgICBpZighaXNFbXB0eVRleHROb2RlICYmIGNoaWxkTm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5DT01NRU5UX05PREUpe1xuICAgICAgICAgICAgbG9nRXJyb3IoXCJvbmx5IEhUTUwgZWxlbWVudCB0YWdzIHdpdGggYW4gaWQgYXJlIGFsbG93ZWQgaW5zaWRlIGNvbnRhaW5lcnMgd2l0aCBwaHgtdXBkYXRlLlxcblxcblwiICtcbiAgICAgICAgICAgICAgYHJlbW92aW5nIGlsbGVnYWwgbm9kZTogXCIkeyhjaGlsZE5vZGUub3V0ZXJIVE1MIHx8IGNoaWxkTm9kZS5ub2RlVmFsdWUpLnRyaW0oKX1cIlxcblxcbmApXG4gICAgICAgICAgfVxuICAgICAgICAgIHRvUmVtb3ZlLnB1c2goY2hpbGROb2RlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdG9SZW1vdmUuZm9yRWFjaChjaGlsZE5vZGUgPT4gY2hpbGROb2RlLnJlbW92ZSgpKVxuICAgIH1cbiAgfSxcblxuICByZXBsYWNlUm9vdENvbnRhaW5lcihjb250YWluZXIsIHRhZ05hbWUsIGF0dHJzKXtcbiAgICBsZXQgcmV0YWluZWRBdHRycyA9IG5ldyBTZXQoW1wiaWRcIiwgUEhYX1NFU1NJT04sIFBIWF9TVEFUSUMsIFBIWF9NQUlOLCBQSFhfUk9PVF9JRF0pXG4gICAgaWYoY29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpKXtcbiAgICAgIEFycmF5LmZyb20oY29udGFpbmVyLmF0dHJpYnV0ZXMpXG4gICAgICAgIC5maWx0ZXIoYXR0ciA9PiAhcmV0YWluZWRBdHRycy5oYXMoYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICAuZm9yRWFjaChhdHRyID0+IGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5uYW1lKSlcblxuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpXG4gICAgICAgIC5maWx0ZXIobmFtZSA9PiAhcmV0YWluZWRBdHRycy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgLmZvckVhY2goYXR0ciA9PiBjb250YWluZXIuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKSlcblxuICAgICAgcmV0dXJuIGNvbnRhaW5lclxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpXG4gICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChhdHRyID0+IG5ld0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pKVxuICAgICAgcmV0YWluZWRBdHRycy5mb3JFYWNoKGF0dHIgPT4gbmV3Q29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBjb250YWluZXIuZ2V0QXR0cmlidXRlKGF0dHIpKSlcbiAgICAgIG5ld0NvbnRhaW5lci5pbm5lckhUTUwgPSBjb250YWluZXIuaW5uZXJIVE1MXG4gICAgICBjb250YWluZXIucmVwbGFjZVdpdGgobmV3Q29udGFpbmVyKVxuICAgICAgcmV0dXJuIG5ld0NvbnRhaW5lclxuICAgIH1cbiAgfSxcblxuICBnZXRTdGlja3koZWwsIG5hbWUsIGRlZmF1bHRWYWwpe1xuICAgIGxldCBvcCA9IChET00ucHJpdmF0ZShlbCwgXCJzdGlja3lcIikgfHwgW10pLmZpbmQoKFtleGlzdGluZ05hbWUsXSkgPT4gbmFtZSA9PT0gZXhpc3RpbmdOYW1lKVxuICAgIGlmKG9wKXtcbiAgICAgIGxldCBbX25hbWUsIF9vcCwgc3Rhc2hlZFJlc3VsdF0gPSBvcFxuICAgICAgcmV0dXJuIHN0YXNoZWRSZXN1bHRcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHR5cGVvZihkZWZhdWx0VmFsKSA9PT0gXCJmdW5jdGlvblwiID8gZGVmYXVsdFZhbCgpIDogZGVmYXVsdFZhbFxuICAgIH1cbiAgfSxcblxuICBkZWxldGVTdGlja3koZWwsIG5hbWUpe1xuICAgIHRoaXMudXBkYXRlUHJpdmF0ZShlbCwgXCJzdGlja3lcIiwgW10sIG9wcyA9PiB7XG4gICAgICByZXR1cm4gb3BzLmZpbHRlcigoW2V4aXN0aW5nTmFtZSwgX10pID0+IGV4aXN0aW5nTmFtZSAhPT0gbmFtZSlcbiAgICB9KVxuICB9LFxuXG4gIHB1dFN0aWNreShlbCwgbmFtZSwgb3Ape1xuICAgIGxldCBzdGFzaGVkUmVzdWx0ID0gb3AoZWwpXG4gICAgdGhpcy51cGRhdGVQcml2YXRlKGVsLCBcInN0aWNreVwiLCBbXSwgb3BzID0+IHtcbiAgICAgIGxldCBleGlzdGluZ0luZGV4ID0gb3BzLmZpbmRJbmRleCgoW2V4aXN0aW5nTmFtZSxdKSA9PiBuYW1lID09PSBleGlzdGluZ05hbWUpXG4gICAgICBpZihleGlzdGluZ0luZGV4ID49IDApe1xuICAgICAgICBvcHNbZXhpc3RpbmdJbmRleF0gPSBbbmFtZSwgb3AsIHN0YXNoZWRSZXN1bHRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHMucHVzaChbbmFtZSwgb3AsIHN0YXNoZWRSZXN1bHRdKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9wc1xuICAgIH0pXG4gIH0sXG5cbiAgYXBwbHlTdGlja3lPcGVyYXRpb25zKGVsKXtcbiAgICBsZXQgb3BzID0gRE9NLnByaXZhdGUoZWwsIFwic3RpY2t5XCIpXG4gICAgaWYoIW9wcyl7IHJldHVybiB9XG5cbiAgICBvcHMuZm9yRWFjaCgoW25hbWUsIG9wLCBfc3Rhc2hlZF0pID0+IHRoaXMucHV0U3RpY2t5KGVsLCBuYW1lLCBvcCkpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRE9NXG4iLCAiaW1wb3J0IHtcbiAgUEhYX0FDVElWRV9FTlRSWV9SRUZTLFxuICBQSFhfTElWRV9GSUxFX1VQREFURUQsXG4gIFBIWF9QUkVGTElHSFRFRF9SRUZTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNoYW5uZWxVcGxvYWRlcixcbiAgbG9nRXJyb3Jcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgTGl2ZVVwbG9hZGVyIGZyb20gXCIuL2xpdmVfdXBsb2FkZXJcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVcGxvYWRFbnRyeSB7XG4gIHN0YXRpYyBpc0FjdGl2ZShmaWxlRWwsIGZpbGUpe1xuICAgIGxldCBpc05ldyA9IGZpbGUuX3BoeFJlZiA9PT0gdW5kZWZpbmVkXG4gICAgbGV0IGFjdGl2ZVJlZnMgPSBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykuc3BsaXQoXCIsXCIpXG4gICAgbGV0IGlzQWN0aXZlID0gYWN0aXZlUmVmcy5pbmRleE9mKExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpKSA+PSAwXG4gICAgcmV0dXJuIGZpbGUuc2l6ZSA+IDAgJiYgKGlzTmV3IHx8IGlzQWN0aXZlKVxuICB9XG5cbiAgc3RhdGljIGlzUHJlZmxpZ2h0ZWQoZmlsZUVsLCBmaWxlKXtcbiAgICBsZXQgcHJlZmxpZ2h0ZWRSZWZzID0gZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykuc3BsaXQoXCIsXCIpXG4gICAgbGV0IGlzUHJlZmxpZ2h0ZWQgPSBwcmVmbGlnaHRlZFJlZnMuaW5kZXhPZihMaXZlVXBsb2FkZXIuZ2VuRmlsZVJlZihmaWxlKSkgPj0gMFxuICAgIHJldHVybiBpc1ByZWZsaWdodGVkICYmIHRoaXMuaXNBY3RpdmUoZmlsZUVsLCBmaWxlKVxuICB9XG5cbiAgc3RhdGljIGlzUHJlZmxpZ2h0SW5Qcm9ncmVzcyhmaWxlKXtcbiAgICByZXR1cm4gZmlsZS5fcHJlZmxpZ2h0SW5Qcm9ncmVzcyA9PT0gdHJ1ZVxuICB9XG5cbiAgc3RhdGljIG1hcmtQcmVmbGlnaHRJblByb2dyZXNzKGZpbGUpe1xuICAgIGZpbGUuX3ByZWZsaWdodEluUHJvZ3Jlc3MgPSB0cnVlXG4gIH1cblxuICBjb25zdHJ1Y3RvcihmaWxlRWwsIGZpbGUsIHZpZXcsIGF1dG9VcGxvYWQpe1xuICAgIHRoaXMucmVmID0gTGl2ZVVwbG9hZGVyLmdlbkZpbGVSZWYoZmlsZSlcbiAgICB0aGlzLmZpbGVFbCA9IGZpbGVFbFxuICAgIHRoaXMuZmlsZSA9IGZpbGVcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5tZXRhID0gbnVsbFxuICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2VcbiAgICB0aGlzLl9pc0RvbmUgPSBmYWxzZVxuICAgIHRoaXMuX3Byb2dyZXNzID0gMFxuICAgIHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQgPSAtMVxuICAgIHRoaXMuX29uRG9uZSA9IGZ1bmN0aW9uKCl7IH1cbiAgICB0aGlzLl9vbkVsVXBkYXRlZCA9IHRoaXMub25FbFVwZGF0ZWQuYmluZCh0aGlzKVxuICAgIHRoaXMuZmlsZUVsLmFkZEV2ZW50TGlzdGVuZXIoUEhYX0xJVkVfRklMRV9VUERBVEVELCB0aGlzLl9vbkVsVXBkYXRlZClcbiAgICB0aGlzLmF1dG9VcGxvYWQgPSBhdXRvVXBsb2FkXG4gIH1cblxuICBtZXRhZGF0YSgpeyByZXR1cm4gdGhpcy5tZXRhIH1cblxuICBwcm9ncmVzcyhwcm9ncmVzcyl7XG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSBNYXRoLmZsb29yKHByb2dyZXNzKVxuICAgIGlmKHRoaXMuX3Byb2dyZXNzID4gdGhpcy5fbGFzdFByb2dyZXNzU2VudCl7XG4gICAgICBpZih0aGlzLl9wcm9ncmVzcyA+PSAxMDApe1xuICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IDEwMFxuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50ID0gMTAwXG4gICAgICAgIHRoaXMuX2lzRG9uZSA9IHRydWVcbiAgICAgICAgdGhpcy52aWV3LnB1c2hGaWxlUHJvZ3Jlc3ModGhpcy5maWxlRWwsIHRoaXMucmVmLCAxMDAsICgpID0+IHtcbiAgICAgICAgICBMaXZlVXBsb2FkZXIudW50cmFja0ZpbGUodGhpcy5maWxlRWwsIHRoaXMuZmlsZSlcbiAgICAgICAgICB0aGlzLl9vbkRvbmUoKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IHRoaXMuX3Byb2dyZXNzXG4gICAgICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwgdGhpcy5fcHJvZ3Jlc3MpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNDYW5jZWxsZWQoKXsgcmV0dXJuIHRoaXMuX2lzQ2FuY2VsbGVkIH1cblxuICBjYW5jZWwoKXtcbiAgICB0aGlzLmZpbGUuX3ByZWZsaWdodEluUHJvZ3Jlc3MgPSBmYWxzZVxuICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gdHJ1ZVxuICAgIHRoaXMuX2lzRG9uZSA9IHRydWVcbiAgICB0aGlzLl9vbkRvbmUoKVxuICB9XG5cbiAgaXNEb25lKCl7IHJldHVybiB0aGlzLl9pc0RvbmUgfVxuXG4gIGVycm9yKHJlYXNvbiA9IFwiZmFpbGVkXCIpe1xuICAgIHRoaXMuZmlsZUVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoUEhYX0xJVkVfRklMRV9VUERBVEVELCB0aGlzLl9vbkVsVXBkYXRlZClcbiAgICB0aGlzLnZpZXcucHVzaEZpbGVQcm9ncmVzcyh0aGlzLmZpbGVFbCwgdGhpcy5yZWYsIHtlcnJvcjogcmVhc29ufSlcbiAgICBpZighdGhpcy5pc0F1dG9VcGxvYWQoKSl7IExpdmVVcGxvYWRlci5jbGVhckZpbGVzKHRoaXMuZmlsZUVsKSB9XG4gIH1cblxuICBpc0F1dG9VcGxvYWQoKXsgcmV0dXJuIHRoaXMuYXV0b1VwbG9hZCB9XG5cbiAgLy9wcml2YXRlXG5cbiAgb25Eb25lKGNhbGxiYWNrKXtcbiAgICB0aGlzLl9vbkRvbmUgPSAoKSA9PiB7XG4gICAgICB0aGlzLmZpbGVFbC5yZW1vdmVFdmVudExpc3RlbmVyKFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCwgdGhpcy5fb25FbFVwZGF0ZWQpXG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgb25FbFVwZGF0ZWQoKXtcbiAgICBsZXQgYWN0aXZlUmVmcyA9IHRoaXMuZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfQUNUSVZFX0VOVFJZX1JFRlMpLnNwbGl0KFwiLFwiKVxuICAgIGlmKGFjdGl2ZVJlZnMuaW5kZXhPZih0aGlzLnJlZikgPT09IC0xKXtcbiAgICAgIExpdmVVcGxvYWRlci51bnRyYWNrRmlsZSh0aGlzLmZpbGVFbCwgdGhpcy5maWxlKVxuICAgICAgdGhpcy5jYW5jZWwoKVxuICAgIH1cbiAgfVxuXG4gIHRvUHJlZmxpZ2h0UGF5bG9hZCgpe1xuICAgIHJldHVybiB7XG4gICAgICBsYXN0X21vZGlmaWVkOiB0aGlzLmZpbGUubGFzdE1vZGlmaWVkLFxuICAgICAgbmFtZTogdGhpcy5maWxlLm5hbWUsXG4gICAgICByZWxhdGl2ZV9wYXRoOiB0aGlzLmZpbGUud2Via2l0UmVsYXRpdmVQYXRoLFxuICAgICAgc2l6ZTogdGhpcy5maWxlLnNpemUsXG4gICAgICB0eXBlOiB0aGlzLmZpbGUudHlwZSxcbiAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICBtZXRhOiB0eXBlb2YodGhpcy5maWxlLm1ldGEpID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLmZpbGUubWV0YSgpIDogdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgdXBsb2FkZXIodXBsb2FkZXJzKXtcbiAgICBpZih0aGlzLm1ldGEudXBsb2FkZXIpe1xuICAgICAgbGV0IGNhbGxiYWNrID0gdXBsb2FkZXJzW3RoaXMubWV0YS51cGxvYWRlcl0gfHwgbG9nRXJyb3IoYG5vIHVwbG9hZGVyIGNvbmZpZ3VyZWQgZm9yICR7dGhpcy5tZXRhLnVwbG9hZGVyfWApXG4gICAgICByZXR1cm4ge25hbWU6IHRoaXMubWV0YS51cGxvYWRlciwgY2FsbGJhY2s6IGNhbGxiYWNrfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge25hbWU6IFwiY2hhbm5lbFwiLCBjYWxsYmFjazogY2hhbm5lbFVwbG9hZGVyfVxuICAgIH1cbiAgfVxuXG4gIHppcFBvc3RGbGlnaHQocmVzcCl7XG4gICAgdGhpcy5tZXRhID0gcmVzcC5lbnRyaWVzW3RoaXMucmVmXVxuICAgIGlmKCF0aGlzLm1ldGEpeyBsb2dFcnJvcihgbm8gcHJlZmxpZ2h0IHVwbG9hZCByZXNwb25zZSByZXR1cm5lZCB3aXRoIHJlZiAke3RoaXMucmVmfWAsIHtpbnB1dDogdGhpcy5maWxlRWwsIHJlc3BvbnNlOiByZXNwfSkgfVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgUEhYX0RPTkVfUkVGUyxcbiAgUEhYX1BSRUZMSUdIVEVEX1JFRlMsXG4gIFBIWF9VUExPQURfUkVGXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IFVwbG9hZEVudHJ5IGZyb20gXCIuL3VwbG9hZF9lbnRyeVwiXG5cbmxldCBsaXZlVXBsb2FkZXJGaWxlUmVmID0gMFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXZlVXBsb2FkZXIge1xuICBzdGF0aWMgZ2VuRmlsZVJlZihmaWxlKXtcbiAgICBsZXQgcmVmID0gZmlsZS5fcGh4UmVmXG4gICAgaWYocmVmICE9PSB1bmRlZmluZWQpe1xuICAgICAgcmV0dXJuIHJlZlxuICAgIH0gZWxzZSB7XG4gICAgICBmaWxlLl9waHhSZWYgPSAobGl2ZVVwbG9hZGVyRmlsZVJlZisrKS50b1N0cmluZygpXG4gICAgICByZXR1cm4gZmlsZS5fcGh4UmVmXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldEVudHJ5RGF0YVVSTChpbnB1dEVsLCByZWYsIGNhbGxiYWNrKXtcbiAgICBsZXQgZmlsZSA9IHRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuZmluZChmaWxlID0+IHRoaXMuZ2VuRmlsZVJlZihmaWxlKSA9PT0gcmVmKVxuICAgIGNhbGxiYWNrKFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSkpXG4gIH1cblxuICBzdGF0aWMgaGFzVXBsb2Fkc0luUHJvZ3Jlc3MoZm9ybUVsKXtcbiAgICBsZXQgYWN0aXZlID0gMFxuICAgIERPTS5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbCkuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICBpZihpbnB1dC5nZXRBdHRyaWJ1dGUoUEhYX1BSRUZMSUdIVEVEX1JFRlMpICE9PSBpbnB1dC5nZXRBdHRyaWJ1dGUoUEhYX0RPTkVfUkVGUykpe1xuICAgICAgICBhY3RpdmUrK1xuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGFjdGl2ZSA+IDBcbiAgfVxuXG4gIHN0YXRpYyBzZXJpYWxpemVVcGxvYWRzKGlucHV0RWwpe1xuICAgIGxldCBmaWxlcyA9IHRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbClcbiAgICBsZXQgZmlsZURhdGEgPSB7fVxuICAgIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICBsZXQgZW50cnkgPSB7cGF0aDogaW5wdXRFbC5uYW1lfVxuICAgICAgbGV0IHVwbG9hZFJlZiA9IGlucHV0RWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKVxuICAgICAgZmlsZURhdGFbdXBsb2FkUmVmXSA9IGZpbGVEYXRhW3VwbG9hZFJlZl0gfHwgW11cbiAgICAgIGVudHJ5LnJlZiA9IHRoaXMuZ2VuRmlsZVJlZihmaWxlKVxuICAgICAgZW50cnkubGFzdF9tb2RpZmllZCA9IGZpbGUubGFzdE1vZGlmaWVkXG4gICAgICBlbnRyeS5uYW1lID0gZmlsZS5uYW1lIHx8IGVudHJ5LnJlZlxuICAgICAgZW50cnkucmVsYXRpdmVfcGF0aCA9IGZpbGUud2Via2l0UmVsYXRpdmVQYXRoXG4gICAgICBlbnRyeS50eXBlID0gZmlsZS50eXBlXG4gICAgICBlbnRyeS5zaXplID0gZmlsZS5zaXplXG4gICAgICBpZih0eXBlb2YoZmlsZS5tZXRhKSA9PT0gXCJmdW5jdGlvblwiKXsgZW50cnkubWV0YSA9IGZpbGUubWV0YSgpIH1cbiAgICAgIGZpbGVEYXRhW3VwbG9hZFJlZl0ucHVzaChlbnRyeSlcbiAgICB9KVxuICAgIHJldHVybiBmaWxlRGF0YVxuICB9XG5cbiAgc3RhdGljIGNsZWFyRmlsZXMoaW5wdXRFbCl7XG4gICAgaW5wdXRFbC52YWx1ZSA9IG51bGxcbiAgICBpbnB1dEVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRilcbiAgICBET00ucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIFtdKVxuICB9XG5cbiAgc3RhdGljIHVudHJhY2tGaWxlKGlucHV0RWwsIGZpbGUpe1xuICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgRE9NLnByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiKS5maWx0ZXIoZiA9PiAhT2JqZWN0LmlzKGYsIGZpbGUpKSlcbiAgfVxuXG4gIHN0YXRpYyB0cmFja0ZpbGVzKGlucHV0RWwsIGZpbGVzLCBkYXRhVHJhbnNmZXIpe1xuICAgIGlmKGlucHV0RWwuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikgIT09IG51bGwpe1xuICAgICAgbGV0IG5ld0ZpbGVzID0gZmlsZXMuZmlsdGVyKGZpbGUgPT4gIXRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuZmluZChmID0+IE9iamVjdC5pcyhmLCBmaWxlKSkpXG4gICAgICBET00udXBkYXRlUHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIFtdLCAoZXhpc3RpbmcpID0+IGV4aXN0aW5nLmNvbmNhdChuZXdGaWxlcykpXG4gICAgICBpbnB1dEVsLnZhbHVlID0gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXNldCBpbnB1dEVsIGZpbGVzIHRvIGFsaWduIG91dHB1dCB3aXRoIHByb2dyYW1tYXRpYyBjaGFuZ2VzIChpLmUuIGRyYWcgYW5kIGRyb3ApXG4gICAgICBpZihkYXRhVHJhbnNmZXIgJiYgZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCA+IDApeyBpbnB1dEVsLmZpbGVzID0gZGF0YVRyYW5zZmVyLmZpbGVzIH1cbiAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgZmlsZXMpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFjdGl2ZUZpbGVJbnB1dHMoZm9ybUVsKXtcbiAgICBsZXQgZmlsZUlucHV0cyA9IERPTS5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbClcbiAgICByZXR1cm4gQXJyYXkuZnJvbShmaWxlSW5wdXRzKS5maWx0ZXIoZWwgPT4gZWwuZmlsZXMgJiYgdGhpcy5hY3RpdmVGaWxlcyhlbCkubGVuZ3RoID4gMClcbiAgfVxuXG4gIHN0YXRpYyBhY3RpdmVGaWxlcyhpbnB1dCl7XG4gICAgcmV0dXJuIChET00ucHJpdmF0ZShpbnB1dCwgXCJmaWxlc1wiKSB8fCBbXSkuZmlsdGVyKGYgPT4gVXBsb2FkRW50cnkuaXNBY3RpdmUoaW5wdXQsIGYpKVxuICB9XG5cbiAgc3RhdGljIGlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0KGZvcm1FbCl7XG4gICAgbGV0IGZpbGVJbnB1dHMgPSBET00uZmluZFVwbG9hZElucHV0cyhmb3JtRWwpXG4gICAgcmV0dXJuIEFycmF5LmZyb20oZmlsZUlucHV0cykuZmlsdGVyKGlucHV0ID0+IHRoaXMuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dCkubGVuZ3RoID4gMClcbiAgfVxuXG4gIHN0YXRpYyBmaWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0KXtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dCkuZmlsdGVyKGYgPT4gIVVwbG9hZEVudHJ5LmlzUHJlZmxpZ2h0ZWQoaW5wdXQsIGYpICYmICFVcGxvYWRFbnRyeS5pc1ByZWZsaWdodEluUHJvZ3Jlc3MoZikpXG4gIH1cblxuICBzdGF0aWMgbWFya1ByZWZsaWdodEluUHJvZ3Jlc3MoZW50cmllcyl7XG4gICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IFVwbG9hZEVudHJ5Lm1hcmtQcmVmbGlnaHRJblByb2dyZXNzKGVudHJ5LmZpbGUpKVxuICB9XG5cbiAgY29uc3RydWN0b3IoaW5wdXRFbCwgdmlldywgb25Db21wbGV0ZSl7XG4gICAgdGhpcy5hdXRvVXBsb2FkID0gRE9NLmlzQXV0b1VwbG9hZChpbnB1dEVsKVxuICAgIHRoaXMudmlldyA9IHZpZXdcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBvbkNvbXBsZXRlXG4gICAgdGhpcy5fZW50cmllcyA9XG4gICAgICBBcnJheS5mcm9tKExpdmVVcGxvYWRlci5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0RWwpIHx8IFtdKVxuICAgICAgICAubWFwKGZpbGUgPT4gbmV3IFVwbG9hZEVudHJ5KGlucHV0RWwsIGZpbGUsIHZpZXcsIHRoaXMuYXV0b1VwbG9hZCkpXG5cbiAgICAvLyBwcmV2ZW50IHNlbmRpbmcgZHVwbGljYXRlIHByZWZsaWdodCByZXF1ZXN0c1xuICAgIExpdmVVcGxvYWRlci5tYXJrUHJlZmxpZ2h0SW5Qcm9ncmVzcyh0aGlzLl9lbnRyaWVzKVxuXG4gICAgdGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcyA9IHRoaXMuX2VudHJpZXMubGVuZ3RoXG4gIH1cblxuICBpc0F1dG9VcGxvYWQoKXsgcmV0dXJuIHRoaXMuYXV0b1VwbG9hZCB9XG5cbiAgZW50cmllcygpeyByZXR1cm4gdGhpcy5fZW50cmllcyB9XG5cbiAgaW5pdEFkYXB0ZXJVcGxvYWQocmVzcCwgb25FcnJvciwgbGl2ZVNvY2tldCl7XG4gICAgdGhpcy5fZW50cmllcyA9XG4gICAgICB0aGlzLl9lbnRyaWVzLm1hcChlbnRyeSA9PiB7XG4gICAgICAgIGlmKGVudHJ5LmlzQ2FuY2VsbGVkKCkpe1xuICAgICAgICAgIHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MtLVxuICAgICAgICAgIGlmKHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MgPT09IDApeyB0aGlzLm9uQ29tcGxldGUoKSB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW50cnkuemlwUG9zdEZsaWdodChyZXNwKVxuICAgICAgICAgIGVudHJ5Lm9uRG9uZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm51bUVudHJpZXNJblByb2dyZXNzLS1cbiAgICAgICAgICAgIGlmKHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MgPT09IDApeyB0aGlzLm9uQ29tcGxldGUoKSB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnlcbiAgICAgIH0pXG5cbiAgICBsZXQgZ3JvdXBlZEVudHJpZXMgPSB0aGlzLl9lbnRyaWVzLnJlZHVjZSgoYWNjLCBlbnRyeSkgPT4ge1xuICAgICAgaWYoIWVudHJ5Lm1ldGEpeyByZXR1cm4gYWNjIH1cbiAgICAgIGxldCB7bmFtZSwgY2FsbGJhY2t9ID0gZW50cnkudXBsb2FkZXIobGl2ZVNvY2tldC51cGxvYWRlcnMpXG4gICAgICBhY2NbbmFtZV0gPSBhY2NbbmFtZV0gfHwge2NhbGxiYWNrOiBjYWxsYmFjaywgZW50cmllczogW119XG4gICAgICBhY2NbbmFtZV0uZW50cmllcy5wdXNoKGVudHJ5KVxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIHt9KVxuXG4gICAgZm9yKGxldCBuYW1lIGluIGdyb3VwZWRFbnRyaWVzKXtcbiAgICAgIGxldCB7Y2FsbGJhY2ssIGVudHJpZXN9ID0gZ3JvdXBlZEVudHJpZXNbbmFtZV1cbiAgICAgIGNhbGxiYWNrKGVudHJpZXMsIG9uRXJyb3IsIHJlc3AsIGxpdmVTb2NrZXQpXG4gICAgfVxuICB9XG59XG4iLCAibGV0IEFSSUEgPSB7XG4gIGFueU9mKGluc3RhbmNlLCBjbGFzc2VzKXsgcmV0dXJuIGNsYXNzZXMuZmluZChuYW1lID0+IGluc3RhbmNlIGluc3RhbmNlb2YgbmFtZSkgfSxcblxuICBpc0ZvY3VzYWJsZShlbCwgaW50ZXJhY3RpdmVPbmx5KXtcbiAgICByZXR1cm4gKFxuICAgICAgKGVsIGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQgJiYgZWwucmVsICE9PSBcImlnbm9yZVwiKSB8fFxuICAgICAgKGVsIGluc3RhbmNlb2YgSFRNTEFyZWFFbGVtZW50ICYmIGVsLmhyZWYgIT09IHVuZGVmaW5lZCkgfHxcbiAgICAgICghZWwuZGlzYWJsZWQgJiYgKHRoaXMuYW55T2YoZWwsIFtIVE1MSW5wdXRFbGVtZW50LCBIVE1MU2VsZWN0RWxlbWVudCwgSFRNTFRleHRBcmVhRWxlbWVudCwgSFRNTEJ1dHRvbkVsZW1lbnRdKSkpIHx8XG4gICAgICAoZWwgaW5zdGFuY2VvZiBIVE1MSUZyYW1lRWxlbWVudCkgfHxcbiAgICAgIChlbC50YWJJbmRleCA+IDAgfHwgKCFpbnRlcmFjdGl2ZU9ubHkgJiYgZWwuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIikgIT09IG51bGwgJiYgZWwuZ2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIikgIT09IFwidHJ1ZVwiKSlcbiAgICApXG4gIH0sXG5cbiAgYXR0ZW1wdEZvY3VzKGVsLCBpbnRlcmFjdGl2ZU9ubHkpe1xuICAgIGlmKHRoaXMuaXNGb2N1c2FibGUoZWwsIGludGVyYWN0aXZlT25seSkpeyB0cnkgeyBlbC5mb2N1cygpIH0gY2F0Y2gge30gfVxuICAgIHJldHVybiAhIWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5pc1NhbWVOb2RlKGVsKVxuICB9LFxuXG4gIGZvY3VzRmlyc3RJbnRlcmFjdGl2ZShlbCl7XG4gICAgbGV0IGNoaWxkID0gZWwuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICB3aGlsZShjaGlsZCl7XG4gICAgICBpZih0aGlzLmF0dGVtcHRGb2N1cyhjaGlsZCwgdHJ1ZSkgfHwgdGhpcy5mb2N1c0ZpcnN0SW50ZXJhY3RpdmUoY2hpbGQsIHRydWUpKXtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQubmV4dEVsZW1lbnRTaWJsaW5nXG4gICAgfVxuICB9LFxuXG4gIGZvY3VzRmlyc3QoZWwpe1xuICAgIGxldCBjaGlsZCA9IGVsLmZpcnN0RWxlbWVudENoaWxkXG4gICAgd2hpbGUoY2hpbGQpe1xuICAgICAgaWYodGhpcy5hdHRlbXB0Rm9jdXMoY2hpbGQpIHx8IHRoaXMuZm9jdXNGaXJzdChjaGlsZCkpe1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0RWxlbWVudFNpYmxpbmdcbiAgICB9XG4gIH0sXG5cbiAgZm9jdXNMYXN0KGVsKXtcbiAgICBsZXQgY2hpbGQgPSBlbC5sYXN0RWxlbWVudENoaWxkXG4gICAgd2hpbGUoY2hpbGQpe1xuICAgICAgaWYodGhpcy5hdHRlbXB0Rm9jdXMoY2hpbGQpIHx8IHRoaXMuZm9jdXNMYXN0KGNoaWxkKSl7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnByZXZpb3VzRWxlbWVudFNpYmxpbmdcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEFSSUFcbiIsICJpbXBvcnQge1xuICBQSFhfQUNUSVZFX0VOVFJZX1JFRlMsXG4gIFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCxcbiAgUEhYX1BSRUZMSUdIVEVEX1JFRlMsXG4gIFBIWF9VUExPQURfUkVGXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5pbXBvcnQgQVJJQSBmcm9tIFwiLi9hcmlhXCJcblxubGV0IEhvb2tzID0ge1xuICBMaXZlRmlsZVVwbG9hZDoge1xuICAgIGFjdGl2ZVJlZnMoKXsgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykgfSxcblxuICAgIHByZWZsaWdodGVkUmVmcygpeyByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1BSRUZMSUdIVEVEX1JFRlMpIH0sXG5cbiAgICBtb3VudGVkKCl7IHRoaXMucHJlZmxpZ2h0ZWRXYXMgPSB0aGlzLnByZWZsaWdodGVkUmVmcygpIH0sXG5cbiAgICB1cGRhdGVkKCl7XG4gICAgICBsZXQgbmV3UHJlZmxpZ2h0cyA9IHRoaXMucHJlZmxpZ2h0ZWRSZWZzKClcbiAgICAgIGlmKHRoaXMucHJlZmxpZ2h0ZWRXYXMgIT09IG5ld1ByZWZsaWdodHMpe1xuICAgICAgICB0aGlzLnByZWZsaWdodGVkV2FzID0gbmV3UHJlZmxpZ2h0c1xuICAgICAgICBpZihuZXdQcmVmbGlnaHRzID09PSBcIlwiKXtcbiAgICAgICAgICB0aGlzLl9fdmlldygpLmNhbmNlbFN1Ym1pdCh0aGlzLmVsLmZvcm0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYodGhpcy5hY3RpdmVSZWZzKCkgPT09IFwiXCIpeyB0aGlzLmVsLnZhbHVlID0gbnVsbCB9XG4gICAgICB0aGlzLmVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCkpXG4gICAgfVxuICB9LFxuXG4gIExpdmVJbWdQcmV2aWV3OiB7XG4gICAgbW91bnRlZCgpe1xuICAgICAgdGhpcy5yZWYgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWVudHJ5LXJlZlwiKVxuICAgICAgdGhpcy5pbnB1dEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpKVxuICAgICAgTGl2ZVVwbG9hZGVyLmdldEVudHJ5RGF0YVVSTCh0aGlzLmlucHV0RWwsIHRoaXMucmVmLCB1cmwgPT4ge1xuICAgICAgICB0aGlzLnVybCA9IHVybFxuICAgICAgICB0aGlzLmVsLnNyYyA9IHVybFxuICAgICAgfSlcbiAgICB9LFxuICAgIGRlc3Ryb3llZCgpe1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLnVybClcbiAgICB9XG4gIH0sXG4gIEZvY3VzV3JhcDoge1xuICAgIG1vdW50ZWQoKXtcbiAgICAgIHRoaXMuZm9jdXNTdGFydCA9IHRoaXMuZWwuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgIHRoaXMuZm9jdXNFbmQgPSB0aGlzLmVsLmxhc3RFbGVtZW50Q2hpbGRcbiAgICAgIHRoaXMuZm9jdXNTdGFydC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgKCkgPT4gQVJJQS5mb2N1c0xhc3QodGhpcy5lbCkpXG4gICAgICB0aGlzLmZvY3VzRW5kLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCAoKSA9PiBBUklBLmZvY3VzRmlyc3QodGhpcy5lbCkpXG4gICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6c2hvdy1lbmRcIiwgKCkgPT4gdGhpcy5lbC5mb2N1cygpKVxuICAgICAgaWYod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbCkuZGlzcGxheSAhPT0gXCJub25lXCIpe1xuICAgICAgICBBUklBLmZvY3VzRmlyc3QodGhpcy5lbClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubGV0IGZpbmRTY3JvbGxDb250YWluZXIgPSAoZWwpID0+IHtcbiAgLy8gdGhlIHNjcm9sbCBldmVudCB3b24ndCBiZSBmaXJlZCBvbiB0aGUgaHRtbC9ib2R5IGVsZW1lbnQgZXZlbiBpZiBvdmVyZmxvdyBpcyBzZXRcbiAgLy8gdGhlcmVmb3JlIHdlIHJldHVybiBudWxsIHRvIGluc3RlYWQgbGlzdGVuIGZvciBzY3JvbGwgZXZlbnRzIG9uIGRvY3VtZW50XG4gIGlmKFtcIkhUTUxcIiwgXCJCT0RZXCJdLmluZGV4T2YoZWwubm9kZU5hbWUudG9VcHBlckNhc2UoKSkgPj0gMCkgcmV0dXJuIG51bGxcbiAgaWYoW1wic2Nyb2xsXCIsIFwiYXV0b1wiXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWwpLm92ZXJmbG93WSkgPj0gMCkgcmV0dXJuIGVsXG4gIHJldHVybiBmaW5kU2Nyb2xsQ29udGFpbmVyKGVsLnBhcmVudEVsZW1lbnQpXG59XG5cbmxldCBzY3JvbGxUb3AgPSAoc2Nyb2xsQ29udGFpbmVyKSA9PiB7XG4gIGlmKHNjcm9sbENvbnRhaW5lcil7XG4gICAgcmV0dXJuIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3BcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcFxuICB9XG59XG5cbmxldCBib3R0b20gPSAoc2Nyb2xsQ29udGFpbmVyKSA9PiB7XG4gIGlmKHNjcm9sbENvbnRhaW5lcil7XG4gICAgcmV0dXJuIHNjcm9sbENvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b21cbiAgfSBlbHNlIHtcbiAgICAvLyB3aGVuIHdlIGhhdmUgbm8gY29udGFpbmVyLCB0aGUgd2hvbGUgcGFnZSBzY3JvbGxzLFxuICAgIC8vIHRoZXJlZm9yZSB0aGUgYm90dG9tIGNvb3JkaW5hdGUgaXMgdGhlIHZpZXdwb3J0IGhlaWdodFxuICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuICB9XG59XG5cbmxldCB0b3AgPSAoc2Nyb2xsQ29udGFpbmVyKSA9PiB7XG4gIGlmKHNjcm9sbENvbnRhaW5lcil7XG4gICAgcmV0dXJuIHNjcm9sbENvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgfSBlbHNlIHtcbiAgICAvLyB3aGVuIHdlIGhhdmUgbm8gY29udGFpbmVyIHRoZSB3aG9sZSBwYWdlIHNjcm9sbHMsXG4gICAgLy8gdGhlcmVmb3JlIHRoZSB0b3AgY29vcmRpbmF0ZSBpcyAwXG4gICAgcmV0dXJuIDBcbiAgfVxufVxuXG5sZXQgaXNBdFZpZXdwb3J0VG9wID0gKGVsLCBzY3JvbGxDb250YWluZXIpID0+IHtcbiAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICByZXR1cm4gTWF0aC5jZWlsKHJlY3QudG9wKSA+PSB0b3Aoc2Nyb2xsQ29udGFpbmVyKSAmJiBNYXRoLmNlaWwocmVjdC5sZWZ0KSA+PSAwICYmIE1hdGguZmxvb3IocmVjdC50b3ApIDw9IGJvdHRvbShzY3JvbGxDb250YWluZXIpXG59XG5cbmxldCBpc0F0Vmlld3BvcnRCb3R0b20gPSAoZWwsIHNjcm9sbENvbnRhaW5lcikgPT4ge1xuICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIHJldHVybiBNYXRoLmNlaWwocmVjdC5ib3R0b20pID49IHRvcChzY3JvbGxDb250YWluZXIpICYmIE1hdGguY2VpbChyZWN0LmxlZnQpID49IDAgJiYgTWF0aC5mbG9vcihyZWN0LmJvdHRvbSkgPD0gYm90dG9tKHNjcm9sbENvbnRhaW5lcilcbn1cblxubGV0IGlzV2l0aGluVmlld3BvcnQgPSAoZWwsIHNjcm9sbENvbnRhaW5lcikgPT4ge1xuICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIHJldHVybiBNYXRoLmNlaWwocmVjdC50b3ApID49IHRvcChzY3JvbGxDb250YWluZXIpICYmIE1hdGguY2VpbChyZWN0LmxlZnQpID49IDAgJiYgTWF0aC5mbG9vcihyZWN0LnRvcCkgPD0gYm90dG9tKHNjcm9sbENvbnRhaW5lcilcbn1cblxuSG9va3MuSW5maW5pdGVTY3JvbGwgPSB7XG4gIG1vdW50ZWQoKXtcbiAgICB0aGlzLnNjcm9sbENvbnRhaW5lciA9IGZpbmRTY3JvbGxDb250YWluZXIodGhpcy5lbClcbiAgICBsZXQgc2Nyb2xsQmVmb3JlID0gc2Nyb2xsVG9wKHRoaXMuc2Nyb2xsQ29udGFpbmVyKVxuICAgIGxldCB0b3BPdmVycmFuID0gZmFsc2VcbiAgICBsZXQgdGhyb3R0bGVJbnRlcnZhbCA9IDUwMFxuICAgIGxldCBwZW5kaW5nT3AgPSBudWxsXG5cbiAgICBsZXQgb25Ub3BPdmVycnVuID0gdGhpcy50aHJvdHRsZSh0aHJvdHRsZUludGVydmFsLCAodG9wRXZlbnQsIGZpcnN0Q2hpbGQpID0+IHtcbiAgICAgIHBlbmRpbmdPcCA9ICgpID0+IHRydWVcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5leGVjSlNIb29rUHVzaCh0aGlzLmVsLCB0b3BFdmVudCwge2lkOiBmaXJzdENoaWxkLmlkLCBfb3ZlcnJhbjogdHJ1ZX0sICgpID0+IHtcbiAgICAgICAgcGVuZGluZ09wID0gbnVsbFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgbGV0IG9uRmlyc3RDaGlsZEF0VG9wID0gdGhpcy50aHJvdHRsZSh0aHJvdHRsZUludGVydmFsLCAodG9wRXZlbnQsIGZpcnN0Q2hpbGQpID0+IHtcbiAgICAgIHBlbmRpbmdPcCA9ICgpID0+IGZpcnN0Q2hpbGQuc2Nyb2xsSW50b1ZpZXcoe2Jsb2NrOiBcInN0YXJ0XCJ9KVxuICAgICAgdGhpcy5saXZlU29ja2V0LmV4ZWNKU0hvb2tQdXNoKHRoaXMuZWwsIHRvcEV2ZW50LCB7aWQ6IGZpcnN0Q2hpbGQuaWR9LCAoKSA9PiB7XG4gICAgICAgIHBlbmRpbmdPcCA9IG51bGxcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIERPTSBpcyBwYXRjaGVkIGJ5IHdhaXRpbmcgZm9yIHRoZSBuZXh0IHRpY2tcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgaWYoIWlzV2l0aGluVmlld3BvcnQoZmlyc3RDaGlsZCwgdGhpcy5zY3JvbGxDb250YWluZXIpKXtcbiAgICAgICAgICAgIGZpcnN0Q2hpbGQuc2Nyb2xsSW50b1ZpZXcoe2Jsb2NrOiBcInN0YXJ0XCJ9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGxldCBvbkxhc3RDaGlsZEF0Qm90dG9tID0gdGhpcy50aHJvdHRsZSh0aHJvdHRsZUludGVydmFsLCAoYm90dG9tRXZlbnQsIGxhc3RDaGlsZCkgPT4ge1xuICAgICAgcGVuZGluZ09wID0gKCkgPT4gbGFzdENoaWxkLnNjcm9sbEludG9WaWV3KHtibG9jazogXCJlbmRcIn0pXG4gICAgICB0aGlzLmxpdmVTb2NrZXQuZXhlY0pTSG9va1B1c2godGhpcy5lbCwgYm90dG9tRXZlbnQsIHtpZDogbGFzdENoaWxkLmlkfSwgKCkgPT4ge1xuICAgICAgICBwZW5kaW5nT3AgPSBudWxsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBET00gaXMgcGF0Y2hlZCBieSB3YWl0aW5nIGZvciB0aGUgbmV4dCB0aWNrXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGlmKCFpc1dpdGhpblZpZXdwb3J0KGxhc3RDaGlsZCwgdGhpcy5zY3JvbGxDb250YWluZXIpKXtcbiAgICAgICAgICAgIGxhc3RDaGlsZC5zY3JvbGxJbnRvVmlldyh7YmxvY2s6IFwiZW5kXCJ9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMub25TY3JvbGwgPSAoX2UpID0+IHtcbiAgICAgIGxldCBzY3JvbGxOb3cgPSBzY3JvbGxUb3AodGhpcy5zY3JvbGxDb250YWluZXIpXG5cbiAgICAgIGlmKHBlbmRpbmdPcCl7XG4gICAgICAgIHNjcm9sbEJlZm9yZSA9IHNjcm9sbE5vd1xuICAgICAgICByZXR1cm4gcGVuZGluZ09wKClcbiAgICAgIH1cbiAgICAgIGxldCByZWN0ID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgbGV0IHRvcEV2ZW50ID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUodGhpcy5saXZlU29ja2V0LmJpbmRpbmcoXCJ2aWV3cG9ydC10b3BcIikpXG4gICAgICBsZXQgYm90dG9tRXZlbnQgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZSh0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhcInZpZXdwb3J0LWJvdHRvbVwiKSlcbiAgICAgIGxldCBsYXN0Q2hpbGQgPSB0aGlzLmVsLmxhc3RFbGVtZW50Q2hpbGRcbiAgICAgIGxldCBmaXJzdENoaWxkID0gdGhpcy5lbC5maXJzdEVsZW1lbnRDaGlsZFxuICAgICAgbGV0IGlzU2Nyb2xsaW5nVXAgPSBzY3JvbGxOb3cgPCBzY3JvbGxCZWZvcmVcbiAgICAgIGxldCBpc1Njcm9sbGluZ0Rvd24gPSBzY3JvbGxOb3cgPiBzY3JvbGxCZWZvcmVcblxuICAgICAgLy8gZWwgb3ZlcnJhbiB3aGlsZSBzY3JvbGxpbmcgdXBcbiAgICAgIGlmKGlzU2Nyb2xsaW5nVXAgJiYgdG9wRXZlbnQgJiYgIXRvcE92ZXJyYW4gJiYgcmVjdC50b3AgPj0gMCl7XG4gICAgICAgIHRvcE92ZXJyYW4gPSB0cnVlXG4gICAgICAgIG9uVG9wT3ZlcnJ1bih0b3BFdmVudCwgZmlyc3RDaGlsZClcbiAgICAgIH0gZWxzZSBpZihpc1Njcm9sbGluZ0Rvd24gJiYgdG9wT3ZlcnJhbiAmJiByZWN0LnRvcCA8PSAwKXtcbiAgICAgICAgdG9wT3ZlcnJhbiA9IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmKHRvcEV2ZW50ICYmIGlzU2Nyb2xsaW5nVXAgJiYgaXNBdFZpZXdwb3J0VG9wKGZpcnN0Q2hpbGQsIHRoaXMuc2Nyb2xsQ29udGFpbmVyKSl7XG4gICAgICAgIG9uRmlyc3RDaGlsZEF0VG9wKHRvcEV2ZW50LCBmaXJzdENoaWxkKVxuICAgICAgfSBlbHNlIGlmKGJvdHRvbUV2ZW50ICYmIGlzU2Nyb2xsaW5nRG93biAmJiBpc0F0Vmlld3BvcnRCb3R0b20obGFzdENoaWxkLCB0aGlzLnNjcm9sbENvbnRhaW5lcikpe1xuICAgICAgICBvbkxhc3RDaGlsZEF0Qm90dG9tKGJvdHRvbUV2ZW50LCBsYXN0Q2hpbGQpXG4gICAgICB9XG4gICAgICBzY3JvbGxCZWZvcmUgPSBzY3JvbGxOb3dcbiAgICB9XG5cbiAgICBpZih0aGlzLnNjcm9sbENvbnRhaW5lcil7XG4gICAgICB0aGlzLnNjcm9sbENvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpXG4gICAgfVxuICB9LFxuICBcbiAgZGVzdHJveWVkKCl7XG4gICAgaWYodGhpcy5zY3JvbGxDb250YWluZXIpe1xuICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKVxuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKVxuICAgIH1cbiAgfSxcblxuICB0aHJvdHRsZShpbnRlcnZhbCwgY2FsbGJhY2spe1xuICAgIGxldCBsYXN0Q2FsbEF0ID0gMFxuICAgIGxldCB0aW1lclxuXG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKVxuICAgICAgbGV0IHJlbWFpbmluZ1RpbWUgPSBpbnRlcnZhbCAtIChub3cgLSBsYXN0Q2FsbEF0KVxuXG4gICAgICBpZihyZW1haW5pbmdUaW1lIDw9IDAgfHwgcmVtYWluaW5nVGltZSA+IGludGVydmFsKXtcbiAgICAgICAgaWYodGltZXIpe1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcilcbiAgICAgICAgICB0aW1lciA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICBsYXN0Q2FsbEF0ID0gbm93XG4gICAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpXG4gICAgICB9IGVsc2UgaWYoIXRpbWVyKXtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBsYXN0Q2FsbEF0ID0gRGF0ZS5ub3coKVxuICAgICAgICAgIHRpbWVyID0gbnVsbFxuICAgICAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpXG4gICAgICAgIH0sIHJlbWFpbmluZ1RpbWUpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5leHBvcnQgZGVmYXVsdCBIb29rc1xuIiwgImltcG9ydCB7XG4gIFBIWF9SRUZfTE9BRElORyxcbiAgUEhYX1JFRl9MT0NLLFxuICBQSFhfUkVGX1NSQyxcbiAgUEhYX0VWRU5UX0NMQVNTRVMsXG4gIFBIWF9ESVNBQkxFRCxcbiAgUEhYX1JFQURPTkxZLFxuICBQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkVcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50UmVmIHtcbiAgY29uc3RydWN0b3IoZWwpe1xuICAgIHRoaXMuZWwgPSBlbFxuICAgIHRoaXMubG9hZGluZ1JlZiA9IGVsLmhhc0F0dHJpYnV0ZShQSFhfUkVGX0xPQURJTkcpID8gcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKFBIWF9SRUZfTE9BRElORyksIDEwKSA6IG51bGxcbiAgICB0aGlzLmxvY2tSZWYgPSBlbC5oYXNBdHRyaWJ1dGUoUEhYX1JFRl9MT0NLKSA/IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZShQSFhfUkVGX0xPQ0spLCAxMCkgOiBudWxsXG4gIH1cblxuICAvLyBwdWJsaWNcblxuICBtYXliZVVuZG8ocmVmLCBwaHhFdmVudCwgZWFjaENsb25lQ2FsbGJhY2spe1xuICAgIGlmKCF0aGlzLmlzV2l0aGluKHJlZikpeyByZXR1cm4gfVxuXG4gICAgLy8gdW5kbyBsb2NrcyBhbmQgYXBwbHkgY2xvbmVzXG4gICAgdGhpcy51bmRvTG9ja3MocmVmLCBwaHhFdmVudCwgZWFjaENsb25lQ2FsbGJhY2spXG5cbiAgICAvLyB1bmRvIGxvYWRpbmcgc3RhdGVzXG4gICAgdGhpcy51bmRvTG9hZGluZyhyZWYsIHBoeEV2ZW50KVxuXG4gICAgLy8gY2xlYW4gdXAgaWYgZnVsbHkgcmVzb2x2ZWRcbiAgICBpZih0aGlzLmlzRnVsbHlSZXNvbHZlZEJ5KHJlZikpeyB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGX1NSQykgfVxuICB9XG5cbiAgLy8gcHJpdmF0ZVxuXG4gIGlzV2l0aGluKHJlZil7XG4gICAgcmV0dXJuICEoKHRoaXMubG9hZGluZ1JlZiAhPT0gbnVsbCAmJiB0aGlzLmxvYWRpbmdSZWYgPiByZWYpICYmICh0aGlzLmxvY2tSZWYgIT09IG51bGwgJiYgdGhpcy5sb2NrUmVmID4gcmVmKSlcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBjbG9uZWQgUEhYX1JFRl9MT0NLIGVsZW1lbnQgdGhhdCBoYXMgYmVlbiBtb3JwaGVkIGJlaGluZFxuICAvLyB0aGUgc2NlbmVzIHdoaWxlIHRoaXMgZWxlbWVudCB3YXMgbG9ja2VkIGluIHRoZSBET00uXG4gIC8vIFdoZW4gd2UgYXBwbHkgdGhlIGNsb25lZCB0cmVlIHRvIHRoZSBhY3RpdmUgRE9NIGVsZW1lbnQsIHdlIG11c3RcbiAgLy9cbiAgLy8gICAxLiBleGVjdXRlIHBlbmRpbmcgbW91bnRlZCBob29rcyBmb3Igbm9kZXMgbm93IGluIHRoZSBET01cbiAgLy8gICAyLiB1bmRvIGFueSByZWYgaW5zaWRlIHRoZSBjbG9uZWQgdHJlZSB0aGF0IGhhcyBzaW5jZSBiZWVuIGFjaydkXG4gIHVuZG9Mb2NrcyhyZWYsIHBoeEV2ZW50LCBlYWNoQ2xvbmVDYWxsYmFjayl7XG4gICAgaWYoIXRoaXMuaXNMb2NrVW5kb25lQnkocmVmKSl7IHJldHVybiB9XG5cbiAgICBsZXQgY2xvbmVkVHJlZSA9IERPTS5wcml2YXRlKHRoaXMuZWwsIFBIWF9SRUZfTE9DSylcbiAgICBpZihjbG9uZWRUcmVlKXtcbiAgICAgIGVhY2hDbG9uZUNhbGxiYWNrKGNsb25lZFRyZWUpXG4gICAgICBET00uZGVsZXRlUHJpdmF0ZSh0aGlzLmVsLCBQSFhfUkVGX0xPQ0spXG4gICAgfVxuICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUZfTE9DSylcblxuICAgIGxldCBvcHRzID0ge2RldGFpbDoge3JlZjogcmVmLCBldmVudDogcGh4RXZlbnR9LCBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiBmYWxzZX1cbiAgICB0aGlzLmVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGBwaHg6dW5kby1sb2NrOiR7dGhpcy5sb2NrUmVmfWAsIG9wdHMpKVxuICB9XG5cbiAgdW5kb0xvYWRpbmcocmVmLCBwaHhFdmVudCl7XG4gICAgaWYoIXRoaXMuaXNMb2FkaW5nVW5kb25lQnkocmVmKSl7XG4gICAgICBpZih0aGlzLmNhblVuZG9Mb2FkaW5nKHJlZikgJiYgdGhpcy5lbC5jbGFzc0xpc3QuY29udGFpbnMoXCJwaHgtc3VibWl0LWxvYWRpbmdcIikpe1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoXCJwaHgtY2hhbmdlLWxvYWRpbmdcIilcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmKHRoaXMuY2FuVW5kb0xvYWRpbmcocmVmKSl7XG4gICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGX0xPQURJTkcpXG4gICAgICBsZXQgZGlzYWJsZWRWYWwgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRUQpXG4gICAgICBsZXQgcmVhZE9ubHlWYWwgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfUkVBRE9OTFkpXG4gICAgICAvLyByZXN0b3JlIGlucHV0c1xuICAgICAgaWYocmVhZE9ubHlWYWwgIT09IG51bGwpe1xuICAgICAgICB0aGlzLmVsLnJlYWRPbmx5ID0gcmVhZE9ubHlWYWwgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUFET05MWSlcbiAgICAgIH1cbiAgICAgIGlmKGRpc2FibGVkVmFsICE9PSBudWxsKXtcbiAgICAgICAgdGhpcy5lbC5kaXNhYmxlZCA9IGRpc2FibGVkVmFsID09PSBcInRydWVcIiA/IHRydWUgOiBmYWxzZVxuICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfRElTQUJMRUQpXG4gICAgICB9XG4gICAgICAvLyByZXN0b3JlIGRpc2FibGVzXG4gICAgICBsZXQgZGlzYWJsZVJlc3RvcmUgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpXG4gICAgICBpZihkaXNhYmxlUmVzdG9yZSAhPT0gbnVsbCl7XG4gICAgICAgIHRoaXMuZWwuaW5uZXJUZXh0ID0gZGlzYWJsZVJlc3RvcmVcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFKVxuICAgICAgfVxuXG4gICAgICBsZXQgb3B0cyA9IHtkZXRhaWw6IHtyZWY6IHJlZiwgZXZlbnQ6IHBoeEV2ZW50fSwgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogZmFsc2V9XG4gICAgICB0aGlzLmVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGBwaHg6dW5kby1sb2FkaW5nOiR7dGhpcy5sb2FkaW5nUmVmfWAsIG9wdHMpKVxuICAgIH1cblxuICAgIC8vIHJlbW92ZSBjbGFzc2VzXG4gICAgUEhYX0VWRU5UX0NMQVNTRVMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGlmKG5hbWUgIT09IFwicGh4LXN1Ym1pdC1sb2FkaW5nXCIgfHwgdGhpcy5jYW5VbmRvTG9hZGluZyhyZWYpKXtcbiAgICAgICAgRE9NLnJlbW92ZUNsYXNzKHRoaXMuZWwsIG5hbWUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGlzTG9hZGluZ1VuZG9uZUJ5KHJlZil7IHJldHVybiB0aGlzLmxvYWRpbmdSZWYgPT09IG51bGwgPyBmYWxzZSA6IHRoaXMubG9hZGluZ1JlZiA8PSByZWYgfVxuICBpc0xvY2tVbmRvbmVCeShyZWYpeyByZXR1cm4gdGhpcy5sb2NrUmVmID09PSBudWxsID8gZmFsc2UgOiB0aGlzLmxvY2tSZWYgPD0gcmVmIH1cblxuICBpc0Z1bGx5UmVzb2x2ZWRCeShyZWYpe1xuICAgIHJldHVybiAodGhpcy5sb2FkaW5nUmVmID09PSBudWxsIHx8IHRoaXMubG9hZGluZ1JlZiA8PSByZWYpICYmICh0aGlzLmxvY2tSZWYgPT09IG51bGwgfHwgdGhpcy5sb2NrUmVmIDw9IHJlZilcbiAgfVxuXG4gIC8vIG9ubHkgcmVtb3ZlIHRoZSBwaHgtc3VibWl0LWxvYWRpbmcgY2xhc3MgaWYgd2UgYXJlIG5vdCBsb2NrZWRcbiAgY2FuVW5kb0xvYWRpbmcocmVmKXsgcmV0dXJuIHRoaXMubG9ja1JlZiA9PT0gbnVsbCB8fCB0aGlzLmxvY2tSZWYgPD0gcmVmIH1cbn1cbiIsICJpbXBvcnQge1xuICBtYXliZVxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRE9NUG9zdE1vcnBoUmVzdG9yZXIge1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXJCZWZvcmUsIGNvbnRhaW5lckFmdGVyLCB1cGRhdGVUeXBlKXtcbiAgICBsZXQgaWRzQmVmb3JlID0gbmV3IFNldCgpXG4gICAgbGV0IGlkc0FmdGVyID0gbmV3IFNldChbLi4uY29udGFpbmVyQWZ0ZXIuY2hpbGRyZW5dLm1hcChjaGlsZCA9PiBjaGlsZC5pZCkpXG5cbiAgICBsZXQgZWxlbWVudHNUb01vZGlmeSA9IFtdXG5cbiAgICBBcnJheS5mcm9tKGNvbnRhaW5lckJlZm9yZS5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBpZihjaGlsZC5pZCl7IC8vIGFsbCBvZiBvdXIgY2hpbGRyZW4gc2hvdWxkIGJlIGVsZW1lbnRzIHdpdGggaWRzXG4gICAgICAgIGlkc0JlZm9yZS5hZGQoY2hpbGQuaWQpXG4gICAgICAgIGlmKGlkc0FmdGVyLmhhcyhjaGlsZC5pZCkpe1xuICAgICAgICAgIGxldCBwcmV2aW91c0VsZW1lbnRJZCA9IGNoaWxkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgY2hpbGQucHJldmlvdXNFbGVtZW50U2libGluZy5pZFxuICAgICAgICAgIGVsZW1lbnRzVG9Nb2RpZnkucHVzaCh7ZWxlbWVudElkOiBjaGlsZC5pZCwgcHJldmlvdXNFbGVtZW50SWQ6IHByZXZpb3VzRWxlbWVudElkfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmNvbnRhaW5lcklkID0gY29udGFpbmVyQWZ0ZXIuaWRcbiAgICB0aGlzLnVwZGF0ZVR5cGUgPSB1cGRhdGVUeXBlXG4gICAgdGhpcy5lbGVtZW50c1RvTW9kaWZ5ID0gZWxlbWVudHNUb01vZGlmeVxuICAgIHRoaXMuZWxlbWVudElkc1RvQWRkID0gWy4uLmlkc0FmdGVyXS5maWx0ZXIoaWQgPT4gIWlkc0JlZm9yZS5oYXMoaWQpKVxuICB9XG5cbiAgLy8gV2UgZG8gdGhlIGZvbGxvd2luZyB0byBvcHRpbWl6ZSBhcHBlbmQvcHJlcGVuZCBvcGVyYXRpb25zOlxuICAvLyAgIDEpIFRyYWNrIGlkcyBvZiBtb2RpZmllZCBlbGVtZW50cyAmIG9mIG5ldyBlbGVtZW50c1xuICAvLyAgIDIpIEFsbCB0aGUgbW9kaWZpZWQgZWxlbWVudHMgYXJlIHB1dCBiYWNrIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluIHRoZSBET00gdHJlZVxuICAvLyAgICAgIGJ5IHN0b3JpbmcgdGhlIGlkIG9mIHRoZWlyIHByZXZpb3VzIHNpYmxpbmdcbiAgLy8gICAzKSBOZXcgZWxlbWVudHMgYXJlIGdvaW5nIHRvIGJlIHB1dCBpbiB0aGUgcmlnaHQgcGxhY2UgYnkgbW9ycGhkb20gZHVyaW5nIGFwcGVuZC5cbiAgLy8gICAgICBGb3IgcHJlcGVuZCwgd2UgbW92ZSB0aGVtIHRvIHRoZSBmaXJzdCBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyXG4gIHBlcmZvcm0oKXtcbiAgICBsZXQgY29udGFpbmVyID0gRE9NLmJ5SWQodGhpcy5jb250YWluZXJJZClcbiAgICB0aGlzLmVsZW1lbnRzVG9Nb2RpZnkuZm9yRWFjaChlbGVtZW50VG9Nb2RpZnkgPT4ge1xuICAgICAgaWYoZWxlbWVudFRvTW9kaWZ5LnByZXZpb3VzRWxlbWVudElkKXtcbiAgICAgICAgbWF5YmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudFRvTW9kaWZ5LnByZXZpb3VzRWxlbWVudElkKSwgcHJldmlvdXNFbGVtID0+IHtcbiAgICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkuZWxlbWVudElkKSwgZWxlbSA9PiB7XG4gICAgICAgICAgICBsZXQgaXNJblJpZ2h0UGxhY2UgPSBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmlkID09IHByZXZpb3VzRWxlbS5pZFxuICAgICAgICAgICAgaWYoIWlzSW5SaWdodFBsYWNlKXtcbiAgICAgICAgICAgICAgcHJldmlvdXNFbGVtLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIGVsZW0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGNvbnRhaW5lclxuICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkuZWxlbWVudElkKSwgZWxlbSA9PiB7XG4gICAgICAgICAgbGV0IGlzSW5SaWdodFBsYWNlID0gZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nID09IG51bGxcbiAgICAgICAgICBpZighaXNJblJpZ2h0UGxhY2Upe1xuICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIiwgZWxlbSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmKHRoaXMudXBkYXRlVHlwZSA9PSBcInByZXBlbmRcIil7XG4gICAgICB0aGlzLmVsZW1lbnRJZHNUb0FkZC5yZXZlcnNlKCkuZm9yRWFjaChlbGVtSWQgPT4ge1xuICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtSWQpLCBlbGVtID0+IGNvbnRhaW5lci5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsIGVsZW0pKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cbiIsICJ2YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuXG5mdW5jdGlvbiBtb3JwaEF0dHJzKGZyb21Ob2RlLCB0b05vZGUpIHtcbiAgICB2YXIgdG9Ob2RlQXR0cnMgPSB0b05vZGUuYXR0cmlidXRlcztcbiAgICB2YXIgYXR0cjtcbiAgICB2YXIgYXR0ck5hbWU7XG4gICAgdmFyIGF0dHJOYW1lc3BhY2VVUkk7XG4gICAgdmFyIGF0dHJWYWx1ZTtcbiAgICB2YXIgZnJvbVZhbHVlO1xuXG4gICAgLy8gZG9jdW1lbnQtZnJhZ21lbnRzIGRvbnQgaGF2ZSBhdHRyaWJ1dGVzIHNvIGxldHMgbm90IGRvIGFueXRoaW5nXG4gICAgaWYgKHRvTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBmcm9tTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBhdHRyaWJ1dGVzIG9uIG9yaWdpbmFsIERPTSBlbGVtZW50XG4gICAgZm9yICh2YXIgaSA9IHRvTm9kZUF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGF0dHIgPSB0b05vZGVBdHRyc1tpXTtcbiAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgIGF0dHJOYW1lc3BhY2VVUkkgPSBhdHRyLm5hbWVzcGFjZVVSSTtcbiAgICAgICAgYXR0clZhbHVlID0gYXR0ci52YWx1ZTtcblxuICAgICAgICBpZiAoYXR0ck5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLmxvY2FsTmFtZSB8fCBhdHRyTmFtZTtcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIucHJlZml4ID09PSAneG1sbnMnKXtcbiAgICAgICAgICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7IC8vIEl0J3Mgbm90IGFsbG93ZWQgdG8gc2V0IGFuIGF0dHJpYnV0ZSB3aXRoIHRoZSBYTUxOUyBuYW1lc3BhY2Ugd2l0aG91dCBzcGVjaWZ5aW5nIHRoZSBgeG1sbnNgIHByZWZpeFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChmcm9tVmFsdWUgIT09IGF0dHJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgZXh0cmEgYXR0cmlidXRlcyBmb3VuZCBvbiB0aGUgb3JpZ2luYWwgRE9NIGVsZW1lbnQgdGhhdFxuICAgIC8vIHdlcmVuJ3QgZm91bmQgb24gdGhlIHRhcmdldCBlbGVtZW50LlxuICAgIHZhciBmcm9tTm9kZUF0dHJzID0gZnJvbU5vZGUuYXR0cmlidXRlcztcblxuICAgIGZvciAodmFyIGQgPSBmcm9tTm9kZUF0dHJzLmxlbmd0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGF0dHIgPSBmcm9tTm9kZUF0dHJzW2RdO1xuICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuXG4gICAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubG9jYWxOYW1lIHx8IGF0dHJOYW1lO1xuXG4gICAgICAgICAgICBpZiAoIXRvTm9kZS5oYXNBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5yZW1vdmVBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRvTm9kZS5oYXNBdHRyaWJ1dGUoYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHJhbmdlOyAvLyBDcmVhdGUgYSByYW5nZSBvYmplY3QgZm9yIGVmZmljZW50bHkgcmVuZGVyaW5nIHN0cmluZ3MgdG8gZWxlbWVudHMuXG52YXIgTlNfWEhUTUwgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5cbnZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZG9jdW1lbnQ7XG52YXIgSEFTX1RFTVBMQVRFX1NVUFBPUlQgPSAhIWRvYyAmJiAnY29udGVudCcgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG52YXIgSEFTX1JBTkdFX1NVUFBPUlQgPSAhIWRvYyAmJiBkb2MuY3JlYXRlUmFuZ2UgJiYgJ2NyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCcgaW4gZG9jLmNyZWF0ZVJhbmdlKCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVRlbXBsYXRlKHN0cikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IGRvYy5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHN0cjtcbiAgICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21SYW5nZShzdHIpIHtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJhbmdlID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGUoZG9jLmJvZHkpO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudCA9IHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChzdHIpO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21XcmFwKHN0cikge1xuICAgIHZhciBmcmFnbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KCdib2R5Jyk7XG4gICAgZnJhZ21lbnQuaW5uZXJIVE1MID0gc3RyO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYWJvdXQgdGhlIHNhbWVcbiAqIHZhciBodG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdHIsICd0ZXh0L2h0bWwnKTtcbiAqIHJldHVybiBodG1sLmJvZHkuZmlyc3RDaGlsZDtcbiAqXG4gKiBAbWV0aG9kIHRvRWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiB0b0VsZW1lbnQoc3RyKSB7XG4gICAgc3RyID0gc3RyLnRyaW0oKTtcbiAgICBpZiAoSEFTX1RFTVBMQVRFX1NVUFBPUlQpIHtcbiAgICAgIC8vIGF2b2lkIHJlc3RyaWN0aW9ucyBvbiBjb250ZW50IGZvciB0aGluZ3MgbGlrZSBgPHRyPjx0aD5IaTwvdGg+PC90cj5gIHdoaWNoXG4gICAgICAvLyBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQgZG9lc24ndCBzdXBwb3J0XG4gICAgICAvLyA8dGVtcGxhdGU+IHN1cHBvcnQgbm90IGF2YWlsYWJsZSBpbiBJRVxuICAgICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVRlbXBsYXRlKHN0cik7XG4gICAgfSBlbHNlIGlmIChIQVNfUkFOR0VfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVJhbmdlKHN0cik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVdyYXAoc3RyKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdHdvIG5vZGUncyBuYW1lcyBhcmUgdGhlIHNhbWUuXG4gKlxuICogTk9URTogV2UgZG9uJ3QgYm90aGVyIGNoZWNraW5nIGBuYW1lc3BhY2VVUklgIGJlY2F1c2UgeW91IHdpbGwgbmV2ZXIgZmluZCB0d28gSFRNTCBlbGVtZW50cyB3aXRoIHRoZSBzYW1lXG4gKiAgICAgICBub2RlTmFtZSBhbmQgZGlmZmVyZW50IG5hbWVzcGFjZSBVUklzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiIFRoZSB0YXJnZXQgZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29tcGFyZU5vZGVOYW1lcyhmcm9tRWwsIHRvRWwpIHtcbiAgICB2YXIgZnJvbU5vZGVOYW1lID0gZnJvbUVsLm5vZGVOYW1lO1xuICAgIHZhciB0b05vZGVOYW1lID0gdG9FbC5ub2RlTmFtZTtcbiAgICB2YXIgZnJvbUNvZGVTdGFydCwgdG9Db2RlU3RhcnQ7XG5cbiAgICBpZiAoZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZyb21Db2RlU3RhcnQgPSBmcm9tTm9kZU5hbWUuY2hhckNvZGVBdCgwKTtcbiAgICB0b0NvZGVTdGFydCA9IHRvTm9kZU5hbWUuY2hhckNvZGVBdCgwKTtcblxuICAgIC8vIElmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIHZpcnR1YWwgRE9NIG5vZGUgb3IgU1ZHIG5vZGUgdGhlbiB3ZSBtYXlcbiAgICAvLyBuZWVkIHRvIG5vcm1hbGl6ZSB0aGUgdGFnIG5hbWUgYmVmb3JlIGNvbXBhcmluZy4gTm9ybWFsIEhUTUwgZWxlbWVudHMgdGhhdCBhcmVcbiAgICAvLyBpbiB0aGUgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCJcbiAgICAvLyBhcmUgY29udmVydGVkIHRvIHVwcGVyIGNhc2VcbiAgICBpZiAoZnJvbUNvZGVTdGFydCA8PSA5MCAmJiB0b0NvZGVTdGFydCA+PSA5NykgeyAvLyBmcm9tIGlzIHVwcGVyIGFuZCB0byBpcyBsb3dlclxuICAgICAgICByZXR1cm4gZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmICh0b0NvZGVTdGFydCA8PSA5MCAmJiBmcm9tQ29kZVN0YXJ0ID49IDk3KSB7IC8vIHRvIGlzIHVwcGVyIGFuZCBmcm9tIGlzIGxvd2VyXG4gICAgICAgIHJldHVybiB0b05vZGVOYW1lID09PSBmcm9tTm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBlbGVtZW50LCBvcHRpb25hbGx5IHdpdGggYSBrbm93biBuYW1lc3BhY2UgVVJJLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBlbGVtZW50IG5hbWUsIGUuZy4gJ2Rpdicgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZXNwYWNlVVJJXSB0aGUgZWxlbWVudCdzIG5hbWVzcGFjZSBVUkksIGkuZS4gdGhlIHZhbHVlIG9mXG4gKiBpdHMgYHhtbG5zYCBhdHRyaWJ1dGUgb3IgaXRzIGluZmVycmVkIG5hbWVzcGFjZS5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZSwgbmFtZXNwYWNlVVJJKSB7XG4gICAgcmV0dXJuICFuYW1lc3BhY2VVUkkgfHwgbmFtZXNwYWNlVVJJID09PSBOU19YSFRNTCA/XG4gICAgICAgIGRvYy5jcmVhdGVFbGVtZW50KG5hbWUpIDpcbiAgICAgICAgZG9jLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIG5hbWUpO1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgY2hpbGRyZW4gb2Ygb25lIERPTSBlbGVtZW50IHRvIGFub3RoZXIgRE9NIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gbW92ZUNoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgIHZhciBjdXJDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICB2YXIgbmV4dENoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIHRvRWwuYXBwZW5kQ2hpbGQoY3VyQ2hpbGQpO1xuICAgICAgICBjdXJDaGlsZCA9IG5leHRDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIHRvRWw7XG59XG5cbmZ1bmN0aW9uIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCBuYW1lKSB7XG4gICAgaWYgKGZyb21FbFtuYW1lXSAhPT0gdG9FbFtuYW1lXSkge1xuICAgICAgICBmcm9tRWxbbmFtZV0gPSB0b0VsW25hbWVdO1xuICAgICAgICBpZiAoZnJvbUVsW25hbWVdKSB7XG4gICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBzcGVjaWFsRWxIYW5kbGVycyA9IHtcbiAgICBPUFRJT046IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGZyb21FbC5wYXJlbnROb2RlO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudE5hbWUgPSBwYXJlbnROb2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZSA9PT0gJ09QVEdST1VQJykge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgcGFyZW50TmFtZSA9IHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudE5hbWUgPT09ICdTRUxFQ1QnICYmICFwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSkge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tRWwuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpICYmICF0b0VsLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIE1TIEVkZ2UgYnVnIHdoZXJlIHRoZSAnc2VsZWN0ZWQnIGF0dHJpYnV0ZSBjYW4gb25seSBiZVxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmVkIGlmIHNldCB0byBhIG5vbi1lbXB0eSB2YWx1ZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTIwODc2NzkvXG4gICAgICAgICAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gcmVzZXQgc2VsZWN0IGVsZW1lbnQncyBzZWxlY3RlZEluZGV4IHRvIC0xLCBvdGhlcndpc2Ugc2V0dGluZ1xuICAgICAgICAgICAgICAgIC8vIGZyb21FbC5zZWxlY3RlZCB1c2luZyB0aGUgc3luY0Jvb2xlYW5BdHRyUHJvcCBiZWxvdyBoYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgICAgIC8vIFRoZSBjb3JyZWN0IHNlbGVjdGVkSW5kZXggd2lsbCBiZSBzZXQgaW4gdGhlIFNFTEVDVCBzcGVjaWFsIGhhbmRsZXIgYmVsb3cuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdzZWxlY3RlZCcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIFwidmFsdWVcIiBhdHRyaWJ1dGUgaXMgc3BlY2lhbCBmb3IgdGhlIDxpbnB1dD4gZWxlbWVudCBzaW5jZSBpdCBzZXRzXG4gICAgICogdGhlIGluaXRpYWwgdmFsdWUuIENoYW5naW5nIHRoZSBcInZhbHVlXCIgYXR0cmlidXRlIHdpdGhvdXQgY2hhbmdpbmcgdGhlXG4gICAgICogXCJ2YWx1ZVwiIHByb3BlcnR5IHdpbGwgaGF2ZSBubyBlZmZlY3Qgc2luY2UgaXQgaXMgb25seSB1c2VkIHRvIHRoZSBzZXQgdGhlXG4gICAgICogaW5pdGlhbCB2YWx1ZS4gIFNpbWlsYXIgZm9yIHRoZSBcImNoZWNrZWRcIiBhdHRyaWJ1dGUsIGFuZCBcImRpc2FibGVkXCIuXG4gICAgICovXG4gICAgSU5QVVQ6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ2NoZWNrZWQnKTtcbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdkaXNhYmxlZCcpO1xuXG4gICAgICAgIGlmIChmcm9tRWwudmFsdWUgIT09IHRvRWwudmFsdWUpIHtcbiAgICAgICAgICAgIGZyb21FbC52YWx1ZSA9IHRvRWwudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRvRWwuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICBmcm9tRWwucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIFRFWFRBUkVBOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgICAgaWYgKGZyb21FbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGZyb21FbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIE5lZWRlZCBmb3IgSUUuIEFwcGFyZW50bHkgSUUgc2V0cyB0aGUgcGxhY2Vob2xkZXIgYXMgdGhlXG4gICAgICAgICAgICAvLyBub2RlIHZhbHVlIGFuZCB2aXNlIHZlcnNhLiBUaGlzIGlnbm9yZXMgYW4gZW1wdHkgdXBkYXRlLlxuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gZmlyc3RDaGlsZC5ub2RlVmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSA9PSBuZXdWYWx1ZSB8fCAoIW5ld1ZhbHVlICYmIG9sZFZhbHVlID09IGZyb21FbC5wbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFNFTEVDVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIGlmICghdG9FbC5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJykpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGxvb3AgdGhyb3VnaCBjaGlsZHJlbiBvZiBmcm9tRWwsIG5vdCB0b0VsIHNpbmNlIG5vZGVzIGNhbiBiZSBtb3ZlZFxuICAgICAgICAgICAgLy8gZnJvbSB0b0VsIHRvIGZyb21FbCBkaXJlY3RseSB3aGVuIG1vcnBoaW5nLlxuICAgICAgICAgICAgLy8gQXQgdGhlIHRpbWUgdGhpcyBzcGVjaWFsIGhhbmRsZXIgaXMgaW52b2tlZCwgYWxsIGNoaWxkcmVuIGhhdmUgYWxyZWFkeSBiZWVuIG1vcnBoZWRcbiAgICAgICAgICAgIC8vIGFuZCBhcHBlbmRlZCB0byAvIHJlbW92ZWQgZnJvbSBmcm9tRWwsIHNvIHVzaW5nIGZyb21FbCBoZXJlIGlzIHNhZmUgYW5kIGNvcnJlY3QuXG4gICAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBvcHRncm91cDtcbiAgICAgICAgICAgIHZhciBub2RlTmFtZTtcbiAgICAgICAgICAgIHdoaWxlKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgbm9kZU5hbWUgPSBjdXJDaGlsZC5ub2RlTmFtZSAmJiBjdXJDaGlsZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ09QVEdST1VQJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cCA9IGN1ckNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IG9wdGdyb3VwLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnT1BUSU9OJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckNoaWxkLmhhc0F0dHJpYnV0ZSgnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VyQ2hpbGQgJiYgb3B0Z3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRncm91cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZyb21FbC5zZWxlY3RlZEluZGV4ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBFTEVNRU5UX05PREUgPSAxO1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUkMSA9IDExO1xudmFyIFRFWFRfTk9ERSA9IDM7XG52YXIgQ09NTUVOVF9OT0RFID0gODtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXROb2RlS2V5KG5vZGUpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpKSB8fCBub2RlLmlkO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vcnBoZG9tRmFjdG9yeShtb3JwaEF0dHJzKSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIG1vcnBoZG9tKGZyb21Ob2RlLCB0b05vZGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRvTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudCcgfHwgZnJvbU5vZGUubm9kZU5hbWUgPT09ICdIVE1MJyB8fCBmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIHZhciB0b05vZGVIdG1sID0gdG9Ob2RlO1xuICAgICAgICB0b05vZGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnaHRtbCcpO1xuICAgICAgICB0b05vZGUuaW5uZXJIVE1MID0gdG9Ob2RlSHRtbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvTm9kZSA9IHRvRWxlbWVudCh0b05vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9Ob2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFJDEpIHtcbiAgICAgIHRvTm9kZSA9IHRvTm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICB9XG5cbiAgICB2YXIgZ2V0Tm9kZUtleSA9IG9wdGlvbnMuZ2V0Tm9kZUtleSB8fCBkZWZhdWx0R2V0Tm9kZUtleTtcbiAgICB2YXIgb25CZWZvcmVOb2RlQWRkZWQgPSBvcHRpb25zLm9uQmVmb3JlTm9kZUFkZGVkIHx8IG5vb3A7XG4gICAgdmFyIG9uTm9kZUFkZGVkID0gb3B0aW9ucy5vbk5vZGVBZGRlZCB8fCBub29wO1xuICAgIHZhciBvbkJlZm9yZUVsVXBkYXRlZCA9IG9wdGlvbnMub25CZWZvcmVFbFVwZGF0ZWQgfHwgbm9vcDtcbiAgICB2YXIgb25FbFVwZGF0ZWQgPSBvcHRpb25zLm9uRWxVcGRhdGVkIHx8IG5vb3A7XG4gICAgdmFyIG9uQmVmb3JlTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgdmFyIG9uTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25Ob2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgdmFyIG9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQgPSBvcHRpb25zLm9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQgfHwgbm9vcDtcbiAgICB2YXIgc2tpcEZyb21DaGlsZHJlbiA9IG9wdGlvbnMuc2tpcEZyb21DaGlsZHJlbiB8fCBub29wO1xuICAgIHZhciBhZGRDaGlsZCA9IG9wdGlvbnMuYWRkQ2hpbGQgfHwgZnVuY3Rpb24ocGFyZW50LCBjaGlsZCl7IHJldHVybiBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpOyB9O1xuICAgIHZhciBjaGlsZHJlbk9ubHkgPSBvcHRpb25zLmNoaWxkcmVuT25seSA9PT0gdHJ1ZTtcblxuICAgIC8vIFRoaXMgb2JqZWN0IGlzIHVzZWQgYXMgYSBsb29rdXAgdG8gcXVpY2tseSBmaW5kIGFsbCBrZXllZCBlbGVtZW50cyBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuXG4gICAgdmFyIGZyb21Ob2Rlc0xvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleWVkUmVtb3ZhbExpc3QgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGFkZEtleWVkUmVtb3ZhbChrZXkpIHtcbiAgICAgIGtleWVkUmVtb3ZhbExpc3QucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKG5vZGUsIHNraXBLZXllZE5vZGVzKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG5cbiAgICAgICAgICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKHNraXBLZXllZE5vZGVzICYmIChrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBza2lwcGluZyBrZXllZCBub2RlcyB0aGVuIHdlIGFkZCB0aGUga2V5XG4gICAgICAgICAgICAvLyB0byBhIGxpc3Qgc28gdGhhdCBpdCBjYW4gYmUgaGFuZGxlZCBhdCB0aGUgdmVyeSBlbmQuXG4gICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoa2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT25seSByZXBvcnQgdGhlIG5vZGUgYXMgZGlzY2FyZGVkIGlmIGl0IGlzIG5vdCBrZXllZC4gV2UgZG8gdGhpcyBiZWNhdXNlXG4gICAgICAgICAgICAvLyBhdCB0aGUgZW5kIHdlIGxvb3AgdGhyb3VnaCBhbGwga2V5ZWQgZWxlbWVudHMgdGhhdCB3ZXJlIHVubWF0Y2hlZFxuICAgICAgICAgICAgLy8gYW5kIHRoZW4gZGlzY2FyZCB0aGVtIGluIG9uZSBmaW5hbCBwYXNzLlxuICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGN1ckNoaWxkKTtcbiAgICAgICAgICAgIGlmIChjdXJDaGlsZC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKGN1ckNoaWxkLCBza2lwS2V5ZWROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogUmVtb3ZlcyBhIERPTSBub2RlIG91dCBvZiB0aGUgb3JpZ2luYWwgRE9NXG4gICAgKlxuICAgICogQHBhcmFtICB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcbiAgICAqIEBwYXJhbSAge05vZGV9IHBhcmVudE5vZGUgVGhlIG5vZGVzIHBhcmVudFxuICAgICogQHBhcmFtICB7Qm9vbGVhbn0gc2tpcEtleWVkTm9kZXMgSWYgdHJ1ZSB0aGVuIGVsZW1lbnRzIHdpdGgga2V5cyB3aWxsIGJlIHNraXBwZWQgYW5kIG5vdCBkaXNjYXJkZWQuXG4gICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUsIHBhcmVudE5vZGUsIHNraXBLZXllZE5vZGVzKSB7XG4gICAgICBpZiAob25CZWZvcmVOb2RlRGlzY2FyZGVkKG5vZGUpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIG9uTm9kZURpc2NhcmRlZChub2RlKTtcbiAgICAgIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKG5vZGUsIHNraXBLZXllZE5vZGVzKTtcbiAgICB9XG5cbiAgICAvLyAvLyBUcmVlV2Fsa2VyIGltcGxlbWVudGF0aW9uIGlzIG5vIGZhc3RlciwgYnV0IGtlZXBpbmcgdGhpcyBhcm91bmQgaW4gY2FzZSB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZVxuICAgIC8vIGZ1bmN0aW9uIGluZGV4VHJlZShyb290KSB7XG4gICAgLy8gICAgIHZhciB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcbiAgICAvLyAgICAgICAgIHJvb3QsXG4gICAgLy8gICAgICAgICBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCk7XG4gICAgLy9cbiAgICAvLyAgICAgdmFyIGVsO1xuICAgIC8vICAgICB3aGlsZSgoZWwgPSB0cmVlV2Fsa2VyLm5leHROb2RlKCkpKSB7XG4gICAgLy8gICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShlbCk7XG4gICAgLy8gICAgICAgICBpZiAoa2V5KSB7XG4gICAgLy8gICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBlbDtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfVxuICAgIC8vIH1cblxuICAgIC8vIC8vIE5vZGVJdGVyYXRvciBpbXBsZW1lbnRhdGlvbiBpcyBubyBmYXN0ZXIsIGJ1dCBrZWVwaW5nIHRoaXMgYXJvdW5kIGluIGNhc2UgdGhpcyBjaGFuZ2VzIGluIHRoZSBmdXR1cmVcbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uIGluZGV4VHJlZShub2RlKSB7XG4gICAgLy8gICAgIHZhciBub2RlSXRlcmF0b3IgPSBkb2N1bWVudC5jcmVhdGVOb2RlSXRlcmF0b3Iobm9kZSwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQpO1xuICAgIC8vICAgICB2YXIgZWw7XG4gICAgLy8gICAgIHdoaWxlKChlbCA9IG5vZGVJdGVyYXRvci5uZXh0Tm9kZSgpKSkge1xuICAgIC8vICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoZWwpO1xuICAgIC8vICAgICAgICAgaWYgKGtleSkge1xuICAgIC8vICAgICAgICAgICAgIGZyb21Ob2Rlc0xvb2t1cFtrZXldID0gZWw7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG5cbiAgICBmdW5jdGlvbiBpbmRleFRyZWUobm9kZSkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFJDEpIHtcbiAgICAgICAgdmFyIGN1ckNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCk7XG4gICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBjdXJDaGlsZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXYWxrIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgaW5kZXhUcmVlKGN1ckNoaWxkKTtcblxuICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRleFRyZWUoZnJvbU5vZGUpO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlTm9kZUFkZGVkKGVsKSB7XG4gICAgICBvbk5vZGVBZGRlZChlbCk7XG5cbiAgICAgIHZhciBjdXJDaGlsZCA9IGVsLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgdmFyIHVubWF0Y2hlZEZyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtrZXldO1xuICAgICAgICAgIC8vIGlmIHdlIGZpbmQgYSBkdXBsaWNhdGUgI2lkIG5vZGUgaW4gY2FjaGUsIHJlcGxhY2UgYGVsYCB3aXRoIGNhY2hlIHZhbHVlXG4gICAgICAgICAgLy8gYW5kIG1vcnBoIGl0IHRvIHRoZSBjaGlsZCBub2RlLlxuICAgICAgICAgIGlmICh1bm1hdGNoZWRGcm9tRWwgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJDaGlsZCwgdW5tYXRjaGVkRnJvbUVsKSkge1xuICAgICAgICAgICAgY3VyQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodW5tYXRjaGVkRnJvbUVsLCBjdXJDaGlsZCk7XG4gICAgICAgICAgICBtb3JwaEVsKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBjYWxsIGZvciBjdXJDaGlsZCBhbmQgaXQncyBjaGlsZHJlbiB0byBzZWUgaWYgd2UgZmluZCBzb21ldGhpbmcgaW5cbiAgICAgICAgICAvLyBmcm9tTm9kZXNMb29rdXBcbiAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyQ2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VyQ2hpbGQgPSBuZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwRnJvbUVsKGZyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCwgY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBvZiB0aGUgXCJ0byBub2Rlc1wiLiBJZiBjdXJGcm9tTm9kZUNoaWxkIGlzXG4gICAgICAvLyBub24tbnVsbCB0aGVuIHdlIHN0aWxsIGhhdmUgc29tZSBmcm9tIG5vZGVzIGxlZnQgb3ZlciB0aGF0IG5lZWRcbiAgICAgIC8vIHRvIGJlIHJlbW92ZWRcbiAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgIHZhciBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoKGN1ckZyb21Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJGcm9tTm9kZUNoaWxkKSkpIHtcbiAgICAgICAgICAvLyBTaW5jZSB0aGUgbm9kZSBpcyBrZXllZCBpdCBtaWdodCBiZSBtYXRjaGVkIHVwIGxhdGVyIHNvIHdlIGRlZmVyXG4gICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOT1RFOiB3ZSBza2lwIG5lc3RlZCBrZXllZCBub2RlcyBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgdGhlcmUgaXNcbiAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9ycGhFbChmcm9tRWwsIHRvRWwsIGNoaWxkcmVuT25seSkge1xuICAgICAgdmFyIHRvRWxLZXkgPSBnZXROb2RlS2V5KHRvRWwpO1xuXG4gICAgICBpZiAodG9FbEtleSkge1xuICAgICAgICAvLyBJZiBhbiBlbGVtZW50IHdpdGggYW4gSUQgaXMgYmVpbmcgbW9ycGhlZCB0aGVuIGl0IHdpbGwgYmUgaW4gdGhlIGZpbmFsXG4gICAgICAgIC8vIERPTSBzbyBjbGVhciBpdCBvdXQgb2YgdGhlIHNhdmVkIGVsZW1lbnRzIGNvbGxlY3Rpb25cbiAgICAgICAgZGVsZXRlIGZyb21Ob2Rlc0xvb2t1cFt0b0VsS2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjaGlsZHJlbk9ubHkpIHtcbiAgICAgICAgLy8gb3B0aW9uYWxcbiAgICAgICAgdmFyIGJlZm9yZVVwZGF0ZVJlc3VsdCA9IG9uQmVmb3JlRWxVcGRhdGVkKGZyb21FbCwgdG9FbCk7XG4gICAgICAgIGlmIChiZWZvcmVVcGRhdGVSZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGJlZm9yZVVwZGF0ZVJlc3VsdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgZnJvbUVsID0gYmVmb3JlVXBkYXRlUmVzdWx0O1xuICAgICAgICAgIC8vIHJlaW5kZXggdGhlIG5ldyBmcm9tRWwgaW4gY2FzZSBpdCdzIG5vdCBpbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIHRyZWUgYXMgdGhlIG9yaWdpbmFsIGZyb21FbFxuICAgICAgICAgIC8vIChQaG9lbml4IExpdmVWaWV3IHNvbWV0aW1lcyByZXR1cm5zIGEgY2xvbmVkIHRyZWUsXG4gICAgICAgICAgLy8gIGJ1dCBrZXllZCBsb29rdXBzIHdvdWxkIHN0aWxsIHBvaW50IHRvIHRoZSBvcmlnaW5hbCB0cmVlKVxuICAgICAgICAgIGluZGV4VHJlZShmcm9tRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIGF0dHJpYnV0ZXMgb24gb3JpZ2luYWwgRE9NIGVsZW1lbnQgZmlyc3RcbiAgICAgICAgbW9ycGhBdHRycyhmcm9tRWwsIHRvRWwpO1xuICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICBvbkVsVXBkYXRlZChmcm9tRWwpO1xuXG4gICAgICAgIGlmIChvbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkKGZyb21FbCwgdG9FbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmcm9tRWwubm9kZU5hbWUgIT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgbW9ycGhDaGlsZHJlbihmcm9tRWwsIHRvRWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BlY2lhbEVsSGFuZGxlcnMuVEVYVEFSRUEoZnJvbUVsLCB0b0VsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3JwaENoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgICAgdmFyIHNraXBGcm9tID0gc2tpcEZyb21DaGlsZHJlbihmcm9tRWwsIHRvRWwpO1xuICAgICAgdmFyIGN1clRvTm9kZUNoaWxkID0gdG9FbC5maXJzdENoaWxkO1xuICAgICAgdmFyIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgIHZhciBjdXJUb05vZGVLZXk7XG4gICAgICB2YXIgY3VyRnJvbU5vZGVLZXk7XG5cbiAgICAgIHZhciBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICB2YXIgdG9OZXh0U2libGluZztcbiAgICAgIHZhciBtYXRjaGluZ0Zyb21FbDtcblxuICAgICAgLy8gd2FsayB0aGUgY2hpbGRyZW5cbiAgICAgIG91dGVyOiB3aGlsZSAoY3VyVG9Ob2RlQ2hpbGQpIHtcbiAgICAgICAgdG9OZXh0U2libGluZyA9IGN1clRvTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICBjdXJUb05vZGVLZXkgPSBnZXROb2RlS2V5KGN1clRvTm9kZUNoaWxkKTtcblxuICAgICAgICAvLyB3YWxrIHRoZSBmcm9tTm9kZSBjaGlsZHJlbiBhbGwgdGhlIHdheSB0aHJvdWdoXG4gICAgICAgIHdoaWxlICghc2tpcEZyb20gJiYgY3VyRnJvbU5vZGVDaGlsZCkge1xuICAgICAgICAgIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICBpZiAoY3VyVG9Ob2RlQ2hpbGQuaXNTYW1lTm9kZSAmJiBjdXJUb05vZGVDaGlsZC5pc1NhbWVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQpKSB7XG4gICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgdmFyIGN1ckZyb21Ob2RlVHlwZSA9IGN1ckZyb21Ob2RlQ2hpbGQubm9kZVR5cGU7XG5cbiAgICAgICAgICAvLyB0aGlzIG1lYW5zIGlmIHRoZSBjdXJGcm9tTm9kZUNoaWxkIGRvZXNudCBoYXZlIGEgbWF0Y2ggd2l0aCB0aGUgY3VyVG9Ob2RlQ2hpbGRcbiAgICAgICAgICB2YXIgaXNDb21wYXRpYmxlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gY3VyVG9Ob2RlQ2hpbGQubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAvLyBCb3RoIG5vZGVzIGJlaW5nIGNvbXBhcmVkIGFyZSBFbGVtZW50IG5vZGVzXG5cbiAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUtleSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgbm9kZSBoYXMgYSBrZXkgc28gd2Ugd2FudCB0byBtYXRjaCBpdCB1cCB3aXRoIHRoZSBjb3JyZWN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWVcbiAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5ICE9PSBjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgZWxlbWVudCBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUgZG9lcyBub3QgaGF2ZSBhIG1hdGNoaW5nIGtleSBzb1xuICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgY2hlY2sgb3VyIGxvb2t1cCB0byBzZWUgaWYgdGhlcmUgaXMgYSBtYXRjaGluZyBlbGVtZW50IGluIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgLy8gRE9NIHRyZWVcbiAgICAgICAgICAgICAgICAgIGlmICgobWF0Y2hpbmdGcm9tRWwgPSBmcm9tTm9kZXNMb29rdXBbY3VyVG9Ob2RlS2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21OZXh0U2libGluZyA9PT0gbWF0Y2hpbmdGcm9tRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHNpbmdsZSBlbGVtZW50IHJlbW92YWxzLiBUbyBhdm9pZCByZW1vdmluZyB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBET00gbm9kZSBvdXQgb2YgdGhlIHRyZWUgKHNpbmNlIHRoYXQgY2FuIGJyZWFrIENTUyB0cmFuc2l0aW9ucywgZXRjLiksXG4gICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCBpbnN0ZWFkIGRpc2NhcmQgdGhlIGN1cnJlbnQgbm9kZSBhbmQgd2FpdCB1bnRpbCB0aGUgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGlvbiB0byBwcm9wZXJseSBtYXRjaCB1cCB0aGUga2V5ZWQgdGFyZ2V0IGVsZW1lbnQgd2l0aCBpdHMgbWF0Y2hpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBtYXRjaGluZyBrZXllZCBlbGVtZW50IHNvbWV3aGVyZSBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gTGV0J3MgbW92ZSB0aGUgb3JpZ2luYWwgRE9NIG5vZGUgaW50byB0aGUgY3VycmVudCBwb3NpdGlvbiBhbmQgbW9ycGhcbiAgICAgICAgICAgICAgICAgICAgICAvLyBpdC5cblxuICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFdlIHVzZSBpbnNlcnRCZWZvcmUgaW5zdGVhZCBvZiByZXBsYWNlQ2hpbGQgYmVjYXVzZSB3ZSB3YW50IHRvIGdvIHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYHJlbW92ZU5vZGUoKWAgZnVuY3Rpb24gZm9yIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgZGlzY2FyZGVkIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgbGlmZWN5Y2xlIGhvb2tzIGFyZSBjb3JyZWN0bHkgaW52b2tlZFxuICAgICAgICAgICAgICAgICAgICAgIGZyb21FbC5pbnNlcnRCZWZvcmUobWF0Y2hpbmdGcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBza2lwIG5lc3RlZCBrZXllZCBub2RlcyBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgdGhlcmUgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSAvKiBza2lwIGtleWVkIG5vZGVzICovKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gbWF0Y2hpbmdGcm9tRWw7XG4gICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbm9kZXMgYXJlIG5vdCBjb21wYXRpYmxlIHNpbmNlIHRoZSBcInRvXCIgbm9kZSBoYXMgYSBrZXkgYW5kIHRoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vIG1hdGNoaW5nIGtleWVkIG5vZGUgaW4gdGhlIHNvdXJjZSB0cmVlXG4gICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvcmlnaW5hbCBoYXMgYSBrZXlcbiAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGlzQ29tcGF0aWJsZSAhPT0gZmFsc2UgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJGcm9tTm9kZUNoaWxkLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBjb21wYXRpYmxlIERPTSBlbGVtZW50cyBzbyB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBcImZyb21cIiBub2RlIHRvIG1hdGNoIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IERPTSBub2RlLlxuICAgICAgICAgICAgICAgIC8vIE1PUlBIXG4gICAgICAgICAgICAgICAgbW9ycGhFbChjdXJGcm9tTm9kZUNoaWxkLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IFRFWFRfTk9ERSB8fCBjdXJGcm9tTm9kZVR5cGUgPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIC8vIEJvdGggbm9kZXMgYmVpbmcgY29tcGFyZWQgYXJlIFRleHQgb3IgQ29tbWVudCBub2Rlc1xuICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBTaW1wbHkgdXBkYXRlIG5vZGVWYWx1ZSBvbiB0aGUgb3JpZ2luYWwgbm9kZSB0b1xuICAgICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIHRleHQgdmFsdWVcbiAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlQ2hpbGQubm9kZVZhbHVlICE9PSBjdXJUb05vZGVDaGlsZC5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkLm5vZGVWYWx1ZSA9IGN1clRvTm9kZUNoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgLy8gQWR2YW5jZSBib3RoIHRoZSBcInRvXCIgY2hpbGQgYW5kIHRoZSBcImZyb21cIiBjaGlsZCBzaW5jZSB3ZSBmb3VuZCBhIG1hdGNoXG4gICAgICAgICAgICAvLyBOb3RoaW5nIGVsc2UgdG8gZG8gYXMgd2UgYWxyZWFkeSByZWN1cnNpdmVseSBjYWxsZWQgbW9ycGhDaGlsZHJlbiBhYm92ZVxuICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE5vIGNvbXBhdGlibGUgbWF0Y2ggc28gcmVtb3ZlIHRoZSBvbGQgbm9kZSBmcm9tIHRoZSBET00gYW5kIGNvbnRpbnVlIHRyeWluZyB0byBmaW5kIGFcbiAgICAgICAgICAvLyBtYXRjaCBpbiB0aGUgb3JpZ2luYWwgRE9NLiBIb3dldmVyLCB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIGZyb20gbm9kZSBpcyBub3Qga2V5ZWRcbiAgICAgICAgICAvLyBzaW5jZSBpdCBpcyBwb3NzaWJsZSB0aGF0IGEga2V5ZWQgbm9kZSBtaWdodCBtYXRjaCB1cCB3aXRoIGEgbm9kZSBzb21ld2hlcmUgZWxzZSBpbiB0aGVcbiAgICAgICAgICAvLyB0YXJnZXQgdHJlZSBhbmQgd2UgZG9uJ3Qgd2FudCB0byBkaXNjYXJkIGl0IGp1c3QgeWV0IHNpbmNlIGl0IHN0aWxsIG1pZ2h0IGZpbmQgYVxuICAgICAgICAgIC8vIGhvbWUgaW4gdGhlIGZpbmFsIERPTSB0cmVlLiBBZnRlciBldmVyeXRoaW5nIGlzIGRvbmUgd2Ugd2lsbCByZW1vdmUgYW55IGtleWVkIG5vZGVzXG4gICAgICAgICAgLy8gdGhhdCBkaWRuJ3QgZmluZCBhIGhvbWVcbiAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgcmVtb3ZhbCB0byBsYXRlclxuICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgfSAvLyBFTkQ6IHdoaWxlKGN1ckZyb21Ob2RlQ2hpbGQpIHt9XG5cbiAgICAgICAgLy8gSWYgd2UgZ290IHRoaXMgZmFyIHRoZW4gd2UgZGlkIG5vdCBmaW5kIGEgY2FuZGlkYXRlIG1hdGNoIGZvclxuICAgICAgICAvLyBvdXIgXCJ0byBub2RlXCIgYW5kIHdlIGV4aGF1c3RlZCBhbGwgb2YgdGhlIGNoaWxkcmVuIFwiZnJvbVwiXG4gICAgICAgIC8vIG5vZGVzLiBUaGVyZWZvcmUsIHdlIHdpbGwganVzdCBhcHBlbmQgdGhlIGN1cnJlbnQgXCJ0b1wiIG5vZGVcbiAgICAgICAgLy8gdG8gdGhlIGVuZFxuICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5ICYmIChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSAmJiBjb21wYXJlTm9kZU5hbWVzKG1hdGNoaW5nRnJvbUVsLCBjdXJUb05vZGVDaGlsZCkpIHtcbiAgICAgICAgICAvLyBNT1JQSFxuICAgICAgICAgIGlmKCFza2lwRnJvbSl7IGFkZENoaWxkKGZyb21FbCwgbWF0Y2hpbmdGcm9tRWwpOyB9XG4gICAgICAgICAgbW9ycGhFbChtYXRjaGluZ0Zyb21FbCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCA9IG9uQmVmb3JlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICBpZiAob25CZWZvcmVOb2RlQWRkZWRSZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlQWRkZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1clRvTm9kZUNoaWxkLmFjdHVhbGl6ZSkge1xuICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IGN1clRvTm9kZUNoaWxkLmFjdHVhbGl6ZShmcm9tRWwub3duZXJEb2N1bWVudCB8fCBkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkQ2hpbGQoZnJvbUVsLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgIH1cblxuICAgICAgY2xlYW51cEZyb21FbChmcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQsIGN1ckZyb21Ob2RlS2V5KTtcblxuICAgICAgdmFyIHNwZWNpYWxFbEhhbmRsZXIgPSBzcGVjaWFsRWxIYW5kbGVyc1tmcm9tRWwubm9kZU5hbWVdO1xuICAgICAgaWYgKHNwZWNpYWxFbEhhbmRsZXIpIHtcbiAgICAgICAgc3BlY2lhbEVsSGFuZGxlcihmcm9tRWwsIHRvRWwpO1xuICAgICAgfVxuICAgIH0gLy8gRU5EOiBtb3JwaENoaWxkcmVuKC4uLilcblxuICAgIHZhciBtb3JwaGVkTm9kZSA9IGZyb21Ob2RlO1xuICAgIHZhciBtb3JwaGVkTm9kZVR5cGUgPSBtb3JwaGVkTm9kZS5ub2RlVHlwZTtcbiAgICB2YXIgdG9Ob2RlVHlwZSA9IHRvTm9kZS5ub2RlVHlwZTtcblxuICAgIGlmICghY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgYXJlIGdpdmVuIHR3byBET00gbm9kZXMgdGhhdCBhcmUgbm90XG4gICAgICAvLyBjb21wYXRpYmxlIChlLmcuIDxkaXY+IC0tPiA8c3Bhbj4gb3IgPGRpdj4gLS0+IFRFWFQpXG4gICAgICBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIGlmICghY29tcGFyZU5vZGVOYW1lcyhmcm9tTm9kZSwgdG9Ob2RlKSkge1xuICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICAgICAgICAgIG1vcnBoZWROb2RlID0gbW92ZUNoaWxkcmVuKGZyb21Ob2RlLCBjcmVhdGVFbGVtZW50TlModG9Ob2RlLm5vZGVOYW1lLCB0b05vZGUubmFtZXNwYWNlVVJJKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEdvaW5nIGZyb20gYW4gZWxlbWVudCBub2RlIHRvIGEgdGV4dCBub2RlXG4gICAgICAgICAgbW9ycGhlZE5vZGUgPSB0b05vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBURVhUX05PREUgfHwgbW9ycGhlZE5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHsgLy8gVGV4dCBvciBjb21tZW50IG5vZGVcbiAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT09IG1vcnBoZWROb2RlVHlwZSkge1xuICAgICAgICAgIGlmIChtb3JwaGVkTm9kZS5ub2RlVmFsdWUgIT09IHRvTm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIG1vcnBoZWROb2RlLm5vZGVWYWx1ZSA9IHRvTm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRleHQgbm9kZSB0byBzb21ldGhpbmcgZWxzZVxuICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vcnBoZWROb2RlID09PSB0b05vZGUpIHtcbiAgICAgIC8vIFRoZSBcInRvIG5vZGVcIiB3YXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgXCJmcm9tIG5vZGVcIiBzbyB3ZSBoYWQgdG9cbiAgICAgIC8vIHRvc3Mgb3V0IHRoZSBcImZyb20gbm9kZVwiIGFuZCB1c2UgdGhlIFwidG8gbm9kZVwiXG4gICAgICBvbk5vZGVEaXNjYXJkZWQoZnJvbU5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodG9Ob2RlLmlzU2FtZU5vZGUgJiYgdG9Ob2RlLmlzU2FtZU5vZGUobW9ycGhlZE5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbW9ycGhFbChtb3JwaGVkTm9kZSwgdG9Ob2RlLCBjaGlsZHJlbk9ubHkpO1xuXG4gICAgICAvLyBXZSBub3cgbmVlZCB0byBsb29wIG92ZXIgYW55IGtleWVkIG5vZGVzIHRoYXQgbWlnaHQgbmVlZCB0byBiZVxuICAgICAgLy8gcmVtb3ZlZC4gV2Ugb25seSBkbyB0aGUgcmVtb3ZhbCBpZiB3ZSBrbm93IHRoYXQgdGhlIGtleWVkIG5vZGVcbiAgICAgIC8vIG5ldmVyIGZvdW5kIGEgbWF0Y2guIFdoZW4gYSBrZXllZCBub2RlIGlzIG1hdGNoZWQgdXAgd2UgcmVtb3ZlXG4gICAgICAvLyBpdCBvdXQgb2YgZnJvbU5vZGVzTG9va3VwIGFuZCB3ZSB1c2UgZnJvbU5vZGVzTG9va3VwIHRvIGRldGVybWluZVxuICAgICAgLy8gaWYgYSBrZXllZCBub2RlIGhhcyBiZWVuIG1hdGNoZWQgdXAgb3Igbm90XG4gICAgICBpZiAoa2V5ZWRSZW1vdmFsTGlzdCkge1xuICAgICAgICBmb3IgKHZhciBpPTAsIGxlbj1rZXllZFJlbW92YWxMaXN0Lmxlbmd0aDsgaTxsZW47IGkrKykge1xuICAgICAgICAgIHZhciBlbFRvUmVtb3ZlID0gZnJvbU5vZGVzTG9va3VwW2tleWVkUmVtb3ZhbExpc3RbaV1dO1xuICAgICAgICAgIGlmIChlbFRvUmVtb3ZlKSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlKGVsVG9SZW1vdmUsIGVsVG9SZW1vdmUucGFyZW50Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2hpbGRyZW5Pbmx5ICYmIG1vcnBoZWROb2RlICE9PSBmcm9tTm9kZSAmJiBmcm9tTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAobW9ycGhlZE5vZGUuYWN0dWFsaXplKSB7XG4gICAgICAgIG1vcnBoZWROb2RlID0gbW9ycGhlZE5vZGUuYWN0dWFsaXplKGZyb21Ob2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGhhZCB0byBzd2FwIG91dCB0aGUgZnJvbSBub2RlIHdpdGggYSBuZXcgbm9kZSBiZWNhdXNlIHRoZSBvbGRcbiAgICAgIC8vIG5vZGUgd2FzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIHRhcmdldCBub2RlIHRoZW4gd2UgbmVlZCB0b1xuICAgICAgLy8gcmVwbGFjZSB0aGUgb2xkIERPTSBub2RlIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS4gVGhpcyBpcyBvbmx5XG4gICAgICAvLyBwb3NzaWJsZSBpZiB0aGUgb3JpZ2luYWwgRE9NIG5vZGUgd2FzIHBhcnQgb2YgYSBET00gdHJlZSB3aGljaFxuICAgICAgLy8gd2Uga25vdyBpcyB0aGUgY2FzZSBpZiBpdCBoYXMgYSBwYXJlbnQgbm9kZS5cbiAgICAgIGZyb21Ob2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG1vcnBoZWROb2RlLCBmcm9tTm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICB9O1xufVxuXG52YXIgbW9ycGhkb20gPSBtb3JwaGRvbUZhY3RvcnkobW9ycGhBdHRycyk7XG5cbmV4cG9ydCBkZWZhdWx0IG1vcnBoZG9tO1xuIiwgImltcG9ydCB7XG4gIFBIWF9DT01QT05FTlQsXG4gIFBIWF9QUlVORSxcbiAgUEhYX1JPT1RfSUQsXG4gIFBIWF9TRVNTSU9OLFxuICBQSFhfU0tJUCxcbiAgUEhYX01BR0lDX0lELFxuICBQSFhfU1RBVElDLFxuICBQSFhfVFJJR0dFUl9BQ1RJT04sXG4gIFBIWF9VUERBVEUsXG4gIFBIWF9SRUZfU1JDLFxuICBQSFhfUkVGX0xPQ0ssXG4gIFBIWF9TVFJFQU0sXG4gIFBIWF9TVFJFQU1fUkVGLFxuICBQSFhfVklFV1BPUlRfVE9QLFxuICBQSFhfVklFV1BPUlRfQk9UVE9NLFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBkZXRlY3REdXBsaWNhdGVJZHMsXG4gIGlzQ2lkXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IERPTVBvc3RNb3JwaFJlc3RvcmVyIGZyb20gXCIuL2RvbV9wb3N0X21vcnBoX3Jlc3RvcmVyXCJcbmltcG9ydCBtb3JwaGRvbSBmcm9tIFwibW9ycGhkb21cIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET01QYXRjaCB7XG4gIHN0YXRpYyBwYXRjaFdpdGhDbG9uZWRUcmVlKGNvbnRhaW5lciwgY2xvbmVkVHJlZSwgbGl2ZVNvY2tldCl7XG4gICAgbGV0IGZvY3VzZWQgPSBsaXZlU29ja2V0LmdldEFjdGl2ZUVsZW1lbnQoKVxuICAgIGxldCB7c2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZH0gPSBmb2N1c2VkICYmIERPTS5oYXNTZWxlY3Rpb25SYW5nZShmb2N1c2VkKSA/IGZvY3VzZWQgOiB7fVxuICAgIGxldCBwaHhVcGRhdGUgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX1VQREFURSlcbiAgICBsZXQgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkID0gbnVsbFxuXG4gICAgbW9ycGhkb20oY29udGFpbmVyLCBjbG9uZWRUcmVlLCB7XG4gICAgICBjaGlsZHJlbk9ubHk6IGZhbHNlLFxuICAgICAgb25CZWZvcmVFbFVwZGF0ZWQ6IChmcm9tRWwsIHRvRWwpID0+IHtcbiAgICAgICAgRE9NLnN5bmNQZW5kaW5nQXR0cnMoZnJvbUVsLCB0b0VsKVxuICAgICAgICAvLyB3ZSBjYW5ub3QgbW9ycGggbG9ja2VkIGNoaWxkcmVuXG4gICAgICAgIGlmKCFjb250YWluZXIuaXNTYW1lTm9kZShmcm9tRWwpICYmIGZyb21FbC5oYXNBdHRyaWJ1dGUoUEhYX1JFRl9MT0NLKSl7IHJldHVybiBmYWxzZSB9XG4gICAgICAgIGlmKERPTS5pc0lnbm9yZWQoZnJvbUVsLCBwaHhVcGRhdGUpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgaWYoZm9jdXNlZCAmJiBmb2N1c2VkLmlzU2FtZU5vZGUoZnJvbUVsKSAmJiBET00uaXNGb3JtSW5wdXQoZnJvbUVsKSl7XG4gICAgICAgICAgRE9NLm1lcmdlRm9jdXNlZElucHV0KGZyb21FbCwgdG9FbClcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBpZihET00uaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKHRvRWwsIGxpdmVTb2NrZXQuYmluZGluZyhQSFhfVFJJR0dFUl9BQ1RJT04pKSl7XG4gICAgICAgICAgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkID0gdG9FbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmKGV4dGVybmFsRm9ybVRyaWdnZXJlZCl7XG4gICAgICBsaXZlU29ja2V0LnVubG9hZCgpXG4gICAgICAvLyB1c2UgcHJvdG90eXBlJ3Mgc3VibWl0IGluIGNhc2UgdGhlcmUncyBhIGZvcm0gY29udHJvbCB3aXRoIG5hbWUgb3IgaWQgb2YgXCJzdWJtaXRcIlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxGb3JtRWxlbWVudC9zdWJtaXRcbiAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihleHRlcm5hbEZvcm1UcmlnZ2VyZWQpLnN1Ym1pdC5jYWxsKGV4dGVybmFsRm9ybVRyaWdnZXJlZClcbiAgICB9XG5cbiAgICBsaXZlU29ja2V0LnNpbGVuY2VFdmVudHMoKCkgPT4gRE9NLnJlc3RvcmVGb2N1cyhmb2N1c2VkLCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSlcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHZpZXcsIGNvbnRhaW5lciwgaWQsIGh0bWwsIHN0cmVhbXMsIHRhcmdldENJRCl7XG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMubGl2ZVNvY2tldCA9IHZpZXcubGl2ZVNvY2tldFxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyXG4gICAgdGhpcy5pZCA9IGlkXG4gICAgdGhpcy5yb290SUQgPSB2aWV3LnJvb3QuaWRcbiAgICB0aGlzLmh0bWwgPSBodG1sXG4gICAgdGhpcy5zdHJlYW1zID0gc3RyZWFtc1xuICAgIHRoaXMuc3RyZWFtSW5zZXJ0cyA9IHt9XG4gICAgdGhpcy5zdHJlYW1Db21wb25lbnRSZXN0b3JlID0ge31cbiAgICB0aGlzLnRhcmdldENJRCA9IHRhcmdldENJRFxuICAgIHRoaXMuY2lkUGF0Y2ggPSBpc0NpZCh0aGlzLnRhcmdldENJRClcbiAgICB0aGlzLnBlbmRpbmdSZW1vdmVzID0gW11cbiAgICB0aGlzLnBoeFJlbW92ZSA9IHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKFwicmVtb3ZlXCIpXG4gICAgdGhpcy50YXJnZXRDb250YWluZXIgPSB0aGlzLmlzQ0lEUGF0Y2goKSA/IHRoaXMudGFyZ2V0Q0lEQ29udGFpbmVyKGh0bWwpIDogY29udGFpbmVyXG4gICAgdGhpcy5jYWxsYmFja3MgPSB7XG4gICAgICBiZWZvcmVhZGRlZDogW10sIGJlZm9yZXVwZGF0ZWQ6IFtdLCBiZWZvcmVwaHhDaGlsZEFkZGVkOiBbXSxcbiAgICAgIGFmdGVyYWRkZWQ6IFtdLCBhZnRlcnVwZGF0ZWQ6IFtdLCBhZnRlcmRpc2NhcmRlZDogW10sIGFmdGVycGh4Q2hpbGRBZGRlZDogW10sXG4gICAgICBhZnRlcnRyYW5zaXRpb25zRGlzY2FyZGVkOiBbXVxuICAgIH1cbiAgfVxuXG4gIGJlZm9yZShraW5kLCBjYWxsYmFjayl7IHRoaXMuY2FsbGJhY2tzW2BiZWZvcmUke2tpbmR9YF0ucHVzaChjYWxsYmFjaykgfVxuICBhZnRlcihraW5kLCBjYWxsYmFjayl7IHRoaXMuY2FsbGJhY2tzW2BhZnRlciR7a2luZH1gXS5wdXNoKGNhbGxiYWNrKSB9XG5cbiAgdHJhY2tCZWZvcmUoa2luZCwgLi4uYXJncyl7XG4gICAgdGhpcy5jYWxsYmFja3NbYGJlZm9yZSR7a2luZH1gXS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKC4uLmFyZ3MpKVxuICB9XG5cbiAgdHJhY2tBZnRlcihraW5kLCAuLi5hcmdzKXtcbiAgICB0aGlzLmNhbGxiYWNrc1tgYWZ0ZXIke2tpbmR9YF0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayguLi5hcmdzKSlcbiAgfVxuXG4gIG1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsKCl7XG4gICAgbGV0IHBoeFVwZGF0ZSA9IHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9VUERBVEUpXG4gICAgRE9NLmFsbCh0aGlzLmNvbnRhaW5lciwgYFske3BoeFVwZGF0ZX09YXBwZW5kXSA+ICosIFske3BoeFVwZGF0ZX09cHJlcGVuZF0gPiAqYCwgZWwgPT4ge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9QUlVORSwgXCJcIilcbiAgICB9KVxuICB9XG5cbiAgcGVyZm9ybShpc0pvaW5QYXRjaCl7XG4gICAgbGV0IHt2aWV3LCBsaXZlU29ja2V0LCBodG1sLCBjb250YWluZXIsIHRhcmdldENvbnRhaW5lcn0gPSB0aGlzXG4gICAgaWYodGhpcy5pc0NJRFBhdGNoKCkgJiYgIXRhcmdldENvbnRhaW5lcil7IHJldHVybiB9XG5cbiAgICBsZXQgZm9jdXNlZCA9IGxpdmVTb2NrZXQuZ2V0QWN0aXZlRWxlbWVudCgpXG4gICAgbGV0IHtzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kfSA9IGZvY3VzZWQgJiYgRE9NLmhhc1NlbGVjdGlvblJhbmdlKGZvY3VzZWQpID8gZm9jdXNlZCA6IHt9XG4gICAgbGV0IHBoeFVwZGF0ZSA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfVVBEQVRFKVxuICAgIGxldCBwaHhWaWV3cG9ydFRvcCA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfVklFV1BPUlRfVE9QKVxuICAgIGxldCBwaHhWaWV3cG9ydEJvdHRvbSA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfVklFV1BPUlRfQk9UVE9NKVxuICAgIGxldCBwaHhUcmlnZ2VyRXh0ZXJuYWwgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX1RSSUdHRVJfQUNUSU9OKVxuICAgIGxldCBhZGRlZCA9IFtdXG4gICAgbGV0IHVwZGF0ZXMgPSBbXVxuICAgIGxldCBhcHBlbmRQcmVwZW5kVXBkYXRlcyA9IFtdXG5cbiAgICBsZXQgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkID0gbnVsbFxuXG4gICAgZnVuY3Rpb24gbW9ycGgodGFyZ2V0Q29udGFpbmVyLCBzb3VyY2UsIHdpdGhDaGlsZHJlbj1mYWxzZSl7XG4gICAgICBsZXQgbW9ycGhDYWxsYmFja3MgPSB7XG4gICAgICAgIC8vIG5vcm1hbGx5LCB3ZSBhcmUgcnVubmluZyB3aXRoIGNoaWxkcmVuT25seSwgYXMgdGhlIHBhdGNoIEhUTUwgZm9yIGEgTFZcbiAgICAgICAgLy8gZG9lcyBub3QgaW5jbHVkZSB0aGUgTFYgYXR0cnMgKGRhdGEtcGh4LXNlc3Npb24sIGV0Yy4pXG4gICAgICAgIC8vIHdoZW4gd2UgYXJlIHBhdGNoaW5nIGEgbGl2ZSBjb21wb25lbnQsIHdlIGRvIHdhbnQgdG8gcGF0Y2ggdGhlIHJvb3QgZWxlbWVudCBhcyB3ZWxsO1xuICAgICAgICAvLyBhbm90aGVyIGNhc2UgaXMgdGhlIHJlY3Vyc2l2ZSBwYXRjaCBvZiBhIHN0cmVhbSBpdGVtIHRoYXQgd2FzIGtlcHQgb24gcmVzZXQgKC0+IG9uQmVmb3JlTm9kZUFkZGVkKVxuICAgICAgICBjaGlsZHJlbk9ubHk6IHRhcmdldENvbnRhaW5lci5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkgPT09IG51bGwgJiYgIXdpdGhDaGlsZHJlbixcbiAgICAgICAgZ2V0Tm9kZUtleTogKG5vZGUpID0+IHtcbiAgICAgICAgICBpZihET00uaXNQaHhEZXN0cm95ZWQobm9kZSkpeyByZXR1cm4gbnVsbCB9XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGpvaW4gcGF0Y2gsIHRoZW4gYnkgZGVmaW5pdGlvbiB0aGVyZSB3YXMgbm8gUEhYX01BR0lDX0lELlxuICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IHRvIHJlZHVjZSB0aGUgYW1vdW50IG9mIGVsZW1lbnRzIG1vcnBoZG9tIGRpc2NhcmRzLlxuICAgICAgICAgIGlmKGlzSm9pblBhdGNoKXsgcmV0dXJuIG5vZGUuaWQgfVxuICAgICAgICAgIHJldHVybiBub2RlLmlkIHx8IChub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShQSFhfTUFHSUNfSUQpKVxuICAgICAgICB9LFxuICAgICAgICAvLyBza2lwIGluZGV4aW5nIGZyb20gY2hpbGRyZW4gd2hlbiBjb250YWluZXIgaXMgc3RyZWFtXG4gICAgICAgIHNraXBGcm9tQ2hpbGRyZW46IChmcm9tKSA9PiB7IHJldHVybiBmcm9tLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpID09PSBQSFhfU1RSRUFNIH0sXG4gICAgICAgIC8vIHRlbGwgbW9ycGhkb20gaG93IHRvIGFkZCBhIGNoaWxkXG4gICAgICAgIGFkZENoaWxkOiAocGFyZW50LCBjaGlsZCkgPT4ge1xuICAgICAgICAgIGxldCB7cmVmLCBzdHJlYW1BdH0gPSB0aGlzLmdldFN0cmVhbUluc2VydChjaGlsZClcbiAgICAgICAgICBpZihyZWYgPT09IHVuZGVmaW5lZCl7IHJldHVybiBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpIH1cblxuICAgICAgICAgIHRoaXMuc2V0U3RyZWFtUmVmKGNoaWxkLCByZWYpXG5cbiAgICAgICAgICAvLyBzdHJlYW1pbmdcbiAgICAgICAgICBpZihzdHJlYW1BdCA9PT0gMCl7XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLCBjaGlsZClcbiAgICAgICAgICB9IGVsc2UgaWYoc3RyZWFtQXQgPT09IC0xKXtcbiAgICAgICAgICAgIGxldCBsYXN0Q2hpbGQgPSBwYXJlbnQubGFzdEVsZW1lbnRDaGlsZFxuICAgICAgICAgICAgaWYobGFzdENoaWxkICYmICFsYXN0Q2hpbGQuaGFzQXR0cmlidXRlKFBIWF9TVFJFQU1fUkVGKSl7XG4gICAgICAgICAgICAgIGxldCBub25TdHJlYW1DaGlsZCA9IEFycmF5LmZyb20ocGFyZW50LmNoaWxkcmVuKS5maW5kKGMgPT4gIWMuaGFzQXR0cmlidXRlKFBIWF9TVFJFQU1fUkVGKSlcbiAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgbm9uU3RyZWFtQ2hpbGQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmKHN0cmVhbUF0ID4gMCl7XG4gICAgICAgICAgICBsZXQgc2libGluZyA9IEFycmF5LmZyb20ocGFyZW50LmNoaWxkcmVuKVtzdHJlYW1BdF1cbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHNpYmxpbmcpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZU5vZGVBZGRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgRE9NLm1haW50YWluUHJpdmF0ZUhvb2tzKGVsLCBlbCwgcGh4Vmlld3BvcnRUb3AsIHBoeFZpZXdwb3J0Qm90dG9tKVxuICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJhZGRlZFwiLCBlbClcblxuICAgICAgICAgIGxldCBtb3JwaGVkRWwgPSBlbFxuICAgICAgICAgIC8vIHRoaXMgaXMgYSBzdHJlYW0gaXRlbSB0aGF0IHdhcyBrZXB0IG9uIHJlc2V0LCByZWN1cnNpdmVseSBtb3JwaCBpdFxuICAgICAgICAgIGlmKHRoaXMuc3RyZWFtQ29tcG9uZW50UmVzdG9yZVtlbC5pZF0pe1xuICAgICAgICAgICAgbW9ycGhlZEVsID0gdGhpcy5zdHJlYW1Db21wb25lbnRSZXN0b3JlW2VsLmlkXVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3RyZWFtQ29tcG9uZW50UmVzdG9yZVtlbC5pZF1cbiAgICAgICAgICAgIG1vcnBoLmNhbGwodGhpcywgbW9ycGhlZEVsLCBlbCwgdHJ1ZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbW9ycGhlZEVsXG4gICAgICAgIH0sXG4gICAgICAgIG9uTm9kZUFkZGVkOiAoZWwpID0+IHtcbiAgICAgICAgICBpZihlbC5nZXRBdHRyaWJ1dGUpeyB0aGlzLm1heWJlUmVPcmRlclN0cmVhbShlbCwgdHJ1ZSkgfVxuXG4gICAgICAgICAgLy8gaGFjayB0byBmaXggU2FmYXJpIGhhbmRsaW5nIG9mIGltZyBzcmNzZXQgYW5kIHZpZGVvIHRhZ3NcbiAgICAgICAgICBpZihlbCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgJiYgZWwuc3Jjc2V0KXtcbiAgICAgICAgICAgIGVsLnNyY3NldCA9IGVsLnNyY3NldFxuICAgICAgICAgIH0gZWxzZSBpZihlbCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgJiYgZWwuYXV0b3BsYXkpe1xuICAgICAgICAgICAgZWwucGxheSgpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKERPTS5pc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWwoZWwsIHBoeFRyaWdnZXJFeHRlcm5hbCkpe1xuICAgICAgICAgICAgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkID0gZWxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBuZXN0ZWQgdmlldyBoYW5kbGluZ1xuICAgICAgICAgIGlmKChET00uaXNQaHhDaGlsZChlbCkgJiYgdmlldy5vd25zRWxlbWVudChlbCkpIHx8IERPTS5pc1BoeFN0aWNreShlbCkgJiYgdmlldy5vd25zRWxlbWVudChlbC5wYXJlbnROb2RlKSl7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQWZ0ZXIoXCJwaHhDaGlsZEFkZGVkXCIsIGVsKVxuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRlZC5wdXNoKGVsKVxuICAgICAgICB9LFxuICAgICAgICBvbk5vZGVEaXNjYXJkZWQ6IChlbCkgPT4gdGhpcy5vbk5vZGVEaXNjYXJkZWQoZWwpLFxuICAgICAgICBvbkJlZm9yZU5vZGVEaXNjYXJkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIGlmKGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1BSVU5FKSAhPT0gbnVsbCl7IHJldHVybiB0cnVlIH1cbiAgICAgICAgICBpZihlbC5wYXJlbnRFbGVtZW50ICE9PSBudWxsICYmIGVsLmlkICYmXG4gICAgICAgICAgICBET00uaXNQaHhVcGRhdGUoZWwucGFyZW50RWxlbWVudCwgcGh4VXBkYXRlLCBbUEhYX1NUUkVBTSwgXCJhcHBlbmRcIiwgXCJwcmVwZW5kXCJdKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYodGhpcy5tYXliZVBlbmRpbmdSZW1vdmUoZWwpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICBpZih0aGlzLnNraXBDSURTaWJsaW5nKGVsKSl7IHJldHVybiBmYWxzZSB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBvbkVsVXBkYXRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgaWYoRE9NLmlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKSl7XG4gICAgICAgICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBlbFxuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVzLnB1c2goZWwpXG4gICAgICAgICAgdGhpcy5tYXliZVJlT3JkZXJTdHJlYW0oZWwsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZUVsVXBkYXRlZDogKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgICAgIC8vIGlmIHdlIGFyZSBwYXRjaGluZyB0aGUgcm9vdCB0YXJnZXQgY29udGFpbmVyIGFuZCB0aGUgaWQgaGFzIGNoYW5nZWQsIHRyZWF0IGl0IGFzIGEgbmV3IG5vZGVcbiAgICAgICAgICAvLyBieSByZXBsYWNpbmcgdGhlIGZyb21FbCB3aXRoIHRoZSB0b0VsLCB3aGljaCBlbnN1cmVzIGhvb2tzIGFyZSB0b3JuIGRvd24gYW5kIHJlLWNyZWF0ZWRcbiAgICAgICAgICBpZihmcm9tRWwuaWQgJiYgZnJvbUVsLmlzU2FtZU5vZGUodGFyZ2V0Q29udGFpbmVyKSAmJiBmcm9tRWwuaWQgIT09IHRvRWwuaWQpe1xuICAgICAgICAgICAgbW9ycGhDYWxsYmFja3Mub25Ob2RlRGlzY2FyZGVkKGZyb21FbClcbiAgICAgICAgICAgIGZyb21FbC5yZXBsYWNlV2l0aCh0b0VsKVxuICAgICAgICAgICAgcmV0dXJuIG1vcnBoQ2FsbGJhY2tzLm9uTm9kZUFkZGVkKHRvRWwpXG4gICAgICAgICAgfVxuICAgICAgICAgIERPTS5zeW5jUGVuZGluZ0F0dHJzKGZyb21FbCwgdG9FbClcbiAgICAgICAgICBET00ubWFpbnRhaW5Qcml2YXRlSG9va3MoZnJvbUVsLCB0b0VsLCBwaHhWaWV3cG9ydFRvcCwgcGh4Vmlld3BvcnRCb3R0b20pXG4gICAgICAgICAgRE9NLmNsZWFuQ2hpbGROb2Rlcyh0b0VsLCBwaHhVcGRhdGUpXG4gICAgICAgICAgaWYodGhpcy5za2lwQ0lEU2libGluZyh0b0VsKSl7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgbGl2ZSBjb21wb25lbnQgdXNlZCBpbiBhIHN0cmVhbSwgd2UgbWF5IG5lZWQgdG8gcmVvcmRlciBpdFxuICAgICAgICAgICAgdGhpcy5tYXliZVJlT3JkZXJTdHJlYW0oZnJvbUVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKERPTS5pc1BoeFN0aWNreShmcm9tRWwpKXtcbiAgICAgICAgICAgIFtQSFhfU0VTU0lPTiwgUEhYX1NUQVRJQywgUEhYX1JPT1RfSURdXG4gICAgICAgICAgICAgIC5tYXAoYXR0ciA9PiBbYXR0ciwgZnJvbUVsLmdldEF0dHJpYnV0ZShhdHRyKSwgdG9FbC5nZXRBdHRyaWJ1dGUoYXR0cildKVxuICAgICAgICAgICAgICAuZm9yRWFjaCgoW2F0dHIsIGZyb21WYWwsIHRvVmFsXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKHRvVmFsICYmIGZyb21WYWwgIT09IHRvVmFsKXsgZnJvbUVsLnNldEF0dHJpYnV0ZShhdHRyLCB0b1ZhbCkgfVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoRE9NLmlzSWdub3JlZChmcm9tRWwsIHBoeFVwZGF0ZSkgfHwgKGZyb21FbC5mb3JtICYmIGZyb21FbC5mb3JtLmlzU2FtZU5vZGUoZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkKSkpe1xuICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgRE9NLm1lcmdlQXR0cnMoZnJvbUVsLCB0b0VsLCB7aXNJZ25vcmVkOiBET00uaXNJZ25vcmVkKGZyb21FbCwgcGh4VXBkYXRlKX0pXG4gICAgICAgICAgICB1cGRhdGVzLnB1c2goZnJvbUVsKVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoZnJvbUVsLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgKGZyb21FbC52YWxpZGl0eSAmJiBmcm9tRWwudmFsaWRpdHkuYmFkSW5wdXQpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBoYXMgUEhYX1JFRl9TUkMsIGl0IGlzIGxvYWRpbmcgb3IgbG9ja2VkIGFuZCBhd2FpdGluZyBhbiBhY2suXG4gICAgICAgICAgLy8gSWYgaXQncyBsb2NrZWQsIHdlIGNsb25lIHRoZSBmcm9tRWwgdHJlZSBhbmQgaW5zdHJ1Y3QgbW9ycGhkb20gdG8gdXNlXG4gICAgICAgICAgLy8gdGhlIGNsb25lZCB0cmVlIGFzIHRoZSBzb3VyY2Ugb2YgdGhlIG1vcnBoIGZvciB0aGlzIGJyYW5jaCBmcm9tIGhlcmUgb24gb3V0LlxuICAgICAgICAgIC8vIFdlIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGNsb25lZCB0cmVlIGluIHRoZSBlbGVtZW50J3MgcHJpdmF0ZSBkYXRhLCBhbmRcbiAgICAgICAgICAvLyBvbiBhY2sgKHZpZXcudW5kb1JlZnMpLCB3ZSBtb3JwaCB0aGUgY2xvbmVkIHRyZWUgd2l0aCB0aGUgdHJ1ZSBmcm9tRWwgaW4gdGhlIERPTSB0b1xuICAgICAgICAgIC8vIGFwcGx5IGFueSBjaGFuZ2VzIHRoYXQgaGFwcGVuZWQgd2hpbGUgdGhlIGVsZW1lbnQgd2FzIGxvY2tlZC5cbiAgICAgICAgICBsZXQgaXNGb2N1c2VkRm9ybUVsID0gZm9jdXNlZCAmJiBmcm9tRWwuaXNTYW1lTm9kZShmb2N1c2VkKSAmJiBET00uaXNGb3JtSW5wdXQoZnJvbUVsKVxuICAgICAgICAgIGxldCBmb2N1c2VkU2VsZWN0Q2hhbmdlZCA9IGlzRm9jdXNlZEZvcm1FbCAmJiB0aGlzLmlzQ2hhbmdlZFNlbGVjdChmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgaWYoZnJvbUVsLmhhc0F0dHJpYnV0ZShQSFhfUkVGX1NSQykpe1xuICAgICAgICAgICAgaWYoRE9NLmlzVXBsb2FkSW5wdXQoZnJvbUVsKSl7XG4gICAgICAgICAgICAgIERPTS5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwge2lzSWdub3JlZDogdHJ1ZX0pXG4gICAgICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGZyb21FbCwgdG9FbClcbiAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKVxuICAgICAgICAgICAgbGV0IGlzTG9ja2VkID0gZnJvbUVsLmhhc0F0dHJpYnV0ZShQSFhfUkVGX0xPQ0spXG4gICAgICAgICAgICBsZXQgY2xvbmUgPSBpc0xvY2tlZCA/IERPTS5wcml2YXRlKGZyb21FbCwgUEhYX1JFRl9MT0NLKSB8fCBmcm9tRWwuY2xvbmVOb2RlKHRydWUpIDogbnVsbFxuICAgICAgICAgICAgaWYoY2xvbmUpe1xuICAgICAgICAgICAgICBET00ucHV0UHJpdmF0ZShmcm9tRWwsIFBIWF9SRUZfTE9DSywgY2xvbmUpXG4gICAgICAgICAgICAgIGlmKCFpc0ZvY3VzZWRGb3JtRWwpe1xuICAgICAgICAgICAgICAgIGZyb21FbCA9IGNsb25lXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBuZXN0ZWQgdmlldyBoYW5kbGluZ1xuICAgICAgICAgIGlmKERPTS5pc1BoeENoaWxkKHRvRWwpKXtcbiAgICAgICAgICAgIGxldCBwcmV2U2Vzc2lvbiA9IGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pXG4gICAgICAgICAgICBET00ubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHtleGNsdWRlOiBbUEhYX1NUQVRJQ119KVxuICAgICAgICAgICAgaWYocHJldlNlc3Npb24gIT09IFwiXCIpeyBmcm9tRWwuc2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OLCBwcmV2U2Vzc2lvbikgfVxuICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCwgdGhpcy5yb290SUQpXG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlucHV0IGhhbmRsaW5nXG4gICAgICAgICAgRE9NLmNvcHlQcml2YXRlcyh0b0VsLCBmcm9tRWwpXG5cbiAgICAgICAgICAvLyBza2lwIHBhdGNoaW5nIGZvY3VzZWQgaW5wdXRzIHVubGVzcyBmb2N1cyBpcyBhIHNlbGVjdCB0aGF0IGhhcyBjaGFuZ2VkIG9wdGlvbnNcbiAgICAgICAgICBpZihpc0ZvY3VzZWRGb3JtRWwgJiYgZnJvbUVsLnR5cGUgIT09IFwiaGlkZGVuXCIgJiYgIWZvY3VzZWRTZWxlY3RDaGFuZ2VkKXtcbiAgICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGZyb21FbCwgdG9FbClcbiAgICAgICAgICAgIERPTS5tZXJnZUZvY3VzZWRJbnB1dChmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICBET00uc3luY0F0dHJzVG9Qcm9wcyhmcm9tRWwpXG4gICAgICAgICAgICB1cGRhdGVzLnB1c2goZnJvbUVsKVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYmx1ciBmb2N1c2VkIHNlbGVjdCBpZiBpdCBjaGFuZ2VkIHNvIG5hdGl2ZSBVSSBpcyB1cGRhdGVkIChpZSBzYWZhcmkgd29uJ3QgdXBkYXRlIHZpc2libGUgb3B0aW9ucylcbiAgICAgICAgICAgIGlmKGZvY3VzZWRTZWxlY3RDaGFuZ2VkKXsgZnJvbUVsLmJsdXIoKSB9XG4gICAgICAgICAgICBpZihET00uaXNQaHhVcGRhdGUodG9FbCwgcGh4VXBkYXRlLCBbXCJhcHBlbmRcIiwgXCJwcmVwZW5kXCJdKSl7XG4gICAgICAgICAgICAgIGFwcGVuZFByZXBlbmRVcGRhdGVzLnB1c2gobmV3IERPTVBvc3RNb3JwaFJlc3RvcmVyKGZyb21FbCwgdG9FbCwgdG9FbC5nZXRBdHRyaWJ1dGUocGh4VXBkYXRlKSkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIERPTS5zeW5jQXR0cnNUb1Byb3BzKHRvRWwpXG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKHRvRWwpXG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUVsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtb3JwaGRvbSh0YXJnZXRDb250YWluZXIsIHNvdXJjZSwgbW9ycGhDYWxsYmFja3MpXG4gICAgfVxuXG4gICAgdGhpcy50cmFja0JlZm9yZShcImFkZGVkXCIsIGNvbnRhaW5lcilcbiAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBjb250YWluZXIsIGNvbnRhaW5lcilcblxuICAgIGxpdmVTb2NrZXQudGltZShcIm1vcnBoZG9tXCIsICgpID0+IHtcbiAgICAgIHRoaXMuc3RyZWFtcy5mb3JFYWNoKChbcmVmLCBpbnNlcnRzLCBkZWxldGVJZHMsIHJlc2V0XSkgPT4ge1xuICAgICAgICBpbnNlcnRzLmZvckVhY2goKFtrZXksIHN0cmVhbUF0LCBsaW1pdF0pID0+IHtcbiAgICAgICAgICB0aGlzLnN0cmVhbUluc2VydHNba2V5XSA9IHtyZWYsIHN0cmVhbUF0LCBsaW1pdCwgcmVzZXR9XG4gICAgICAgIH0pXG4gICAgICAgIGlmKHJlc2V0ICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgIERPTS5hbGwoY29udGFpbmVyLCBgWyR7UEhYX1NUUkVBTV9SRUZ9PVwiJHtyZWZ9XCJdYCwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVTdHJlYW1DaGlsZEVsZW1lbnQoY2hpbGQpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBkZWxldGVJZHMuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgbGV0IGNoaWxkID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYFtpZD1cIiR7aWR9XCJdYClcbiAgICAgICAgICBpZihjaGlsZCl7IHRoaXMucmVtb3ZlU3RyZWFtQ2hpbGRFbGVtZW50KGNoaWxkKSB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuXG4gICAgICAvLyBjbGVhciBzdHJlYW0gaXRlbXMgZnJvbSB0aGUgZGVhZCByZW5kZXIgaWYgdGhleSBhcmUgbm90IGluc2VydGVkIGFnYWluXG4gICAgICBpZihpc0pvaW5QYXRjaCl7XG4gICAgICAgIERPTS5hbGwodGhpcy5jb250YWluZXIsIGBbJHtwaHhVcGRhdGV9PSR7UEhYX1NUUkVBTX1dYCwgZWwgPT4ge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byBvbmx5IHJlbW92ZSBlbGVtZW50cyBvd25lZCBieSB0aGUgY3VycmVudCB2aWV3XG4gICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L2lzc3Vlcy8zMDQ3XG4gICAgICAgICAgdGhpcy5saXZlU29ja2V0Lm93bmVyKGVsLCAodmlldykgPT4ge1xuICAgICAgICAgICAgaWYodmlldyA9PT0gdGhpcy52aWV3KXtcbiAgICAgICAgICAgICAgQXJyYXkuZnJvbShlbC5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVTdHJlYW1DaGlsZEVsZW1lbnQoY2hpbGQpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgbW9ycGguY2FsbCh0aGlzLCB0YXJnZXRDb250YWluZXIsIGh0bWwpXG4gICAgfSlcblxuICAgIGlmKGxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSl7XG4gICAgICBkZXRlY3REdXBsaWNhdGVJZHMoKVxuICAgICAgLy8gd2FybiBpZiB0aGVyZSBhcmUgYW55IGlucHV0cyBuYW1lZCBcImlkXCJcbiAgICAgIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImlucHV0W25hbWU9aWRdXCIpKS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICBpZihub2RlLmZvcm0pe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEZXRlY3RlZCBhbiBpbnB1dCB3aXRoIG5hbWU9XFxcImlkXFxcIiBpbnNpZGUgYSBmb3JtISBUaGlzIHdpbGwgY2F1c2UgcHJvYmxlbXMgd2hlbiBwYXRjaGluZyB0aGUgRE9NLlxcblwiLCBub2RlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmKGFwcGVuZFByZXBlbmRVcGRhdGVzLmxlbmd0aCA+IDApe1xuICAgICAgbGl2ZVNvY2tldC50aW1lKFwicG9zdC1tb3JwaCBhcHBlbmQvcHJlcGVuZCByZXN0b3JhdGlvblwiLCAoKSA9PiB7XG4gICAgICAgIGFwcGVuZFByZXBlbmRVcGRhdGVzLmZvckVhY2godXBkYXRlID0+IHVwZGF0ZS5wZXJmb3JtKCkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGxpdmVTb2NrZXQuc2lsZW5jZUV2ZW50cygoKSA9PiBET00ucmVzdG9yZUZvY3VzKGZvY3VzZWQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpKVxuICAgIERPTS5kaXNwYXRjaEV2ZW50KGRvY3VtZW50LCBcInBoeDp1cGRhdGVcIilcbiAgICBhZGRlZC5mb3JFYWNoKGVsID0+IHRoaXMudHJhY2tBZnRlcihcImFkZGVkXCIsIGVsKSlcbiAgICB1cGRhdGVzLmZvckVhY2goZWwgPT4gdGhpcy50cmFja0FmdGVyKFwidXBkYXRlZFwiLCBlbCkpXG5cbiAgICB0aGlzLnRyYW5zaXRpb25QZW5kaW5nUmVtb3ZlcygpXG5cbiAgICBpZihleHRlcm5hbEZvcm1UcmlnZ2VyZWQpe1xuICAgICAgbGl2ZVNvY2tldC51bmxvYWQoKVxuICAgICAgLy8gdXNlIHByb3RvdHlwZSdzIHN1Ym1pdCBpbiBjYXNlIHRoZXJlJ3MgYSBmb3JtIGNvbnRyb2wgd2l0aCBuYW1lIG9yIGlkIG9mIFwic3VibWl0XCJcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MRm9ybUVsZW1lbnQvc3VibWl0XG4gICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkKS5zdWJtaXQuY2FsbChleHRlcm5hbEZvcm1UcmlnZ2VyZWQpXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBvbk5vZGVEaXNjYXJkZWQoZWwpe1xuICAgIC8vIG5lc3RlZCB2aWV3IGhhbmRsaW5nXG4gICAgaWYoRE9NLmlzUGh4Q2hpbGQoZWwpIHx8IERPTS5pc1BoeFN0aWNreShlbCkpeyB0aGlzLmxpdmVTb2NrZXQuZGVzdHJveVZpZXdCeUVsKGVsKSB9XG4gICAgdGhpcy50cmFja0FmdGVyKFwiZGlzY2FyZGVkXCIsIGVsKVxuICB9XG5cbiAgbWF5YmVQZW5kaW5nUmVtb3ZlKG5vZGUpe1xuICAgIGlmKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKHRoaXMucGh4UmVtb3ZlKSAhPT0gbnVsbCl7XG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmVzLnB1c2gobm9kZSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJlbW92ZVN0cmVhbUNoaWxkRWxlbWVudChjaGlsZCl7XG4gICAgLy8gd2UgbmVlZCB0byBzdG9yZSB0aGUgbm9kZSBpZiBpdCBpcyBhY3R1YWxseSByZS1hZGRlZCBpbiB0aGUgc2FtZSBwYXRjaFxuICAgIC8vIHdlIGRvIE5PVCB3YW50IHRvIGV4ZWN1dGUgcGh4LXJlbW92ZSwgd2UgZG8gTk9UIHdhbnQgdG8gY2FsbCBvbk5vZGVEaXNjYXJkZWRcbiAgICBpZih0aGlzLnN0cmVhbUluc2VydHNbY2hpbGQuaWRdKXtcbiAgICAgIHRoaXMuc3RyZWFtQ29tcG9uZW50UmVzdG9yZVtjaGlsZC5pZF0gPSBjaGlsZFxuICAgICAgY2hpbGQucmVtb3ZlKClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb25seSByZW1vdmUgdGhlIGVsZW1lbnQgbm93IGlmIGl0IGhhcyBubyBwaHgtcmVtb3ZlIGJpbmRpbmdcbiAgICAgIGlmKCF0aGlzLm1heWJlUGVuZGluZ1JlbW92ZShjaGlsZCkpe1xuICAgICAgICBjaGlsZC5yZW1vdmUoKVxuICAgICAgICB0aGlzLm9uTm9kZURpc2NhcmRlZChjaGlsZClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRTdHJlYW1JbnNlcnQoZWwpe1xuICAgIGxldCBpbnNlcnQgPSBlbC5pZCA/IHRoaXMuc3RyZWFtSW5zZXJ0c1tlbC5pZF0gOiB7fVxuICAgIHJldHVybiBpbnNlcnQgfHwge31cbiAgfVxuXG4gIHNldFN0cmVhbVJlZihlbCwgcmVmKXtcbiAgICBET00ucHV0U3RpY2t5KGVsLCBQSFhfU1RSRUFNX1JFRiwgZWwgPT4gZWwuc2V0QXR0cmlidXRlKFBIWF9TVFJFQU1fUkVGLCByZWYpKVxuICB9XG5cbiAgbWF5YmVSZU9yZGVyU3RyZWFtKGVsLCBpc05ldyl7XG4gICAgbGV0IHtyZWYsIHN0cmVhbUF0LCByZXNldH0gPSB0aGlzLmdldFN0cmVhbUluc2VydChlbClcbiAgICBpZihzdHJlYW1BdCA9PT0gdW5kZWZpbmVkKXsgcmV0dXJuIH1cblxuICAgIC8vIHdlIG5lZWQgdG8gc2V0IHRoZSBQSFhfU1RSRUFNX1JFRiBoZXJlIGFzIHdlbGwgYXMgYWRkQ2hpbGQgaXMgaW52b2tlZCBvbmx5IGZvciBwYXJlbnRzXG4gICAgdGhpcy5zZXRTdHJlYW1SZWYoZWwsIHJlZilcblxuICAgIGlmKCFyZXNldCAmJiAhaXNOZXcpe1xuICAgICAgLy8gd2Ugb25seSByZW9yZGVyIGlmIHRoZSBlbGVtZW50IGlzIG5ldyBvciBpdCdzIGEgc3RyZWFtIHJlc2V0XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB0aGUgZWxlbWVudCBoYXMgYSBwYXJlbnQgZWxlbWVudDtcbiAgICAvLyBpdCBkb2Vzbid0IGlmIHdlIGFyZSBjdXJyZW50bHkgcmVjdXJzaXZlbHkgbW9ycGhpbmcgKHJlc3RvcmluZyBhIHNhdmVkIHN0cmVhbSBjaGlsZClcbiAgICAvLyBiZWNhdXNlIHRoZSBlbGVtZW50IGlzIG5vdCB5ZXQgYWRkZWQgdG8gdGhlIHJlYWwgZG9tO1xuICAgIC8vIHJlb3JkZXJpbmcgZG9lcyBub3QgbWFrZSBzZW5zZSBpbiB0aGF0IGNhc2UgYW55d2F5XG4gICAgaWYoIWVsLnBhcmVudEVsZW1lbnQpeyByZXR1cm4gfVxuXG4gICAgaWYoc3RyZWFtQXQgPT09IDApe1xuICAgICAgZWwucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoZWwsIGVsLnBhcmVudEVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpXG4gICAgfSBlbHNlIGlmKHN0cmVhbUF0ID4gMCl7XG4gICAgICBsZXQgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGVsLnBhcmVudEVsZW1lbnQuY2hpbGRyZW4pXG4gICAgICBsZXQgb2xkSW5kZXggPSBjaGlsZHJlbi5pbmRleE9mKGVsKVxuICAgICAgaWYoc3RyZWFtQXQgPj0gY2hpbGRyZW4ubGVuZ3RoIC0gMSl7XG4gICAgICAgIGVsLnBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZWwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgc2libGluZyA9IGNoaWxkcmVuW3N0cmVhbUF0XVxuICAgICAgICBpZihvbGRJbmRleCA+IHN0cmVhbUF0KXtcbiAgICAgICAgICBlbC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShlbCwgc2libGluZylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShlbCwgc2libGluZy5uZXh0RWxlbWVudFNpYmxpbmcpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1heWJlTGltaXRTdHJlYW0oZWwpXG4gIH1cblxuICBtYXliZUxpbWl0U3RyZWFtKGVsKXtcbiAgICBsZXQge2xpbWl0fSA9IHRoaXMuZ2V0U3RyZWFtSW5zZXJ0KGVsKVxuICAgIGxldCBjaGlsZHJlbiA9IGxpbWl0ICE9PSBudWxsICYmIEFycmF5LmZyb20oZWwucGFyZW50RWxlbWVudC5jaGlsZHJlbilcbiAgICBpZihsaW1pdCAmJiBsaW1pdCA8IDAgJiYgY2hpbGRyZW4ubGVuZ3RoID4gbGltaXQgKiAtMSl7XG4gICAgICBjaGlsZHJlbi5zbGljZSgwLCBjaGlsZHJlbi5sZW5ndGggKyBsaW1pdCkuZm9yRWFjaChjaGlsZCA9PiB0aGlzLnJlbW92ZVN0cmVhbUNoaWxkRWxlbWVudChjaGlsZCkpXG4gICAgfSBlbHNlIGlmKGxpbWl0ICYmIGxpbWl0ID49IDAgJiYgY2hpbGRyZW4ubGVuZ3RoID4gbGltaXQpe1xuICAgICAgY2hpbGRyZW4uc2xpY2UobGltaXQpLmZvckVhY2goY2hpbGQgPT4gdGhpcy5yZW1vdmVTdHJlYW1DaGlsZEVsZW1lbnQoY2hpbGQpKVxuICAgIH1cbiAgfVxuXG4gIHRyYW5zaXRpb25QZW5kaW5nUmVtb3Zlcygpe1xuICAgIGxldCB7cGVuZGluZ1JlbW92ZXMsIGxpdmVTb2NrZXR9ID0gdGhpc1xuICAgIGlmKHBlbmRpbmdSZW1vdmVzLmxlbmd0aCA+IDApe1xuICAgICAgbGl2ZVNvY2tldC50cmFuc2l0aW9uUmVtb3ZlcyhwZW5kaW5nUmVtb3ZlcywgZmFsc2UsICgpID0+IHtcbiAgICAgICAgcGVuZGluZ1JlbW92ZXMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgbGV0IGNoaWxkID0gRE9NLmZpcnN0UGh4Q2hpbGQoZWwpXG4gICAgICAgICAgaWYoY2hpbGQpeyBsaXZlU29ja2V0LmRlc3Ryb3lWaWV3QnlFbChjaGlsZCkgfVxuICAgICAgICAgIGVsLnJlbW92ZSgpXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMudHJhY2tBZnRlcihcInRyYW5zaXRpb25zRGlzY2FyZGVkXCIsIHBlbmRpbmdSZW1vdmVzKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpc0NoYW5nZWRTZWxlY3QoZnJvbUVsLCB0b0VsKXtcbiAgICBpZighKGZyb21FbCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50KSB8fCBmcm9tRWwubXVsdGlwbGUpeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmKGZyb21FbC5vcHRpb25zLmxlbmd0aCAhPT0gdG9FbC5vcHRpb25zLmxlbmd0aCl7IHJldHVybiB0cnVlIH1cblxuICAgIC8vIGtlZXAgdGhlIGN1cnJlbnQgdmFsdWVcbiAgICB0b0VsLnZhbHVlID0gZnJvbUVsLnZhbHVlXG5cbiAgICAvLyBpbiBnZW5lcmFsIHdlIGhhdmUgdG8gYmUgdmVyeSBjYXJlZnVsIHdpdGggdXNpbmcgaXNFcXVhbE5vZGUgYXMgaXQgZG9lcyBub3QgYSByZWxpYWJsZVxuICAgIC8vIERPTSB0cmVlIGVxdWFsaXR5IGNoZWNrLCBidXQgZm9yIHNlbGVjdGlvbiBhdHRyaWJ1dGVzIGFuZCBvcHRpb25zIGl0IHdvcmtzIGZpbmVcbiAgICByZXR1cm4gIWZyb21FbC5pc0VxdWFsTm9kZSh0b0VsKVxuICB9XG5cbiAgaXNDSURQYXRjaCgpeyByZXR1cm4gdGhpcy5jaWRQYXRjaCB9XG5cbiAgc2tpcENJRFNpYmxpbmcoZWwpe1xuICAgIHJldHVybiBlbC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgZWwuaGFzQXR0cmlidXRlKFBIWF9TS0lQKVxuICB9XG5cbiAgdGFyZ2V0Q0lEQ29udGFpbmVyKGh0bWwpe1xuICAgIGlmKCF0aGlzLmlzQ0lEUGF0Y2goKSl7IHJldHVybiB9XG4gICAgbGV0IFtmaXJzdCwgLi4ucmVzdF0gPSBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuY29udGFpbmVyLCB0aGlzLnRhcmdldENJRClcbiAgICBpZihyZXN0Lmxlbmd0aCA9PT0gMCAmJiBET00uY2hpbGROb2RlTGVuZ3RoKGh0bWwpID09PSAxKXtcbiAgICAgIHJldHVybiBmaXJzdFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmlyc3QgJiYgZmlyc3QucGFyZW50Tm9kZVxuICAgIH1cbiAgfVxuXG4gIGluZGV4T2YocGFyZW50LCBjaGlsZCl7IHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5jaGlsZHJlbikuaW5kZXhPZihjaGlsZCkgfVxufVxuIiwgImltcG9ydCB7XG4gIENPTVBPTkVOVFMsXG4gIERZTkFNSUNTLFxuICBURU1QTEFURVMsXG4gIEVWRU5UUyxcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX1NLSVAsXG4gIFBIWF9NQUdJQ19JRCxcbiAgUkVQTFksXG4gIFNUQVRJQyxcbiAgVElUTEUsXG4gIFNUUkVBTSxcbiAgUk9PVCxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgaXNPYmplY3QsXG4gIGxvZ0Vycm9yLFxuICBpc0NpZCxcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5jb25zdCBWT0lEX1RBR1MgPSBuZXcgU2V0KFtcbiAgXCJhcmVhXCIsXG4gIFwiYmFzZVwiLFxuICBcImJyXCIsXG4gIFwiY29sXCIsXG4gIFwiY29tbWFuZFwiLFxuICBcImVtYmVkXCIsXG4gIFwiaHJcIixcbiAgXCJpbWdcIixcbiAgXCJpbnB1dFwiLFxuICBcImtleWdlblwiLFxuICBcImxpbmtcIixcbiAgXCJtZXRhXCIsXG4gIFwicGFyYW1cIixcbiAgXCJzb3VyY2VcIixcbiAgXCJ0cmFja1wiLFxuICBcIndiclwiXG5dKVxuY29uc3QgcXVvdGVDaGFycyA9IG5ldyBTZXQoW1wiJ1wiLCBcIlxcXCJcIl0pXG5cbmV4cG9ydCBsZXQgbW9kaWZ5Um9vdCA9IChodG1sLCBhdHRycywgY2xlYXJJbm5lckhUTUwpID0+IHtcbiAgbGV0IGkgPSAwXG4gIGxldCBpbnNpZGVDb21tZW50ID0gZmFsc2VcbiAgbGV0IGJlZm9yZVRhZywgYWZ0ZXJUYWcsIHRhZywgdGFnTmFtZUVuZHNBdCwgaWQsIG5ld0hUTUxcblxuICBsZXQgbG9va2FoZWFkID0gaHRtbC5tYXRjaCgvXihcXHMqKD86PCEtLS4qPy0tPlxccyopKik8KFteXFxzXFwvPl0rKS8pXG4gIGlmKGxvb2thaGVhZCA9PT0gbnVsbCl7IHRocm93IG5ldyBFcnJvcihgbWFsZm9ybWVkIGh0bWwgJHtodG1sfWApIH1cblxuICBpID0gbG9va2FoZWFkWzBdLmxlbmd0aFxuICBiZWZvcmVUYWcgPSBsb29rYWhlYWRbMV1cbiAgdGFnID0gbG9va2FoZWFkWzJdXG4gIHRhZ05hbWVFbmRzQXQgPSBpXG5cbiAgLy8gU2NhbiB0aGUgb3BlbmluZyB0YWcgZm9yIGlkLCBpZiB0aGVyZSBpcyBhbnlcbiAgZm9yKGk7IGkgPCBodG1sLmxlbmd0aDsgaSsrKXtcbiAgICBpZihodG1sLmNoYXJBdChpKSA9PT0gXCI+XCIgKXsgYnJlYWsgfVxuICAgIGlmKGh0bWwuY2hhckF0KGkpID09PSBcIj1cIil7XG4gICAgICBsZXQgaXNJZCA9IGh0bWwuc2xpY2UoaSAtIDMsIGkpID09PSBcIiBpZFwiXG4gICAgICBpKytcbiAgICAgIGxldCBjaGFyID0gaHRtbC5jaGFyQXQoaSlcbiAgICAgIGlmKHF1b3RlQ2hhcnMuaGFzKGNoYXIpKXtcbiAgICAgICAgbGV0IGF0dHJTdGFydHNBdCA9IGlcbiAgICAgICAgaSsrXG4gICAgICAgIGZvcihpOyBpIDwgaHRtbC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgaWYoaHRtbC5jaGFyQXQoaSkgPT09IGNoYXIpeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoaXNJZCl7XG4gICAgICAgICAgaWQgPSBodG1sLnNsaWNlKGF0dHJTdGFydHNBdCArIDEsIGkpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBjbG9zZUF0ID0gaHRtbC5sZW5ndGggLSAxXG4gIGluc2lkZUNvbW1lbnQgPSBmYWxzZVxuICB3aGlsZShjbG9zZUF0ID49IGJlZm9yZVRhZy5sZW5ndGggKyB0YWcubGVuZ3RoKXtcbiAgICBsZXQgY2hhciA9IGh0bWwuY2hhckF0KGNsb3NlQXQpXG4gICAgaWYoaW5zaWRlQ29tbWVudCl7XG4gICAgICBpZihjaGFyID09PSBcIi1cIiAmJiBodG1sLnNsaWNlKGNsb3NlQXQgLSAzLCBjbG9zZUF0KSA9PT0gXCI8IS1cIil7XG4gICAgICAgIGluc2lkZUNvbW1lbnQgPSBmYWxzZVxuICAgICAgICBjbG9zZUF0IC09IDRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb3NlQXQgLT0gMVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihjaGFyID09PSBcIj5cIiAmJiBodG1sLnNsaWNlKGNsb3NlQXQgLSAyLCBjbG9zZUF0KSA9PT0gXCItLVwiKXtcbiAgICAgIGluc2lkZUNvbW1lbnQgPSB0cnVlXG4gICAgICBjbG9zZUF0IC09IDNcbiAgICB9IGVsc2UgaWYoY2hhciA9PT0gXCI+XCIpe1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2VBdCAtPSAxXG4gICAgfVxuICB9XG4gIGFmdGVyVGFnID0gaHRtbC5zbGljZShjbG9zZUF0ICsgMSwgaHRtbC5sZW5ndGgpXG5cbiAgbGV0IGF0dHJzU3RyID1cbiAgICBPYmplY3Qua2V5cyhhdHRycylcbiAgICAgIC5tYXAoYXR0ciA9PiBhdHRyc1thdHRyXSA9PT0gdHJ1ZSA/IGF0dHIgOiBgJHthdHRyfT1cIiR7YXR0cnNbYXR0cl19XCJgKVxuICAgICAgLmpvaW4oXCIgXCIpXG5cbiAgaWYoY2xlYXJJbm5lckhUTUwpe1xuICAgIC8vIEtlZXAgdGhlIGlkIGlmIGFueVxuICAgIGxldCBpZEF0dHJTdHIgPSBpZCA/IGAgaWQ9XCIke2lkfVwiYCA6IFwiXCJcbiAgICBpZihWT0lEX1RBR1MuaGFzKHRhZykpe1xuICAgICAgbmV3SFRNTCA9IGA8JHt0YWd9JHtpZEF0dHJTdHJ9JHthdHRyc1N0ciA9PT0gXCJcIiA/IFwiXCIgOiBcIiBcIn0ke2F0dHJzU3RyfS8+YFxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdIVE1MID0gYDwke3RhZ30ke2lkQXR0clN0cn0ke2F0dHJzU3RyID09PSBcIlwiID8gXCJcIiA6IFwiIFwifSR7YXR0cnNTdHJ9PjwvJHt0YWd9PmBcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IHJlc3QgPSBodG1sLnNsaWNlKHRhZ05hbWVFbmRzQXQsIGNsb3NlQXQgKyAxKVxuICAgIG5ld0hUTUwgPSBgPCR7dGFnfSR7YXR0cnNTdHIgPT09IFwiXCIgPyBcIlwiIDogXCIgXCJ9JHthdHRyc1N0cn0ke3Jlc3R9YFxuICB9XG5cbiAgcmV0dXJuIFtuZXdIVE1MLCBiZWZvcmVUYWcsIGFmdGVyVGFnXVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJlZCB7XG4gIHN0YXRpYyBleHRyYWN0KGRpZmYpe1xuICAgIGxldCB7W1JFUExZXTogcmVwbHksIFtFVkVOVFNdOiBldmVudHMsIFtUSVRMRV06IHRpdGxlfSA9IGRpZmZcbiAgICBkZWxldGUgZGlmZltSRVBMWV1cbiAgICBkZWxldGUgZGlmZltFVkVOVFNdXG4gICAgZGVsZXRlIGRpZmZbVElUTEVdXG4gICAgcmV0dXJuIHtkaWZmLCB0aXRsZSwgcmVwbHk6IHJlcGx5IHx8IG51bGwsIGV2ZW50czogZXZlbnRzIHx8IFtdfVxuICB9XG5cbiAgY29uc3RydWN0b3Iodmlld0lkLCByZW5kZXJlZCl7XG4gICAgdGhpcy52aWV3SWQgPSB2aWV3SWRcbiAgICB0aGlzLnJlbmRlcmVkID0ge31cbiAgICB0aGlzLm1hZ2ljSWQgPSAwXG4gICAgdGhpcy5tZXJnZURpZmYocmVuZGVyZWQpXG4gIH1cblxuICBwYXJlbnRWaWV3SWQoKXsgcmV0dXJuIHRoaXMudmlld0lkIH1cblxuICB0b1N0cmluZyhvbmx5Q2lkcyl7XG4gICAgbGV0IFtzdHIsIHN0cmVhbXNdID0gdGhpcy5yZWN1cnNpdmVUb1N0cmluZyh0aGlzLnJlbmRlcmVkLCB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdLCBvbmx5Q2lkcywgdHJ1ZSwge30pXG4gICAgcmV0dXJuIFtzdHIsIHN0cmVhbXNdXG4gIH1cblxuICByZWN1cnNpdmVUb1N0cmluZyhyZW5kZXJlZCwgY29tcG9uZW50cyA9IHJlbmRlcmVkW0NPTVBPTkVOVFNdLCBvbmx5Q2lkcywgY2hhbmdlVHJhY2tpbmcsIHJvb3RBdHRycyl7XG4gICAgb25seUNpZHMgPSBvbmx5Q2lkcyA/IG5ldyBTZXQob25seUNpZHMpIDogbnVsbFxuICAgIGxldCBvdXRwdXQgPSB7YnVmZmVyOiBcIlwiLCBjb21wb25lbnRzOiBjb21wb25lbnRzLCBvbmx5Q2lkczogb25seUNpZHMsIHN0cmVhbXM6IG5ldyBTZXQoKX1cbiAgICB0aGlzLnRvT3V0cHV0QnVmZmVyKHJlbmRlcmVkLCBudWxsLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nLCByb290QXR0cnMpXG4gICAgcmV0dXJuIFtvdXRwdXQuYnVmZmVyLCBvdXRwdXQuc3RyZWFtc11cbiAgfVxuXG4gIGNvbXBvbmVudENJRHMoZGlmZil7IHJldHVybiBPYmplY3Qua2V5cyhkaWZmW0NPTVBPTkVOVFNdIHx8IHt9KS5tYXAoaSA9PiBwYXJzZUludChpKSkgfVxuXG4gIGlzQ29tcG9uZW50T25seURpZmYoZGlmZil7XG4gICAgaWYoIWRpZmZbQ09NUE9ORU5UU10peyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhkaWZmKS5sZW5ndGggPT09IDFcbiAgfVxuXG4gIGdldENvbXBvbmVudChkaWZmLCBjaWQpeyByZXR1cm4gZGlmZltDT01QT05FTlRTXVtjaWRdIH1cblxuICByZXNldFJlbmRlcihjaWQpe1xuICAgIC8vIHdlIGFyZSByYWNpbmcgYSBjb21wb25lbnQgZGVzdHJveSwgaXQgY291bGQgbm90IGV4aXN0LCBzb1xuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IHRyeSB0byBzZXQgcmVzZXQgb24gdW5kZWZpbmVkXG4gICAgaWYodGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXVtjaWRdKXtcbiAgICAgIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU11bY2lkXS5yZXNldCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBtZXJnZURpZmYoZGlmZil7XG4gICAgbGV0IG5ld2MgPSBkaWZmW0NPTVBPTkVOVFNdXG4gICAgbGV0IGNhY2hlID0ge31cbiAgICBkZWxldGUgZGlmZltDT01QT05FTlRTXVxuICAgIHRoaXMucmVuZGVyZWQgPSB0aGlzLm11dGFibGVNZXJnZSh0aGlzLnJlbmRlcmVkLCBkaWZmKVxuICAgIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10gPSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdIHx8IHt9XG5cbiAgICBpZihuZXdjKXtcbiAgICAgIGxldCBvbGRjID0gdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXVxuXG4gICAgICBmb3IobGV0IGNpZCBpbiBuZXdjKXtcbiAgICAgICAgbmV3Y1tjaWRdID0gdGhpcy5jYWNoZWRGaW5kQ29tcG9uZW50KGNpZCwgbmV3Y1tjaWRdLCBvbGRjLCBuZXdjLCBjYWNoZSlcbiAgICAgIH1cblxuICAgICAgZm9yKGxldCBjaWQgaW4gbmV3Yyl7IG9sZGNbY2lkXSA9IG5ld2NbY2lkXSB9XG4gICAgICBkaWZmW0NPTVBPTkVOVFNdID0gbmV3Y1xuICAgIH1cbiAgfVxuXG4gIGNhY2hlZEZpbmRDb21wb25lbnQoY2lkLCBjZGlmZiwgb2xkYywgbmV3YywgY2FjaGUpe1xuICAgIGlmKGNhY2hlW2NpZF0pe1xuICAgICAgcmV0dXJuIGNhY2hlW2NpZF1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG5kaWZmLCBzdGF0LCBzY2lkID0gY2RpZmZbU1RBVElDXVxuXG4gICAgICBpZihpc0NpZChzY2lkKSl7XG4gICAgICAgIGxldCB0ZGlmZlxuXG4gICAgICAgIGlmKHNjaWQgPiAwKXtcbiAgICAgICAgICB0ZGlmZiA9IHRoaXMuY2FjaGVkRmluZENvbXBvbmVudChzY2lkLCBuZXdjW3NjaWRdLCBvbGRjLCBuZXdjLCBjYWNoZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZGlmZiA9IG9sZGNbLXNjaWRdXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ID0gdGRpZmZbU1RBVElDXVxuICAgICAgICBuZGlmZiA9IHRoaXMuY2xvbmVNZXJnZSh0ZGlmZiwgY2RpZmYsIHRydWUpXG4gICAgICAgIG5kaWZmW1NUQVRJQ10gPSBzdGF0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZGlmZiA9IGNkaWZmW1NUQVRJQ10gIT09IHVuZGVmaW5lZCB8fCBvbGRjW2NpZF0gPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgY2RpZmYgOiB0aGlzLmNsb25lTWVyZ2Uob2xkY1tjaWRdLCBjZGlmZiwgZmFsc2UpXG4gICAgICB9XG5cbiAgICAgIGNhY2hlW2NpZF0gPSBuZGlmZlxuICAgICAgcmV0dXJuIG5kaWZmXG4gICAgfVxuICB9XG5cbiAgbXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKXtcbiAgICBpZihzb3VyY2VbU1RBVElDXSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgIHJldHVybiBzb3VyY2VcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb011dGFibGVNZXJnZSh0YXJnZXQsIHNvdXJjZSlcbiAgICAgIHJldHVybiB0YXJnZXRcbiAgICB9XG4gIH1cblxuICBkb011dGFibGVNZXJnZSh0YXJnZXQsIHNvdXJjZSl7XG4gICAgZm9yKGxldCBrZXkgaW4gc291cmNlKXtcbiAgICAgIGxldCB2YWwgPSBzb3VyY2Vba2V5XVxuICAgICAgbGV0IHRhcmdldFZhbCA9IHRhcmdldFtrZXldXG4gICAgICBsZXQgaXNPYmpWYWwgPSBpc09iamVjdCh2YWwpXG4gICAgICBpZihpc09ialZhbCAmJiB2YWxbU1RBVElDXSA9PT0gdW5kZWZpbmVkICYmIGlzT2JqZWN0KHRhcmdldFZhbCkpe1xuICAgICAgICB0aGlzLmRvTXV0YWJsZU1lcmdlKHRhcmdldFZhbCwgdmFsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWxcbiAgICAgIH1cbiAgICB9XG4gICAgaWYodGFyZ2V0W1JPT1RdKXtcbiAgICAgIHRhcmdldC5uZXdSZW5kZXIgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgLy8gTWVyZ2VzIGNpZCB0cmVlcyB0b2dldGhlciwgY29weWluZyBzdGF0aWNzIGZyb20gc291cmNlIHRyZWUuXG4gIC8vXG4gIC8vIFRoZSBgcHJ1bmVNYWdpY0lkYCBpcyBwYXNzZWQgdG8gY29udHJvbCBwcnVuaW5nIHRoZSBtYWdpY0lkIG9mIHRoZVxuICAvLyB0YXJnZXQuIFdlIG11c3QgYWx3YXlzIHBydW5lIHRoZSBtYWdpY0lkIHdoZW4gd2UgYXJlIHNoYXJpbmcgc3RhdGljc1xuICAvLyBmcm9tIGFub3RoZXIgY29tcG9uZW50LiBJZiBub3QgcHJ1bmluZywgd2UgcmVwbGljYXRlIHRoZSBsb2dpYyBmcm9tXG4gIC8vIG11dGFibGVNZXJnZSwgd2hlcmUgd2Ugc2V0IG5ld1JlbmRlciB0byB0cnVlIGlmIHRoZXJlIGlzIGEgcm9vdFxuICAvLyAoZWZmZWN0aXZlbHkgZm9yY2luZyB0aGUgbmV3IHZlcnNpb24gdG8gYmUgcmVuZGVyZWQgaW5zdGVhZCBvZiBza2lwcGVkKVxuICAvL1xuICBjbG9uZU1lcmdlKHRhcmdldCwgc291cmNlLCBwcnVuZU1hZ2ljSWQpe1xuICAgIGxldCBtZXJnZWQgPSB7Li4udGFyZ2V0LCAuLi5zb3VyY2V9XG4gICAgZm9yKGxldCBrZXkgaW4gbWVyZ2VkKXtcbiAgICAgIGxldCB2YWwgPSBzb3VyY2Vba2V5XVxuICAgICAgbGV0IHRhcmdldFZhbCA9IHRhcmdldFtrZXldXG4gICAgICBpZihpc09iamVjdCh2YWwpICYmIHZhbFtTVEFUSUNdID09PSB1bmRlZmluZWQgJiYgaXNPYmplY3QodGFyZ2V0VmFsKSl7XG4gICAgICAgIG1lcmdlZFtrZXldID0gdGhpcy5jbG9uZU1lcmdlKHRhcmdldFZhbCwgdmFsLCBwcnVuZU1hZ2ljSWQpXG4gICAgICB9IGVsc2UgaWYodmFsID09PSB1bmRlZmluZWQgJiYgaXNPYmplY3QodGFyZ2V0VmFsKSl7XG4gICAgICAgIG1lcmdlZFtrZXldID0gdGhpcy5jbG9uZU1lcmdlKHRhcmdldFZhbCwge30sIHBydW5lTWFnaWNJZClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYocHJ1bmVNYWdpY0lkKXtcbiAgICAgIGRlbGV0ZSBtZXJnZWQubWFnaWNJZFxuICAgICAgZGVsZXRlIG1lcmdlZC5uZXdSZW5kZXJcbiAgICB9IGVsc2UgaWYodGFyZ2V0W1JPT1RdKXtcbiAgICAgIG1lcmdlZC5uZXdSZW5kZXIgPSB0cnVlXG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRcbiAgfVxuXG4gIGNvbXBvbmVudFRvU3RyaW5nKGNpZCl7XG4gICAgbGV0IFtzdHIsIHN0cmVhbXNdID0gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyh0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdLCBjaWQsIG51bGwpXG4gICAgbGV0IFtzdHJpcHBlZEhUTUwsIF9iZWZvcmUsIF9hZnRlcl0gPSBtb2RpZnlSb290KHN0ciwge30pXG4gICAgcmV0dXJuIFtzdHJpcHBlZEhUTUwsIHN0cmVhbXNdXG4gIH1cblxuICBwcnVuZUNJRHMoY2lkcyl7XG4gICAgY2lkcy5mb3JFYWNoKGNpZCA9PiBkZWxldGUgdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXVtjaWRdKVxuICB9XG5cbiAgLy8gcHJpdmF0ZVxuXG4gIGdldCgpeyByZXR1cm4gdGhpcy5yZW5kZXJlZCB9XG5cbiAgaXNOZXdGaW5nZXJwcmludChkaWZmID0ge30peyByZXR1cm4gISFkaWZmW1NUQVRJQ10gfVxuXG4gIHRlbXBsYXRlU3RhdGljKHBhcnQsIHRlbXBsYXRlcyl7XG4gICAgaWYodHlwZW9mIChwYXJ0KSA9PT0gXCJudW1iZXJcIil7XG4gICAgICByZXR1cm4gdGVtcGxhdGVzW3BhcnRdXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJ0XG4gICAgfVxuICB9XG5cbiAgbmV4dE1hZ2ljSUQoKXtcbiAgICB0aGlzLm1hZ2ljSWQrK1xuICAgIHJldHVybiBgbSR7dGhpcy5tYWdpY0lkfS0ke3RoaXMucGFyZW50Vmlld0lkKCl9YFxuICB9XG5cbiAgLy8gQ29udmVydHMgcmVuZGVyZWQgdHJlZSB0byBvdXRwdXQgYnVmZmVyLlxuICAvL1xuICAvLyBjaGFuZ2VUcmFja2luZyBjb250cm9scyBpZiB3ZSBjYW4gYXBwbHkgdGhlIFBIWF9TS0lQIG9wdGltaXphdGlvbi5cbiAgLy8gSXQgaXMgZGlzYWJsZWQgZm9yIGNvbXByZWhlbnNpb25zIHNpbmNlIHdlIG11c3QgcmUtcmVuZGVyIHRoZSBlbnRpcmUgY29sbGVjdGlvblxuICAvLyBhbmQgbm8gaW5kaXZpZHVhbCBlbGVtZW50IGlzIHRyYWNrZWQgaW5zaWRlIHRoZSBjb21wcmVoZW5zaW9uLlxuICB0b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nLCByb290QXR0cnMgPSB7fSl7XG4gICAgaWYocmVuZGVyZWRbRFlOQU1JQ1NdKXsgcmV0dXJuIHRoaXMuY29tcHJlaGVuc2lvblRvQnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCkgfVxuICAgIGxldCB7W1NUQVRJQ106IHN0YXRpY3N9ID0gcmVuZGVyZWRcbiAgICBzdGF0aWNzID0gdGhpcy50ZW1wbGF0ZVN0YXRpYyhzdGF0aWNzLCB0ZW1wbGF0ZXMpXG4gICAgbGV0IGlzUm9vdCA9IHJlbmRlcmVkW1JPT1RdXG4gICAgbGV0IHByZXZCdWZmZXIgPSBvdXRwdXQuYnVmZmVyXG4gICAgaWYoaXNSb290KXsgb3V0cHV0LmJ1ZmZlciA9IFwiXCIgfVxuXG4gICAgLy8gdGhpcyBjb25kaXRpb24gaXMgY2FsbGVkIHdoZW4gZmlyc3QgcmVuZGVyaW5nIGFuIG9wdGltaXphYmxlIGZ1bmN0aW9uIGNvbXBvbmVudC5cbiAgICAvLyBMQyBoYXZlIHRoZWlyIG1hZ2ljSWQgcHJldmlvdXNseSBzZXRcbiAgICBpZihjaGFuZ2VUcmFja2luZyAmJiBpc1Jvb3QgJiYgIXJlbmRlcmVkLm1hZ2ljSWQpe1xuICAgICAgcmVuZGVyZWQubmV3UmVuZGVyID0gdHJ1ZVxuICAgICAgcmVuZGVyZWQubWFnaWNJZCA9IHRoaXMubmV4dE1hZ2ljSUQoKVxuICAgIH1cblxuICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1swXVxuICAgIGZvcihsZXQgaSA9IDE7IGkgPCBzdGF0aWNzLmxlbmd0aDsgaSsrKXtcbiAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKHJlbmRlcmVkW2kgLSAxXSwgdGVtcGxhdGVzLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nKVxuICAgICAgb3V0cHV0LmJ1ZmZlciArPSBzdGF0aWNzW2ldXG4gICAgfVxuXG4gICAgLy8gQXBwbGllcyB0aGUgcm9vdCB0YWcgXCJza2lwXCIgb3B0aW1pemF0aW9uIGlmIHN1cHBvcnRlZCwgd2hpY2ggY2xlYXJzXG4gICAgLy8gdGhlIHJvb3QgdGFnIGF0dHJpYnV0ZXMgYW5kIGlubmVySFRNTCwgYW5kIG9ubHkgbWFpbnRhaW5zIHRoZSBtYWdpY0lkLlxuICAgIC8vIFdlIGNhbiBvbmx5IHNraXAgd2hlbiBjaGFuZ2VUcmFja2luZyBpcyBzdXBwb3J0ZWQgKG91dHNpZGUgb2YgYSBjb21wcmVoZW5zaW9uKSxcbiAgICAvLyBhbmQgd2hlbiB0aGUgcm9vdCBlbGVtZW50IGhhc24ndCBleHBlcmllbmNlZCBhbiB1bnJlbmRlcmVkIG1lcmdlIChuZXdSZW5kZXIgdHJ1ZSkuXG4gICAgaWYoaXNSb290KXtcbiAgICAgIGxldCBza2lwID0gZmFsc2VcbiAgICAgIGxldCBhdHRyc1xuICAgICAgLy8gV2hlbiBhIExDIGlzIHJlLWFkZGVkIHRvIHRoZSBwYWdlLCB3ZSBuZWVkIHRvIHJlLXJlbmRlciB0aGUgZW50aXJlIExDIHRyZWUsXG4gICAgICAvLyB0aGVyZWZvcmUgY2hhbmdlVHJhY2tpbmcgaXMgZmFsc2U7IGhvd2V2ZXIsIHdlIG5lZWQgdG8ga2VlcCBhbGwgdGhlIG1hZ2ljSWRzXG4gICAgICAvLyBmcm9tIGFueSBmdW5jdGlvbiBjb21wb25lbnQgc28gdGhlIG5leHQgdGltZSB0aGUgTEMgaXMgdXBkYXRlZCwgd2UgY2FuIGFwcGx5XG4gICAgICAvLyB0aGUgc2tpcCBvcHRpbWl6YXRpb25cbiAgICAgIGlmKGNoYW5nZVRyYWNraW5nIHx8IHJlbmRlcmVkLm1hZ2ljSWQpe1xuICAgICAgICBza2lwID0gY2hhbmdlVHJhY2tpbmcgJiYgIXJlbmRlcmVkLm5ld1JlbmRlclxuICAgICAgICBhdHRycyA9IHtbUEhYX01BR0lDX0lEXTogcmVuZGVyZWQubWFnaWNJZCwgLi4ucm9vdEF0dHJzfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnMgPSByb290QXR0cnNcbiAgICAgIH1cbiAgICAgIGlmKHNraXApeyBhdHRyc1tQSFhfU0tJUF0gPSB0cnVlIH1cbiAgICAgIGxldCBbbmV3Um9vdCwgY29tbWVudEJlZm9yZSwgY29tbWVudEFmdGVyXSA9IG1vZGlmeVJvb3Qob3V0cHV0LmJ1ZmZlciwgYXR0cnMsIHNraXApXG4gICAgICByZW5kZXJlZC5uZXdSZW5kZXIgPSBmYWxzZVxuICAgICAgb3V0cHV0LmJ1ZmZlciA9IHByZXZCdWZmZXIgKyBjb21tZW50QmVmb3JlICsgbmV3Um9vdCArIGNvbW1lbnRBZnRlclxuICAgIH1cbiAgfVxuXG4gIGNvbXByZWhlbnNpb25Ub0J1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpe1xuICAgIGxldCB7W0RZTkFNSUNTXTogZHluYW1pY3MsIFtTVEFUSUNdOiBzdGF0aWNzLCBbU1RSRUFNXTogc3RyZWFtfSA9IHJlbmRlcmVkXG4gICAgbGV0IFtfcmVmLCBfaW5zZXJ0cywgZGVsZXRlSWRzLCByZXNldF0gPSBzdHJlYW0gfHwgW251bGwsIHt9LCBbXSwgbnVsbF1cbiAgICBzdGF0aWNzID0gdGhpcy50ZW1wbGF0ZVN0YXRpYyhzdGF0aWNzLCB0ZW1wbGF0ZXMpXG4gICAgbGV0IGNvbXBUZW1wbGF0ZXMgPSB0ZW1wbGF0ZXMgfHwgcmVuZGVyZWRbVEVNUExBVEVTXVxuICAgIGZvcihsZXQgZCA9IDA7IGQgPCBkeW5hbWljcy5sZW5ndGg7IGQrKyl7XG4gICAgICBsZXQgZHluYW1pYyA9IGR5bmFtaWNzW2RdXG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbMF1cbiAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBzdGF0aWNzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgLy8gSW5zaWRlIGEgY29tcHJlaGVuc2lvbiwgd2UgZG9uJ3QgdHJhY2sgaG93IGR5bmFtaWNzIGNoYW5nZVxuICAgICAgICAvLyBvdmVyIHRpbWUgKGFuZCBmZWF0dXJlcyBsaWtlIHN0cmVhbXMgd291bGQgbWFrZSB0aGF0IGltcG9zc2libGVcbiAgICAgICAgLy8gdW5sZXNzIHdlIG1vdmUgdGhlIHN0cmVhbSBkaWZmaW5nIGF3YXkgZnJvbSBtb3JwaGRvbSksXG4gICAgICAgIC8vIHNvIHdlIGNhbid0IHBlcmZvcm0gcm9vdCBjaGFuZ2UgdHJhY2tpbmcuXG4gICAgICAgIGxldCBjaGFuZ2VUcmFja2luZyA9IGZhbHNlXG4gICAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKGR5bmFtaWNbaSAtIDFdLCBjb21wVGVtcGxhdGVzLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nKVxuICAgICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbaV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihzdHJlYW0gIT09IHVuZGVmaW5lZCAmJiAocmVuZGVyZWRbRFlOQU1JQ1NdLmxlbmd0aCA+IDAgfHwgZGVsZXRlSWRzLmxlbmd0aCA+IDAgfHwgcmVzZXQpKXtcbiAgICAgIGRlbGV0ZSByZW5kZXJlZFtTVFJFQU1dXG4gICAgICByZW5kZXJlZFtEWU5BTUlDU10gPSBbXVxuICAgICAgb3V0cHV0LnN0cmVhbXMuYWRkKHN0cmVhbSlcbiAgICB9XG4gIH1cblxuICBkeW5hbWljVG9CdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0LCBjaGFuZ2VUcmFja2luZyl7XG4gICAgaWYodHlwZW9mIChyZW5kZXJlZCkgPT09IFwibnVtYmVyXCIpe1xuICAgICAgbGV0IFtzdHIsIHN0cmVhbXNdID0gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyhvdXRwdXQuY29tcG9uZW50cywgcmVuZGVyZWQsIG91dHB1dC5vbmx5Q2lkcylcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RyXG4gICAgICBvdXRwdXQuc3RyZWFtcyA9IG5ldyBTZXQoWy4uLm91dHB1dC5zdHJlYW1zLCAuLi5zdHJlYW1zXSlcbiAgICB9IGVsc2UgaWYoaXNPYmplY3QocmVuZGVyZWQpKXtcbiAgICAgIHRoaXMudG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0LCBjaGFuZ2VUcmFja2luZywge30pXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gcmVuZGVyZWRcbiAgICB9XG4gIH1cblxuICByZWN1cnNpdmVDSURUb1N0cmluZyhjb21wb25lbnRzLCBjaWQsIG9ubHlDaWRzKXtcbiAgICBsZXQgY29tcG9uZW50ID0gY29tcG9uZW50c1tjaWRdIHx8IGxvZ0Vycm9yKGBubyBjb21wb25lbnQgZm9yIENJRCAke2NpZH1gLCBjb21wb25lbnRzKVxuICAgIGxldCBhdHRycyA9IHtbUEhYX0NPTVBPTkVOVF06IGNpZH1cbiAgICBsZXQgc2tpcCA9IG9ubHlDaWRzICYmICFvbmx5Q2lkcy5oYXMoY2lkKVxuICAgIC8vIFR3byBvcHRpbWl6YXRpb24gcGF0aHMgYXBwbHkgaGVyZTpcbiAgICAvL1xuICAgIC8vICAgMS4gVGhlIG9ubHlDaWRzIG9wdGltaXphdGlvbiB3b3JrcyBieSB0aGUgc2VydmVyIGRpZmYgdGVsbGluZyB1cyBvbmx5IHNwZWNpZmljXG4gICAgLy8gICAgIGNpZCdzIGhhdmUgY2hhbmdlZC4gVGhpcyBhbGxvd3MgdXMgdG8gc2tpcCByZW5kZXJpbmcgYW55IGNvbXBvbmVudCB0aGF0IGhhc24ndCBjaGFuZ2VkLFxuICAgIC8vICAgICB3aGljaCB1bHRpbWF0ZWx5IHNldHMgUEhYX1NLSVAgcm9vdCBhdHRyaWJ1dGUgYW5kIGF2b2lkcyByZW5kZXJpbmcgdGhlIGlubmVySFRNTC5cbiAgICAvL1xuICAgIC8vICAgMi4gVGhlIHJvb3QgUEhYX1NLSVAgb3B0aW1pemF0aW9uIGdlbmVyYWxpemVzIHRvIGFsbCBIRUV4IGZ1bmN0aW9uIGNvbXBvbmVudHMsIGFuZFxuICAgIC8vICAgICB3b3JrcyBpbiB0aGUgc2FtZSBQSFhfU0tJUCBhdHRyaWJ1dGUgZmFzaGlvbiBhcyAxLCBidXQgdGhlIG5ld1JlbmRlciB0cmFja2luZyBpcyBkb25lXG4gICAgLy8gICAgIGF0IHRoZSBnZW5lcmFsIGRpZmYgbWVyZ2UgbGV2ZWwuIElmIHdlIG1lcmdlIGEgZGlmZiB3aXRoIG5ldyBkeW5hbWljcywgd2UgbmVjZXNzYXJpbHkgaGF2ZVxuICAgIC8vICAgICBleHBlcmllbmNlZCBhIGNoYW5nZSB3aGljaCBtdXN0IGJlIGEgbmV3UmVuZGVyLCBhbmQgdGh1cyB3ZSBjYW4ndCBza2lwIHRoZSByZW5kZXIuXG4gICAgLy9cbiAgICAvLyBCb3RoIG9wdGltaXphdGlvbiBmbG93cyBhcHBseSBoZXJlLiBuZXdSZW5kZXIgaXMgc2V0IGJhc2VkIG9uIHRoZSBvbmx5Q2lkcyBvcHRpbWl6YXRpb24sIGFuZFxuICAgIC8vIHdlIHRyYWNrIGEgZGV0ZXJtaW5pc3RpYyBtYWdpY0lkIGJhc2VkIG9uIHRoZSBjaWQuXG4gICAgLy9cbiAgICAvLyBjaGFuZ2VUcmFja2luZyBpcyBhYm91dCB0aGUgZW50aXJlIHRyZWVcbiAgICAvLyBuZXdSZW5kZXIgaXMgYWJvdXQgdGhlIGN1cnJlbnQgcm9vdCBpbiB0aGUgdHJlZVxuICAgIC8vXG4gICAgLy8gQnkgZGVmYXVsdCBjaGFuZ2VUcmFja2luZyBpcyBlbmFibGVkLCBidXQgd2Ugc3BlY2lhbCBjYXNlIHRoZSBmbG93IHdoZXJlIHRoZSBjbGllbnQgaXMgcHJ1bmluZ1xuICAgIC8vIGNpZHMgYW5kIHRoZSBzZXJ2ZXIgYWRkcyB0aGUgY29tcG9uZW50IGJhY2suIEluIHN1Y2ggY2FzZXMsIHdlIGV4cGxpY2l0bHkgZGlzYWJsZSBjaGFuZ2VUcmFja2luZ1xuICAgIC8vIHdpdGggcmVzZXRSZW5kZXIgZm9yIHRoaXMgY2lkLCB0aGVuIHJlLWVuYWJsZSBpdCBhZnRlciB0aGUgcmVjdXJzaXZlIGNhbGwgdG8gc2tpcCB0aGUgb3B0aW1pemF0aW9uXG4gICAgLy8gZm9yIHRoZSBlbnRpcmUgY29tcG9uZW50IHRyZWUuXG4gICAgY29tcG9uZW50Lm5ld1JlbmRlciA9ICFza2lwXG4gICAgY29tcG9uZW50Lm1hZ2ljSWQgPSBgYyR7Y2lkfS0ke3RoaXMucGFyZW50Vmlld0lkKCl9YFxuICAgIC8vIGVuYWJsZSBjaGFuZ2UgdHJhY2tpbmcgYXMgbG9uZyBhcyB0aGUgY29tcG9uZW50IGhhc24ndCBiZWVuIHJlc2V0XG4gICAgbGV0IGNoYW5nZVRyYWNraW5nID0gIWNvbXBvbmVudC5yZXNldFxuICAgIGxldCBbaHRtbCwgc3RyZWFtc10gPSB0aGlzLnJlY3Vyc2l2ZVRvU3RyaW5nKGNvbXBvbmVudCwgY29tcG9uZW50cywgb25seUNpZHMsIGNoYW5nZVRyYWNraW5nLCBhdHRycylcbiAgICAvLyBkaXNhYmxlIHJlc2V0IGFmdGVyIHdlJ3ZlIHJlbmRlcmVkXG4gICAgZGVsZXRlIGNvbXBvbmVudC5yZXNldFxuXG4gICAgcmV0dXJuIFtodG1sLCBzdHJlYW1zXVxuICB9XG59XG4iLCAiaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IEFSSUEgZnJvbSBcIi4vYXJpYVwiXG5cbmxldCBmb2N1c1N0YWNrID0gW11cbmxldCBkZWZhdWx0X3RyYW5zaXRpb25fdGltZSA9IDIwMFxuXG5sZXQgSlMgPSB7XG4gIC8vIHByaXZhdGVcbiAgZXhlYyhlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZGVmYXVsdHMpe1xuICAgIGxldCBbZGVmYXVsdEtpbmQsIGRlZmF1bHRBcmdzXSA9IGRlZmF1bHRzIHx8IFtudWxsLCB7Y2FsbGJhY2s6IGRlZmF1bHRzICYmIGRlZmF1bHRzLmNhbGxiYWNrfV1cbiAgICBsZXQgY29tbWFuZHMgPSBwaHhFdmVudC5jaGFyQXQoMCkgPT09IFwiW1wiID9cbiAgICAgIEpTT04ucGFyc2UocGh4RXZlbnQpIDogW1tkZWZhdWx0S2luZCwgZGVmYXVsdEFyZ3NdXVxuXG4gICAgY29tbWFuZHMuZm9yRWFjaCgoW2tpbmQsIGFyZ3NdKSA9PiB7XG4gICAgICBpZihraW5kID09PSBkZWZhdWx0S2luZCl7XG4gICAgICAgIC8vIGFsd2F5cyBwcmVmZXIgdGhlIGFyZ3MsIGJ1dCBrZWVwIGV4aXN0aW5nIGtleXMgZnJvbSB0aGUgZGVmYXVsdEFyZ3NcbiAgICAgICAgYXJncyA9IHsuLi5kZWZhdWx0QXJncywgLi4uYXJnc31cbiAgICAgICAgYXJncy5jYWxsYmFjayA9IGFyZ3MuY2FsbGJhY2sgfHwgZGVmYXVsdEFyZ3MuY2FsbGJhY2tcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlsdGVyVG9FbHModmlldy5saXZlU29ja2V0LCBzb3VyY2VFbCwgYXJncykuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIHRoaXNbYGV4ZWNfJHtraW5kfWBdKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgYXJncylcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcblxuICBpc1Zpc2libGUoZWwpe1xuICAgIHJldHVybiAhIShlbC5vZmZzZXRXaWR0aCB8fCBlbC5vZmZzZXRIZWlnaHQgfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPiAwKVxuICB9LFxuXG4gIC8vIHJldHVybnMgdHJ1ZSBpZiBhbnkgcGFydCBvZiB0aGUgZWxlbWVudCBpcyBpbnNpZGUgdGhlIHZpZXdwb3J0XG4gIGlzSW5WaWV3cG9ydChlbCl7XG4gICAgY29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3Qgd2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICBjb25zdCB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aFxuXG4gICAgcmV0dXJuIChcbiAgICAgIHJlY3QucmlnaHQgPiAwICYmXG4gICAgICByZWN0LmJvdHRvbSA+IDAgJiZcbiAgICAgIHJlY3QubGVmdCA8IHdpbmRvd1dpZHRoICYmXG4gICAgICByZWN0LnRvcCA8IHdpbmRvd0hlaWdodFxuICAgIClcbiAgfSxcblxuICAvLyBwcml2YXRlXG5cbiAgLy8gY29tbWFuZHNcblxuICBleGVjX2V4ZWMoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7YXR0ciwgdG99KXtcbiAgICBsZXQgbm9kZXMgPSB0byA/IERPTS5hbGwoZG9jdW1lbnQsIHRvKSA6IFtzb3VyY2VFbF1cbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgbGV0IGVuY29kZWRKUyA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHIpXG4gICAgICBpZighZW5jb2RlZEpTKXsgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke2F0dHJ9IHRvIGNvbnRhaW4gSlMgY29tbWFuZCBvbiBcIiR7dG99XCJgKSB9XG4gICAgICB2aWV3LmxpdmVTb2NrZXQuZXhlY0pTKG5vZGUsIGVuY29kZWRKUywgZXZlbnRUeXBlKVxuICAgIH0pXG4gIH0sXG5cbiAgZXhlY19kaXNwYXRjaChlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtldmVudCwgZGV0YWlsLCBidWJibGVzfSl7XG4gICAgZGV0YWlsID0gZGV0YWlsIHx8IHt9XG4gICAgZGV0YWlsLmRpc3BhdGNoZXIgPSBzb3VyY2VFbFxuICAgIERPTS5kaXNwYXRjaEV2ZW50KGVsLCBldmVudCwge2RldGFpbCwgYnViYmxlc30pXG4gIH0sXG5cbiAgZXhlY19wdXNoKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgYXJncyl7XG4gICAgbGV0IHtldmVudCwgZGF0YSwgdGFyZ2V0LCBwYWdlX2xvYWRpbmcsIGxvYWRpbmcsIHZhbHVlLCBkaXNwYXRjaGVyLCBjYWxsYmFja30gPSBhcmdzXG4gICAgbGV0IHB1c2hPcHRzID0ge2xvYWRpbmcsIHZhbHVlLCB0YXJnZXQsIHBhZ2VfbG9hZGluZzogISFwYWdlX2xvYWRpbmd9XG4gICAgbGV0IHRhcmdldFNyYyA9IGV2ZW50VHlwZSA9PT0gXCJjaGFuZ2VcIiAmJiBkaXNwYXRjaGVyID8gZGlzcGF0Y2hlciA6IHNvdXJjZUVsXG4gICAgbGV0IHBoeFRhcmdldCA9IHRhcmdldCB8fCB0YXJnZXRTcmMuZ2V0QXR0cmlidXRlKHZpZXcuYmluZGluZyhcInRhcmdldFwiKSkgfHwgdGFyZ2V0U3JjXG4gICAgY29uc3QgaGFuZGxlciA9ICh0YXJnZXRWaWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIGlmKCF0YXJnZXRWaWV3LmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuICAgICAgaWYoZXZlbnRUeXBlID09PSBcImNoYW5nZVwiKXtcbiAgICAgICAgbGV0IHtuZXdDaWQsIF90YXJnZXR9ID0gYXJnc1xuICAgICAgICBfdGFyZ2V0ID0gX3RhcmdldCB8fCAoRE9NLmlzRm9ybUlucHV0KHNvdXJjZUVsKSA/IHNvdXJjZUVsLm5hbWUgOiB1bmRlZmluZWQpXG4gICAgICAgIGlmKF90YXJnZXQpeyBwdXNoT3B0cy5fdGFyZ2V0ID0gX3RhcmdldCB9XG4gICAgICAgIHRhcmdldFZpZXcucHVzaElucHV0KHNvdXJjZUVsLCB0YXJnZXRDdHgsIG5ld0NpZCwgZXZlbnQgfHwgcGh4RXZlbnQsIHB1c2hPcHRzLCBjYWxsYmFjaylcbiAgICAgIH0gZWxzZSBpZihldmVudFR5cGUgPT09IFwic3VibWl0XCIpe1xuICAgICAgICBsZXQge3N1Ym1pdHRlcn0gPSBhcmdzXG4gICAgICAgIHRhcmdldFZpZXcuc3VibWl0Rm9ybShzb3VyY2VFbCwgdGFyZ2V0Q3R4LCBldmVudCB8fCBwaHhFdmVudCwgc3VibWl0dGVyLCBwdXNoT3B0cywgY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRWaWV3LnB1c2hFdmVudChldmVudFR5cGUsIHNvdXJjZUVsLCB0YXJnZXRDdHgsIGV2ZW50IHx8IHBoeEV2ZW50LCBkYXRhLCBwdXNoT3B0cywgY2FsbGJhY2spXG4gICAgICB9XG4gICAgfVxuICAgIC8vIGluIGNhc2Ugb2YgZm9ybVJlY292ZXJ5LCB0YXJnZXRWaWV3IGFuZCB0YXJnZXRDdHggYXJlIHBhc3NlZCBhcyBhcmd1bWVudFxuICAgIC8vIGFzIHRoZXkgYXJlIGxvb2tlZCB1cCBpbiBhIHRlbXBsYXRlIGVsZW1lbnQsIG5vdCB0aGUgcmVhbCBET01cbiAgICBpZihhcmdzLnRhcmdldFZpZXcgJiYgYXJncy50YXJnZXRDdHgpe1xuICAgICAgaGFuZGxlcihhcmdzLnRhcmdldFZpZXcsIGFyZ3MudGFyZ2V0Q3R4KVxuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3LndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCBoYW5kbGVyKVxuICAgIH1cbiAgfSxcblxuICBleGVjX25hdmlnYXRlKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2hyZWYsIHJlcGxhY2V9KXtcbiAgICB2aWV3LmxpdmVTb2NrZXQuaGlzdG9yeVJlZGlyZWN0KGUsIGhyZWYsIHJlcGxhY2UgPyBcInJlcGxhY2VcIiA6IFwicHVzaFwiLCBudWxsLCBzb3VyY2VFbClcbiAgfSxcblxuICBleGVjX3BhdGNoKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2hyZWYsIHJlcGxhY2V9KXtcbiAgICB2aWV3LmxpdmVTb2NrZXQucHVzaEhpc3RvcnlQYXRjaChlLCBocmVmLCByZXBsYWNlID8gXCJyZXBsYWNlXCIgOiBcInB1c2hcIiwgc291cmNlRWwpXG4gIH0sXG5cbiAgZXhlY19mb2N1cyhlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwpe1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gQVJJQS5hdHRlbXB0Rm9jdXMoZWwpKVxuICB9LFxuXG4gIGV4ZWNfZm9jdXNfZmlyc3QoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsKXtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IEFSSUEuZm9jdXNGaXJzdEludGVyYWN0aXZlKGVsKSB8fCBBUklBLmZvY3VzRmlyc3QoZWwpKVxuICB9LFxuXG4gIGV4ZWNfcHVzaF9mb2N1cyhlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwpe1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gZm9jdXNTdGFjay5wdXNoKGVsIHx8IHNvdXJjZUVsKSlcbiAgfSxcblxuICBleGVjX3BvcF9mb2N1cyhfZSwgX2V2ZW50VHlwZSwgX3BoeEV2ZW50LCBfdmlldywgX3NvdXJjZUVsLCBfZWwpe1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgY29uc3QgZWwgPSBmb2N1c1N0YWNrLnBvcCgpXG4gICAgICBpZihlbCl7IGVsLmZvY3VzKCkgfVxuICAgIH0pXG4gIH0sXG5cbiAgZXhlY19hZGRfY2xhc3MoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7bmFtZXMsIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nfSl7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG5hbWVzLCBbXSwgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpXG4gIH0sXG5cbiAgZXhlY19yZW1vdmVfY2xhc3MoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7bmFtZXMsIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nfSl7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBuYW1lcywgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpXG4gIH0sXG5cbiAgZXhlY190b2dnbGVfY2xhc3MoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7bmFtZXMsIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nfSl7XG4gICAgdGhpcy50b2dnbGVDbGFzc2VzKGVsLCBuYW1lcywgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpXG4gIH0sXG5cbiAgZXhlY190b2dnbGVfYXR0cihlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHthdHRyOiBbYXR0ciwgdmFsMSwgdmFsMl19KXtcbiAgICB0aGlzLnRvZ2dsZUF0dHIoZWwsIGF0dHIsIHZhbDEsIHZhbDIpXG4gIH0sXG5cbiAgZXhlY190cmFuc2l0aW9uKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge3RpbWUsIHRyYW5zaXRpb24sIGJsb2NraW5nfSl7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBbXSwgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpXG4gIH0sXG5cbiAgZXhlY190b2dnbGUoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7ZGlzcGxheSwgaW5zLCBvdXRzLCB0aW1lLCBibG9ja2luZ30pe1xuICAgIHRoaXMudG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIGlucywgb3V0cywgdGltZSwgYmxvY2tpbmcpXG4gIH0sXG5cbiAgZXhlY19zaG93KGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2Rpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nfSl7XG4gICAgdGhpcy5zaG93KGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nKVxuICB9LFxuXG4gIGV4ZWNfaGlkZShlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lLCBibG9ja2luZ30pe1xuICAgIHRoaXMuaGlkZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lLCBibG9ja2luZylcbiAgfSxcblxuICBleGVjX3NldF9hdHRyKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2F0dHI6IFthdHRyLCB2YWxdfSl7XG4gICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbF1dLCBbXSlcbiAgfSxcblxuICBleGVjX3JlbW92ZV9hdHRyKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2F0dHJ9KXtcbiAgICB0aGlzLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtdLCBbYXR0cl0pXG4gIH0sXG5cbiAgLy8gdXRpbHMgZm9yIGNvbW1hbmRzXG5cbiAgc2hvdyhldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lLCBibG9ja2luZyl7XG4gICAgaWYoIXRoaXMuaXNWaXNpYmxlKGVsKSl7XG4gICAgICB0aGlzLnRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCBudWxsLCB0aW1lLCBibG9ja2luZylcbiAgICB9XG4gIH0sXG5cbiAgaGlkZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lLCBibG9ja2luZyl7XG4gICAgaWYodGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgIHRoaXMudG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIG51bGwsIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nKVxuICAgIH1cbiAgfSxcblxuICB0b2dnbGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgaW5zLCBvdXRzLCB0aW1lLCBibG9ja2luZyl7XG4gICAgdGltZSA9IHRpbWUgfHwgZGVmYXVsdF90cmFuc2l0aW9uX3RpbWVcbiAgICBsZXQgW2luQ2xhc3NlcywgaW5TdGFydENsYXNzZXMsIGluRW5kQ2xhc3Nlc10gPSBpbnMgfHwgW1tdLCBbXSwgW11dXG4gICAgbGV0IFtvdXRDbGFzc2VzLCBvdXRTdGFydENsYXNzZXMsIG91dEVuZENsYXNzZXNdID0gb3V0cyB8fCBbW10sIFtdLCBbXV1cbiAgICBpZihpbkNsYXNzZXMubGVuZ3RoID4gMCB8fCBvdXRDbGFzc2VzLmxlbmd0aCA+IDApe1xuICAgICAgaWYodGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG91dFN0YXJ0Q2xhc3NlcywgaW5DbGFzc2VzLmNvbmNhdChpblN0YXJ0Q2xhc3NlcykuY29uY2F0KGluRW5kQ2xhc3NlcykpXG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgb3V0Q2xhc3NlcywgW10pXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBvdXRFbmRDbGFzc2VzLCBvdXRTdGFydENsYXNzZXMpKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9uRW5kID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBbXSwgb3V0Q2xhc3Nlcy5jb25jYXQob3V0RW5kQ2xhc3NlcykpXG4gICAgICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgY3VycmVudEVsID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1lbmRcIikpXG4gICAgICAgIH1cbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1zdGFydFwiKSlcbiAgICAgICAgaWYoYmxvY2tpbmcgPT09IGZhbHNlKXtcbiAgICAgICAgICBvblN0YXJ0KClcbiAgICAgICAgICBzZXRUaW1lb3V0KG9uRW5kLCB0aW1lKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkVuZClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoZXZlbnRUeXBlID09PSBcInJlbW92ZVwiKXsgcmV0dXJuIH1cbiAgICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGluU3RhcnRDbGFzc2VzLCBvdXRDbGFzc2VzLmNvbmNhdChvdXRTdGFydENsYXNzZXMpLmNvbmNhdChvdXRFbmRDbGFzc2VzKSlcbiAgICAgICAgICBsZXQgc3RpY2t5RGlzcGxheSA9IGRpc3BsYXkgfHwgdGhpcy5kZWZhdWx0RGlzcGxheShlbClcbiAgICAgICAgICBET00ucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCBjdXJyZW50RWwgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBzdGlja3lEaXNwbGF5KVxuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGluQ2xhc3NlcywgW10pXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBpbkVuZENsYXNzZXMsIGluU3RhcnRDbGFzc2VzKSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGxldCBvbkVuZCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIGluQ2xhc3Nlcy5jb25jYXQoaW5FbmRDbGFzc2VzKSlcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LWVuZFwiKSlcbiAgICAgICAgfVxuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LXN0YXJ0XCIpKVxuICAgICAgICBpZihibG9ja2luZyA9PT0gZmFsc2Upe1xuICAgICAgICAgIG9uU3RhcnQoKVxuICAgICAgICAgIHNldFRpbWVvdXQob25FbmQsIHRpbWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmlldy50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRW5kKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKHRoaXMuaXNWaXNpYmxlKGVsKSl7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtc3RhcnRcIikpXG4gICAgICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgY3VycmVudEVsID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1lbmRcIikpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LXN0YXJ0XCIpKVxuICAgICAgICAgIGxldCBzdGlja3lEaXNwbGF5ID0gZGlzcGxheSB8fCB0aGlzLmRlZmF1bHREaXNwbGF5KGVsKVxuICAgICAgICAgIERPTS5wdXRTdGlja3koZWwsIFwidG9nZ2xlXCIsIGN1cnJlbnRFbCA9PiBjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IHN0aWNreURpc3BsYXkpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1lbmRcIikpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRvZ2dsZUNsYXNzZXMoZWwsIGNsYXNzZXMsIHRyYW5zaXRpb24sIHRpbWUsIHZpZXcsIGJsb2NraW5nKXtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGxldCBbcHJldkFkZHMsIHByZXZSZW1vdmVzXSA9IERPTS5nZXRTdGlja3koZWwsIFwiY2xhc3Nlc1wiLCBbW10sIFtdXSlcbiAgICAgIGxldCBuZXdBZGRzID0gY2xhc3Nlcy5maWx0ZXIobmFtZSA9PiBwcmV2QWRkcy5pbmRleE9mKG5hbWUpIDwgMCAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKVxuICAgICAgbGV0IG5ld1JlbW92ZXMgPSBjbGFzc2VzLmZpbHRlcihuYW1lID0+IHByZXZSZW1vdmVzLmluZGV4T2YobmFtZSkgPCAwICYmIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSlcbiAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBuZXdBZGRzLCBuZXdSZW1vdmVzLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3LCBibG9ja2luZylcbiAgICB9KVxuICB9LFxuXG4gIHRvZ2dsZUF0dHIoZWwsIGF0dHIsIHZhbDEsIHZhbDIpe1xuICAgIGlmKGVsLmhhc0F0dHJpYnV0ZShhdHRyKSl7XG4gICAgICBpZih2YWwyICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAvLyB0b2dnbGUgYmV0d2VlbiB2YWwxIGFuZCB2YWwyXG4gICAgICAgIGlmKGVsLmdldEF0dHJpYnV0ZShhdHRyKSA9PT0gdmFsMSl7XG4gICAgICAgICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbDJdXSwgW10pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbDFdXSwgW10pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlbW92ZSBhdHRyXG4gICAgICAgIHRoaXMuc2V0T3JSZW1vdmVBdHRycyhlbCwgW10sIFthdHRyXSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbDFdXSwgW10pXG4gICAgfVxuICB9LFxuXG4gIGFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgYWRkcywgcmVtb3ZlcywgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpe1xuICAgIHRpbWUgPSB0aW1lIHx8IGRlZmF1bHRfdHJhbnNpdGlvbl90aW1lXG4gICAgbGV0IFt0cmFuc2l0aW9uUnVuLCB0cmFuc2l0aW9uU3RhcnQsIHRyYW5zaXRpb25FbmRdID0gdHJhbnNpdGlvbiB8fCBbW10sIFtdLCBbXV1cbiAgICBpZih0cmFuc2l0aW9uUnVuLmxlbmd0aCA+IDApe1xuICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uU3RhcnQsIFtdLmNvbmNhdCh0cmFuc2l0aW9uUnVuKS5jb25jYXQodHJhbnNpdGlvbkVuZCkpXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uUnVuLCBbXSlcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uRW5kLCB0cmFuc2l0aW9uU3RhcnQpKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgbGV0IG9uRG9uZSA9ICgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBhZGRzLmNvbmNhdCh0cmFuc2l0aW9uRW5kKSwgcmVtb3Zlcy5jb25jYXQodHJhbnNpdGlvblJ1bikuY29uY2F0KHRyYW5zaXRpb25TdGFydCkpXG4gICAgICBpZihibG9ja2luZyA9PT0gZmFsc2Upe1xuICAgICAgICBvblN0YXJ0KClcbiAgICAgICAgc2V0VGltZW91dChvbkRvbmUsIHRpbWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBsZXQgW3ByZXZBZGRzLCBwcmV2UmVtb3Zlc10gPSBET00uZ2V0U3RpY2t5KGVsLCBcImNsYXNzZXNcIiwgW1tdLCBbXV0pXG4gICAgICBsZXQga2VlcEFkZHMgPSBhZGRzLmZpbHRlcihuYW1lID0+IHByZXZBZGRzLmluZGV4T2YobmFtZSkgPCAwICYmICFlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSkpXG4gICAgICBsZXQga2VlcFJlbW92ZXMgPSByZW1vdmVzLmZpbHRlcihuYW1lID0+IHByZXZSZW1vdmVzLmluZGV4T2YobmFtZSkgPCAwICYmIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSlcbiAgICAgIGxldCBuZXdBZGRzID0gcHJldkFkZHMuZmlsdGVyKG5hbWUgPT4gcmVtb3Zlcy5pbmRleE9mKG5hbWUpIDwgMCkuY29uY2F0KGtlZXBBZGRzKVxuICAgICAgbGV0IG5ld1JlbW92ZXMgPSBwcmV2UmVtb3Zlcy5maWx0ZXIobmFtZSA9PiBhZGRzLmluZGV4T2YobmFtZSkgPCAwKS5jb25jYXQoa2VlcFJlbW92ZXMpXG5cbiAgICAgIERPTS5wdXRTdGlja3koZWwsIFwiY2xhc3Nlc1wiLCBjdXJyZW50RWwgPT4ge1xuICAgICAgICBjdXJyZW50RWwuY2xhc3NMaXN0LnJlbW92ZSguLi5uZXdSZW1vdmVzKVxuICAgICAgICBjdXJyZW50RWwuY2xhc3NMaXN0LmFkZCguLi5uZXdBZGRzKVxuICAgICAgICByZXR1cm4gW25ld0FkZHMsIG5ld1JlbW92ZXNdXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG5cbiAgc2V0T3JSZW1vdmVBdHRycyhlbCwgc2V0cywgcmVtb3Zlcyl7XG4gICAgbGV0IFtwcmV2U2V0cywgcHJldlJlbW92ZXNdID0gRE9NLmdldFN0aWNreShlbCwgXCJhdHRyc1wiLCBbW10sIFtdXSlcblxuICAgIGxldCBhbHRlcmVkQXR0cnMgPSBzZXRzLm1hcCgoW2F0dHIsIF92YWxdKSA9PiBhdHRyKS5jb25jYXQocmVtb3ZlcylcbiAgICBsZXQgbmV3U2V0cyA9IHByZXZTZXRzLmZpbHRlcigoW2F0dHIsIF92YWxdKSA9PiAhYWx0ZXJlZEF0dHJzLmluY2x1ZGVzKGF0dHIpKS5jb25jYXQoc2V0cylcbiAgICBsZXQgbmV3UmVtb3ZlcyA9IHByZXZSZW1vdmVzLmZpbHRlcigoYXR0cikgPT4gIWFsdGVyZWRBdHRycy5pbmNsdWRlcyhhdHRyKSkuY29uY2F0KHJlbW92ZXMpXG5cbiAgICBET00ucHV0U3RpY2t5KGVsLCBcImF0dHJzXCIsIGN1cnJlbnRFbCA9PiB7XG4gICAgICBuZXdSZW1vdmVzLmZvckVhY2goYXR0ciA9PiBjdXJyZW50RWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpKVxuICAgICAgbmV3U2V0cy5mb3JFYWNoKChbYXR0ciwgdmFsXSkgPT4gY3VycmVudEVsLnNldEF0dHJpYnV0ZShhdHRyLCB2YWwpKVxuICAgICAgcmV0dXJuIFtuZXdTZXRzLCBuZXdSZW1vdmVzXVxuICAgIH0pXG4gIH0sXG5cbiAgaGFzQWxsQ2xhc3NlcyhlbCwgY2xhc3Nlcyl7IHJldHVybiBjbGFzc2VzLmV2ZXJ5KG5hbWUgPT4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKSB9LFxuXG4gIGlzVG9nZ2xlZE91dChlbCwgb3V0Q2xhc3Nlcyl7XG4gICAgcmV0dXJuICF0aGlzLmlzVmlzaWJsZShlbCkgfHwgdGhpcy5oYXNBbGxDbGFzc2VzKGVsLCBvdXRDbGFzc2VzKVxuICB9LFxuXG4gIGZpbHRlclRvRWxzKGxpdmVTb2NrZXQsIHNvdXJjZUVsLCB7dG99KXtcbiAgICBsZXQgZGVmYXVsdFF1ZXJ5ID0gKCkgPT4ge1xuICAgICAgaWYodHlwZW9mKHRvKSA9PT0gXCJzdHJpbmdcIil7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRvKVxuICAgICAgfSBlbHNlIGlmKHRvLmNsb3Nlc3Qpe1xuICAgICAgICBsZXQgdG9FbCA9IHNvdXJjZUVsLmNsb3Nlc3QodG8uY2xvc2VzdClcbiAgICAgICAgcmV0dXJuIHRvRWwgPyBbdG9FbF0gOiBbXVxuICAgICAgfSBlbHNlIGlmKHRvLmlubmVyKXtcbiAgICAgICAgcmV0dXJuIHNvdXJjZUVsLnF1ZXJ5U2VsZWN0b3JBbGwodG8uaW5uZXIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0byA/IGxpdmVTb2NrZXQuanNRdWVyeVNlbGVjdG9yQWxsKHNvdXJjZUVsLCB0bywgZGVmYXVsdFF1ZXJ5KSA6IFtzb3VyY2VFbF1cbiAgfSxcblxuICBkZWZhdWx0RGlzcGxheShlbCl7XG4gICAgcmV0dXJuIHt0cjogXCJ0YWJsZS1yb3dcIiwgdGQ6IFwidGFibGUtY2VsbFwifVtlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8IFwiYmxvY2tcIlxuICB9LFxuXG4gIHRyYW5zaXRpb25DbGFzc2VzKHZhbCl7XG4gICAgaWYoIXZhbCl7IHJldHVybiBudWxsIH1cblxuICAgIGxldCBbdHJhbnMsIHRTdGFydCwgdEVuZF0gPSBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsLnNwbGl0KFwiIFwiKSwgW10sIFtdXVxuICAgIHRyYW5zID0gQXJyYXkuaXNBcnJheSh0cmFucykgPyB0cmFucyA6IHRyYW5zLnNwbGl0KFwiIFwiKVxuICAgIHRTdGFydCA9IEFycmF5LmlzQXJyYXkodFN0YXJ0KSA/IHRTdGFydCA6IHRTdGFydC5zcGxpdChcIiBcIilcbiAgICB0RW5kID0gQXJyYXkuaXNBcnJheSh0RW5kKSA/IHRFbmQgOiB0RW5kLnNwbGl0KFwiIFwiKVxuICAgIHJldHVybiBbdHJhbnMsIHRTdGFydCwgdEVuZF1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBKU1xuIiwgImltcG9ydCBKUyBmcm9tIFwiLi9qc1wiXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5cbmNvbnN0IEhPT0tfSUQgPSBcImhvb2tJZFwiXG5cbmxldCB2aWV3SG9va0lEID0gMVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld0hvb2sge1xuICBzdGF0aWMgbWFrZUlEKCl7IHJldHVybiB2aWV3SG9va0lEKysgfVxuICBzdGF0aWMgZWxlbWVudElEKGVsKXsgcmV0dXJuIERPTS5wcml2YXRlKGVsLCBIT09LX0lEKSB9XG5cbiAgY29uc3RydWN0b3IodmlldywgZWwsIGNhbGxiYWNrcyl7XG4gICAgdGhpcy5lbCA9IGVsXG4gICAgdGhpcy5fX2F0dGFjaFZpZXcodmlldylcbiAgICB0aGlzLl9fY2FsbGJhY2tzID0gY2FsbGJhY2tzXG4gICAgdGhpcy5fX2xpc3RlbmVycyA9IG5ldyBTZXQoKVxuICAgIHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgRE9NLnB1dFByaXZhdGUodGhpcy5lbCwgSE9PS19JRCwgdGhpcy5jb25zdHJ1Y3Rvci5tYWtlSUQoKSlcbiAgICBmb3IobGV0IGtleSBpbiB0aGlzLl9fY2FsbGJhY2tzKXsgdGhpc1trZXldID0gdGhpcy5fX2NhbGxiYWNrc1trZXldIH1cbiAgfVxuXG4gIF9fYXR0YWNoVmlldyh2aWV3KXtcbiAgICBpZih2aWV3KXtcbiAgICAgIHRoaXMuX192aWV3ID0gKCkgPT4gdmlld1xuICAgICAgdGhpcy5saXZlU29ja2V0ID0gdmlldy5saXZlU29ja2V0XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX192aWV3ID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhvb2sgbm90IHlldCBhdHRhY2hlZCB0byBhIGxpdmUgdmlldzogJHt0aGlzLmVsLm91dGVySFRNTH1gKVxuICAgICAgfVxuICAgICAgdGhpcy5saXZlU29ja2V0ID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIF9fbW91bnRlZCgpeyB0aGlzLm1vdW50ZWQgJiYgdGhpcy5tb3VudGVkKCkgfVxuICBfX3VwZGF0ZWQoKXsgdGhpcy51cGRhdGVkICYmIHRoaXMudXBkYXRlZCgpIH1cbiAgX19iZWZvcmVVcGRhdGUoKXsgdGhpcy5iZWZvcmVVcGRhdGUgJiYgdGhpcy5iZWZvcmVVcGRhdGUoKSB9XG4gIF9fZGVzdHJveWVkKCl7XG4gICAgdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5kZXN0cm95ZWQoKVxuICAgIERPTS5kZWxldGVQcml2YXRlKHRoaXMuZWwsIEhPT0tfSUQpIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L2lzc3Vlcy8zNDk2XG4gIH1cbiAgX19yZWNvbm5lY3RlZCgpe1xuICAgIGlmKHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCl7XG4gICAgICB0aGlzLl9faXNEaXNjb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgdGhpcy5yZWNvbm5lY3RlZCAmJiB0aGlzLnJlY29ubmVjdGVkKClcbiAgICB9XG4gIH1cbiAgX19kaXNjb25uZWN0ZWQoKXtcbiAgICB0aGlzLl9faXNEaXNjb25uZWN0ZWQgPSB0cnVlXG4gICAgdGhpcy5kaXNjb25uZWN0ZWQgJiYgdGhpcy5kaXNjb25uZWN0ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIHRoZSBob29rIHRvIEpTIGNvbW1hbmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge1ZpZXdIb29rfSBob29rIC0gVGhlIFZpZXdIb29rIGluc3RhbmNlIHRvIGJpbmQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIG1ldGhvZHMgdG8gbWFuaXB1bGF0ZSB0aGUgRE9NIGFuZCBleGVjdXRlIEphdmFTY3JpcHQuXG4gICAqL1xuICBqcygpe1xuICAgIGxldCBob29rID0gdGhpc1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogRXhlY3V0ZXMgZW5jb2RlZCBKYXZhU2NyaXB0IGluIHRoZSBjb250ZXh0IG9mIHRoZSBob29rIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGVuY29kZWRKUyAtIFRoZSBlbmNvZGVkIEphdmFTY3JpcHQgc3RyaW5nIHRvIGV4ZWN1dGUuXG4gICAgICAgKi9cbiAgICAgIGV4ZWMoZW5jb2RlZEpTKXtcbiAgICAgICAgaG9vay5fX3ZpZXcoKS5saXZlU29ja2V0LmV4ZWNKUyhob29rLmVsLCBlbmNvZGVkSlMsIFwiaG9va1wiKVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBTaG93cyBhbiBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gVGhlIGVsZW1lbnQgdG8gc2hvdy5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBPcHRpb25hbCBzZXR0aW5ncy5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5kaXNwbGF5XSAtIFRoZSBDU1MgZGlzcGxheSB2YWx1ZSB0byBzZXQuIERlZmF1bHRzIFwiYmxvY2tcIi5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50cmFuc2l0aW9uXSAtIFRoZSBDU1MgdHJhbnNpdGlvbiBjbGFzc2VzIHRvIHNldCB3aGVuIHNob3dpbmcuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZV0gLSBUaGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuIERlZmF1bHRzIDIwMC5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuYmxvY2tpbmddIC0gVGhlIGJvb2xlYW4gZmxhZyB0byBibG9jayB0aGUgVUkgZHVyaW5nIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICogIERlZmF1bHRzIGB0cnVlYC5cbiAgICAgICAqL1xuICAgICAgc2hvdyhlbCwgb3B0cyA9IHt9KXtcbiAgICAgICAgbGV0IG93bmVyID0gaG9vay5fX3ZpZXcoKS5saXZlU29ja2V0Lm93bmVyKGVsKVxuICAgICAgICBKUy5zaG93KFwiaG9va1wiLCBvd25lciwgZWwsIG9wdHMuZGlzcGxheSwgb3B0cy50cmFuc2l0aW9uLCBvcHRzLnRpbWUsIG9wdHMuYmxvY2tpbmcpXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEhpZGVzIGFuIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBUaGUgZWxlbWVudCB0byBoaWRlLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPXt9XSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnRyYW5zaXRpb25dIC0gVGhlIENTUyB0cmFuc2l0aW9uIGNsYXNzZXMgdG8gc2V0IHdoZW4gaGlkaW5nLlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVdIC0gVGhlIHRyYW5zaXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLiBEZWZhdWx0cyAyMDAuXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmJsb2NraW5nXSAtIFRoZSBib29sZWFuIGZsYWcgdG8gYmxvY2sgdGhlIFVJIGR1cmluZyB0aGUgdHJhbnNpdGlvbi5cbiAgICAgICAqICAgRGVmYXVsdHMgYHRydWVgLlxuICAgICAgICovXG4gICAgICBoaWRlKGVsLCBvcHRzID0ge30pe1xuICAgICAgICBsZXQgb3duZXIgPSBob29rLl9fdmlldygpLmxpdmVTb2NrZXQub3duZXIoZWwpXG4gICAgICAgIEpTLmhpZGUoXCJob29rXCIsIG93bmVyLCBlbCwgbnVsbCwgb3B0cy50cmFuc2l0aW9uLCBvcHRzLnRpbWUsIG9wdHMuYmxvY2tpbmcpXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZXMgdGhlIHZpc2liaWxpdHkgb2YgYW4gZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIFRoZSBlbGVtZW50IHRvIHRvZ2dsZS5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBPcHRpb25hbCBzZXR0aW5ncy5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5kaXNwbGF5XSAtIFRoZSBDU1MgZGlzcGxheSB2YWx1ZSB0byBzZXQuIERlZmF1bHRzIFwiYmxvY2tcIi5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pbl0gLSBUaGUgQ1NTIHRyYW5zaXRpb24gY2xhc3NlcyBmb3Igc2hvd2luZy5cbiAgICAgICAqICAgQWNjZXB0cyBlaXRoZXIgdGhlIHN0cmluZyBvZiBjbGFzc2VzIHRvIGFwcGx5IHdoZW4gdG9nZ2xpbmcgaW4sIG9yXG4gICAgICAgKiAgIGEgMy10dXBsZSBjb250YWluaW5nIHRoZSB0cmFuc2l0aW9uIGNsYXNzLCB0aGUgY2xhc3MgdG8gYXBwbHlcbiAgICAgICAqICAgdG8gc3RhcnQgdGhlIHRyYW5zaXRpb24sIGFuZCB0aGUgZW5kaW5nIHRyYW5zaXRpb24gY2xhc3MsIHN1Y2ggYXM6XG4gICAgICAgKlxuICAgICAgICogICAgICAgW1wiZWFzZS1vdXQgZHVyYXRpb24tMzAwXCIsIFwib3BhY2l0eS0wXCIsIFwib3BhY2l0eS0xMDBcIl1cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0XSAtIFRoZSBDU1MgdHJhbnNpdGlvbiBjbGFzc2VzIGZvciBoaWRpbmcuXG4gICAgICAgKiAgIEFjY2VwdHMgZWl0aGVyIHN0cmluZyBvZiBjbGFzc2VzIHRvIGFwcGx5IHdoZW4gdG9nZ2xpbmcgb3V0LCBvclxuICAgICAgICogICBhIDMtdHVwbGUgY29udGFpbmluZyB0aGUgdHJhbnNpdGlvbiBjbGFzcywgdGhlIGNsYXNzIHRvIGFwcGx5XG4gICAgICAgKiAgIHRvIHN0YXJ0IHRoZSB0cmFuc2l0aW9uLCBhbmQgdGhlIGVuZGluZyB0cmFuc2l0aW9uIGNsYXNzLCBzdWNoIGFzOlxuICAgICAgICpcbiAgICAgICAqICAgICAgIFtcImVhc2Utb3V0IGR1cmF0aW9uLTMwMFwiLCBcIm9wYWNpdHktMTAwXCIsIFwib3BhY2l0eS0wXCJdXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVdIC0gVGhlIHRyYW5zaXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuYmxvY2tpbmddIC0gVGhlIGJvb2xlYW4gZmxhZyB0byBibG9jayB0aGUgVUkgZHVyaW5nIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICogICBEZWZhdWx0cyBgdHJ1ZWAuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZShlbCwgb3B0cyA9IHt9KXtcbiAgICAgICAgbGV0IG93bmVyID0gaG9vay5fX3ZpZXcoKS5saXZlU29ja2V0Lm93bmVyKGVsKVxuICAgICAgICBvcHRzLmluID0gSlMudHJhbnNpdGlvbkNsYXNzZXMob3B0cy5pbilcbiAgICAgICAgb3B0cy5vdXQgPSBKUy50cmFuc2l0aW9uQ2xhc3NlcyhvcHRzLm91dClcbiAgICAgICAgSlMudG9nZ2xlKFwiaG9va1wiLCBvd25lciwgZWwsIG9wdHMuZGlzcGxheSwgb3B0cy5pbiwgb3B0cy5vdXQsIG9wdHMudGltZSwgb3B0cy5ibG9ja2luZylcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBDU1MgY2xhc3NlcyB0byBhbiBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gVGhlIGVsZW1lbnQgdG8gYWRkIGNsYXNzZXMgdG8uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gbmFtZXMgLSBUaGUgY2xhc3MgbmFtZShzKSB0byBhZGQuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9e31dIC0gT3B0aW9uYWwgc2V0dGluZ3MuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMudHJhbnNpdGlvbl0gLSBUaGUgQ1NTIHRyYW5zaXRpb24gcHJvcGVydHkgdG8gc2V0LlxuICAgICAgICogICBBY2NlcHRzIGEgc3RyaW5nIG9mIGNsYXNzZXMgdG8gYXBwbHkgd2hlbiBhZGRpbmcgY2xhc3NlcyBvclxuICAgICAgICogICBhIDMtdHVwbGUgY29udGFpbmluZyB0aGUgdHJhbnNpdGlvbiBjbGFzcywgdGhlIGNsYXNzIHRvIGFwcGx5XG4gICAgICAgKiAgIHRvIHN0YXJ0IHRoZSB0cmFuc2l0aW9uLCBhbmQgdGhlIGVuZGluZyB0cmFuc2l0aW9uIGNsYXNzLCBzdWNoIGFzOlxuICAgICAgICpcbiAgICAgICAqICAgICAgIFtcImVhc2Utb3V0IGR1cmF0aW9uLTMwMFwiLCBcIm9wYWNpdHktMFwiLCBcIm9wYWNpdHktMTAwXCJdXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVdIC0gVGhlIHRyYW5zaXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5ibG9ja2luZ10gLSBUaGUgYm9vbGVhbiBmbGFnIHRvIGJsb2NrIHRoZSBVSSBkdXJpbmcgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgKiAgIERlZmF1bHRzIGB0cnVlYC5cbiAgICAgICAqL1xuICAgICAgYWRkQ2xhc3MoZWwsIG5hbWVzLCBvcHRzID0ge30pe1xuICAgICAgICBuYW1lcyA9IEFycmF5LmlzQXJyYXkobmFtZXMpID8gbmFtZXMgOiBuYW1lcy5zcGxpdChcIiBcIilcbiAgICAgICAgbGV0IG93bmVyID0gaG9vay5fX3ZpZXcoKS5saXZlU29ja2V0Lm93bmVyKGVsKVxuICAgICAgICBKUy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG5hbWVzLCBbXSwgb3B0cy50cmFuc2l0aW9uLCBvcHRzLnRpbWUsIG93bmVyLCBvcHRzLmJsb2NraW5nKVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIENTUyBjbGFzc2VzIGZyb20gYW4gZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIFRoZSBlbGVtZW50IHRvIHJlbW92ZSBjbGFzc2VzIGZyb20uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gbmFtZXMgLSBUaGUgY2xhc3MgbmFtZShzKSB0byByZW1vdmUuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9e31dIC0gT3B0aW9uYWwgc2V0dGluZ3MuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMudHJhbnNpdGlvbl0gLSBUaGUgQ1NTIHRyYW5zaXRpb24gY2xhc3NlcyB0byBzZXQuXG4gICAgICAgKiAgIEFjY2VwdHMgYSBzdHJpbmcgb2YgY2xhc3NlcyB0byBhcHBseSB3aGVuIHJlbW92aW5nIGNsYXNzZXMgb3JcbiAgICAgICAqICAgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdGhlIHRyYW5zaXRpb24gY2xhc3MsIHRoZSBjbGFzcyB0byBhcHBseVxuICAgICAgICogICB0byBzdGFydCB0aGUgdHJhbnNpdGlvbiwgYW5kIHRoZSBlbmRpbmcgdHJhbnNpdGlvbiBjbGFzcywgc3VjaCBhczpcbiAgICAgICAqXG4gICAgICAgKiAgICAgICBbXCJlYXNlLW91dCBkdXJhdGlvbi0zMDBcIiwgXCJvcGFjaXR5LTEwMFwiLCBcIm9wYWNpdHktMFwiXVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lXSAtIFRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuYmxvY2tpbmddIC0gVGhlIGJvb2xlYW4gZmxhZyB0byBibG9jayB0aGUgVUkgZHVyaW5nIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICogICBEZWZhdWx0cyBgdHJ1ZWAuXG4gICAgICAgKi9cbiAgICAgIHJlbW92ZUNsYXNzKGVsLCBuYW1lcywgb3B0cyA9IHt9KXtcbiAgICAgICAgb3B0cy50cmFuc2l0aW9uID0gSlMudHJhbnNpdGlvbkNsYXNzZXMob3B0cy50cmFuc2l0aW9uKVxuICAgICAgICBuYW1lcyA9IEFycmF5LmlzQXJyYXkobmFtZXMpID8gbmFtZXMgOiBuYW1lcy5zcGxpdChcIiBcIilcbiAgICAgICAgbGV0IG93bmVyID0gaG9vay5fX3ZpZXcoKS5saXZlU29ja2V0Lm93bmVyKGVsKVxuICAgICAgICBKUy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBuYW1lcywgb3B0cy50cmFuc2l0aW9uLCBvcHRzLnRpbWUsIG93bmVyLCBvcHRzLmJsb2NraW5nKVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGVzIENTUyBjbGFzc2VzIG9uIGFuIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBUaGUgZWxlbWVudCB0byB0b2dnbGUgY2xhc3NlcyBvbi5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBuYW1lcyAtIFRoZSBjbGFzcyBuYW1lKHMpIHRvIHRvZ2dsZS5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBPcHRpb25hbCBzZXR0aW5ncy5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50cmFuc2l0aW9uXSAtIFRoZSBDU1MgdHJhbnNpdGlvbiBjbGFzc2VzIHRvIHNldC5cbiAgICAgICAqICAgQWNjZXB0cyBhIHN0cmluZyBvZiBjbGFzc2VzIHRvIGFwcGx5IHdoZW4gdG9nZ2xpbmcgY2xhc3NlcyBvclxuICAgICAgICogICBhIDMtdHVwbGUgY29udGFpbmluZyB0aGUgdHJhbnNpdGlvbiBjbGFzcywgdGhlIGNsYXNzIHRvIGFwcGx5XG4gICAgICAgKiAgIHRvIHN0YXJ0IHRoZSB0cmFuc2l0aW9uLCBhbmQgdGhlIGVuZGluZyB0cmFuc2l0aW9uIGNsYXNzLCBzdWNoIGFzOlxuICAgICAgICpcbiAgICAgICAqICAgICAgIFtcImVhc2Utb3V0IGR1cmF0aW9uLTMwMFwiLCBcIm9wYWNpdHktMTAwXCIsIFwib3BhY2l0eS0wXCJdXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVdIC0gVGhlIHRyYW5zaXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5ibG9ja2luZ10gLSBUaGUgYm9vbGVhbiBmbGFnIHRvIGJsb2NrIHRoZSBVSSBkdXJpbmcgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgKiAgIERlZmF1bHRzIGB0cnVlYC5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlQ2xhc3MoZWwsIG5hbWVzLCBvcHRzID0ge30pe1xuICAgICAgICBvcHRzLnRyYW5zaXRpb24gPSBKUy50cmFuc2l0aW9uQ2xhc3NlcyhvcHRzLnRyYW5zaXRpb24pXG4gICAgICAgIG5hbWVzID0gQXJyYXkuaXNBcnJheShuYW1lcykgPyBuYW1lcyA6IG5hbWVzLnNwbGl0KFwiIFwiKVxuICAgICAgICBsZXQgb3duZXIgPSBob29rLl9fdmlldygpLmxpdmVTb2NrZXQub3duZXIoZWwpXG4gICAgICAgIEpTLnRvZ2dsZUNsYXNzZXMoZWwsIG5hbWVzLCBvcHRzLnRyYW5zaXRpb24sIG9wdHMudGltZSwgb3duZXIsIG9wdHMuYmxvY2tpbmcpXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEFwcGxpZXMgYSBDU1MgdHJhbnNpdGlvbiB0byBhbiBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gVGhlIGVsZW1lbnQgdG8gYXBwbHkgdGhlIHRyYW5zaXRpb24gdG8uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdHJhbnNpdGlvbiAtIFRoZSB0cmFuc2l0aW9uIGNsYXNzKGVzKSB0byBhcHBseS5cbiAgICAgICAqICAgQWNjZXB0cyBhIHN0cmluZyBvZiBjbGFzc2VzIHRvIGFwcGx5IHdoZW4gdHJhbnNpdGlvbmluZyBvclxuICAgICAgICogICBhIDMtdHVwbGUgY29udGFpbmluZyB0aGUgdHJhbnNpdGlvbiBjbGFzcywgdGhlIGNsYXNzIHRvIGFwcGx5XG4gICAgICAgKiAgIHRvIHN0YXJ0IHRoZSB0cmFuc2l0aW9uLCBhbmQgdGhlIGVuZGluZyB0cmFuc2l0aW9uIGNsYXNzLCBzdWNoIGFzOlxuICAgICAgICpcbiAgICAgICAqICAgICAgIFtcImVhc2Utb3V0IGR1cmF0aW9uLTMwMFwiLCBcIm9wYWNpdHktMTAwXCIsIFwib3BhY2l0eS0wXCJdXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPXt9XSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVdIC0gVGhlIHRyYW5zaXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5ibG9ja2luZ10gLSBUaGUgYm9vbGVhbiBmbGFnIHRvIGJsb2NrIHRoZSBVSSBkdXJpbmcgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgKiAgIERlZmF1bHRzIGB0cnVlYC5cbiAgICAgICAqL1xuICAgICAgdHJhbnNpdGlvbihlbCwgdHJhbnNpdGlvbiwgb3B0cyA9IHt9KXtcbiAgICAgICAgbGV0IG93bmVyID0gaG9vay5fX3ZpZXcoKS5saXZlU29ja2V0Lm93bmVyKGVsKVxuICAgICAgICBKUy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBbXSwgSlMudHJhbnNpdGlvbkNsYXNzZXModHJhbnNpdGlvbiksIG9wdHMudGltZSwgb3duZXIsIG9wdHMuYmxvY2tpbmcpXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgYW4gYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGF0dHJpYnV0ZSBvbi5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyIC0gVGhlIGF0dHJpYnV0ZSBuYW1lIHRvIHNldC5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWwgLSBUaGUgdmFsdWUgdG8gc2V0IGZvciB0aGUgYXR0cmlidXRlLlxuICAgICAgICovXG4gICAgICBzZXRBdHRyaWJ1dGUoZWwsIGF0dHIsIHZhbCl7IEpTLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtbYXR0ciwgdmFsXV0sIFtdKSB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gYW4gZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIFRoZSBlbGVtZW50IHRvIHJlbW92ZSB0aGUgYXR0cmlidXRlIGZyb20uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ciAtIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byByZW1vdmUuXG4gICAgICAgKi9cbiAgICAgIHJlbW92ZUF0dHJpYnV0ZShlbCwgYXR0cil7IEpTLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtdLCBbYXR0cl0pIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlcyBhbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCBiZXR3ZWVuIHR3byB2YWx1ZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBUaGUgZWxlbWVudCB0byB0b2dnbGUgdGhlIGF0dHJpYnV0ZSBvbi5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyIC0gVGhlIGF0dHJpYnV0ZSBuYW1lIHRvIHRvZ2dsZS5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWwxIC0gVGhlIGZpcnN0IHZhbHVlIHRvIHRvZ2dsZSBiZXR3ZWVuLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbDIgLSBUaGUgc2Vjb25kIHZhbHVlIHRvIHRvZ2dsZSBiZXR3ZWVuLlxuICAgICAgICovXG4gICAgICB0b2dnbGVBdHRyaWJ1dGUoZWwsIGF0dHIsIHZhbDEsIHZhbDIpeyBKUy50b2dnbGVBdHRyKGVsLCBhdHRyLCB2YWwxLCB2YWwyKSB9LFxuICAgIH1cbiAgfVxuXG4gIHB1c2hFdmVudChldmVudCwgcGF5bG9hZCA9IHt9LCBvblJlcGx5KXtcbiAgICBpZihvblJlcGx5ID09PSB1bmRlZmluZWQpe1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZWYgPSB0aGlzLl9fdmlldygpLnB1c2hIb29rRXZlbnQodGhpcy5lbCwgbnVsbCwgZXZlbnQsIHBheWxvYWQsIChyZXBseSwgX3JlZikgPT4gcmVzb2x2ZShyZXBseSkpXG4gICAgICAgICAgaWYocmVmID09PSBmYWxzZSl7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwidW5hYmxlIHRvIHB1c2ggaG9vayBldmVudC4gTGl2ZVZpZXcgbm90IGNvbm5lY3RlZFwiKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKXtcbiAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fdmlldygpLnB1c2hIb29rRXZlbnQodGhpcy5lbCwgbnVsbCwgZXZlbnQsIHBheWxvYWQsIG9uUmVwbHkpXG4gIH1cblxuICBwdXNoRXZlbnRUbyhwaHhUYXJnZXQsIGV2ZW50LCBwYXlsb2FkID0ge30sIG9uUmVwbHkpe1xuICAgIGlmKG9uUmVwbHkgPT09IHVuZGVmaW5lZCl7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuX192aWV3KCkud2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsICh2aWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IHZpZXcucHVzaEhvb2tFdmVudCh0aGlzLmVsLCB0YXJnZXRDdHgsIGV2ZW50LCBwYXlsb2FkLCAocmVwbHksIF9yZWYpID0+IHJlc29sdmUocmVwbHkpKVxuICAgICAgICAgICAgaWYocmVmID09PSBmYWxzZSl7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJ1bmFibGUgdG8gcHVzaCBob29rIGV2ZW50LiBMaXZlVmlldyBub3QgY29ubmVjdGVkXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKXtcbiAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fdmlldygpLndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICByZXR1cm4gdmlldy5wdXNoSG9va0V2ZW50KHRoaXMuZWwsIHRhcmdldEN0eCwgZXZlbnQsIHBheWxvYWQsIG9uUmVwbHkpXG4gICAgfSlcbiAgfVxuXG4gIGhhbmRsZUV2ZW50KGV2ZW50LCBjYWxsYmFjayl7XG4gICAgbGV0IGNhbGxiYWNrUmVmID0gKGN1c3RvbUV2ZW50LCBieXBhc3MpID0+IGJ5cGFzcyA/IGV2ZW50IDogY2FsbGJhY2soY3VzdG9tRXZlbnQuZGV0YWlsKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGBwaHg6JHtldmVudH1gLCBjYWxsYmFja1JlZilcbiAgICB0aGlzLl9fbGlzdGVuZXJzLmFkZChjYWxsYmFja1JlZilcbiAgICByZXR1cm4gY2FsbGJhY2tSZWZcbiAgfVxuXG4gIHJlbW92ZUhhbmRsZUV2ZW50KGNhbGxiYWNrUmVmKXtcbiAgICBsZXQgZXZlbnQgPSBjYWxsYmFja1JlZihudWxsLCB0cnVlKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGBwaHg6JHtldmVudH1gLCBjYWxsYmFja1JlZilcbiAgICB0aGlzLl9fbGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFja1JlZilcbiAgfVxuXG4gIHVwbG9hZChuYW1lLCBmaWxlcyl7XG4gICAgcmV0dXJuIHRoaXMuX192aWV3KCkuZGlzcGF0Y2hVcGxvYWRzKG51bGwsIG5hbWUsIGZpbGVzKVxuICB9XG5cbiAgdXBsb2FkVG8ocGh4VGFyZ2V0LCBuYW1lLCBmaWxlcyl7XG4gICAgcmV0dXJuIHRoaXMuX192aWV3KCkud2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsICh2aWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIHZpZXcuZGlzcGF0Y2hVcGxvYWRzKHRhcmdldEN0eCwgbmFtZSwgZmlsZXMpXG4gICAgfSlcbiAgfVxuXG4gIF9fY2xlYW51cF9fKCl7XG4gICAgdGhpcy5fX2xpc3RlbmVycy5mb3JFYWNoKGNhbGxiYWNrUmVmID0+IHRoaXMucmVtb3ZlSGFuZGxlRXZlbnQoY2FsbGJhY2tSZWYpKVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgQkVGT1JFX1VOTE9BRF9MT0FERVJfVElNRU9VVCxcbiAgQ0hFQ0tBQkxFX0lOUFVUUyxcbiAgQ09OU0VDVVRJVkVfUkVMT0FEUyxcbiAgUEhYX0FVVE9fUkVDT1ZFUixcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX0NPTk5FQ1RFRF9DTEFTUyxcbiAgUEhYX0RJU0FCTEVfV0lUSCxcbiAgUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFLFxuICBQSFhfRElTQUJMRUQsXG4gIFBIWF9MT0FESU5HX0NMQVNTLFxuICBQSFhfRVJST1JfQ0xBU1MsXG4gIFBIWF9DTElFTlRfRVJST1JfQ0xBU1MsXG4gIFBIWF9TRVJWRVJfRVJST1JfQ0xBU1MsXG4gIFBIWF9IQVNfRk9DVVNFRCxcbiAgUEhYX0hBU19TVUJNSVRURUQsXG4gIFBIWF9IT09LLFxuICBQSFhfUEFSRU5UX0lELFxuICBQSFhfUFJPR1JFU1MsXG4gIFBIWF9SRUFET05MWSxcbiAgUEhYX1JFRl9MT0FESU5HLFxuICBQSFhfUkVGX1NSQyxcbiAgUEhYX1JFRl9MT0NLLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1NFU1NJT04sXG4gIFBIWF9TVEFUSUMsXG4gIFBIWF9UUkFDS19TVEFUSUMsXG4gIFBIWF9UUkFDS19VUExPQURTLFxuICBQSFhfVVBEQVRFLFxuICBQSFhfVVBMT0FEX1JFRixcbiAgUEhYX1ZJRVdfU0VMRUNUT1IsXG4gIFBIWF9NQUlOLFxuICBQSFhfTU9VTlRFRCxcbiAgUFVTSF9USU1FT1VULFxuICBQSFhfVklFV1BPUlRfVE9QLFxuICBQSFhfVklFV1BPUlRfQk9UVE9NLFxuICBNQVhfQ0hJTERfSk9JTl9BVFRFTVBUU1xufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBjbG9uZSxcbiAgY2xvc2VzdFBoeEJpbmRpbmcsXG4gIGlzRW1wdHksXG4gIGlzRXF1YWxPYmosXG4gIGxvZ0Vycm9yLFxuICBtYXliZSxcbiAgaXNDaWQsXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IEJyb3dzZXIgZnJvbSBcIi4vYnJvd3NlclwiXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgRWxlbWVudFJlZiBmcm9tIFwiLi9lbGVtZW50X3JlZlwiXG5pbXBvcnQgRE9NUGF0Y2ggZnJvbSBcIi4vZG9tX3BhdGNoXCJcbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5pbXBvcnQgUmVuZGVyZWQgZnJvbSBcIi4vcmVuZGVyZWRcIlxuaW1wb3J0IFZpZXdIb29rIGZyb20gXCIuL3ZpZXdfaG9va1wiXG5pbXBvcnQgSlMgZnJvbSBcIi4vanNcIlxuXG5leHBvcnQgbGV0IHByZXBlbmRGb3JtRGF0YUtleSA9IChrZXksIHByZWZpeCkgPT4ge1xuICBsZXQgaXNBcnJheSA9IGtleS5lbmRzV2l0aChcIltdXCIpXG4gIC8vIFJlbW92ZSB0aGUgXCJbXVwiIGlmIGl0J3MgYW4gYXJyYXlcbiAgbGV0IGJhc2VLZXkgPSBpc0FycmF5ID8ga2V5LnNsaWNlKDAsIC0yKSA6IGtleVxuICAvLyBSZXBsYWNlIGxhc3Qgb2NjdXJyZW5jZSBvZiBrZXkgYmVmb3JlIGEgY2xvc2luZyBicmFja2V0IG9yIHRoZSBlbmQgd2l0aCBrZXkgcGx1cyBzdWZmaXhcbiAgYmFzZUtleSA9IGJhc2VLZXkucmVwbGFjZSgvKFteXFxbXFxdXSspKFxcXT8kKS8sIGAke3ByZWZpeH0kMSQyYClcbiAgLy8gQWRkIGJhY2sgdGhlIFwiW11cIiBpZiBpdCB3YXMgYW4gYXJyYXlcbiAgaWYoaXNBcnJheSl7IGJhc2VLZXkgKz0gXCJbXVwiIH1cbiAgcmV0dXJuIGJhc2VLZXlcbn1cblxubGV0IHNlcmlhbGl6ZUZvcm0gPSAoZm9ybSwgbWV0YWRhdGEsIG9ubHlOYW1lcyA9IFtdKSA9PiB7XG4gIGNvbnN0IHtzdWJtaXR0ZXIsIC4uLm1ldGF9ID0gbWV0YWRhdGFcblxuICAvLyBXZSBtdXN0IGluamVjdCB0aGUgc3VibWl0dGVyIGluIHRoZSBvcmRlciB0aGF0IGl0IGV4aXN0cyBpbiB0aGUgRE9NXG4gIC8vIHJlbGF0aXZlIHRvIG90aGVyIGlucHV0cy4gRm9yIGV4YW1wbGUsIGZvciBjaGVja2JveCBncm91cHMsIHRoZSBvcmRlciBtdXN0IGJlIG1haW50YWluZWQuXG4gIGxldCBpbmplY3RlZEVsZW1lbnRcbiAgaWYoc3VibWl0dGVyICYmIHN1Ym1pdHRlci5uYW1lKXtcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKVxuICAgIGlucHV0LnR5cGUgPSBcImhpZGRlblwiXG4gICAgLy8gc2V0IHRoZSBmb3JtIGF0dHJpYnV0ZSBpZiB0aGUgc3VibWl0dGVyIGhhcyBvbmU7XG4gICAgLy8gdGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBlbGVtZW50IGlzIG91dHNpZGUgdGhlIGFjdHVhbCBmb3JtIGVsZW1lbnRcbiAgICBjb25zdCBmb3JtSWQgPSBzdWJtaXR0ZXIuZ2V0QXR0cmlidXRlKFwiZm9ybVwiKVxuICAgIGlmKGZvcm1JZCl7XG4gICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJmb3JtXCIsIGZvcm1JZClcbiAgICB9XG4gICAgaW5wdXQubmFtZSA9IHN1Ym1pdHRlci5uYW1lXG4gICAgaW5wdXQudmFsdWUgPSBzdWJtaXR0ZXIudmFsdWVcbiAgICBzdWJtaXR0ZXIucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoaW5wdXQsIHN1Ym1pdHRlcilcbiAgICBpbmplY3RlZEVsZW1lbnQgPSBpbnB1dFxuICB9XG5cbiAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoZm9ybSlcbiAgY29uc3QgdG9SZW1vdmUgPSBbXVxuXG4gIGZvcm1EYXRhLmZvckVhY2goKHZhbCwga2V5LCBfaW5kZXgpID0+IHtcbiAgICBpZih2YWwgaW5zdGFuY2VvZiBGaWxlKXsgdG9SZW1vdmUucHVzaChrZXkpIH1cbiAgfSlcblxuICAvLyBDbGVhbnVwIGFmdGVyIGJ1aWxkaW5nIGZpbGVEYXRhXG4gIHRvUmVtb3ZlLmZvckVhY2goa2V5ID0+IGZvcm1EYXRhLmRlbGV0ZShrZXkpKVxuXG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxuXG4gIGxldCBlbGVtZW50cyA9IEFycmF5LmZyb20oZm9ybS5lbGVtZW50cylcbiAgZm9yKGxldCBba2V5LCB2YWxdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSl7XG4gICAgaWYob25seU5hbWVzLmxlbmd0aCA9PT0gMCB8fCBvbmx5TmFtZXMuaW5kZXhPZihrZXkpID49IDApe1xuICAgICAgbGV0IGlucHV0cyA9IGVsZW1lbnRzLmZpbHRlcihpbnB1dCA9PiBpbnB1dC5uYW1lID09PSBrZXkpXG4gICAgICBsZXQgaXNVbnVzZWQgPSAhaW5wdXRzLnNvbWUoaW5wdXQgPT4gKERPTS5wcml2YXRlKGlucHV0LCBQSFhfSEFTX0ZPQ1VTRUQpIHx8IERPTS5wcml2YXRlKGlucHV0LCBQSFhfSEFTX1NVQk1JVFRFRCkpKVxuICAgICAgbGV0IGhpZGRlbiA9IGlucHV0cy5ldmVyeShpbnB1dCA9PiBpbnB1dC50eXBlID09PSBcImhpZGRlblwiKVxuICAgICAgaWYoaXNVbnVzZWQgJiYgIShzdWJtaXR0ZXIgJiYgc3VibWl0dGVyLm5hbWUgPT0ga2V5KSAmJiAhaGlkZGVuKXtcbiAgICAgICAgcGFyYW1zLmFwcGVuZChwcmVwZW5kRm9ybURhdGFLZXkoa2V5LCBcIl91bnVzZWRfXCIpLCBcIlwiKVxuICAgICAgfVxuICAgICAgcGFyYW1zLmFwcGVuZChrZXksIHZhbClcbiAgICB9XG4gIH1cblxuICAvLyByZW1vdmUgdGhlIGluamVjdGVkIGVsZW1lbnQgYWdhaW5cbiAgLy8gKGl0IHdvdWxkIGJlIHJlbW92ZWQgYnkgdGhlIG5leHQgZG9tIHBhdGNoIGFueXdheSwgYnV0IHRoaXMgaXMgY2xlYW5lcilcbiAgaWYoc3VibWl0dGVyICYmIGluamVjdGVkRWxlbWVudCl7XG4gICAgc3VibWl0dGVyLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoaW5qZWN0ZWRFbGVtZW50KVxuICB9XG5cbiAgZm9yKGxldCBtZXRhS2V5IGluIG1ldGEpeyBwYXJhbXMuYXBwZW5kKG1ldGFLZXksIG1ldGFbbWV0YUtleV0pIH1cblxuICByZXR1cm4gcGFyYW1zLnRvU3RyaW5nKClcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlldyB7XG4gIHN0YXRpYyBjbG9zZXN0VmlldyhlbCl7XG4gICAgbGV0IGxpdmVWaWV3RWwgPSBlbC5jbG9zZXN0KFBIWF9WSUVXX1NFTEVDVE9SKVxuICAgIHJldHVybiBsaXZlVmlld0VsID8gRE9NLnByaXZhdGUobGl2ZVZpZXdFbCwgXCJ2aWV3XCIpIDogbnVsbFxuICB9XG5cbiAgY29uc3RydWN0b3IoZWwsIGxpdmVTb2NrZXQsIHBhcmVudFZpZXcsIGZsYXNoLCBsaXZlUmVmZXJlcil7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZVxuICAgIHRoaXMubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXRcbiAgICB0aGlzLmZsYXNoID0gZmxhc2hcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudFZpZXdcbiAgICB0aGlzLnJvb3QgPSBwYXJlbnRWaWV3ID8gcGFyZW50Vmlldy5yb290IDogdGhpc1xuICAgIHRoaXMuZWwgPSBlbFxuICAgIERPTS5wdXRQcml2YXRlKHRoaXMuZWwsIFwidmlld1wiLCB0aGlzKVxuICAgIHRoaXMuaWQgPSB0aGlzLmVsLmlkXG4gICAgdGhpcy5yZWYgPSAwXG4gICAgdGhpcy5sYXN0QWNrUmVmID0gbnVsbFxuICAgIHRoaXMuY2hpbGRKb2lucyA9IDBcbiAgICB0aGlzLmxvYWRlclRpbWVyID0gbnVsbFxuICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cbiAgICB0aGlzLnBlbmRpbmdGb3JtcyA9IG5ldyBTZXQoKVxuICAgIHRoaXMucmVkaXJlY3QgPSBmYWxzZVxuICAgIHRoaXMuaHJlZiA9IG51bGxcbiAgICB0aGlzLmpvaW5Db3VudCA9IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuam9pbkNvdW50IC0gMSA6IDBcbiAgICB0aGlzLmpvaW5BdHRlbXB0cyA9IDBcbiAgICB0aGlzLmpvaW5QZW5kaW5nID0gdHJ1ZVxuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcbiAgICB0aGlzLmpvaW5DYWxsYmFjayA9IGZ1bmN0aW9uKG9uRG9uZSl7IG9uRG9uZSAmJiBvbkRvbmUoKSB9XG4gICAgdGhpcy5zdG9wQ2FsbGJhY2sgPSBmdW5jdGlvbigpeyB9XG4gICAgdGhpcy5wZW5kaW5nSm9pbk9wcyA9IHRoaXMucGFyZW50ID8gbnVsbCA6IFtdXG4gICAgdGhpcy52aWV3SG9va3MgPSB7fVxuICAgIHRoaXMuZm9ybVN1Ym1pdHMgPSBbXVxuICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLnBhcmVudCA/IG51bGwgOiB7fVxuICAgIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXSA9IHt9XG4gICAgdGhpcy5mb3Jtc0ZvclJlY292ZXJ5ID0ge31cbiAgICB0aGlzLmNoYW5uZWwgPSB0aGlzLmxpdmVTb2NrZXQuY2hhbm5lbChgbHY6JHt0aGlzLmlkfWAsICgpID0+IHtcbiAgICAgIGxldCB1cmwgPSB0aGlzLmhyZWYgJiYgdGhpcy5leHBhbmRVUkwodGhpcy5ocmVmKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVkaXJlY3Q6IHRoaXMucmVkaXJlY3QgPyB1cmwgOiB1bmRlZmluZWQsXG4gICAgICAgIHVybDogdGhpcy5yZWRpcmVjdCA/IHVuZGVmaW5lZCA6IHVybCB8fCB1bmRlZmluZWQsXG4gICAgICAgIHBhcmFtczogdGhpcy5jb25uZWN0UGFyYW1zKGxpdmVSZWZlcmVyKSxcbiAgICAgICAgc2Vzc2lvbjogdGhpcy5nZXRTZXNzaW9uKCksXG4gICAgICAgIHN0YXRpYzogdGhpcy5nZXRTdGF0aWMoKSxcbiAgICAgICAgZmxhc2g6IHRoaXMuZmxhc2gsXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHNldEhyZWYoaHJlZil7IHRoaXMuaHJlZiA9IGhyZWYgfVxuXG4gIHNldFJlZGlyZWN0KGhyZWYpe1xuICAgIHRoaXMucmVkaXJlY3QgPSB0cnVlXG4gICAgdGhpcy5ocmVmID0gaHJlZlxuICB9XG5cbiAgaXNNYWluKCl7IHJldHVybiB0aGlzLmVsLmhhc0F0dHJpYnV0ZShQSFhfTUFJTikgfVxuXG4gIGNvbm5lY3RQYXJhbXMobGl2ZVJlZmVyZXIpe1xuICAgIGxldCBwYXJhbXMgPSB0aGlzLmxpdmVTb2NrZXQucGFyYW1zKHRoaXMuZWwpXG4gICAgbGV0IG1hbmlmZXN0ID1cbiAgICAgIERPTS5hbGwoZG9jdW1lbnQsIGBbJHt0aGlzLmJpbmRpbmcoUEhYX1RSQUNLX1NUQVRJQyl9XWApXG4gICAgICAgIC5tYXAobm9kZSA9PiBub2RlLnNyYyB8fCBub2RlLmhyZWYpLmZpbHRlcih1cmwgPT4gdHlwZW9mICh1cmwpID09PSBcInN0cmluZ1wiKVxuXG4gICAgaWYobWFuaWZlc3QubGVuZ3RoID4gMCl7IHBhcmFtc1tcIl90cmFja19zdGF0aWNcIl0gPSBtYW5pZmVzdCB9XG4gICAgcGFyYW1zW1wiX21vdW50c1wiXSA9IHRoaXMuam9pbkNvdW50XG4gICAgcGFyYW1zW1wiX21vdW50X2F0dGVtcHRzXCJdID0gdGhpcy5qb2luQXR0ZW1wdHNcbiAgICBwYXJhbXNbXCJfbGl2ZV9yZWZlcmVyXCJdID0gbGl2ZVJlZmVyZXJcbiAgICB0aGlzLmpvaW5BdHRlbXB0cysrXG5cbiAgICByZXR1cm4gcGFyYW1zXG4gIH1cblxuICBpc0Nvbm5lY3RlZCgpeyByZXR1cm4gdGhpcy5jaGFubmVsLmNhblB1c2goKSB9XG5cbiAgZ2V0U2Vzc2lvbigpeyByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pIH1cblxuICBnZXRTdGF0aWMoKXtcbiAgICBsZXQgdmFsID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQylcbiAgICByZXR1cm4gdmFsID09PSBcIlwiID8gbnVsbCA6IHZhbFxuICB9XG5cbiAgZGVzdHJveShjYWxsYmFjayA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICB0aGlzLmRlc3Ryb3lBbGxDaGlsZHJlbigpXG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gICAgZGVsZXRlIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXVxuICAgIGlmKHRoaXMucGFyZW50KXsgZGVsZXRlIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLnBhcmVudC5pZF1bdGhpcy5pZF0gfVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmxvYWRlclRpbWVyKVxuICAgIGxldCBvbkZpbmlzaGVkID0gKCkgPT4ge1xuICAgICAgY2FsbGJhY2soKVxuICAgICAgZm9yKGxldCBpZCBpbiB0aGlzLnZpZXdIb29rcyl7XG4gICAgICAgIHRoaXMuZGVzdHJveUhvb2sodGhpcy52aWV3SG9va3NbaWRdKVxuICAgICAgfVxuICAgIH1cblxuICAgIERPTS5tYXJrUGh4Q2hpbGREZXN0cm95ZWQodGhpcy5lbClcblxuICAgIHRoaXMubG9nKFwiZGVzdHJveWVkXCIsICgpID0+IFtcInRoZSBjaGlsZCBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhcmVudFwiXSlcbiAgICB0aGlzLmNoYW5uZWwubGVhdmUoKVxuICAgICAgLnJlY2VpdmUoXCJva1wiLCBvbkZpbmlzaGVkKVxuICAgICAgLnJlY2VpdmUoXCJlcnJvclwiLCBvbkZpbmlzaGVkKVxuICAgICAgLnJlY2VpdmUoXCJ0aW1lb3V0XCIsIG9uRmluaXNoZWQpXG4gIH1cblxuICBzZXRDb250YWluZXJDbGFzc2VzKC4uLmNsYXNzZXMpe1xuICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgIFBIWF9DT05ORUNURURfQ0xBU1MsXG4gICAgICBQSFhfTE9BRElOR19DTEFTUyxcbiAgICAgIFBIWF9FUlJPUl9DTEFTUyxcbiAgICAgIFBIWF9DTElFTlRfRVJST1JfQ0xBU1MsXG4gICAgICBQSFhfU0VSVkVSX0VSUk9SX0NMQVNTXG4gICAgKVxuICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzKVxuICB9XG5cbiAgc2hvd0xvYWRlcih0aW1lb3V0KXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcilcbiAgICBpZih0aW1lb3V0KXtcbiAgICAgIHRoaXMubG9hZGVyVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2hvd0xvYWRlcigpLCB0aW1lb3V0KVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IobGV0IGlkIGluIHRoaXMudmlld0hvb2tzKXsgdGhpcy52aWV3SG9va3NbaWRdLl9fZGlzY29ubmVjdGVkKCkgfVxuICAgICAgdGhpcy5zZXRDb250YWluZXJDbGFzc2VzKFBIWF9MT0FESU5HX0NMQVNTKVxuICAgIH1cbiAgfVxuXG4gIGV4ZWNBbGwoYmluZGluZyl7XG4gICAgRE9NLmFsbCh0aGlzLmVsLCBgWyR7YmluZGluZ31dYCwgZWwgPT4gdGhpcy5saXZlU29ja2V0LmV4ZWNKUyhlbCwgZWwuZ2V0QXR0cmlidXRlKGJpbmRpbmcpKSlcbiAgfVxuXG4gIGhpZGVMb2FkZXIoKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcilcbiAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoUEhYX0NPTk5FQ1RFRF9DTEFTUylcbiAgICB0aGlzLmV4ZWNBbGwodGhpcy5iaW5kaW5nKFwiY29ubmVjdGVkXCIpKVxuICB9XG5cbiAgdHJpZ2dlclJlY29ubmVjdGVkKCl7XG4gICAgZm9yKGxldCBpZCBpbiB0aGlzLnZpZXdIb29rcyl7IHRoaXMudmlld0hvb2tzW2lkXS5fX3JlY29ubmVjdGVkKCkgfVxuICB9XG5cbiAgbG9nKGtpbmQsIG1zZ0NhbGxiYWNrKXtcbiAgICB0aGlzLmxpdmVTb2NrZXQubG9nKHRoaXMsIGtpbmQsIG1zZ0NhbGxiYWNrKVxuICB9XG5cbiAgdHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUgPSBmdW5jdGlvbigpe30pe1xuICAgIHRoaXMubGl2ZVNvY2tldC50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSlcbiAgfVxuXG4gIC8vIGNhbGxzIHRoZSBjYWxsYmFjayB3aXRoIHRoZSB2aWV3IGFuZCB0YXJnZXQgZWxlbWVudCBmb3IgdGhlIGdpdmVuIHBoeFRhcmdldFxuICAvLyB0YXJnZXRzIGNhbiBiZTpcbiAgLy8gICogYW4gZWxlbWVudCBpdHNlbGYsIHRoZW4gaXQgaXMgc2ltcGx5IHBhc3NlZCB0byBsaXZlU29ja2V0Lm93bmVyO1xuICAvLyAgKiBhIENJRCAoQ29tcG9uZW50IElEKSwgdGhlbiB3ZSBmaXJzdCBzZWFyY2ggdGhlIGNvbXBvbmVudCdzIGVsZW1lbnQgaW4gdGhlIERPTVxuICAvLyAgKiBhIHNlbGVjdG9yLCB0aGVuIHdlIHNlYXJjaCB0aGUgc2VsZWN0b3IgaW4gdGhlIERPTSBhbmQgY2FsbCB0aGUgY2FsbGJhY2tcbiAgLy8gICAgZm9yIGVhY2ggZWxlbWVudCBmb3VuZCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIG93bmVyIHZpZXdcbiAgd2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsIGNhbGxiYWNrLCBkb20gPSBkb2N1bWVudCwgdmlld0VsKXtcbiAgICAvLyBpbiB0aGUgZm9ybSByZWNvdmVyeSBjYXNlIHdlIHNlYXJjaCBpbiBhIHRlbXBsYXRlIGZyYWdtZW50IGluc3RlYWQgb2ZcbiAgICAvLyB0aGUgcmVhbCBkb20sIHRoZXJlZm9yZSB3ZSBvcHRpb25hbGx5IHBhc3MgZG9tIGFuZCB2aWV3RWxcblxuICAgIGlmKHBoeFRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHBoeFRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpe1xuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5vd25lcihwaHhUYXJnZXQsIHZpZXcgPT4gY2FsbGJhY2sodmlldywgcGh4VGFyZ2V0KSlcbiAgICB9XG5cbiAgICBpZihpc0NpZChwaHhUYXJnZXQpKXtcbiAgICAgIGxldCB0YXJnZXRzID0gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh2aWV3RWwgfHwgdGhpcy5lbCwgcGh4VGFyZ2V0KVxuICAgICAgaWYodGFyZ2V0cy5sZW5ndGggPT09IDApe1xuICAgICAgICBsb2dFcnJvcihgbm8gY29tcG9uZW50IGZvdW5kIG1hdGNoaW5nIHBoeC10YXJnZXQgb2YgJHtwaHhUYXJnZXR9YClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMsIHBhcnNlSW50KHBoeFRhcmdldCkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB0YXJnZXRzID0gQXJyYXkuZnJvbShkb20ucXVlcnlTZWxlY3RvckFsbChwaHhUYXJnZXQpKVxuICAgICAgaWYodGFyZ2V0cy5sZW5ndGggPT09IDApeyBsb2dFcnJvcihgbm90aGluZyBmb3VuZCBtYXRjaGluZyB0aGUgcGh4LXRhcmdldCBzZWxlY3RvciBcIiR7cGh4VGFyZ2V0fVwiYCkgfVxuICAgICAgdGFyZ2V0cy5mb3JFYWNoKHRhcmdldCA9PiB0aGlzLmxpdmVTb2NrZXQub3duZXIodGFyZ2V0LCB2aWV3ID0+IGNhbGxiYWNrKHZpZXcsIHRhcmdldCkpKVxuICAgIH1cbiAgfVxuXG4gIGFwcGx5RGlmZih0eXBlLCByYXdEaWZmLCBjYWxsYmFjayl7XG4gICAgdGhpcy5sb2codHlwZSwgKCkgPT4gW1wiXCIsIGNsb25lKHJhd0RpZmYpXSlcbiAgICBsZXQge2RpZmYsIHJlcGx5LCBldmVudHMsIHRpdGxlfSA9IFJlbmRlcmVkLmV4dHJhY3QocmF3RGlmZilcbiAgICBjYWxsYmFjayh7ZGlmZiwgcmVwbHksIGV2ZW50c30pXG4gICAgaWYodHlwZW9mIHRpdGxlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT0gXCJtb3VudFwiKXsgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBET00ucHV0VGl0bGUodGl0bGUpKSB9XG4gIH1cblxuICBvbkpvaW4ocmVzcCl7XG4gICAgbGV0IHtyZW5kZXJlZCwgY29udGFpbmVyLCBsaXZldmlld192ZXJzaW9ufSA9IHJlc3BcbiAgICBpZihjb250YWluZXIpe1xuICAgICAgbGV0IFt0YWcsIGF0dHJzXSA9IGNvbnRhaW5lclxuICAgICAgdGhpcy5lbCA9IERPTS5yZXBsYWNlUm9vdENvbnRhaW5lcih0aGlzLmVsLCB0YWcsIGF0dHJzKVxuICAgIH1cbiAgICB0aGlzLmNoaWxkSm9pbnMgPSAwXG4gICAgdGhpcy5qb2luUGVuZGluZyA9IHRydWVcbiAgICB0aGlzLmZsYXNoID0gbnVsbFxuICAgIGlmKHRoaXMucm9vdCA9PT0gdGhpcyl7XG4gICAgICB0aGlzLmZvcm1zRm9yUmVjb3ZlcnkgPSB0aGlzLmdldEZvcm1zRm9yUmVjb3ZlcnkoKVxuICAgIH1cbiAgICBpZih0aGlzLmlzTWFpbigpICYmIHdpbmRvdy5oaXN0b3J5LnN0YXRlID09PSBudWxsKXtcbiAgICAgIC8vIHNldCBpbml0aWFsIGhpc3RvcnkgZW50cnkgaWYgdGhpcyBpcyB0aGUgZmlyc3QgcGFnZSBsb2FkXG4gICAgICB0aGlzLmxpdmVTb2NrZXQucmVwbGFjZVJvb3RIaXN0b3J5KClcbiAgICB9XG5cbiAgICBpZihsaXZldmlld192ZXJzaW9uICE9PSB0aGlzLmxpdmVTb2NrZXQudmVyc2lvbigpKXtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYExpdmVWaWV3IGFzc2V0IHZlcnNpb24gbWlzbWF0Y2guIEphdmFTY3JpcHQgdmVyc2lvbiAke3RoaXMubGl2ZVNvY2tldC52ZXJzaW9uKCl9IHZzLiBzZXJ2ZXIgJHtsaXZldmlld192ZXJzaW9ufS4gVG8gYXZvaWQgaXNzdWVzLCBwbGVhc2UgZW5zdXJlIHRoYXQgeW91ciBhc3NldHMgdXNlIHRoZSBzYW1lIHZlcnNpb24gYXMgdGhlIHNlcnZlci5gKVxuICAgIH1cblxuICAgIEJyb3dzZXIuZHJvcExvY2FsKHRoaXMubGl2ZVNvY2tldC5sb2NhbFN0b3JhZ2UsIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSwgQ09OU0VDVVRJVkVfUkVMT0FEUylcbiAgICB0aGlzLmFwcGx5RGlmZihcIm1vdW50XCIsIHJlbmRlcmVkLCAoe2RpZmYsIGV2ZW50c30pID0+IHtcbiAgICAgIHRoaXMucmVuZGVyZWQgPSBuZXcgUmVuZGVyZWQodGhpcy5pZCwgZGlmZilcbiAgICAgIGxldCBbaHRtbCwgc3RyZWFtc10gPSB0aGlzLnJlbmRlckNvbnRhaW5lcihudWxsLCBcImpvaW5cIilcbiAgICAgIHRoaXMuZHJvcFBlbmRpbmdSZWZzKClcbiAgICAgIHRoaXMuam9pbkNvdW50KytcbiAgICAgIHRoaXMuam9pbkF0dGVtcHRzID0gMFxuXG4gICAgICB0aGlzLm1heWJlUmVjb3ZlckZvcm1zKGh0bWwsICgpID0+IHtcbiAgICAgICAgdGhpcy5vbkpvaW5Db21wbGV0ZShyZXNwLCBodG1sLCBzdHJlYW1zLCBldmVudHMpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBkcm9wUGVuZGluZ1JlZnMoKXtcbiAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7UEhYX1JFRl9TUkN9PVwiJHt0aGlzLnJlZlNyYygpfVwiXWAsIGVsID0+IHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGX0xPQURJTkcpXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRl9MT0NLKVxuICAgIH0pXG4gIH1cblxuICBvbkpvaW5Db21wbGV0ZSh7bGl2ZV9wYXRjaH0sIGh0bWwsIHN0cmVhbXMsIGV2ZW50cyl7XG4gICAgLy8gSW4gb3JkZXIgdG8gcHJvdmlkZSBhIGJldHRlciBleHBlcmllbmNlLCB3ZSB3YW50IHRvIGpvaW5cbiAgICAvLyBhbGwgTGl2ZVZpZXdzIGZpcnN0IGFuZCBvbmx5IHRoZW4gYXBwbHkgdGhlaXIgcGF0Y2hlcy5cbiAgICBpZih0aGlzLmpvaW5Db3VudCA+IDEgfHwgKHRoaXMucGFyZW50ICYmICF0aGlzLnBhcmVudC5pc0pvaW5QZW5kaW5nKCkpKXtcbiAgICAgIHJldHVybiB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIHN0cmVhbXMsIGV2ZW50cylcbiAgICB9XG5cbiAgICAvLyBPbmUgZG93bnNpZGUgb2YgdGhpcyBhcHByb2FjaCBpcyB0aGF0IHdlIG5lZWQgdG8gZmluZCBwaHhDaGlsZHJlblxuICAgIC8vIGluIHRoZSBodG1sIGZyYWdtZW50LCBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBET00uIFRoZSBmcmFnbWVudFxuICAgIC8vIGFsc28gZG9lcyBub3QgaW5jbHVkZSBQSFhfU1RBVElDLCBzbyB3ZSBuZWVkIHRvIGNvcHkgaXQgb3ZlciBmcm9tXG4gICAgLy8gdGhlIERPTS5cbiAgICBsZXQgbmV3Q2hpbGRyZW4gPSBET00uZmluZFBoeENoaWxkcmVuSW5GcmFnbWVudChodG1sLCB0aGlzLmlkKS5maWx0ZXIodG9FbCA9PiB7XG4gICAgICBsZXQgZnJvbUVsID0gdG9FbC5pZCAmJiB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoYFtpZD1cIiR7dG9FbC5pZH1cIl1gKVxuICAgICAgbGV0IHBoeFN0YXRpYyA9IGZyb21FbCAmJiBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9TVEFUSUMpXG4gICAgICBpZihwaHhTdGF0aWMpeyB0b0VsLnNldEF0dHJpYnV0ZShQSFhfU1RBVElDLCBwaHhTdGF0aWMpIH1cbiAgICAgIC8vIHNldCBQSFhfUk9PVF9JRCB0byBwcmV2ZW50IGV2ZW50cyBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgdG8gdGhlIHJvb3Qgdmlld1xuICAgICAgLy8gd2hpbGUgdGhlIGNoaWxkIGpvaW4gaXMgc3RpbGwgcGVuZGluZ1xuICAgICAgaWYoZnJvbUVsKXsgZnJvbUVsLnNldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCwgdGhpcy5yb290LmlkKSB9XG4gICAgICByZXR1cm4gdGhpcy5qb2luQ2hpbGQodG9FbClcbiAgICB9KVxuXG4gICAgaWYobmV3Q2hpbGRyZW4ubGVuZ3RoID09PSAwKXtcbiAgICAgIGlmKHRoaXMucGFyZW50KXtcbiAgICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgc3RyZWFtcywgZXZlbnRzKV0pXG4gICAgICAgIHRoaXMucGFyZW50LmFja0pvaW4odGhpcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKVxuICAgICAgICB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIHN0cmVhbXMsIGV2ZW50cylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgc3RyZWFtcywgZXZlbnRzKV0pXG4gICAgfVxuICB9XG5cbiAgYXR0YWNoVHJ1ZURvY0VsKCl7XG4gICAgdGhpcy5lbCA9IERPTS5ieUlkKHRoaXMuaWQpXG4gICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdC5pZClcbiAgfVxuXG4gIC8vIHRoaXMgaXMgaW52b2tlZCBmb3IgZGVhZCBhbmQgbGl2ZSB2aWV3cywgc28gd2UgbXVzdCBmaWx0ZXIgYnlcbiAgLy8gYnkgb3duZXIgdG8gZW5zdXJlIHdlIGFyZW4ndCBkdXBsaWNhdGluZyBob29rcyBhY3Jvc3MgZGlzY29ubmVjdFxuICAvLyBhbmQgY29ubmVjdGVkIHN0YXRlcy4gVGhpcyBhbHNvIGhhbmRsZXMgY2FzZXMgd2hlcmUgaG9va3MgZXhpc3RcbiAgLy8gaW4gYSByb290IGxheW91dCB3aXRoIGEgTFYgaW4gdGhlIGJvZHlcbiAgZXhlY05ld01vdW50ZWQocGFyZW50ID0gdGhpcy5lbCl7XG4gICAgbGV0IHBoeFZpZXdwb3J0VG9wID0gdGhpcy5iaW5kaW5nKFBIWF9WSUVXUE9SVF9UT1ApXG4gICAgbGV0IHBoeFZpZXdwb3J0Qm90dG9tID0gdGhpcy5iaW5kaW5nKFBIWF9WSUVXUE9SVF9CT1RUT00pXG4gICAgRE9NLmFsbChwYXJlbnQsIGBbJHtwaHhWaWV3cG9ydFRvcH1dLCBbJHtwaHhWaWV3cG9ydEJvdHRvbX1dYCwgaG9va0VsID0+IHtcbiAgICAgIGlmKHRoaXMub3duc0VsZW1lbnQoaG9va0VsKSl7XG4gICAgICAgIERPTS5tYWludGFpblByaXZhdGVIb29rcyhob29rRWwsIGhvb2tFbCwgcGh4Vmlld3BvcnRUb3AsIHBoeFZpZXdwb3J0Qm90dG9tKVxuICAgICAgICB0aGlzLm1heWJlQWRkTmV3SG9vayhob29rRWwpXG4gICAgICB9XG4gICAgfSlcbiAgICBET00uYWxsKHBhcmVudCwgYFske3RoaXMuYmluZGluZyhQSFhfSE9PSyl9XSwgW2RhdGEtcGh4LSR7UEhYX0hPT0t9XWAsIGhvb2tFbCA9PiB7XG4gICAgICBpZih0aGlzLm93bnNFbGVtZW50KGhvb2tFbCkpe1xuICAgICAgICB0aGlzLm1heWJlQWRkTmV3SG9vayhob29rRWwpXG4gICAgICB9XG4gICAgfSlcbiAgICBET00uYWxsKHBhcmVudCwgYFske3RoaXMuYmluZGluZyhQSFhfTU9VTlRFRCl9XWAsIGVsID0+IHtcbiAgICAgIGlmKHRoaXMub3duc0VsZW1lbnQoZWwpKXtcbiAgICAgICAgdGhpcy5tYXliZU1vdW50ZWQoZWwpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIHN0cmVhbXMsIGV2ZW50cyl7XG4gICAgdGhpcy5hdHRhY2hUcnVlRG9jRWwoKVxuICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBzdHJlYW1zLCBudWxsKVxuICAgIHBhdGNoLm1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsKClcbiAgICB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgZmFsc2UsIHRydWUpXG4gICAgdGhpcy5qb2luTmV3Q2hpbGRyZW4oKVxuICAgIHRoaXMuZXhlY05ld01vdW50ZWQoKVxuXG4gICAgdGhpcy5qb2luUGVuZGluZyA9IGZhbHNlXG4gICAgdGhpcy5saXZlU29ja2V0LmRpc3BhdGNoRXZlbnRzKGV2ZW50cylcbiAgICB0aGlzLmFwcGx5UGVuZGluZ1VwZGF0ZXMoKVxuXG4gICAgaWYobGl2ZV9wYXRjaCl7XG4gICAgICBsZXQge2tpbmQsIHRvfSA9IGxpdmVfcGF0Y2hcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UGF0Y2godG8sIGtpbmQpXG4gICAgfVxuICAgIHRoaXMuaGlkZUxvYWRlcigpXG4gICAgaWYodGhpcy5qb2luQ291bnQgPiAxKXsgdGhpcy50cmlnZ2VyUmVjb25uZWN0ZWQoKSB9XG4gICAgdGhpcy5zdG9wQ2FsbGJhY2soKVxuICB9XG5cbiAgdHJpZ2dlckJlZm9yZVVwZGF0ZUhvb2soZnJvbUVsLCB0b0VsKXtcbiAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uQmVmb3JlRWxVcGRhdGVkXCIsIFtmcm9tRWwsIHRvRWxdKVxuICAgIGxldCBob29rID0gdGhpcy5nZXRIb29rKGZyb21FbClcbiAgICBsZXQgaXNJZ25vcmVkID0gaG9vayAmJiBET00uaXNJZ25vcmVkKGZyb21FbCwgdGhpcy5iaW5kaW5nKFBIWF9VUERBVEUpKVxuICAgIGlmKGhvb2sgJiYgIWZyb21FbC5pc0VxdWFsTm9kZSh0b0VsKSAmJiAhKGlzSWdub3JlZCAmJiBpc0VxdWFsT2JqKGZyb21FbC5kYXRhc2V0LCB0b0VsLmRhdGFzZXQpKSl7XG4gICAgICBob29rLl9fYmVmb3JlVXBkYXRlKClcbiAgICAgIHJldHVybiBob29rXG4gICAgfVxuICB9XG5cbiAgbWF5YmVNb3VudGVkKGVsKXtcbiAgICBsZXQgcGh4TW91bnRlZCA9IGVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX01PVU5URUQpKVxuICAgIGxldCBoYXNCZWVuSW52b2tlZCA9IHBoeE1vdW50ZWQgJiYgRE9NLnByaXZhdGUoZWwsIFwibW91bnRlZFwiKVxuICAgIGlmKHBoeE1vdW50ZWQgJiYgIWhhc0JlZW5JbnZva2VkKXtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5leGVjSlMoZWwsIHBoeE1vdW50ZWQpXG4gICAgICBET00ucHV0UHJpdmF0ZShlbCwgXCJtb3VudGVkXCIsIHRydWUpXG4gICAgfVxuICB9XG5cbiAgbWF5YmVBZGROZXdIb29rKGVsKXtcbiAgICBsZXQgbmV3SG9vayA9IHRoaXMuYWRkSG9vayhlbClcbiAgICBpZihuZXdIb29rKXsgbmV3SG9vay5fX21vdW50ZWQoKSB9XG4gIH1cblxuICBwZXJmb3JtUGF0Y2gocGF0Y2gsIHBydW5lQ2lkcywgaXNKb2luUGF0Y2ggPSBmYWxzZSl7XG4gICAgbGV0IHJlbW92ZWRFbHMgPSBbXVxuICAgIGxldCBwaHhDaGlsZHJlbkFkZGVkID0gZmFsc2VcbiAgICBsZXQgdXBkYXRlZEhvb2tJZHMgPSBuZXcgU2V0KClcblxuICAgIHRoaXMubGl2ZVNvY2tldC50cmlnZ2VyRE9NKFwib25QYXRjaFN0YXJ0XCIsIFtwYXRjaC50YXJnZXRDb250YWluZXJdKVxuXG4gICAgcGF0Y2guYWZ0ZXIoXCJhZGRlZFwiLCBlbCA9PiB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uTm9kZUFkZGVkXCIsIFtlbF0pXG4gICAgICBsZXQgcGh4Vmlld3BvcnRUb3AgPSB0aGlzLmJpbmRpbmcoUEhYX1ZJRVdQT1JUX1RPUClcbiAgICAgIGxldCBwaHhWaWV3cG9ydEJvdHRvbSA9IHRoaXMuYmluZGluZyhQSFhfVklFV1BPUlRfQk9UVE9NKVxuICAgICAgRE9NLm1haW50YWluUHJpdmF0ZUhvb2tzKGVsLCBlbCwgcGh4Vmlld3BvcnRUb3AsIHBoeFZpZXdwb3J0Qm90dG9tKVxuICAgICAgdGhpcy5tYXliZUFkZE5ld0hvb2soZWwpXG4gICAgICBpZihlbC5nZXRBdHRyaWJ1dGUpeyB0aGlzLm1heWJlTW91bnRlZChlbCkgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5hZnRlcihcInBoeENoaWxkQWRkZWRcIiwgZWwgPT4ge1xuICAgICAgaWYoRE9NLmlzUGh4U3RpY2t5KGVsKSl7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5qb2luUm9vdFZpZXdzKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBoeENoaWxkcmVuQWRkZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcblxuICAgIHBhdGNoLmJlZm9yZShcInVwZGF0ZWRcIiwgKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgbGV0IGhvb2sgPSB0aGlzLnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGZyb21FbCwgdG9FbClcbiAgICAgIGlmKGhvb2speyB1cGRhdGVkSG9va0lkcy5hZGQoZnJvbUVsLmlkKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwidXBkYXRlZFwiLCBlbCA9PiB7XG4gICAgICBpZih1cGRhdGVkSG9va0lkcy5oYXMoZWwuaWQpKXsgdGhpcy5nZXRIb29rKGVsKS5fX3VwZGF0ZWQoKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwiZGlzY2FyZGVkXCIsIChlbCkgPT4ge1xuICAgICAgaWYoZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKXsgcmVtb3ZlZEVscy5wdXNoKGVsKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwidHJhbnNpdGlvbnNEaXNjYXJkZWRcIiwgZWxzID0+IHRoaXMuYWZ0ZXJFbGVtZW50c1JlbW92ZWQoZWxzLCBwcnVuZUNpZHMpKVxuICAgIHBhdGNoLnBlcmZvcm0oaXNKb2luUGF0Y2gpXG4gICAgdGhpcy5hZnRlckVsZW1lbnRzUmVtb3ZlZChyZW1vdmVkRWxzLCBwcnVuZUNpZHMpXG5cbiAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uUGF0Y2hFbmRcIiwgW3BhdGNoLnRhcmdldENvbnRhaW5lcl0pXG4gICAgcmV0dXJuIHBoeENoaWxkcmVuQWRkZWRcbiAgfVxuXG4gIGFmdGVyRWxlbWVudHNSZW1vdmVkKGVsZW1lbnRzLCBwcnVuZUNpZHMpe1xuICAgIGxldCBkZXN0cm95ZWRDSURzID0gW11cbiAgICBlbGVtZW50cy5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICBsZXQgY29tcG9uZW50cyA9IERPTS5hbGwocGFyZW50LCBgWyR7UEhYX0NPTVBPTkVOVH1dYClcbiAgICAgIGxldCBob29rcyA9IERPTS5hbGwocGFyZW50LCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9IT09LKX1dLCBbZGF0YS1waHgtaG9va11gKVxuICAgICAgY29tcG9uZW50cy5jb25jYXQocGFyZW50KS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgbGV0IGNpZCA9IHRoaXMuY29tcG9uZW50SUQoZWwpXG4gICAgICAgIGlmKGlzQ2lkKGNpZCkgJiYgZGVzdHJveWVkQ0lEcy5pbmRleE9mKGNpZCkgPT09IC0xKXsgZGVzdHJveWVkQ0lEcy5wdXNoKGNpZCkgfVxuICAgICAgfSlcbiAgICAgIGhvb2tzLmNvbmNhdChwYXJlbnQpLmZvckVhY2goaG9va0VsID0+IHtcbiAgICAgICAgbGV0IGhvb2sgPSB0aGlzLmdldEhvb2soaG9va0VsKVxuICAgICAgICBob29rICYmIHRoaXMuZGVzdHJveUhvb2soaG9vaylcbiAgICAgIH0pXG4gICAgfSlcbiAgICAvLyBXZSBzaG91bGQgbm90IHBydW5lQ2lkcyBvbiBqb2lucy4gT3RoZXJ3aXNlLCBpbiBjYXNlIG9mXG4gICAgLy8gcmVqb2lucywgd2UgbWF5IG5vdGlmeSBjaWRzIHRoYXQgbm8gbG9uZ2VyIGJlbG9uZyB0byB0aGVcbiAgICAvLyBjdXJyZW50IExpdmVWaWV3IHRvIGJlIHJlbW92ZWQuXG4gICAgaWYocHJ1bmVDaWRzKXtcbiAgICAgIHRoaXMubWF5YmVQdXNoQ29tcG9uZW50c0Rlc3Ryb3llZChkZXN0cm95ZWRDSURzKVxuICAgIH1cbiAgfVxuXG4gIGpvaW5OZXdDaGlsZHJlbigpe1xuICAgIERPTS5maW5kUGh4Q2hpbGRyZW4odGhpcy5lbCwgdGhpcy5pZCkuZm9yRWFjaChlbCA9PiB0aGlzLmpvaW5DaGlsZChlbCkpXG4gIH1cblxuICBtYXliZVJlY292ZXJGb3JtcyhodG1sLCBjYWxsYmFjayl7XG4gICAgY29uc3QgcGh4Q2hhbmdlID0gdGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpXG4gICAgY29uc3Qgb2xkRm9ybXMgPSB0aGlzLnJvb3QuZm9ybXNGb3JSZWNvdmVyeVxuICAgIC8vIFNvIHdoeSBkbyB3ZSBjcmVhdGUgYSB0ZW1wbGF0ZSBlbGVtZW50IGhlcmU/XG4gICAgLy8gT25lIHdheSB0byByZWNvdmVyIGZvcm1zIHdvdWxkIGJlIHRvIGltbWVkaWF0ZWx5IGFwcGx5IHRoZSBtb3VudFxuICAgIC8vIHBhdGNoIGFuZCB0aGVuIGFmdGVyd2FyZHMgcmVjb3ZlciB0aGUgZm9ybXMuIEhvd2V2ZXIsIHRoaXMgd291bGRcbiAgICAvLyBjYXVzZSBhIGZsaWNrZXIsIGJlY2F1c2UgdGhlIG1vdW50IHBhdGNoIHdvdWxkIHJlbW92ZSB0aGUgZm9ybSBjb250ZW50XG4gICAgLy8gdW50aWwgaXQgaXMgcmVzdG9yZWQuIFRoZXJlZm9yZSBMViBkZWNpZGVkIHRvIGRvIGZvcm0gcmVjb3Zlcnkgd2l0aCB0aGVcbiAgICAvLyByYXcgSFRNTCBiZWZvcmUgaXQgaXMgYXBwbGllZCBhbmQgZGVsYXkgdGhlIG1vdW50IHBhdGNoIHVudGlsIHRoZSBmb3JtXG4gICAgLy8gcmVjb3ZlcnkgZXZlbnRzIGFyZSBkb25lLlxuICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWxcbiAgICAvLyBiZWNhdXNlIHdlIHdvcmsgd2l0aCBhIHRlbXBsYXRlIGVsZW1lbnQsIHdlIG11c3QgbWFudWFsbHkgY29weSB0aGUgYXR0cmlidXRlc1xuICAgIC8vIG90aGVyd2lzZSB0aGUgb3duZXIgLyB0YXJnZXQgaGVscGVycyBkb24ndCB3b3JrIHByb3Blcmx5XG4gICAgY29uc3Qgcm9vdEVsID0gdGVtcGxhdGUuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZFxuICAgIHJvb3RFbC5pZCA9IHRoaXMuaWRcbiAgICByb290RWwuc2V0QXR0cmlidXRlKFBIWF9ST09UX0lELCB0aGlzLnJvb3QuaWQpXG4gICAgcm9vdEVsLnNldEF0dHJpYnV0ZShQSFhfU0VTU0lPTiwgdGhpcy5nZXRTZXNzaW9uKCkpXG4gICAgcm9vdEVsLnNldEF0dHJpYnV0ZShQSFhfU1RBVElDLCB0aGlzLmdldFN0YXRpYygpKVxuICAgIHJvb3RFbC5zZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCwgdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5pZCA6IG51bGwpXG5cbiAgICAvLyB3ZSBnbyBvdmVyIGFsbCBmb3JtIGVsZW1lbnRzIGluIHRoZSBuZXcgSFRNTCBmb3IgdGhlIExWXG4gICAgLy8gYW5kIGxvb2sgZm9yIG9sZCBmb3JtcyBpbiB0aGUgYGZvcm1zRm9yUmVjb3ZlcnlgIG9iamVjdDtcbiAgICAvLyB0aGUgZm9ybXNGb3JSZWNvdmVyeSBjYW4gYWxzbyBjb250YWluIGZvcm1zIGZyb20gY2hpbGQgdmlld3NcbiAgICBjb25zdCBmb3Jtc1RvUmVjb3ZlciA9XG4gICAgICAvLyB3ZSBnbyBvdmVyIGFsbCBmb3JtcyBpbiB0aGUgbmV3IERPTTsgYmVjYXVzZSB0aGlzIGlzIG9ubHkgdGhlIEhUTUwgZm9yIHRoZSBjdXJyZW50XG4gICAgICAvLyB2aWV3LCB3ZSBjYW4gYmUgc3VyZSB0aGF0IGFsbCBmb3JtcyBhcmUgb3duZWQgYnkgdGhpcyB2aWV3OlxuICAgICAgRE9NLmFsbCh0ZW1wbGF0ZS5jb250ZW50LCBcImZvcm1cIilcbiAgICAgICAgLy8gb25seSByZWNvdmVyIGZvcm1zIHRoYXQgaGF2ZSBhbiBpZCBhbmQgYXJlIGluIHRoZSBvbGQgRE9NXG4gICAgICAgIC5maWx0ZXIobmV3Rm9ybSA9PiBuZXdGb3JtLmlkICYmIG9sZEZvcm1zW25ld0Zvcm0uaWRdKVxuICAgICAgICAvLyBhYmFuZG9uIGZvcm1zIHdlIGFscmVhZHkgdHJpZWQgdG8gcmVjb3ZlciB0byBwcmV2ZW50IGxvb3BpbmcgYSBmYWlsZWQgc3RhdGVcbiAgICAgICAgLmZpbHRlcihuZXdGb3JtID0+ICF0aGlzLnBlbmRpbmdGb3Jtcy5oYXMobmV3Rm9ybS5pZCkpXG4gICAgICAgIC8vIG9ubHkgcmVjb3ZlciBpZiB0aGUgZm9ybSBoYXMgdGhlIHNhbWUgcGh4LWNoYW5nZSB2YWx1ZVxuICAgICAgICAuZmlsdGVyKG5ld0Zvcm0gPT4gb2xkRm9ybXNbbmV3Rm9ybS5pZF0uZ2V0QXR0cmlidXRlKHBoeENoYW5nZSkgPT09IG5ld0Zvcm0uZ2V0QXR0cmlidXRlKHBoeENoYW5nZSkpXG4gICAgICAgIC5tYXAobmV3Rm9ybSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtvbGRGb3Jtc1tuZXdGb3JtLmlkXSwgbmV3Rm9ybV1cbiAgICAgICAgfSlcblxuICAgIGlmKGZvcm1zVG9SZWNvdmVyLmxlbmd0aCA9PT0gMCl7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgIH1cblxuICAgIGZvcm1zVG9SZWNvdmVyLmZvckVhY2goKFtvbGRGb3JtLCBuZXdGb3JtXSwgaSkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nRm9ybXMuYWRkKG5ld0Zvcm0uaWQpXG4gICAgICAvLyBpdCBpcyBpbXBvcnRhbnQgdG8gdXNlIHRoZSBmaXJzdEVsZW1lbnRDaGlsZCBvZiB0aGUgdGVtcGxhdGUgY29udGVudFxuICAgICAgLy8gYmVjYXVzZSB3aGVuIHRyYXZlcnNpbmcgYSBkb2N1bWVudEZyYWdtZW50IHVzaW5nIHBhcmVudE5vZGUsIHdlIHdvbid0IGV2ZXIgYXJyaXZlIGF0XG4gICAgICAvLyB0aGUgZnJhZ21lbnQ7IGFzIHRoZSB0ZW1wbGF0ZSBpcyBhbHdheXMgYSBMaXZlVmlldywgd2UgY2FuIGJlIHN1cmUgdGhhdCB0aGVyZSBpcyBvbmx5XG4gICAgICAvLyBvbmUgY2hpbGQgb24gdGhlIHJvb3QgbGV2ZWxcbiAgICAgIHRoaXMucHVzaEZvcm1SZWNvdmVyeShvbGRGb3JtLCBuZXdGb3JtLCB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkLCAoKSA9PiB7XG4gICAgICAgIHRoaXMucGVuZGluZ0Zvcm1zLmRlbGV0ZShuZXdGb3JtLmlkKVxuICAgICAgICAvLyB3ZSBvbmx5IGNhbGwgdGhlIGNhbGxiYWNrIG9uY2UgYWxsIGZvcm1zIGhhdmUgYmVlbiByZWNvdmVyZWRcbiAgICAgICAgaWYoaSA9PT0gZm9ybXNUb1JlY292ZXIubGVuZ3RoIC0gMSl7XG4gICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBnZXRDaGlsZEJ5SWQoaWQpeyByZXR1cm4gdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdW2lkXSB9XG5cbiAgZ2V0RGVzY2VuZGVudEJ5RWwoZWwpe1xuICAgIGlmKGVsLmlkID09PSB0aGlzLmlkKXtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2VsLmdldEF0dHJpYnV0ZShQSFhfUEFSRU5UX0lEKV0/LltlbC5pZF1cbiAgICB9XG4gIH1cblxuICBkZXN0cm95RGVzY2VuZGVudChpZCl7XG4gICAgZm9yKGxldCBwYXJlbnRJZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW4pe1xuICAgICAgZm9yKGxldCBjaGlsZElkIGluIHRoaXMucm9vdC5jaGlsZHJlbltwYXJlbnRJZF0pe1xuICAgICAgICBpZihjaGlsZElkID09PSBpZCl7IHJldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bcGFyZW50SWRdW2NoaWxkSWRdLmRlc3Ryb3koKSB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgam9pbkNoaWxkKGVsKXtcbiAgICBsZXQgY2hpbGQgPSB0aGlzLmdldENoaWxkQnlJZChlbC5pZClcbiAgICBpZighY2hpbGQpe1xuICAgICAgbGV0IHZpZXcgPSBuZXcgVmlldyhlbCwgdGhpcy5saXZlU29ja2V0LCB0aGlzKVxuICAgICAgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdW3ZpZXcuaWRdID0gdmlld1xuICAgICAgdmlldy5qb2luKClcbiAgICAgIHRoaXMuY2hpbGRKb2lucysrXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGlzSm9pblBlbmRpbmcoKXsgcmV0dXJuIHRoaXMuam9pblBlbmRpbmcgfVxuXG4gIGFja0pvaW4oX2NoaWxkKXtcbiAgICB0aGlzLmNoaWxkSm9pbnMtLVxuXG4gICAgaWYodGhpcy5jaGlsZEpvaW5zID09PSAwKXtcbiAgICAgIGlmKHRoaXMucGFyZW50KXtcbiAgICAgICAgdGhpcy5wYXJlbnQuYWNrSm9pbih0aGlzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkFsbENoaWxkSm9pbnNDb21wbGV0ZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKXtcbiAgICAvLyB3ZSBjYW4gY2xlYXIgcGVuZGluZyBmb3JtIHJlY292ZXJpZXMgbm93IHRoYXQgd2UndmUgam9pbmVkLlxuICAgIC8vIFRoZXkgZWl0aGVyIGFsbCByZXNvbHZlZCBvciB3ZXJlIGFiYW5kb25lZFxuICAgIHRoaXMucGVuZGluZ0Zvcm1zLmNsZWFyKClcbiAgICAvLyB3ZSBjYW4gYWxzbyBjbGVhciB0aGUgZm9ybXNGb3JSZWNvdmVyeSBvYmplY3QgdG8gbm90IGtlZXAgb2xkIGZvcm0gZWxlbWVudHMgYXJvdW5kXG4gICAgdGhpcy5mb3Jtc0ZvclJlY292ZXJ5ID0ge31cbiAgICB0aGlzLmpvaW5DYWxsYmFjaygoKSA9PiB7XG4gICAgICB0aGlzLnBlbmRpbmdKb2luT3BzLmZvckVhY2goKFt2aWV3LCBvcF0pID0+IHtcbiAgICAgICAgaWYoIXZpZXcuaXNEZXN0cm95ZWQoKSl7IG9wKCkgfVxuICAgICAgfSlcbiAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMgPSBbXVxuICAgIH0pXG4gIH1cblxuICB1cGRhdGUoZGlmZiwgZXZlbnRzKXtcbiAgICBpZih0aGlzLmlzSm9pblBlbmRpbmcoKSB8fCAodGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkgJiYgdGhpcy5yb290LmlzTWFpbigpKSl7XG4gICAgICByZXR1cm4gdGhpcy5wZW5kaW5nRGlmZnMucHVzaCh7ZGlmZiwgZXZlbnRzfSlcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVkLm1lcmdlRGlmZihkaWZmKVxuICAgIGxldCBwaHhDaGlsZHJlbkFkZGVkID0gZmFsc2VcblxuICAgIC8vIFdoZW4gdGhlIGRpZmYgb25seSBjb250YWlucyBjb21wb25lbnQgZGlmZnMsIHRoZW4gd2FsayBjb21wb25lbnRzXG4gICAgLy8gYW5kIHBhdGNoIG9ubHkgdGhlIHBhcmVudCBjb21wb25lbnQgY29udGFpbmVycyBmb3VuZCBpbiB0aGUgZGlmZi5cbiAgICAvLyBPdGhlcndpc2UsIHBhdGNoIGVudGlyZSBMViBjb250YWluZXIuXG4gICAgaWYodGhpcy5yZW5kZXJlZC5pc0NvbXBvbmVudE9ubHlEaWZmKGRpZmYpKXtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC50aW1lKFwiY29tcG9uZW50IHBhdGNoIGNvbXBsZXRlXCIsICgpID0+IHtcbiAgICAgICAgbGV0IHBhcmVudENpZHMgPSBET00uZmluZEV4aXN0aW5nUGFyZW50Q0lEcyh0aGlzLmVsLCB0aGlzLnJlbmRlcmVkLmNvbXBvbmVudENJRHMoZGlmZikpXG4gICAgICAgIHBhcmVudENpZHMuZm9yRWFjaChwYXJlbnRDSUQgPT4ge1xuICAgICAgICAgIGlmKHRoaXMuY29tcG9uZW50UGF0Y2godGhpcy5yZW5kZXJlZC5nZXRDb21wb25lbnQoZGlmZiwgcGFyZW50Q0lEKSwgcGFyZW50Q0lEKSl7IHBoeENoaWxkcmVuQWRkZWQgPSB0cnVlIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmKCFpc0VtcHR5KGRpZmYpKXtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC50aW1lKFwiZnVsbCBwYXRjaCBjb21wbGV0ZVwiLCAoKSA9PiB7XG4gICAgICAgIGxldCBbaHRtbCwgc3RyZWFtc10gPSB0aGlzLnJlbmRlckNvbnRhaW5lcihkaWZmLCBcInVwZGF0ZVwiKVxuICAgICAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgc3RyZWFtcywgbnVsbClcbiAgICAgICAgcGh4Q2hpbGRyZW5BZGRlZCA9IHRoaXMucGVyZm9ybVBhdGNoKHBhdGNoLCB0cnVlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmxpdmVTb2NrZXQuZGlzcGF0Y2hFdmVudHMoZXZlbnRzKVxuICAgIGlmKHBoeENoaWxkcmVuQWRkZWQpeyB0aGlzLmpvaW5OZXdDaGlsZHJlbigpIH1cbiAgfVxuXG4gIHJlbmRlckNvbnRhaW5lcihkaWZmLCBraW5kKXtcbiAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LnRpbWUoYHRvU3RyaW5nIGRpZmYgKCR7a2luZH0pYCwgKCkgPT4ge1xuICAgICAgbGV0IHRhZyA9IHRoaXMuZWwudGFnTmFtZVxuICAgICAgLy8gRG9uJ3Qgc2tpcCBhbnkgY29tcG9uZW50IGluIHRoZSBkaWZmIG5vciBhbnkgbWFya2VkIGFzIHBydW5lZFxuICAgICAgLy8gKGFzIHRoZXkgbWF5IGhhdmUgYmVlbiBhZGRlZCBiYWNrKVxuICAgICAgbGV0IGNpZHMgPSBkaWZmID8gdGhpcy5yZW5kZXJlZC5jb21wb25lbnRDSURzKGRpZmYpIDogbnVsbFxuICAgICAgbGV0IFtodG1sLCBzdHJlYW1zXSA9IHRoaXMucmVuZGVyZWQudG9TdHJpbmcoY2lkcylcbiAgICAgIHJldHVybiBbYDwke3RhZ30+JHtodG1sfTwvJHt0YWd9PmAsIHN0cmVhbXNdXG4gICAgfSlcbiAgfVxuXG4gIGNvbXBvbmVudFBhdGNoKGRpZmYsIGNpZCl7XG4gICAgaWYoaXNFbXB0eShkaWZmKSkgcmV0dXJuIGZhbHNlXG4gICAgbGV0IFtodG1sLCBzdHJlYW1zXSA9IHRoaXMucmVuZGVyZWQuY29tcG9uZW50VG9TdHJpbmcoY2lkKVxuICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBzdHJlYW1zLCBjaWQpXG4gICAgbGV0IGNoaWxkcmVuQWRkZWQgPSB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgdHJ1ZSlcbiAgICByZXR1cm4gY2hpbGRyZW5BZGRlZFxuICB9XG5cbiAgZ2V0SG9vayhlbCl7IHJldHVybiB0aGlzLnZpZXdIb29rc1tWaWV3SG9vay5lbGVtZW50SUQoZWwpXSB9XG5cbiAgYWRkSG9vayhlbCl7XG4gICAgbGV0IGhvb2tFbElkID0gVmlld0hvb2suZWxlbWVudElEKGVsKVxuXG4gICAgaWYoaG9va0VsSWQgJiYgIXRoaXMudmlld0hvb2tzW2hvb2tFbElkXSl7XG4gICAgICAvLyBob29rIGNyZWF0ZWQsIGJ1dCBub3QgYXR0YWNoZWQgKGNyZWF0ZUhvb2sgZm9yIHdlYiBjb21wb25lbnQpXG4gICAgICBsZXQgaG9vayA9IERPTS5nZXRDdXN0b21FbEhvb2soZWwpIHx8IGxvZ0Vycm9yKGBubyBob29rIGZvdW5kIGZvciBjdXN0b20gZWxlbWVudDogJHtlbC5pZH1gKVxuICAgICAgdGhpcy52aWV3SG9va3NbaG9va0VsSWRdID0gaG9va1xuICAgICAgaG9vay5fX2F0dGFjaFZpZXcodGhpcylcbiAgICAgIHJldHVybiBob29rXG4gICAgfVxuICAgIGVsc2UgaWYoaG9va0VsSWQgfHwgIWVsLmdldEF0dHJpYnV0ZSl7XG4gICAgICAvLyBubyBob29rIGZvdW5kXG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbmV3IGhvb2sgZm91bmQgd2l0aCBwaHgtaG9vayBhdHRyaWJ1dGVcbiAgICAgIGxldCBob29rTmFtZSA9IGVsLmdldEF0dHJpYnV0ZShgZGF0YS1waHgtJHtQSFhfSE9PS31gKSB8fCBlbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9IT09LKSlcbiAgICAgIGlmKGhvb2tOYW1lICYmICF0aGlzLm93bnNFbGVtZW50KGVsKSl7IHJldHVybiB9XG4gICAgICBsZXQgY2FsbGJhY2tzID0gdGhpcy5saXZlU29ja2V0LmdldEhvb2tDYWxsYmFja3MoaG9va05hbWUpXG5cbiAgICAgIGlmKGNhbGxiYWNrcyl7XG4gICAgICAgIGlmKCFlbC5pZCl7IGxvZ0Vycm9yKGBubyBET00gSUQgZm9yIGhvb2sgXCIke2hvb2tOYW1lfVwiLiBIb29rcyByZXF1aXJlIGEgdW5pcXVlIElEIG9uIGVhY2ggZWxlbWVudC5gLCBlbCkgfVxuICAgICAgICBsZXQgaG9vayA9IG5ldyBWaWV3SG9vayh0aGlzLCBlbCwgY2FsbGJhY2tzKVxuICAgICAgICB0aGlzLnZpZXdIb29rc1tWaWV3SG9vay5lbGVtZW50SUQoaG9vay5lbCldID0gaG9va1xuICAgICAgICByZXR1cm4gaG9va1xuICAgICAgfSBlbHNlIGlmKGhvb2tOYW1lICE9PSBudWxsKXtcbiAgICAgICAgbG9nRXJyb3IoYHVua25vd24gaG9vayBmb3VuZCBmb3IgXCIke2hvb2tOYW1lfVwiYCwgZWwpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveUhvb2soaG9vayl7XG4gICAgaG9vay5fX2Rlc3Ryb3llZCgpXG4gICAgaG9vay5fX2NsZWFudXBfXygpXG4gICAgZGVsZXRlIHRoaXMudmlld0hvb2tzW1ZpZXdIb29rLmVsZW1lbnRJRChob29rLmVsKV1cbiAgfVxuXG4gIGFwcGx5UGVuZGluZ1VwZGF0ZXMoKXtcbiAgICB0aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKCh7ZGlmZiwgZXZlbnRzfSkgPT4gdGhpcy51cGRhdGUoZGlmZiwgZXZlbnRzKSlcbiAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdXG4gICAgdGhpcy5lYWNoQ2hpbGQoY2hpbGQgPT4gY2hpbGQuYXBwbHlQZW5kaW5nVXBkYXRlcygpKVxuICB9XG5cbiAgZWFjaENoaWxkKGNhbGxiYWNrKXtcbiAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF0gfHwge31cbiAgICBmb3IobGV0IGlkIGluIGNoaWxkcmVuKXsgY2FsbGJhY2sodGhpcy5nZXRDaGlsZEJ5SWQoaWQpKSB9XG4gIH1cblxuICBvbkNoYW5uZWwoZXZlbnQsIGNiKXtcbiAgICB0aGlzLmxpdmVTb2NrZXQub25DaGFubmVsKHRoaXMuY2hhbm5lbCwgZXZlbnQsIHJlc3AgPT4ge1xuICAgICAgaWYodGhpcy5pc0pvaW5QZW5kaW5nKCkpe1xuICAgICAgICB0aGlzLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbdGhpcywgKCkgPT4gY2IocmVzcCldKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4gY2IocmVzcCkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGJpbmRDaGFubmVsKCl7XG4gICAgLy8gVGhlIGRpZmYgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhlIHJlZ3VsYXIgdXBkYXRlIG9wZXJhdGlvbnMuXG4gICAgLy8gQWxsIG90aGVyIG9wZXJhdGlvbnMgYXJlIHF1ZXVlZCB0byBiZSBhcHBsaWVkIG9ubHkgYWZ0ZXIgam9pbi5cbiAgICB0aGlzLmxpdmVTb2NrZXQub25DaGFubmVsKHRoaXMuY2hhbm5lbCwgXCJkaWZmXCIsIChyYXdEaWZmKSA9PiB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuYXBwbHlEaWZmKFwidXBkYXRlXCIsIHJhd0RpZmYsICh7ZGlmZiwgZXZlbnRzfSkgPT4gdGhpcy51cGRhdGUoZGlmZiwgZXZlbnRzKSlcbiAgICAgIH0pXG4gICAgfSlcbiAgICB0aGlzLm9uQ2hhbm5lbChcInJlZGlyZWN0XCIsICh7dG8sIGZsYXNofSkgPT4gdGhpcy5vblJlZGlyZWN0KHt0bywgZmxhc2h9KSlcbiAgICB0aGlzLm9uQ2hhbm5lbChcImxpdmVfcGF0Y2hcIiwgKHJlZGlyKSA9PiB0aGlzLm9uTGl2ZVBhdGNoKHJlZGlyKSlcbiAgICB0aGlzLm9uQ2hhbm5lbChcImxpdmVfcmVkaXJlY3RcIiwgKHJlZGlyKSA9PiB0aGlzLm9uTGl2ZVJlZGlyZWN0KHJlZGlyKSlcbiAgICB0aGlzLmNoYW5uZWwub25FcnJvcihyZWFzb24gPT4gdGhpcy5vbkVycm9yKHJlYXNvbikpXG4gICAgdGhpcy5jaGFubmVsLm9uQ2xvc2UocmVhc29uID0+IHRoaXMub25DbG9zZShyZWFzb24pKVxuICB9XG5cbiAgZGVzdHJveUFsbENoaWxkcmVuKCl7IHRoaXMuZWFjaENoaWxkKGNoaWxkID0+IGNoaWxkLmRlc3Ryb3koKSkgfVxuXG4gIG9uTGl2ZVJlZGlyZWN0KHJlZGlyKXtcbiAgICBsZXQge3RvLCBraW5kLCBmbGFzaH0gPSByZWRpclxuICAgIGxldCB1cmwgPSB0aGlzLmV4cGFuZFVSTCh0bylcbiAgICBsZXQgZSA9IG5ldyBDdXN0b21FdmVudChcInBoeDpzZXJ2ZXItbmF2aWdhdGVcIiwge2RldGFpbDoge3RvLCBraW5kLCBmbGFzaH19KVxuICAgIHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UmVkaXJlY3QoZSwgdXJsLCBraW5kLCBmbGFzaClcbiAgfVxuXG4gIG9uTGl2ZVBhdGNoKHJlZGlyKXtcbiAgICBsZXQge3RvLCBraW5kfSA9IHJlZGlyXG4gICAgdGhpcy5ocmVmID0gdGhpcy5leHBhbmRVUkwodG8pXG4gICAgdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlQYXRjaCh0bywga2luZClcbiAgfVxuXG4gIGV4cGFuZFVSTCh0byl7XG4gICAgcmV0dXJuIHRvLnN0YXJ0c1dpdGgoXCIvXCIpID8gYCR7d2luZG93LmxvY2F0aW9uLnByb3RvY29sfS8vJHt3aW5kb3cubG9jYXRpb24uaG9zdH0ke3RvfWAgOiB0b1xuICB9XG5cbiAgb25SZWRpcmVjdCh7dG8sIGZsYXNoLCByZWxvYWRUb2tlbn0peyB0aGlzLmxpdmVTb2NrZXQucmVkaXJlY3QodG8sIGZsYXNoLCByZWxvYWRUb2tlbikgfVxuXG4gIGlzRGVzdHJveWVkKCl7IHJldHVybiB0aGlzLmRlc3Ryb3llZCB9XG5cbiAgam9pbkRlYWQoKXsgdGhpcy5pc0RlYWQgPSB0cnVlIH1cblxuICBqb2luUHVzaCgpe1xuICAgIHRoaXMuam9pblB1c2ggPSB0aGlzLmpvaW5QdXNoIHx8IHRoaXMuY2hhbm5lbC5qb2luKClcbiAgICByZXR1cm4gdGhpcy5qb2luUHVzaFxuICB9XG5cbiAgam9pbihjYWxsYmFjayl7XG4gICAgdGhpcy5zaG93TG9hZGVyKHRoaXMubGl2ZVNvY2tldC5sb2FkZXJUaW1lb3V0KVxuICAgIHRoaXMuYmluZENoYW5uZWwoKVxuICAgIGlmKHRoaXMuaXNNYWluKCkpe1xuICAgICAgdGhpcy5zdG9wQ2FsbGJhY2sgPSB0aGlzLmxpdmVTb2NrZXQud2l0aFBhZ2VMb2FkaW5nKHt0bzogdGhpcy5ocmVmLCBraW5kOiBcImluaXRpYWxcIn0pXG4gICAgfVxuICAgIHRoaXMuam9pbkNhbGxiYWNrID0gKG9uRG9uZSkgPT4ge1xuICAgICAgb25Eb25lID0gb25Eb25lIHx8IGZ1bmN0aW9uKCl7fVxuICAgICAgY2FsbGJhY2sgPyBjYWxsYmFjayh0aGlzLmpvaW5Db3VudCwgb25Eb25lKSA6IG9uRG9uZSgpXG4gICAgfVxuXG4gICAgdGhpcy53cmFwUHVzaCgoKSA9PiB0aGlzLmNoYW5uZWwuam9pbigpLCB7XG4gICAgICBvazogKHJlc3ApID0+IHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHRoaXMub25Kb2luKHJlc3ApKSxcbiAgICAgIGVycm9yOiAoZXJyb3IpID0+IHRoaXMub25Kb2luRXJyb3IoZXJyb3IpLFxuICAgICAgdGltZW91dDogKCkgPT4gdGhpcy5vbkpvaW5FcnJvcih7cmVhc29uOiBcInRpbWVvdXRcIn0pXG4gICAgfSlcbiAgfVxuXG4gIG9uSm9pbkVycm9yKHJlc3Ape1xuICAgIGlmKHJlc3AucmVhc29uID09PSBcInJlbG9hZFwiKXtcbiAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW2BmYWlsZWQgbW91bnQgd2l0aCAke3Jlc3Auc3RhdHVzfS4gRmFsbGluZyBiYWNrIHRvIHBhZ2UgcmVsb2FkYCwgcmVzcF0pXG4gICAgICB0aGlzLm9uUmVkaXJlY3Qoe3RvOiB0aGlzLnJvb3QuaHJlZiwgcmVsb2FkVG9rZW46IHJlc3AudG9rZW59KVxuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIGlmKHJlc3AucmVhc29uID09PSBcInVuYXV0aG9yaXplZFwiIHx8IHJlc3AucmVhc29uID09PSBcInN0YWxlXCIpe1xuICAgICAgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ1bmF1dGhvcml6ZWQgbGl2ZV9yZWRpcmVjdC4gRmFsbGluZyBiYWNrIHRvIHBhZ2UgcmVxdWVzdFwiLCByZXNwXSlcbiAgICAgIHRoaXMub25SZWRpcmVjdCh7dG86IHRoaXMucm9vdC5ocmVmfSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZihyZXNwLnJlZGlyZWN0IHx8IHJlc3AubGl2ZV9yZWRpcmVjdCl7XG4gICAgICB0aGlzLmpvaW5QZW5kaW5nID0gZmFsc2VcbiAgICAgIHRoaXMuY2hhbm5lbC5sZWF2ZSgpXG4gICAgfVxuICAgIGlmKHJlc3AucmVkaXJlY3QpeyByZXR1cm4gdGhpcy5vblJlZGlyZWN0KHJlc3AucmVkaXJlY3QpIH1cbiAgICBpZihyZXNwLmxpdmVfcmVkaXJlY3QpeyByZXR1cm4gdGhpcy5vbkxpdmVSZWRpcmVjdChyZXNwLmxpdmVfcmVkaXJlY3QpIH1cbiAgICB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtcInVuYWJsZSB0byBqb2luXCIsIHJlc3BdKVxuICAgIGlmKHRoaXMuaXNNYWluKCkpe1xuICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoW1BIWF9MT0FESU5HX0NMQVNTLCBQSFhfRVJST1JfQ0xBU1MsIFBIWF9TRVJWRVJfRVJST1JfQ0xBU1NdKVxuICAgICAgaWYodGhpcy5saXZlU29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLmxpdmVTb2NrZXQucmVsb2FkV2l0aEppdHRlcih0aGlzKSB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKHRoaXMuam9pbkF0dGVtcHRzID49IE1BWF9DSElMRF9KT0lOX0FUVEVNUFRTKXtcbiAgICAgICAgLy8gcHV0IHRoZSByb290IHJldmlldyBpbnRvIHBlcm1hbmVudCBlcnJvciBzdGF0ZSwgYnV0IGRvbid0IGRlc3Ryb3kgaXQgYXMgaXQgY2FuIHJlbWFpbiBhY3RpdmVcbiAgICAgICAgdGhpcy5yb290LmRpc3BsYXlFcnJvcihbUEhYX0xPQURJTkdfQ0xBU1MsIFBIWF9FUlJPUl9DTEFTUywgUEhYX1NFUlZFUl9FUlJPUl9DTEFTU10pXG4gICAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW2BnaXZpbmcgdXAgdHJ5aW5nIHRvIG1vdW50IGFmdGVyICR7TUFYX0NISUxEX0pPSU5fQVRURU1QVFN9IHRyaWVzYCwgcmVzcF0pXG4gICAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgICB9XG4gICAgICBsZXQgdHJ1ZUNoaWxkRWwgPSBET00uYnlJZCh0aGlzLmVsLmlkKVxuICAgICAgaWYodHJ1ZUNoaWxkRWwpe1xuICAgICAgICBET00ubWVyZ2VBdHRycyh0cnVlQ2hpbGRFbCwgdGhpcy5lbClcbiAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoW1BIWF9MT0FESU5HX0NMQVNTLCBQSFhfRVJST1JfQ0xBU1MsIFBIWF9TRVJWRVJfRVJST1JfQ0xBU1NdKVxuICAgICAgICB0aGlzLmVsID0gdHJ1ZUNoaWxkRWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25DbG9zZShyZWFzb24pe1xuICAgIGlmKHRoaXMuaXNEZXN0cm95ZWQoKSl7IHJldHVybiB9XG4gICAgaWYodGhpcy5pc01haW4oKSAmJiB0aGlzLmxpdmVTb2NrZXQuaGFzUGVuZGluZ0xpbmsoKSAmJiByZWFzb24gIT09IFwibGVhdmVcIil7XG4gICAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LnJlbG9hZFdpdGhKaXR0ZXIodGhpcylcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95QWxsQ2hpbGRyZW4oKVxuICAgIHRoaXMubGl2ZVNvY2tldC5kcm9wQWN0aXZlRWxlbWVudCh0aGlzKVxuICAgIC8vIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIGJlIG51bGwgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTFcbiAgICBpZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KXsgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCkgfVxuICAgIGlmKHRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkpe1xuICAgICAgdGhpcy5zaG93TG9hZGVyKEJFRk9SRV9VTkxPQURfTE9BREVSX1RJTUVPVVQpXG4gICAgfVxuICB9XG5cbiAgb25FcnJvcihyZWFzb24pe1xuICAgIHRoaXMub25DbG9zZShyZWFzb24pXG4gICAgaWYodGhpcy5saXZlU29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtcInZpZXcgY3Jhc2hlZFwiLCByZWFzb25dKSB9XG4gICAgaWYoIXRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkpe1xuICAgICAgaWYodGhpcy5saXZlU29ja2V0LmlzQ29ubmVjdGVkKCkpe1xuICAgICAgICB0aGlzLmRpc3BsYXlFcnJvcihbUEhYX0xPQURJTkdfQ0xBU1MsIFBIWF9FUlJPUl9DTEFTUywgUEhYX1NFUlZFUl9FUlJPUl9DTEFTU10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc3BsYXlFcnJvcihbUEhYX0xPQURJTkdfQ0xBU1MsIFBIWF9FUlJPUl9DTEFTUywgUEhYX0NMSUVOVF9FUlJPUl9DTEFTU10pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGlzcGxheUVycm9yKGNsYXNzZXMpe1xuICAgIGlmKHRoaXMuaXNNYWluKCkpeyBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCB7ZGV0YWlsOiB7dG86IHRoaXMuaHJlZiwga2luZDogXCJlcnJvclwifX0pIH1cbiAgICB0aGlzLnNob3dMb2FkZXIoKVxuICAgIHRoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyguLi5jbGFzc2VzKVxuICAgIHRoaXMuZXhlY0FsbCh0aGlzLmJpbmRpbmcoXCJkaXNjb25uZWN0ZWRcIikpXG4gIH1cblxuICB3cmFwUHVzaChjYWxsZXJQdXNoLCByZWNlaXZlcyl7XG4gICAgbGV0IGxhdGVuY3kgPSB0aGlzLmxpdmVTb2NrZXQuZ2V0TGF0ZW5jeVNpbSgpXG4gICAgbGV0IHdpdGhMYXRlbmN5ID0gbGF0ZW5jeSA/XG4gICAgICAoY2IpID0+IHNldFRpbWVvdXQoKCkgPT4gIXRoaXMuaXNEZXN0cm95ZWQoKSAmJiBjYigpLCBsYXRlbmN5KSA6XG4gICAgICAoY2IpID0+ICF0aGlzLmlzRGVzdHJveWVkKCkgJiYgY2IoKVxuXG4gICAgd2l0aExhdGVuY3koKCkgPT4ge1xuICAgICAgY2FsbGVyUHVzaCgpXG4gICAgICAgIC5yZWNlaXZlKFwib2tcIiwgcmVzcCA9PiB3aXRoTGF0ZW5jeSgoKSA9PiByZWNlaXZlcy5vayAmJiByZWNlaXZlcy5vayhyZXNwKSkpXG4gICAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgcmVhc29uID0+IHdpdGhMYXRlbmN5KCgpID0+IHJlY2VpdmVzLmVycm9yICYmIHJlY2VpdmVzLmVycm9yKHJlYXNvbikpKVxuICAgICAgICAucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4gd2l0aExhdGVuY3koKCkgPT4gcmVjZWl2ZXMudGltZW91dCAmJiByZWNlaXZlcy50aW1lb3V0KCkpKVxuICAgIH0pXG4gIH1cblxuICBwdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgZXZlbnQsIHBheWxvYWQpe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe2Vycm9yOiBcIm5vY29ubmVjdGlvblwifSkgfVxuXG4gICAgbGV0IFtyZWYsIFtlbF0sIG9wdHNdID0gcmVmR2VuZXJhdG9yID8gcmVmR2VuZXJhdG9yKCkgOiBbbnVsbCwgW10sIHt9XVxuICAgIGxldCBvbGRKb2luQ291bnQgPSB0aGlzLmpvaW5Db3VudFxuICAgIGxldCBvbkxvYWRpbmdEb25lID0gZnVuY3Rpb24oKXt9XG4gICAgaWYob3B0cy5wYWdlX2xvYWRpbmcpe1xuICAgICAgb25Mb2FkaW5nRG9uZSA9IHRoaXMubGl2ZVNvY2tldC53aXRoUGFnZUxvYWRpbmcoe2tpbmQ6IFwiZWxlbWVudFwiLCB0YXJnZXQ6IGVsfSlcbiAgICB9XG5cbiAgICBpZih0eXBlb2YgKHBheWxvYWQuY2lkKSAhPT0gXCJudW1iZXJcIil7IGRlbGV0ZSBwYXlsb2FkLmNpZCB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy53cmFwUHVzaCgoKSA9PiB0aGlzLmNoYW5uZWwucHVzaChldmVudCwgcGF5bG9hZCwgUFVTSF9USU1FT1VUKSwge1xuICAgICAgICBvazogKHJlc3ApID0+IHtcbiAgICAgICAgICBpZihyZWYgIT09IG51bGwpeyB0aGlzLmxhc3RBY2tSZWYgPSByZWYgfVxuICAgICAgICAgIGxldCBmaW5pc2ggPSAoaG9va1JlcGx5KSA9PiB7XG4gICAgICAgICAgICBpZihyZXNwLnJlZGlyZWN0KXsgdGhpcy5vblJlZGlyZWN0KHJlc3AucmVkaXJlY3QpIH1cbiAgICAgICAgICAgIGlmKHJlc3AubGl2ZV9wYXRjaCl7IHRoaXMub25MaXZlUGF0Y2gocmVzcC5saXZlX3BhdGNoKSB9XG4gICAgICAgICAgICBpZihyZXNwLmxpdmVfcmVkaXJlY3QpeyB0aGlzLm9uTGl2ZVJlZGlyZWN0KHJlc3AubGl2ZV9yZWRpcmVjdCkgfVxuICAgICAgICAgICAgb25Mb2FkaW5nRG9uZSgpXG4gICAgICAgICAgICByZXNvbHZlKHtyZXNwOiByZXNwLCByZXBseTogaG9va1JlcGx5fSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmVzcC5kaWZmKXtcbiAgICAgICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBseURpZmYoXCJ1cGRhdGVcIiwgcmVzcC5kaWZmLCAoe2RpZmYsIHJlcGx5LCBldmVudHN9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYocmVmICE9PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgIHRoaXMudW5kb1JlZnMocmVmLCBwYXlsb2FkLmV2ZW50KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpXG4gICAgICAgICAgICAgICAgZmluaXNoKHJlcGx5KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYocmVmICE9PSBudWxsKXsgdGhpcy51bmRvUmVmcyhyZWYsIHBheWxvYWQuZXZlbnQpIH1cbiAgICAgICAgICAgIGZpbmlzaChudWxsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IChyZWFzb24pID0+IHJlamVjdCh7ZXJyb3I6IHJlYXNvbn0pLFxuICAgICAgICB0aW1lb3V0OiAoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KHt0aW1lb3V0OiB0cnVlfSlcbiAgICAgICAgICBpZih0aGlzLmpvaW5Db3VudCA9PT0gb2xkSm9pbkNvdW50KXtcbiAgICAgICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZWxvYWRXaXRoSml0dGVyKHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5sb2coXCJ0aW1lb3V0XCIsICgpID0+IFtcInJlY2VpdmVkIHRpbWVvdXQgd2hpbGUgY29tbXVuaWNhdGluZyB3aXRoIHNlcnZlci4gRmFsbGluZyBiYWNrIHRvIGhhcmQgcmVmcmVzaCBmb3IgcmVjb3ZlcnlcIl0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdW5kb1JlZnMocmVmLCBwaHhFdmVudCwgb25seUVscyl7XG4gICAgaWYoIXRoaXMuaXNDb25uZWN0ZWQoKSl7IHJldHVybiB9IC8vIGV4aXQgaWYgZXh0ZXJuYWwgZm9ybSB0cmlnZ2VyZWRcbiAgICBsZXQgc2VsZWN0b3IgPSBgWyR7UEhYX1JFRl9TUkN9PVwiJHt0aGlzLnJlZlNyYygpfVwiXWBcblxuICAgIGlmKG9ubHlFbHMpe1xuICAgICAgb25seUVscyA9IG5ldyBTZXQob25seUVscylcbiAgICAgIERPTS5hbGwoZG9jdW1lbnQsIHNlbGVjdG9yLCBwYXJlbnQgPT4ge1xuICAgICAgICBpZihvbmx5RWxzICYmICFvbmx5RWxzLmhhcyhwYXJlbnQpKXsgcmV0dXJuIH1cbiAgICAgICAgLy8gdW5kbyBhbnkgY2hpbGQgcmVmcyB3aXRoaW4gcGFyZW50IGZpcnN0XG4gICAgICAgIERPTS5hbGwocGFyZW50LCBzZWxlY3RvciwgY2hpbGQgPT4gdGhpcy51bmRvRWxSZWYoY2hpbGQsIHJlZiwgcGh4RXZlbnQpKVxuICAgICAgICB0aGlzLnVuZG9FbFJlZihwYXJlbnQsIHJlZiwgcGh4RXZlbnQpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBET00uYWxsKGRvY3VtZW50LCBzZWxlY3RvciwgZWwgPT4gdGhpcy51bmRvRWxSZWYoZWwsIHJlZiwgcGh4RXZlbnQpKVxuICAgIH1cbiAgfVxuXG4gIHVuZG9FbFJlZihlbCwgcmVmLCBwaHhFdmVudCl7XG4gICAgbGV0IGVsUmVmID0gbmV3IEVsZW1lbnRSZWYoZWwpXG5cbiAgICBlbFJlZi5tYXliZVVuZG8ocmVmLCBwaHhFdmVudCwgY2xvbmVkVHJlZSA9PiB7XG4gICAgICBsZXQgaG9vayA9IHRoaXMudHJpZ2dlckJlZm9yZVVwZGF0ZUhvb2soZWwsIGNsb25lZFRyZWUpXG4gICAgICBET01QYXRjaC5wYXRjaFdpdGhDbG9uZWRUcmVlKGVsLCBjbG9uZWRUcmVlLCB0aGlzLmxpdmVTb2NrZXQpXG4gICAgICBET00uYWxsKGVsLCBgWyR7UEhYX1JFRl9TUkN9PVwiJHt0aGlzLnJlZlNyYygpfVwiXWAsIGNoaWxkID0+IHRoaXMudW5kb0VsUmVmKGNoaWxkLCByZWYsIHBoeEV2ZW50KSlcbiAgICAgIHRoaXMuZXhlY05ld01vdW50ZWQoZWwpXG4gICAgICBpZihob29rKXsgaG9vay5fX3VwZGF0ZWQoKSB9XG4gICAgfSlcbiAgfVxuXG4gIHJlZlNyYygpeyByZXR1cm4gdGhpcy5lbC5pZCB9XG5cbiAgcHV0UmVmKGVsZW1lbnRzLCBwaHhFdmVudCwgZXZlbnRUeXBlLCBvcHRzID0ge30pe1xuICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZisrXG4gICAgbGV0IGRpc2FibGVXaXRoID0gdGhpcy5iaW5kaW5nKFBIWF9ESVNBQkxFX1dJVEgpXG4gICAgaWYob3B0cy5sb2FkaW5nKXtcbiAgICAgIGxldCBsb2FkaW5nRWxzID0gRE9NLmFsbChkb2N1bWVudCwgb3B0cy5sb2FkaW5nKS5tYXAoZWwgPT4ge1xuICAgICAgICByZXR1cm4ge2VsLCBsb2NrOiB0cnVlLCBsb2FkaW5nOiB0cnVlfVxuICAgICAgfSlcbiAgICAgIGVsZW1lbnRzID0gZWxlbWVudHMuY29uY2F0KGxvYWRpbmdFbHMpXG4gICAgfVxuXG4gICAgZm9yKGxldCB7ZWwsIGxvY2ssIGxvYWRpbmd9IG9mIGVsZW1lbnRzKXtcbiAgICAgIGlmKCFsb2NrICYmICFsb2FkaW5nKXsgdGhyb3cgbmV3IEVycm9yKFwicHV0UmVmIHJlcXVpcmVzIGxvY2sgb3IgbG9hZGluZ1wiKSB9XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRl9TUkMsIHRoaXMucmVmU3JjKCkpXG4gICAgICBpZihsb2FkaW5nKXsgZWwuc2V0QXR0cmlidXRlKFBIWF9SRUZfTE9BRElORywgbmV3UmVmKSB9XG4gICAgICBpZihsb2NrKXsgZWwuc2V0QXR0cmlidXRlKFBIWF9SRUZfTE9DSywgbmV3UmVmKSB9XG5cbiAgICAgIGlmKCFsb2FkaW5nIHx8IChvcHRzLnN1Ym1pdHRlciAmJiAhKGVsID09PSBvcHRzLnN1Ym1pdHRlciB8fCBlbCA9PT0gb3B0cy5mb3JtKSkpeyBjb250aW51ZSB9XG5cbiAgICAgIGxldCBsb2NrQ29tcGxldGVQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoYHBoeDp1bmRvLWxvY2s6JHtuZXdSZWZ9YCwgKCkgPT4gcmVzb2x2ZShkZXRhaWwpLCB7b25jZTogdHJ1ZX0pXG4gICAgICB9KVxuXG4gICAgICBsZXQgbG9hZGluZ0NvbXBsZXRlUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGBwaHg6dW5kby1sb2FkaW5nOiR7bmV3UmVmfWAsICgpID0+IHJlc29sdmUoZGV0YWlsKSwge29uY2U6IHRydWV9KVxuICAgICAgfSlcblxuICAgICAgZWwuY2xhc3NMaXN0LmFkZChgcGh4LSR7ZXZlbnRUeXBlfS1sb2FkaW5nYClcbiAgICAgIGxldCBkaXNhYmxlVGV4dCA9IGVsLmdldEF0dHJpYnV0ZShkaXNhYmxlV2l0aClcbiAgICAgIGlmKGRpc2FibGVUZXh0ICE9PSBudWxsKXtcbiAgICAgICAgaWYoIWVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpKXtcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFLCBlbC5pbm5lclRleHQpXG4gICAgICAgIH1cbiAgICAgICAgaWYoZGlzYWJsZVRleHQgIT09IFwiXCIpeyBlbC5pbm5lclRleHQgPSBkaXNhYmxlVGV4dCB9XG4gICAgICAgIC8vIFBIWF9ESVNBQkxFRCBjb3VsZCBoYXZlIGFscmVhZHkgYmVlbiBzZXQgaW4gZGlzYWJsZUZvcm1cbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRCwgZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRCkgfHwgZWwuZGlzYWJsZWQpXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpXG4gICAgICB9XG5cbiAgICAgIGxldCBkZXRhaWwgPSB7XG4gICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXG4gICAgICAgIHJlZjogbmV3UmVmLFxuICAgICAgICBpc0xvYWRpbmc6IGxvYWRpbmcsXG4gICAgICAgIGlzTG9ja2VkOiBsb2NrLFxuICAgICAgICBsb2NrRWxlbWVudHM6IGVsZW1lbnRzLmZpbHRlcigoe2xvY2t9KSA9PiBsb2NrKS5tYXAoKHtlbH0pID0+IGVsKSxcbiAgICAgICAgbG9hZGluZ0VsZW1lbnRzOiBlbGVtZW50cy5maWx0ZXIoKHtsb2FkaW5nfSkgPT4gbG9hZGluZykubWFwKCh7ZWx9KSA9PiBlbCksXG4gICAgICAgIHVubG9jazogKGVscykgPT4ge1xuICAgICAgICAgIGVscyA9IEFycmF5LmlzQXJyYXkoZWxzKSA/IGVscyA6IFtlbHNdXG4gICAgICAgICAgdGhpcy51bmRvUmVmcyhuZXdSZWYsIHBoeEV2ZW50LCBlbHMpXG4gICAgICAgIH0sXG4gICAgICAgIGxvY2tDb21wbGV0ZTogbG9ja0NvbXBsZXRlUHJvbWlzZSxcbiAgICAgICAgbG9hZGluZ0NvbXBsZXRlOiBsb2FkaW5nQ29tcGxldGVQcm9taXNlLFxuICAgICAgICBsb2NrOiAobG9ja0VsKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgaWYodGhpcy5pc0Fja2VkKG5ld1JlZikpeyByZXR1cm4gcmVzb2x2ZShkZXRhaWwpIH1cbiAgICAgICAgICAgIGxvY2tFbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRl9MT0NLLCBuZXdSZWYpXG4gICAgICAgICAgICBsb2NrRWwuc2V0QXR0cmlidXRlKFBIWF9SRUZfU1JDLCB0aGlzLnJlZlNyYygpKVxuICAgICAgICAgICAgbG9ja0VsLmFkZEV2ZW50TGlzdGVuZXIoYHBoeDpsb2NrLXN0b3A6JHtuZXdSZWZ9YCwgKCkgPT4gcmVzb2x2ZShkZXRhaWwpLCB7b25jZTogdHJ1ZX0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJwaHg6cHVzaFwiLCB7XG4gICAgICAgIGRldGFpbDogZGV0YWlsLFxuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgICAgfSkpXG4gICAgICBpZihwaHhFdmVudCl7XG4gICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGBwaHg6cHVzaDoke3BoeEV2ZW50fWAsIHtcbiAgICAgICAgICBkZXRhaWw6IGRldGFpbCxcbiAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW25ld1JlZiwgZWxlbWVudHMubWFwKCh7ZWx9KSA9PiBlbCksIG9wdHNdXG4gIH1cblxuICBpc0Fja2VkKHJlZil7IHJldHVybiB0aGlzLmxhc3RBY2tSZWYgIT09IG51bGwgJiYgdGhpcy5sYXN0QWNrUmVmID49IHJlZiB9XG5cbiAgY29tcG9uZW50SUQoZWwpe1xuICAgIGxldCBjaWQgPSBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpXG4gICAgcmV0dXJuIGNpZCA/IHBhcnNlSW50KGNpZCkgOiBudWxsXG4gIH1cblxuICB0YXJnZXRDb21wb25lbnRJRCh0YXJnZXQsIHRhcmdldEN0eCwgb3B0cyA9IHt9KXtcbiAgICBpZihpc0NpZCh0YXJnZXRDdHgpKXsgcmV0dXJuIHRhcmdldEN0eCB9XG5cbiAgICBsZXQgY2lkT3JTZWxlY3RvciA9IG9wdHMudGFyZ2V0IHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwidGFyZ2V0XCIpKVxuICAgIGlmKGlzQ2lkKGNpZE9yU2VsZWN0b3IpKXtcbiAgICAgIHJldHVybiBwYXJzZUludChjaWRPclNlbGVjdG9yKVxuICAgIH0gZWxzZSBpZih0YXJnZXRDdHggJiYgKGNpZE9yU2VsZWN0b3IgIT09IG51bGwgfHwgb3B0cy50YXJnZXQpKXtcbiAgICAgIHJldHVybiB0aGlzLmNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eCl7XG4gICAgaWYoaXNDaWQodGFyZ2V0Q3R4KSl7XG4gICAgICByZXR1cm4gdGFyZ2V0Q3R4XG4gICAgfSBlbHNlIGlmKHRhcmdldEN0eCl7XG4gICAgICByZXR1cm4gbWF5YmUodGFyZ2V0Q3R4LmNsb3Nlc3QoYFske1BIWF9DT01QT05FTlR9XWApLCBlbCA9PiB0aGlzLm93bnNFbGVtZW50KGVsKSAmJiB0aGlzLmNvbXBvbmVudElEKGVsKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBwdXNoSG9va0V2ZW50KGVsLCB0YXJnZXRDdHgsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KXtcbiAgICBpZighdGhpcy5pc0Nvbm5lY3RlZCgpKXtcbiAgICAgIHRoaXMubG9nKFwiaG9va1wiLCAoKSA9PiBbXCJ1bmFibGUgdG8gcHVzaCBob29rIGV2ZW50LiBMaXZlVmlldyBub3QgY29ubmVjdGVkXCIsIGV2ZW50LCBwYXlsb2FkXSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBsZXQgW3JlZiwgZWxzLCBvcHRzXSA9IHRoaXMucHV0UmVmKFt7ZWwsIGxvYWRpbmc6IHRydWUsIGxvY2s6IHRydWV9XSwgZXZlbnQsIFwiaG9va1wiKVxuICAgIHRoaXMucHVzaFdpdGhSZXBseSgoKSA9PiBbcmVmLCBlbHMsIG9wdHNdLCBcImV2ZW50XCIsIHtcbiAgICAgIHR5cGU6IFwiaG9va1wiLFxuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgdmFsdWU6IHBheWxvYWQsXG4gICAgICBjaWQ6IHRoaXMuY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eClcbiAgICB9KS50aGVuKCh7cmVzcDogX3Jlc3AsIHJlcGx5OiBob29rUmVwbHl9KSA9PiBvblJlcGx5KGhvb2tSZXBseSwgcmVmKSlcblxuICAgIHJldHVybiByZWZcbiAgfVxuXG4gIGV4dHJhY3RNZXRhKGVsLCBtZXRhLCB2YWx1ZSl7XG4gICAgbGV0IHByZWZpeCA9IHRoaXMuYmluZGluZyhcInZhbHVlLVwiKVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBlbC5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGlmKCFtZXRhKXsgbWV0YSA9IHt9IH1cbiAgICAgIGxldCBuYW1lID0gZWwuYXR0cmlidXRlc1tpXS5uYW1lXG4gICAgICBpZihuYW1lLnN0YXJ0c1dpdGgocHJlZml4KSl7IG1ldGFbbmFtZS5yZXBsYWNlKHByZWZpeCwgXCJcIildID0gZWwuZ2V0QXR0cmlidXRlKG5hbWUpIH1cbiAgICB9XG4gICAgaWYoZWwudmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhKGVsIGluc3RhbmNlb2YgSFRNTEZvcm1FbGVtZW50KSl7XG4gICAgICBpZighbWV0YSl7IG1ldGEgPSB7fSB9XG4gICAgICBtZXRhLnZhbHVlID0gZWwudmFsdWVcblxuICAgICAgaWYoZWwudGFnTmFtZSA9PT0gXCJJTlBVVFwiICYmIENIRUNLQUJMRV9JTlBVVFMuaW5kZXhPZihlbC50eXBlKSA+PSAwICYmICFlbC5jaGVja2VkKXtcbiAgICAgICAgZGVsZXRlIG1ldGEudmFsdWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYodmFsdWUpe1xuICAgICAgaWYoIW1ldGEpeyBtZXRhID0ge30gfVxuICAgICAgZm9yKGxldCBrZXkgaW4gdmFsdWUpeyBtZXRhW2tleV0gPSB2YWx1ZVtrZXldIH1cbiAgICB9XG4gICAgcmV0dXJuIG1ldGFcbiAgfVxuXG4gIHB1c2hFdmVudCh0eXBlLCBlbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgbWV0YSwgb3B0cyA9IHt9LCBvblJlcGx5KXtcbiAgICB0aGlzLnB1c2hXaXRoUmVwbHkoKCkgPT4gdGhpcy5wdXRSZWYoW3tlbCwgbG9hZGluZzogdHJ1ZSwgbG9jazogdHJ1ZX1dLCBwaHhFdmVudCwgdHlwZSwgb3B0cyksIFwiZXZlbnRcIiwge1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgIHZhbHVlOiB0aGlzLmV4dHJhY3RNZXRhKGVsLCBtZXRhLCBvcHRzLnZhbHVlKSxcbiAgICAgIGNpZDogdGhpcy50YXJnZXRDb21wb25lbnRJRChlbCwgdGFyZ2V0Q3R4LCBvcHRzKVxuICAgIH0pLnRoZW4oKHtyZXBseX0pID0+IG9uUmVwbHkgJiYgb25SZXBseShyZXBseSkpXG4gIH1cblxuICBwdXNoRmlsZVByb2dyZXNzKGZpbGVFbCwgZW50cnlSZWYsIHByb2dyZXNzLCBvblJlcGx5ID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIHRoaXMubGl2ZVNvY2tldC53aXRoaW5Pd25lcnMoZmlsZUVsLmZvcm0sICh2aWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIHZpZXcucHVzaFdpdGhSZXBseShudWxsLCBcInByb2dyZXNzXCIsIHtcbiAgICAgICAgZXZlbnQ6IGZpbGVFbC5nZXRBdHRyaWJ1dGUodmlldy5iaW5kaW5nKFBIWF9QUk9HUkVTUykpLFxuICAgICAgICByZWY6IGZpbGVFbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpLFxuICAgICAgICBlbnRyeV9yZWY6IGVudHJ5UmVmLFxuICAgICAgICBwcm9ncmVzczogcHJvZ3Jlc3MsXG4gICAgICAgIGNpZDogdmlldy50YXJnZXRDb21wb25lbnRJRChmaWxlRWwuZm9ybSwgdGFyZ2V0Q3R4KVxuICAgICAgfSkudGhlbigoe3Jlc3B9KSA9PiBvblJlcGx5KHJlc3ApKVxuICAgIH0pXG4gIH1cblxuICBwdXNoSW5wdXQoaW5wdXRFbCwgdGFyZ2V0Q3R4LCBmb3JjZUNpZCwgcGh4RXZlbnQsIG9wdHMsIGNhbGxiYWNrKXtcbiAgICBpZighaW5wdXRFbC5mb3JtKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm0gZXZlbnRzIHJlcXVpcmUgdGhlIGlucHV0IHRvIGJlIGluc2lkZSBhIGZvcm1cIilcbiAgICB9XG5cbiAgICBsZXQgdXBsb2Fkc1xuICAgIGxldCBjaWQgPSBpc0NpZChmb3JjZUNpZCkgPyBmb3JjZUNpZCA6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoaW5wdXRFbC5mb3JtLCB0YXJnZXRDdHgsIG9wdHMpXG4gICAgbGV0IHJlZkdlbmVyYXRvciA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnB1dFJlZihbXG4gICAgICAgIHtlbDogaW5wdXRFbCwgbG9hZGluZzogdHJ1ZSwgbG9jazogdHJ1ZX0sXG4gICAgICAgIHtlbDogaW5wdXRFbC5mb3JtLCBsb2FkaW5nOiB0cnVlLCBsb2NrOiB0cnVlfVxuICAgICAgXSwgcGh4RXZlbnQsIFwiY2hhbmdlXCIsIG9wdHMpXG4gICAgfVxuICAgIGxldCBmb3JtRGF0YVxuICAgIGxldCBtZXRhICA9IHRoaXMuZXh0cmFjdE1ldGEoaW5wdXRFbC5mb3JtKVxuICAgIGlmKGlucHV0RWwgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCl7IG1ldGEuc3VibWl0dGVyID0gaW5wdXRFbCB9XG4gICAgaWYoaW5wdXRFbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpKSl7XG4gICAgICBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oaW5wdXRFbC5mb3JtLCB7X3RhcmdldDogb3B0cy5fdGFyZ2V0LCAuLi5tZXRhfSwgW2lucHV0RWwubmFtZV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShpbnB1dEVsLmZvcm0sIHtfdGFyZ2V0OiBvcHRzLl90YXJnZXQsIC4uLm1ldGF9KVxuICAgIH1cbiAgICBpZihET00uaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBpbnB1dEVsLmZpbGVzICYmIGlucHV0RWwuZmlsZXMubGVuZ3RoID4gMCl7XG4gICAgICBMaXZlVXBsb2FkZXIudHJhY2tGaWxlcyhpbnB1dEVsLCBBcnJheS5mcm9tKGlucHV0RWwuZmlsZXMpKVxuICAgIH1cbiAgICB1cGxvYWRzID0gTGl2ZVVwbG9hZGVyLnNlcmlhbGl6ZVVwbG9hZHMoaW5wdXRFbClcblxuICAgIGxldCBldmVudCA9IHtcbiAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgdmFsdWU6IGZvcm1EYXRhLFxuICAgICAgdXBsb2FkczogdXBsb2FkcyxcbiAgICAgIGNpZDogY2lkXG4gICAgfVxuICAgIHRoaXMucHVzaFdpdGhSZXBseShyZWZHZW5lcmF0b3IsIFwiZXZlbnRcIiwgZXZlbnQpLnRoZW4oKHtyZXNwfSkgPT4ge1xuICAgICAgaWYoRE9NLmlzVXBsb2FkSW5wdXQoaW5wdXRFbCkgJiYgRE9NLmlzQXV0b1VwbG9hZChpbnB1dEVsKSl7XG4gICAgICAgIGlmKExpdmVVcGxvYWRlci5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0RWwpLmxlbmd0aCA+IDApe1xuICAgICAgICAgIGxldCBbcmVmLCBfZWxzXSA9IHJlZkdlbmVyYXRvcigpXG4gICAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYsIHBoeEV2ZW50LCBbaW5wdXRFbC5mb3JtXSlcbiAgICAgICAgICB0aGlzLnVwbG9hZEZpbGVzKGlucHV0RWwuZm9ybSwgcGh4RXZlbnQsIHRhcmdldEN0eCwgcmVmLCBjaWQsIChfdXBsb2FkcykgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcClcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckF3YWl0aW5nU3VibWl0KGlucHV0RWwuZm9ybSwgcGh4RXZlbnQpXG4gICAgICAgICAgICB0aGlzLnVuZG9SZWZzKHJlZiwgcGh4RXZlbnQpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgdHJpZ2dlckF3YWl0aW5nU3VibWl0KGZvcm1FbCwgcGh4RXZlbnQpe1xuICAgIGxldCBhd2FpdGluZ1N1Ym1pdCA9IHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbClcbiAgICBpZihhd2FpdGluZ1N1Ym1pdCl7XG4gICAgICBsZXQgW19lbCwgX3JlZiwgX29wdHMsIGNhbGxiYWNrXSA9IGF3YWl0aW5nU3VibWl0XG4gICAgICB0aGlzLmNhbmNlbFN1Ym1pdChmb3JtRWwsIHBoeEV2ZW50KVxuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIGdldFNjaGVkdWxlZFN1Ym1pdChmb3JtRWwpe1xuICAgIHJldHVybiB0aGlzLmZvcm1TdWJtaXRzLmZpbmQoKFtlbCwgX3JlZiwgX29wdHMsIF9jYWxsYmFja10pID0+IGVsLmlzU2FtZU5vZGUoZm9ybUVsKSlcbiAgfVxuXG4gIHNjaGVkdWxlU3VibWl0KGZvcm1FbCwgcmVmLCBvcHRzLCBjYWxsYmFjayl7XG4gICAgaWYodGhpcy5nZXRTY2hlZHVsZWRTdWJtaXQoZm9ybUVsKSl7IHJldHVybiB0cnVlIH1cbiAgICB0aGlzLmZvcm1TdWJtaXRzLnB1c2goW2Zvcm1FbCwgcmVmLCBvcHRzLCBjYWxsYmFja10pXG4gIH1cblxuICBjYW5jZWxTdWJtaXQoZm9ybUVsLCBwaHhFdmVudCl7XG4gICAgdGhpcy5mb3JtU3VibWl0cyA9IHRoaXMuZm9ybVN1Ym1pdHMuZmlsdGVyKChbZWwsIHJlZiwgX29wdHMsIF9jYWxsYmFja10pID0+IHtcbiAgICAgIGlmKGVsLmlzU2FtZU5vZGUoZm9ybUVsKSl7XG4gICAgICAgIHRoaXMudW5kb1JlZnMocmVmLCBwaHhFdmVudClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBkaXNhYmxlRm9ybShmb3JtRWwsIHBoeEV2ZW50LCBvcHRzID0ge30pe1xuICAgIGxldCBmaWx0ZXJJZ25vcmVkID0gZWwgPT4ge1xuICAgICAgbGV0IHVzZXJJZ25vcmVkID0gY2xvc2VzdFBoeEJpbmRpbmcoZWwsIGAke3RoaXMuYmluZGluZyhQSFhfVVBEQVRFKX09aWdub3JlYCwgZWwuZm9ybSlcbiAgICAgIHJldHVybiAhKHVzZXJJZ25vcmVkIHx8IGNsb3Nlc3RQaHhCaW5kaW5nKGVsLCBcImRhdGEtcGh4LXVwZGF0ZT1pZ25vcmVcIiwgZWwuZm9ybSkpXG4gICAgfVxuICAgIGxldCBmaWx0ZXJEaXNhYmxlcyA9IGVsID0+IHtcbiAgICAgIHJldHVybiBlbC5oYXNBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9ESVNBQkxFX1dJVEgpKVxuICAgIH1cbiAgICBsZXQgZmlsdGVyQnV0dG9uID0gZWwgPT4gZWwudGFnTmFtZSA9PSBcIkJVVFRPTlwiXG5cbiAgICBsZXQgZmlsdGVySW5wdXQgPSBlbCA9PiBbXCJJTlBVVFwiLCBcIlRFWFRBUkVBXCIsIFwiU0VMRUNUXCJdLmluY2x1ZGVzKGVsLnRhZ05hbWUpXG5cbiAgICBsZXQgZm9ybUVsZW1lbnRzID0gQXJyYXkuZnJvbShmb3JtRWwuZWxlbWVudHMpXG4gICAgbGV0IGRpc2FibGVzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJEaXNhYmxlcylcbiAgICBsZXQgYnV0dG9ucyA9IGZvcm1FbGVtZW50cy5maWx0ZXIoZmlsdGVyQnV0dG9uKS5maWx0ZXIoZmlsdGVySWdub3JlZClcbiAgICBsZXQgaW5wdXRzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJJbnB1dCkuZmlsdGVyKGZpbHRlcklnbm9yZWQpXG5cbiAgICBidXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBidXR0b24uZGlzYWJsZWQpXG4gICAgICBidXR0b24uZGlzYWJsZWQgPSB0cnVlXG4gICAgfSlcbiAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX1JFQURPTkxZLCBpbnB1dC5yZWFkT25seSlcbiAgICAgIGlucHV0LnJlYWRPbmx5ID0gdHJ1ZVxuICAgICAgaWYoaW5wdXQuZmlsZXMpe1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBpbnB1dC5kaXNhYmxlZClcbiAgICAgICAgaW5wdXQuZGlzYWJsZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgICBsZXQgZm9ybUVscyA9IGRpc2FibGVzLmNvbmNhdChidXR0b25zKS5jb25jYXQoaW5wdXRzKS5tYXAoZWwgPT4ge1xuICAgICAgcmV0dXJuIHtlbCwgbG9hZGluZzogdHJ1ZSwgbG9jazogdHJ1ZX1cbiAgICB9KVxuXG4gICAgLy8gd2UgcmV2ZXJzZSB0aGUgb3JkZXIgc28gZm9ybSBjaGlsZHJlbiBhcmUgYWxyZWFkeSBsb2NrZWQgYnkgdGhlIHRpbWVcbiAgICAvLyB0aGUgZm9ybSBpcyBsb2NrZWRcbiAgICBsZXQgZWxzID0gW3tlbDogZm9ybUVsLCBsb2FkaW5nOiB0cnVlLCBsb2NrOiBmYWxzZX1dLmNvbmNhdChmb3JtRWxzKS5yZXZlcnNlKClcbiAgICByZXR1cm4gdGhpcy5wdXRSZWYoZWxzLCBwaHhFdmVudCwgXCJzdWJtaXRcIiwgb3B0cylcbiAgfVxuXG4gIHB1c2hGb3JtU3VibWl0KGZvcm1FbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgc3VibWl0dGVyLCBvcHRzLCBvblJlcGx5KXtcbiAgICBsZXQgcmVmR2VuZXJhdG9yID0gKCkgPT4gdGhpcy5kaXNhYmxlRm9ybShmb3JtRWwsIHBoeEV2ZW50LCB7XG4gICAgICAuLi5vcHRzLFxuICAgICAgZm9ybTogZm9ybUVsLFxuICAgICAgc3VibWl0dGVyOiBzdWJtaXR0ZXJcbiAgICB9KVxuICAgIGxldCBjaWQgPSB0aGlzLnRhcmdldENvbXBvbmVudElEKGZvcm1FbCwgdGFyZ2V0Q3R4KVxuICAgIGlmKExpdmVVcGxvYWRlci5oYXNVcGxvYWRzSW5Qcm9ncmVzcyhmb3JtRWwpKXtcbiAgICAgIGxldCBbcmVmLCBfZWxzXSA9IHJlZkdlbmVyYXRvcigpXG4gICAgICBsZXQgcHVzaCA9ICgpID0+IHRoaXMucHVzaEZvcm1TdWJtaXQoZm9ybUVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBzdWJtaXR0ZXIsIG9wdHMsIG9uUmVwbHkpXG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZVN1Ym1pdChmb3JtRWwsIHJlZiwgb3B0cywgcHVzaClcbiAgICB9IGVsc2UgaWYoTGl2ZVVwbG9hZGVyLmlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0KGZvcm1FbCkubGVuZ3RoID4gMCl7XG4gICAgICBsZXQgW3JlZiwgZWxzXSA9IHJlZkdlbmVyYXRvcigpXG4gICAgICBsZXQgcHJveHlSZWZHZW4gPSAoKSA9PiBbcmVmLCBlbHMsIG9wdHNdXG4gICAgICB0aGlzLnVwbG9hZEZpbGVzKGZvcm1FbCwgcGh4RXZlbnQsIHRhcmdldEN0eCwgcmVmLCBjaWQsIChfdXBsb2FkcykgPT4ge1xuICAgICAgICAvLyBpZiB3ZSBzdGlsbCBoYXZpbmcgcGVuZGluZyBwcmVmbGlnaHRzIGl0IG1lYW5zIHdlIGhhdmUgaW52YWxpZCBlbnRyaWVzXG4gICAgICAgIC8vIGFuZCB0aGUgcGh4LXN1Ym1pdCBjYW5ub3QgYmUgY29tcGxldGVkXG4gICAgICAgIGlmKExpdmVVcGxvYWRlci5pbnB1dHNBd2FpdGluZ1ByZWZsaWdodChmb3JtRWwpLmxlbmd0aCA+IDApe1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuZG9SZWZzKHJlZiwgcGh4RXZlbnQpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGEgPSB0aGlzLmV4dHJhY3RNZXRhKGZvcm1FbClcbiAgICAgICAgbGV0IGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShmb3JtRWwsIHtzdWJtaXR0ZXIsIC4uLm1ldGF9KVxuICAgICAgICB0aGlzLnB1c2hXaXRoUmVwbHkocHJveHlSZWZHZW4sIFwiZXZlbnRcIiwge1xuICAgICAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgICB2YWx1ZTogZm9ybURhdGEsXG4gICAgICAgICAgY2lkOiBjaWRcbiAgICAgICAgfSkudGhlbigoe3Jlc3B9KSA9PiBvblJlcGx5KHJlc3ApKVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYoIShmb3JtRWwuaGFzQXR0cmlidXRlKFBIWF9SRUZfU1JDKSAmJiBmb3JtRWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwicGh4LXN1Ym1pdC1sb2FkaW5nXCIpKSl7XG4gICAgICBsZXQgbWV0YSA9IHRoaXMuZXh0cmFjdE1ldGEoZm9ybUVsKVxuICAgICAgbGV0IGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShmb3JtRWwsIHtzdWJtaXR0ZXIsIC4uLm1ldGF9KVxuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgXCJldmVudFwiLCB7XG4gICAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgY2lkOiBjaWRcbiAgICAgIH0pLnRoZW4oKHtyZXNwfSkgPT4gb25SZXBseShyZXNwKSlcbiAgICB9XG4gIH1cblxuICB1cGxvYWRGaWxlcyhmb3JtRWwsIHBoeEV2ZW50LCB0YXJnZXRDdHgsIHJlZiwgY2lkLCBvbkNvbXBsZXRlKXtcbiAgICBsZXQgam9pbkNvdW50QXRVcGxvYWQgPSB0aGlzLmpvaW5Db3VudFxuICAgIGxldCBpbnB1dEVscyA9IExpdmVVcGxvYWRlci5hY3RpdmVGaWxlSW5wdXRzKGZvcm1FbClcbiAgICBsZXQgbnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MgPSBpbnB1dEVscy5sZW5ndGhcblxuICAgIC8vIGdldCBlYWNoIGZpbGUgaW5wdXRcbiAgICBpbnB1dEVscy5mb3JFYWNoKGlucHV0RWwgPT4ge1xuICAgICAgbGV0IHVwbG9hZGVyID0gbmV3IExpdmVVcGxvYWRlcihpbnB1dEVsLCB0aGlzLCAoKSA9PiB7XG4gICAgICAgIG51bUZpbGVJbnB1dHNJblByb2dyZXNzLS1cbiAgICAgICAgaWYobnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MgPT09IDApeyBvbkNvbXBsZXRlKCkgfVxuICAgICAgfSlcblxuICAgICAgbGV0IGVudHJpZXMgPSB1cGxvYWRlci5lbnRyaWVzKCkubWFwKGVudHJ5ID0+IGVudHJ5LnRvUHJlZmxpZ2h0UGF5bG9hZCgpKVxuXG4gICAgICBpZihlbnRyaWVzLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIG51bUZpbGVJbnB1dHNJblByb2dyZXNzLS1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxldCBwYXlsb2FkID0ge1xuICAgICAgICByZWY6IGlucHV0RWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSxcbiAgICAgICAgZW50cmllczogZW50cmllcyxcbiAgICAgICAgY2lkOiB0aGlzLnRhcmdldENvbXBvbmVudElEKGlucHV0RWwuZm9ybSwgdGFyZ2V0Q3R4KVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZyhcInVwbG9hZFwiLCAoKSA9PiBbXCJzZW5kaW5nIHByZWZsaWdodCByZXF1ZXN0XCIsIHBheWxvYWRdKVxuXG4gICAgICB0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJhbGxvd191cGxvYWRcIiwgcGF5bG9hZCkudGhlbigoe3Jlc3B9KSA9PiB7XG4gICAgICAgIHRoaXMubG9nKFwidXBsb2FkXCIsICgpID0+IFtcImdvdCBwcmVmbGlnaHQgcmVzcG9uc2VcIiwgcmVzcF0pXG4gICAgICAgIC8vIHRoZSBwcmVmbGlnaHQgd2lsbCByZWplY3QgZW50cmllcyBiZXlvbmQgdGhlIG1heCBlbnRyaWVzXG4gICAgICAgIC8vIHNvIHdlIGVycm9yIGFuZCBjYW5jZWwgZW50cmllcyBvbiB0aGUgY2xpZW50IHRoYXQgYXJlIG1pc3NpbmcgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICAgICAgdXBsb2FkZXIuZW50cmllcygpLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICAgIGlmKHJlc3AuZW50cmllcyAmJiAhcmVzcC5lbnRyaWVzW2VudHJ5LnJlZl0pe1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVGYWlsZWRFbnRyeVByZWZsaWdodChlbnRyeS5yZWYsIFwiZmFpbGVkIHByZWZsaWdodFwiLCB1cGxvYWRlcilcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC8vIGZvciBhdXRvIHVwbG9hZHMsIHdlIG1heSBoYXZlIGFuIGVtcHR5IGVudHJpZXMgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyXG4gICAgICAgIC8vIGZvciBmb3JtIHN1Ym1pdHMgdGhhdCBjb250YWluIGludmFsaWQgZW50cmllc1xuICAgICAgICBpZihyZXNwLmVycm9yIHx8IE9iamVjdC5rZXlzKHJlc3AuZW50cmllcykubGVuZ3RoID09PSAwKXtcbiAgICAgICAgICB0aGlzLnVuZG9SZWZzKHJlZiwgcGh4RXZlbnQpXG4gICAgICAgICAgbGV0IGVycm9ycyA9IHJlc3AuZXJyb3IgfHwgW11cbiAgICAgICAgICBlcnJvcnMubWFwKChbZW50cnlfcmVmLCByZWFzb25dKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUZhaWxlZEVudHJ5UHJlZmxpZ2h0KGVudHJ5X3JlZiwgcmVhc29uLCB1cGxvYWRlcilcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBvbkVycm9yID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwub25FcnJvcigoKSA9PiB7XG4gICAgICAgICAgICAgIGlmKHRoaXMuam9pbkNvdW50ID09PSBqb2luQ291bnRBdFVwbG9hZCl7IGNhbGxiYWNrKCkgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBsb2FkZXIuaW5pdEFkYXB0ZXJVcGxvYWQocmVzcCwgb25FcnJvciwgdGhpcy5saXZlU29ja2V0KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVGYWlsZWRFbnRyeVByZWZsaWdodCh1cGxvYWRSZWYsIHJlYXNvbiwgdXBsb2FkZXIpe1xuICAgIGlmKHVwbG9hZGVyLmlzQXV0b1VwbG9hZCgpKXtcbiAgICAgIC8vIHVwbG9hZFJlZiBtYXkgYmUgdG9wIGxldmVsIHVwbG9hZCBjb25maWcgcmVmIG9yIGVudHJ5IHJlZlxuICAgICAgbGV0IGVudHJ5ID0gdXBsb2FkZXIuZW50cmllcygpLmZpbmQoZW50cnkgPT4gZW50cnkucmVmID09PSB1cGxvYWRSZWYudG9TdHJpbmcoKSlcbiAgICAgIGlmKGVudHJ5KXsgZW50cnkuY2FuY2VsKCkgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGxvYWRlci5lbnRyaWVzKCkubWFwKGVudHJ5ID0+IGVudHJ5LmNhbmNlbCgpKVxuICAgIH1cbiAgICB0aGlzLmxvZyhcInVwbG9hZFwiLCAoKSA9PiBbYGVycm9yIGZvciBlbnRyeSAke3VwbG9hZFJlZn1gLCByZWFzb25dKVxuICB9XG5cbiAgZGlzcGF0Y2hVcGxvYWRzKHRhcmdldEN0eCwgbmFtZSwgZmlsZXNPckJsb2JzKXtcbiAgICBsZXQgdGFyZ2V0RWxlbWVudCA9IHRoaXMudGFyZ2V0Q3R4RWxlbWVudCh0YXJnZXRDdHgpIHx8IHRoaXMuZWxcbiAgICBsZXQgaW5wdXRzID0gRE9NLmZpbmRVcGxvYWRJbnB1dHModGFyZ2V0RWxlbWVudCkuZmlsdGVyKGVsID0+IGVsLm5hbWUgPT09IG5hbWUpXG4gICAgaWYoaW5wdXRzLmxlbmd0aCA9PT0gMCl7IGxvZ0Vycm9yKGBubyBsaXZlIGZpbGUgaW5wdXRzIGZvdW5kIG1hdGNoaW5nIHRoZSBuYW1lIFwiJHtuYW1lfVwiYCkgfVxuICAgIGVsc2UgaWYoaW5wdXRzLmxlbmd0aCA+IDEpeyBsb2dFcnJvcihgZHVwbGljYXRlIGxpdmUgZmlsZSBpbnB1dHMgZm91bmQgbWF0Y2hpbmcgdGhlIG5hbWUgXCIke25hbWV9XCJgKSB9XG4gICAgZWxzZSB7IERPTS5kaXNwYXRjaEV2ZW50KGlucHV0c1swXSwgUEhYX1RSQUNLX1VQTE9BRFMsIHtkZXRhaWw6IHtmaWxlczogZmlsZXNPckJsb2JzfX0pIH1cbiAgfVxuXG4gIHRhcmdldEN0eEVsZW1lbnQodGFyZ2V0Q3R4KXtcbiAgICBpZihpc0NpZCh0YXJnZXRDdHgpKXtcbiAgICAgIGxldCBbdGFyZ2V0XSA9IERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgdGFyZ2V0Q3R4KVxuICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH0gZWxzZSBpZih0YXJnZXRDdHgpe1xuICAgICAgcmV0dXJuIHRhcmdldEN0eFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHB1c2hGb3JtUmVjb3Zlcnkob2xkRm9ybSwgbmV3Rm9ybSwgdGVtcGxhdGVEb20sIGNhbGxiYWNrKXtcbiAgICAvLyB3ZSBhcmUgb25seSByZWNvdmVyaW5nIGZvcm1zIGluc2lkZSB0aGUgY3VycmVudCB2aWV3LCB0aGVyZWZvcmUgaXQgaXMgc2FmZSB0b1xuICAgIC8vIHNraXAgd2l0aGluT3duZXJzIGhlcmUgYW5kIGFsd2F5cyB1c2UgdGhpcyB3aGVuIHJlZmVycmluZyB0byB0aGUgdmlld1xuICAgIGNvbnN0IHBoeENoYW5nZSA9IHRoaXMuYmluZGluZyhcImNoYW5nZVwiKVxuICAgIGNvbnN0IHBoeFRhcmdldCA9IG5ld0Zvcm0uZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcInRhcmdldFwiKSkgfHwgbmV3Rm9ybVxuICAgIGNvbnN0IHBoeEV2ZW50ID0gbmV3Rm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSB8fCBuZXdGb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpXG4gICAgY29uc3QgaW5wdXRzID0gQXJyYXkuZnJvbShvbGRGb3JtLmVsZW1lbnRzKS5maWx0ZXIoZWwgPT4gRE9NLmlzRm9ybUlucHV0KGVsKSAmJiBlbC5uYW1lICYmICFlbC5oYXNBdHRyaWJ1dGUocGh4Q2hhbmdlKSlcbiAgICBpZihpbnB1dHMubGVuZ3RoID09PSAwKXsgcmV0dXJuIH1cblxuICAgIC8vIHdlIG11c3QgY2xlYXIgdHJhY2tlZCB1cGxvYWRzIGJlZm9yZSByZWNvdmVyeSBhcyB0aGV5IG5vIGxvbmdlciBoYXZlIHZhbGlkIHJlZnNcbiAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBpbnB1dC5oYXNBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpICYmIExpdmVVcGxvYWRlci5jbGVhckZpbGVzKGlucHV0KSlcbiAgICAvLyBwdXNoSW5wdXQgYXNzdW1lcyB0aGF0IHRoZXJlIGlzIGEgc291cmNlIGVsZW1lbnQgdGhhdCBpbml0aWF0ZWQgdGhlIGNoYW5nZTtcbiAgICAvLyBiZWNhdXNlIHRoaXMgaXMgbm90IHRoZSBjYXNlIHdoZW4gd2UgcmVjb3ZlciBmb3Jtcywgd2UgcHJvdmlkZSB0aGUgZmlyc3QgaW5wdXQgd2UgZmluZFxuICAgIGxldCBpbnB1dCA9IGlucHV0cy5maW5kKGVsID0+IGVsLnR5cGUgIT09IFwiaGlkZGVuXCIpIHx8IGlucHV0c1swXVxuXG4gICAgLy8gaW4gdGhlIGNhc2UgdGhhdCB0aGVyZSBhcmUgbXVsdGlwbGUgdGFyZ2V0cywgd2UgY291bnQgdGhlIG51bWJlciBvZiBwZW5kaW5nIHJlY292ZXJ5IGV2ZW50c1xuICAgIC8vIGFuZCBvbmx5IGNhbGwgdGhlIGNhbGxiYWNrIG9uY2UgYWxsIGV2ZW50cyBoYXZlIGJlZW4gcHJvY2Vzc2VkXG4gICAgbGV0IHBlbmRpbmcgPSAwXG4gICAgLy8gd2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsIGNhbGxiYWNrLCBkb20sIHZpZXdFbClcbiAgICB0aGlzLndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCAodGFyZ2V0VmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICBjb25zdCBjaWQgPSB0aGlzLnRhcmdldENvbXBvbmVudElEKG5ld0Zvcm0sIHRhcmdldEN0eClcbiAgICAgIHBlbmRpbmcrK1xuICAgICAgbGV0IGUgPSBuZXcgQ3VzdG9tRXZlbnQoXCJwaHg6Zm9ybS1yZWNvdmVyeVwiLCB7ZGV0YWlsOiB7c291cmNlRWxlbWVudDogb2xkRm9ybX19KVxuICAgICAgSlMuZXhlYyhlLCBcImNoYW5nZVwiLCBwaHhFdmVudCwgdGhpcywgaW5wdXQsIFtcInB1c2hcIiwge1xuICAgICAgICBfdGFyZ2V0OiBpbnB1dC5uYW1lLFxuICAgICAgICB0YXJnZXRWaWV3LFxuICAgICAgICB0YXJnZXRDdHgsXG4gICAgICAgIG5ld0NpZDogY2lkLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHBlbmRpbmctLVxuICAgICAgICAgIGlmKHBlbmRpbmcgPT09IDApeyBjYWxsYmFjaygpIH1cbiAgICAgICAgfVxuICAgICAgfV0pXG4gICAgfSwgdGVtcGxhdGVEb20sIHRlbXBsYXRlRG9tKVxuICB9XG5cbiAgcHVzaExpbmtQYXRjaChlLCBocmVmLCB0YXJnZXRFbCwgY2FsbGJhY2spe1xuICAgIGxldCBsaW5rUmVmID0gdGhpcy5saXZlU29ja2V0LnNldFBlbmRpbmdMaW5rKGhyZWYpXG4gICAgLy8gb25seSBhZGQgbG9hZGluZyBzdGF0ZXMgaWYgZXZlbnQgaXMgdHJ1c3RlZCAoaXQgd2FzIHRyaWdnZXJlZCBieSB1c2VyLCBzdWNoIGFzIGNsaWNrKSBhbmRcbiAgICAvLyBpdCdzIG5vdCBhIGZvcndhcmQvYmFjayBuYXZpZ2F0aW9uIGZyb20gcG9wc3RhdGVcbiAgICBsZXQgbG9hZGluZyA9IGUuaXNUcnVzdGVkICYmIGUudHlwZSAhPT0gXCJwb3BzdGF0ZVwiXG4gICAgbGV0IHJlZkdlbiA9IHRhcmdldEVsID8gKCkgPT4gdGhpcy5wdXRSZWYoW3tlbDogdGFyZ2V0RWwsIGxvYWRpbmc6IGxvYWRpbmcsIGxvY2s6IHRydWV9XSwgbnVsbCwgXCJjbGlja1wiKSA6IG51bGxcbiAgICBsZXQgZmFsbGJhY2sgPSAoKSA9PiB0aGlzLmxpdmVTb2NrZXQucmVkaXJlY3Qod2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgbGV0IHVybCA9IGhyZWYuc3RhcnRzV2l0aChcIi9cIikgPyBgJHtsb2NhdGlvbi5wcm90b2NvbH0vLyR7bG9jYXRpb24uaG9zdH0ke2hyZWZ9YCA6IGhyZWZcblxuICAgIHRoaXMucHVzaFdpdGhSZXBseShyZWZHZW4sIFwibGl2ZV9wYXRjaFwiLCB7dXJsfSkudGhlbihcbiAgICAgICh7cmVzcH0pID0+IHtcbiAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgIGlmKHJlc3AubGlua19yZWRpcmVjdCl7XG4gICAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVwbGFjZU1haW4oaHJlZiwgbnVsbCwgY2FsbGJhY2ssIGxpbmtSZWYpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKHRoaXMubGl2ZVNvY2tldC5jb21taXRQZW5kaW5nTGluayhsaW5rUmVmKSl7XG4gICAgICAgICAgICAgIHRoaXMuaHJlZiA9IGhyZWZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpXG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhsaW5rUmVmKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICAoe2Vycm9yOiBfZXJyb3IsIHRpbWVvdXQ6IF90aW1lb3V0fSkgPT4gZmFsbGJhY2soKVxuICAgIClcbiAgfVxuXG4gIGdldEZvcm1zRm9yUmVjb3ZlcnkoKXtcbiAgICBpZih0aGlzLmpvaW5Db3VudCA9PT0gMCl7IHJldHVybiB7fSB9XG5cbiAgICBsZXQgcGh4Q2hhbmdlID0gdGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpXG5cbiAgICByZXR1cm4gRE9NLmFsbCh0aGlzLmVsLCBgZm9ybVske3BoeENoYW5nZX1dYClcbiAgICAgIC5maWx0ZXIoZm9ybSA9PiBmb3JtLmlkKVxuICAgICAgLmZpbHRlcihmb3JtID0+IGZvcm0uZWxlbWVudHMubGVuZ3RoID4gMClcbiAgICAgIC5maWx0ZXIoZm9ybSA9PiBmb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0FVVE9fUkVDT1ZFUikpICE9PSBcImlnbm9yZVwiKVxuICAgICAgLm1hcChmb3JtID0+IGZvcm0uY2xvbmVOb2RlKHRydWUpKVxuICAgICAgLnJlZHVjZSgoYWNjLCBmb3JtKSA9PiB7XG4gICAgICAgIGFjY1tmb3JtLmlkXSA9IGZvcm1cbiAgICAgICAgcmV0dXJuIGFjY1xuICAgICAgfSwge30pXG4gIH1cblxuICBtYXliZVB1c2hDb21wb25lbnRzRGVzdHJveWVkKGRlc3Ryb3llZENJRHMpe1xuICAgIGxldCB3aWxsRGVzdHJveUNJRHMgPSBkZXN0cm95ZWRDSURzLmZpbHRlcihjaWQgPT4ge1xuICAgICAgcmV0dXJuIERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgY2lkKS5sZW5ndGggPT09IDBcbiAgICB9KVxuXG4gICAgaWYod2lsbERlc3Ryb3lDSURzLmxlbmd0aCA+IDApe1xuICAgICAgLy8gd2UgbXVzdCByZXNldCB0aGUgcmVuZGVyIGNoYW5nZSB0cmFja2luZyBmb3IgY2lkcyB0aGF0XG4gICAgICAvLyBjb3VsZCBiZSBhZGRlZCBiYWNrIGZyb20gdGhlIHNlcnZlciBzbyB3ZSBkb24ndCBza2lwIHRoZW1cbiAgICAgIHdpbGxEZXN0cm95Q0lEcy5mb3JFYWNoKGNpZCA9PiB0aGlzLnJlbmRlcmVkLnJlc2V0UmVuZGVyKGNpZCkpXG5cbiAgICAgIHRoaXMucHVzaFdpdGhSZXBseShudWxsLCBcImNpZHNfd2lsbF9kZXN0cm95XCIsIHtjaWRzOiB3aWxsRGVzdHJveUNJRHN9KS50aGVuKCgpID0+IHtcbiAgICAgICAgLy8gd2UgbXVzdCB3YWl0IGZvciBwZW5kaW5nIHRyYW5zaXRpb25zIHRvIGNvbXBsZXRlIGJlZm9yZSBkZXRlcm1pbmluZ1xuICAgICAgICAvLyBpZiB0aGUgY2lkcyB3ZXJlIGFkZGVkIGJhY2sgdG8gdGhlIERPTSBpbiB0aGUgbWVhbnRpbWUgKCMzMTM5KVxuICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgLy8gU2VlIGlmIGFueSBvZiB0aGUgY2lkcyB3ZSB3YW50ZWQgdG8gZGVzdHJveSB3ZXJlIGFkZGVkIGJhY2ssXG4gICAgICAgICAgLy8gaWYgdGhleSB3ZXJlIGFkZGVkIGJhY2ssIHdlIGRvbid0IGFjdHVhbGx5IGRlc3Ryb3kgdGhlbS5cbiAgICAgICAgICBsZXQgY29tcGxldGVseURlc3Ryb3lDSURzID0gd2lsbERlc3Ryb3lDSURzLmZpbHRlcihjaWQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgY2lkKS5sZW5ndGggPT09IDBcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgaWYoY29tcGxldGVseURlc3Ryb3lDSURzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiY2lkc19kZXN0cm95ZWRcIiwge2NpZHM6IGNvbXBsZXRlbHlEZXN0cm95Q0lEc30pLnRoZW4oKHtyZXNwfSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkLnBydW5lQ0lEcyhyZXNwLmNpZHMpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgb3duc0VsZW1lbnQoZWwpe1xuICAgIGxldCBwYXJlbnRWaWV3RWwgPSBlbC5jbG9zZXN0KFBIWF9WSUVXX1NFTEVDVE9SKVxuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCkgPT09IHRoaXMuaWQgfHxcbiAgICAgIChwYXJlbnRWaWV3RWwgJiYgcGFyZW50Vmlld0VsLmlkID09PSB0aGlzLmlkKSB8fFxuICAgICAgKCFwYXJlbnRWaWV3RWwgJiYgdGhpcy5pc0RlYWQpXG4gIH1cblxuICBzdWJtaXRGb3JtKGZvcm0sIHRhcmdldEN0eCwgcGh4RXZlbnQsIHN1Ym1pdHRlciwgb3B0cyA9IHt9KXtcbiAgICBET00ucHV0UHJpdmF0ZShmb3JtLCBQSFhfSEFTX1NVQk1JVFRFRCwgdHJ1ZSlcbiAgICBjb25zdCBpbnB1dHMgPSBBcnJheS5mcm9tKGZvcm0uZWxlbWVudHMpXG4gICAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4gRE9NLnB1dFByaXZhdGUoaW5wdXQsIFBIWF9IQVNfU1VCTUlUVEVELCB0cnVlKSlcbiAgICB0aGlzLmxpdmVTb2NrZXQuYmx1ckFjdGl2ZUVsZW1lbnQodGhpcylcbiAgICB0aGlzLnB1c2hGb3JtU3VibWl0KGZvcm0sIHRhcmdldEN0eCwgcGh4RXZlbnQsIHN1Ym1pdHRlciwgb3B0cywgKCkgPT4ge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnJlc3RvcmVQcmV2aW91c2x5QWN0aXZlRm9jdXMoKVxuICAgIH0pXG4gIH1cblxuICBiaW5kaW5nKGtpbmQpeyByZXR1cm4gdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoa2luZCkgfVxufVxuIiwgIi8qKiBJbml0aWFsaXplcyB0aGUgTGl2ZVNvY2tldFxuICpcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kUG9pbnQgLSBUaGUgc3RyaW5nIFdlYlNvY2tldCBlbmRwb2ludCwgaWUsIGBcIndzczovL2V4YW1wbGUuY29tL2xpdmVcImAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFwiL2xpdmVcImAgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gKiBAcGFyYW0ge1Bob2VuaXguU29ja2V0fSBzb2NrZXQgLSB0aGUgcmVxdWlyZWQgUGhvZW5peCBTb2NrZXQgY2xhc3MgaW1wb3J0ZWQgZnJvbSBcInBob2VuaXhcIi4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIGltcG9ydCB7U29ja2V0fSBmcm9tIFwicGhvZW5peFwiXG4gKiAgICAgaW1wb3J0IHtMaXZlU29ja2V0fSBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIlxuICogICAgIGxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHsuLi59KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBPcHRpb25hbCBjb25maWd1cmF0aW9uLiBPdXRzaWRlIG9mIGtleXMgbGlzdGVkIGJlbG93LCBhbGxcbiAqIGNvbmZpZ3VyYXRpb24gaXMgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSBQaG9lbml4IFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5kZWZhdWx0c10gLSBUaGUgb3B0aW9uYWwgZGVmYXVsdHMgdG8gdXNlIGZvciB2YXJpb3VzIGJpbmRpbmdzLFxuICogc3VjaCBhcyBgcGh4LWRlYm91bmNlYC4gU3VwcG9ydHMgdGhlIGZvbGxvd2luZyBrZXlzOlxuICpcbiAqICAgLSBkZWJvdW5jZSAtIHRoZSBtaWxsaXNlY29uZCBwaHgtZGVib3VuY2UgdGltZS4gRGVmYXVsdHMgMzAwXG4gKiAgIC0gdGhyb3R0bGUgLSB0aGUgbWlsbGlzZWNvbmQgcGh4LXRocm90dGxlIHRpbWUuIERlZmF1bHRzIDMwMFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLnBhcmFtc10gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gZm9yIHBhc3NpbmcgY29ubmVjdCBwYXJhbXMuXG4gKiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gTGl2ZVZpZXcuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICAoZWwpID0+IHt2aWV3OiBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW15LXZpZXctbmFtZVwiLCB0b2tlbjogd2luZG93Lm15VG9rZW59XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJpbmRpbmdQcmVmaXhdIC0gVGhlIG9wdGlvbmFsIHByZWZpeCB0byB1c2UgZm9yIGFsbCBwaHggRE9NIGFubm90YXRpb25zLlxuICogRGVmYXVsdHMgdG8gXCJwaHgtXCIuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMuaG9va3NdIC0gVGhlIG9wdGlvbmFsIG9iamVjdCBmb3IgcmVmZXJlbmNpbmcgTGl2ZVZpZXcgaG9vayBjYWxsYmFja3MuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMudXBsb2FkZXJzXSAtIFRoZSBvcHRpb25hbCBvYmplY3QgZm9yIHJlZmVyZW5jaW5nIExpdmVWaWV3IHVwbG9hZGVyIGNhbGxiYWNrcy5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMubG9hZGVyVGltZW91dF0gLSBUaGUgb3B0aW9uYWwgZGVsYXkgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGFwcGx5XG4gKiBsb2FkaW5nIHN0YXRlcy5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMubWF4UmVsb2Fkc10gLSBUaGUgbWF4aW11bSByZWxvYWRzIGJlZm9yZSBlbnRlcmluZyBmYWlsc2FmZSBtb2RlLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5yZWxvYWRKaXR0ZXJNaW5dIC0gVGhlIG1pbmltdW0gdGltZSBiZXR3ZWVuIG5vcm1hbCByZWxvYWQgYXR0ZW1wdHMuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLnJlbG9hZEppdHRlck1heF0gLSBUaGUgbWF4aW11bSB0aW1lIGJldHdlZW4gbm9ybWFsIHJlbG9hZCBhdHRlbXB0cy5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMuZmFpbHNhZmVKaXR0ZXJdIC0gVGhlIHRpbWUgYmV0d2VlbiByZWxvYWQgYXR0ZW1wdHMgaW4gZmFpbHNhZmUgbW9kZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLnZpZXdMb2dnZXJdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGxvZyBkZWJ1ZyBpbmZvcm1hdGlvbi4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgICh2aWV3LCBraW5kLCBtc2csIG9iaikgPT4gY29uc29sZS5sb2coYCR7dmlldy5pZH0gJHtraW5kfTogJHttc2d9IC0gYCwgb2JqKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5tZXRhZGF0YV0gLSBUaGUgb3B0aW9uYWwgb2JqZWN0IG1hcHBpbmcgZXZlbnQgbmFtZXMgdG8gZnVuY3Rpb25zIGZvclxuICogcG9wdWxhdGluZyBldmVudCBtZXRhZGF0YS4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIG1ldGFkYXRhOiB7XG4gKiAgICAgICBjbGljazogKGUsIGVsKSA9PiB7XG4gKiAgICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICogICAgICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcbiAqICAgICAgICAgICBkZXRhaWw6IGUuZGV0YWlsIHx8IDEsXG4gKiAgICAgICAgIH1cbiAqICAgICAgIH0sXG4gKiAgICAgICBrZXlkb3duOiAoZSwgZWwpID0+IHtcbiAqICAgICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgICBrZXk6IGUua2V5LFxuICogICAgICAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcbiAqICAgICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXksXG4gKiAgICAgICAgICAgc2hpZnRLZXk6IGUuc2hpZnRLZXlcbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5zZXNzaW9uU3RvcmFnZV0gLSBBbiBvcHRpb25hbCBTdG9yYWdlIGNvbXBhdGlibGUgb2JqZWN0XG4gKiBVc2VmdWwgd2hlbiBMaXZlVmlldyB3b24ndCBoYXZlIGFjY2VzcyB0byBgc2Vzc2lvblN0b3JhZ2VgLiAgRm9yIGV4YW1wbGUsIFRoaXMgY291bGRcbiAqIGhhcHBlbiBpZiBhIHNpdGUgbG9hZHMgYSBjcm9zcy1kb21haW4gTGl2ZVZpZXcgaW4gYW4gaWZyYW1lLiAgRXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgICAgY2xhc3MgSW5NZW1vcnlTdG9yYWdlIHtcbiAqICAgICAgIGNvbnN0cnVjdG9yKCkgeyB0aGlzLnN0b3JhZ2UgPSB7fSB9XG4gKiAgICAgICBnZXRJdGVtKGtleU5hbWUpIHsgcmV0dXJuIHRoaXMuc3RvcmFnZVtrZXlOYW1lXSB8fCBudWxsIH1cbiAqICAgICAgIHJlbW92ZUl0ZW0oa2V5TmFtZSkgeyBkZWxldGUgdGhpcy5zdG9yYWdlW2tleU5hbWVdIH1cbiAqICAgICAgIHNldEl0ZW0oa2V5TmFtZSwga2V5VmFsdWUpIHsgdGhpcy5zdG9yYWdlW2tleU5hbWVdID0ga2V5VmFsdWUgfVxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMubG9jYWxTdG9yYWdlXSAtIEFuIG9wdGlvbmFsIFN0b3JhZ2UgY29tcGF0aWJsZSBvYmplY3RcbiAqIFVzZWZ1bCBmb3Igd2hlbiBMaXZlVmlldyB3b24ndCBoYXZlIGFjY2VzcyB0byBgbG9jYWxTdG9yYWdlYC5cbiAqIFNlZSBgb3B0cy5zZXNzaW9uU3RvcmFnZWAgZm9yIGV4YW1wbGVzLlxuKi9cblxuaW1wb3J0IHtcbiAgQklORElOR19QUkVGSVgsXG4gIENPTlNFQ1VUSVZFX1JFTE9BRFMsXG4gIERFRkFVTFRTLFxuICBGQUlMU0FGRV9KSVRURVIsXG4gIExPQURFUl9USU1FT1VULFxuICBNQVhfUkVMT0FEUyxcbiAgUEhYX0RFQk9VTkNFLFxuICBQSFhfRFJPUF9UQVJHRVQsXG4gIFBIWF9IQVNfRk9DVVNFRCxcbiAgUEhYX0tFWSxcbiAgUEhYX0xJTktfU1RBVEUsXG4gIFBIWF9MSVZFX0xJTkssXG4gIFBIWF9MVl9ERUJVRyxcbiAgUEhYX0xWX0xBVEVOQ1lfU0lNLFxuICBQSFhfTFZfUFJPRklMRSxcbiAgUEhYX0xWX0hJU1RPUllfUE9TSVRJT04sXG4gIFBIWF9NQUlOLFxuICBQSFhfUEFSRU5UX0lELFxuICBQSFhfVklFV19TRUxFQ1RPUixcbiAgUEhYX1JPT1RfSUQsXG4gIFBIWF9USFJPVFRMRSxcbiAgUEhYX1RSQUNLX1VQTE9BRFMsXG4gIFBIWF9TRVNTSU9OLFxuICBSRUxPQURfSklUVEVSX01JTixcbiAgUkVMT0FEX0pJVFRFUl9NQVgsXG4gIFBIWF9SRUZfU1JDLFxuICBQSFhfUkVMT0FEX1NUQVRVU1xufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBjbG9uZSxcbiAgY2xvc2VzdFBoeEJpbmRpbmcsXG4gIGNsb3N1cmUsXG4gIGRlYnVnLFxuICBtYXliZVxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBCcm93c2VyIGZyb20gXCIuL2Jyb3dzZXJcIlxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IEhvb2tzIGZyb20gXCIuL2hvb2tzXCJcbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5pbXBvcnQgVmlldyBmcm9tIFwiLi92aWV3XCJcbmltcG9ydCBKUyBmcm9tIFwiLi9qc1wiXG5cbmV4cG9ydCBsZXQgaXNVc2VkSW5wdXQgPSAoZWwpID0+IERPTS5pc1VzZWRJbnB1dChlbClcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl2ZVNvY2tldCB7XG4gIGNvbnN0cnVjdG9yKHVybCwgcGh4U29ja2V0LCBvcHRzID0ge30pe1xuICAgIHRoaXMudW5sb2FkZWQgPSBmYWxzZVxuICAgIGlmKCFwaHhTb2NrZXQgfHwgcGh4U29ja2V0LmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiT2JqZWN0XCIpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgIGEgcGhvZW5peCBTb2NrZXQgbXVzdCBiZSBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBMaXZlU29ja2V0IGNvbnN0cnVjdG9yLiBGb3IgZXhhbXBsZTpcblxuICAgICAgICAgIGltcG9ydCB7U29ja2V0fSBmcm9tIFwicGhvZW5peFwiXG4gICAgICAgICAgaW1wb3J0IHtMaXZlU29ja2V0fSBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIlxuICAgICAgICAgIGxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHsuLi59KVxuICAgICAgYClcbiAgICB9XG4gICAgdGhpcy5zb2NrZXQgPSBuZXcgcGh4U29ja2V0KHVybCwgb3B0cylcbiAgICB0aGlzLmJpbmRpbmdQcmVmaXggPSBvcHRzLmJpbmRpbmdQcmVmaXggfHwgQklORElOR19QUkVGSVhcbiAgICB0aGlzLm9wdHMgPSBvcHRzXG4gICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKG9wdHMucGFyYW1zIHx8IHt9KVxuICAgIHRoaXMudmlld0xvZ2dlciA9IG9wdHMudmlld0xvZ2dlclxuICAgIHRoaXMubWV0YWRhdGFDYWxsYmFja3MgPSBvcHRzLm1ldGFkYXRhIHx8IHt9XG4gICAgdGhpcy5kZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oY2xvbmUoREVGQVVMVFMpLCBvcHRzLmRlZmF1bHRzIHx8IHt9KVxuICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IG51bGxcbiAgICB0aGlzLnByZXZBY3RpdmUgPSBudWxsXG4gICAgdGhpcy5zaWxlbmNlZCA9IGZhbHNlXG4gICAgdGhpcy5tYWluID0gbnVsbFxuICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSBudWxsXG4gICAgdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCA9IG51bGxcbiAgICB0aGlzLmxpbmtSZWYgPSAxXG4gICAgdGhpcy5yb290cyA9IHt9XG4gICAgdGhpcy5ocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICB0aGlzLnBlbmRpbmdMaW5rID0gbnVsbFxuICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gY2xvbmUod2luZG93LmxvY2F0aW9uKVxuICAgIHRoaXMuaG9va3MgPSBvcHRzLmhvb2tzIHx8IHt9XG4gICAgdGhpcy51cGxvYWRlcnMgPSBvcHRzLnVwbG9hZGVycyB8fCB7fVxuICAgIHRoaXMubG9hZGVyVGltZW91dCA9IG9wdHMubG9hZGVyVGltZW91dCB8fCBMT0FERVJfVElNRU9VVFxuICAgIHRoaXMucmVsb2FkV2l0aEppdHRlclRpbWVyID0gbnVsbFxuICAgIHRoaXMubWF4UmVsb2FkcyA9IG9wdHMubWF4UmVsb2FkcyB8fCBNQVhfUkVMT0FEU1xuICAgIHRoaXMucmVsb2FkSml0dGVyTWluID0gb3B0cy5yZWxvYWRKaXR0ZXJNaW4gfHwgUkVMT0FEX0pJVFRFUl9NSU5cbiAgICB0aGlzLnJlbG9hZEppdHRlck1heCA9IG9wdHMucmVsb2FkSml0dGVyTWF4IHx8IFJFTE9BRF9KSVRURVJfTUFYXG4gICAgdGhpcy5mYWlsc2FmZUppdHRlciA9IG9wdHMuZmFpbHNhZmVKaXR0ZXIgfHwgRkFJTFNBRkVfSklUVEVSXG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSBvcHRzLmxvY2FsU3RvcmFnZSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlXG4gICAgdGhpcy5zZXNzaW9uU3RvcmFnZSA9IG9wdHMuc2Vzc2lvblN0b3JhZ2UgfHwgd2luZG93LnNlc3Npb25TdG9yYWdlXG4gICAgdGhpcy5ib3VuZFRvcExldmVsRXZlbnRzID0gZmFsc2VcbiAgICB0aGlzLmJvdW5kRXZlbnROYW1lcyA9IG5ldyBTZXQoKVxuICAgIHRoaXMuc2VydmVyQ2xvc2VSZWYgPSBudWxsXG4gICAgdGhpcy5kb21DYWxsYmFja3MgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGpzUXVlcnlTZWxlY3RvckFsbDogbnVsbCxcbiAgICAgIG9uUGF0Y2hTdGFydDogY2xvc3VyZSgpLFxuICAgICAgb25QYXRjaEVuZDogY2xvc3VyZSgpLFxuICAgICAgb25Ob2RlQWRkZWQ6IGNsb3N1cmUoKSxcbiAgICAgIG9uQmVmb3JlRWxVcGRhdGVkOiBjbG9zdXJlKCl9LFxuICAgIG9wdHMuZG9tIHx8IHt9KVxuICAgIHRoaXMudHJhbnNpdGlvbnMgPSBuZXcgVHJhbnNpdGlvblNldCgpXG4gICAgdGhpcy5jdXJyZW50SGlzdG9yeVBvc2l0aW9uID0gcGFyc2VJbnQodGhpcy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFBIWF9MVl9ISVNUT1JZX1BPU0lUSU9OKSkgfHwgMFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX2UgPT4ge1xuICAgICAgdGhpcy51bmxvYWRlZCA9IHRydWVcbiAgICB9KVxuICAgIHRoaXMuc29ja2V0Lm9uT3BlbigoKSA9PiB7XG4gICAgICBpZih0aGlzLmlzVW5sb2FkZWQoKSl7XG4gICAgICAgIC8vIHJlbG9hZCBwYWdlIGlmIGJlaW5nIHJlc3RvcmVkIGZyb20gYmFjay9mb3J3YXJkIGNhY2hlIGFuZCBicm93c2VyIGRvZXMgbm90IGVtaXQgXCJwYWdlc2hvd1wiXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBwdWJsaWNcblxuICB2ZXJzaW9uKCl7IHJldHVybiBMVl9WU04gfVxuXG4gIGlzUHJvZmlsZUVuYWJsZWQoKXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfUFJPRklMRSkgPT09IFwidHJ1ZVwiIH1cblxuICBpc0RlYnVnRW5hYmxlZCgpeyByZXR1cm4gdGhpcy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFBIWF9MVl9ERUJVRykgPT09IFwidHJ1ZVwiIH1cblxuICBpc0RlYnVnRGlzYWJsZWQoKXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfREVCVUcpID09PSBcImZhbHNlXCIgfVxuXG4gIGVuYWJsZURlYnVnKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfREVCVUcsIFwidHJ1ZVwiKSB9XG5cbiAgZW5hYmxlUHJvZmlsaW5nKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfUFJPRklMRSwgXCJ0cnVlXCIpIH1cblxuICBkaXNhYmxlRGVidWcoKXsgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9ERUJVRywgXCJmYWxzZVwiKSB9XG5cbiAgZGlzYWJsZVByb2ZpbGluZygpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oUEhYX0xWX1BST0ZJTEUpIH1cblxuICBlbmFibGVMYXRlbmN5U2ltKHVwcGVyQm91bmRNcyl7XG4gICAgdGhpcy5lbmFibGVEZWJ1ZygpXG4gICAgY29uc29sZS5sb2coXCJsYXRlbmN5IHNpbXVsYXRvciBlbmFibGVkIGZvciB0aGUgZHVyYXRpb24gb2YgdGhpcyBicm93c2VyIHNlc3Npb24uIENhbGwgZGlzYWJsZUxhdGVuY3lTaW0oKSB0byBkaXNhYmxlXCIpXG4gICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9MQVRFTkNZX1NJTSwgdXBwZXJCb3VuZE1zKVxuICB9XG5cbiAgZGlzYWJsZUxhdGVuY3lTaW0oKXsgdGhpcy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFBIWF9MVl9MQVRFTkNZX1NJTSkgfVxuXG4gIGdldExhdGVuY3lTaW0oKXtcbiAgICBsZXQgc3RyID0gdGhpcy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFBIWF9MVl9MQVRFTkNZX1NJTSlcbiAgICByZXR1cm4gc3RyID8gcGFyc2VJbnQoc3RyKSA6IG51bGxcbiAgfVxuXG4gIGdldFNvY2tldCgpeyByZXR1cm4gdGhpcy5zb2NrZXQgfVxuXG4gIGNvbm5lY3QoKXtcbiAgICAvLyBlbmFibGUgZGVidWcgYnkgZGVmYXVsdCBpZiBvbiBsb2NhbGhvc3QgYW5kIG5vdCBleHBsaWNpdGx5IGRpc2FibGVkXG4gICAgaWYod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lID09PSBcImxvY2FsaG9zdFwiICYmICF0aGlzLmlzRGVidWdEaXNhYmxlZCgpKXsgdGhpcy5lbmFibGVEZWJ1ZygpIH1cbiAgICBsZXQgZG9Db25uZWN0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5yZXNldFJlbG9hZFN0YXR1cygpXG4gICAgICBpZih0aGlzLmpvaW5Sb290Vmlld3MoKSl7XG4gICAgICAgIHRoaXMuYmluZFRvcExldmVsRXZlbnRzKClcbiAgICAgICAgdGhpcy5zb2NrZXQuY29ubmVjdCgpXG4gICAgICB9IGVsc2UgaWYodGhpcy5tYWluKXtcbiAgICAgICAgdGhpcy5zb2NrZXQuY29ubmVjdCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJpbmRUb3BMZXZlbEV2ZW50cyh7ZGVhZDogdHJ1ZX0pXG4gICAgICB9XG4gICAgICB0aGlzLmpvaW5EZWFkVmlldygpXG4gICAgfVxuICAgIGlmKFtcImNvbXBsZXRlXCIsIFwibG9hZGVkXCIsIFwiaW50ZXJhY3RpdmVcIl0uaW5kZXhPZihkb2N1bWVudC5yZWFkeVN0YXRlKSA+PSAwKXtcbiAgICAgIGRvQ29ubmVjdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IGRvQ29ubmVjdCgpKVxuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3QoY2FsbGJhY2spe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lcilcbiAgICAvLyByZW1vdmUgdGhlIHNvY2tldCBjbG9zZSBsaXN0ZW5lciB0byBhdm9pZCB0cnlpbmcgdG8gaGFuZGxlXG4gICAgLy8gYSBzZXJ2ZXIgY2xvc2UgZXZlbnQgd2hlbiBpdCBpcyBhY3R1YWxseSBjYXVzZWQgYnkgdXMgZGlzY29ubmVjdGluZ1xuICAgIGlmKHRoaXMuc2VydmVyQ2xvc2VSZWYpe1xuICAgICAgdGhpcy5zb2NrZXQub2ZmKHRoaXMuc2VydmVyQ2xvc2VSZWYpXG4gICAgICB0aGlzLnNlcnZlckNsb3NlUmVmID0gbnVsbFxuICAgIH1cbiAgICB0aGlzLnNvY2tldC5kaXNjb25uZWN0KGNhbGxiYWNrKVxuICB9XG5cbiAgcmVwbGFjZVRyYW5zcG9ydCh0cmFuc3BvcnQpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lcilcbiAgICB0aGlzLnNvY2tldC5yZXBsYWNlVHJhbnNwb3J0KHRyYW5zcG9ydClcbiAgICB0aGlzLmNvbm5lY3QoKVxuICB9XG5cbiAgZXhlY0pTKGVsLCBlbmNvZGVkSlMsIGV2ZW50VHlwZSA9IG51bGwpe1xuICAgIGxldCBlID0gbmV3IEN1c3RvbUV2ZW50KFwicGh4OmV4ZWNcIiwge2RldGFpbDoge3NvdXJjZUVsZW1lbnQ6IGVsfX0pXG4gICAgdGhpcy5vd25lcihlbCwgdmlldyA9PiBKUy5leGVjKGUsIGV2ZW50VHlwZSwgZW5jb2RlZEpTLCB2aWV3LCBlbCkpXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgZXhlY0pTSG9va1B1c2goZWwsIHBoeEV2ZW50LCBkYXRhLCBjYWxsYmFjayl7XG4gICAgdGhpcy53aXRoaW5Pd25lcnMoZWwsIHZpZXcgPT4ge1xuICAgICAgbGV0IGUgPSBuZXcgQ3VzdG9tRXZlbnQoXCJwaHg6ZXhlY1wiLCB7ZGV0YWlsOiB7c291cmNlRWxlbWVudDogZWx9fSlcbiAgICAgIEpTLmV4ZWMoZSwgXCJob29rXCIsIHBoeEV2ZW50LCB2aWV3LCBlbCwgW1wicHVzaFwiLCB7ZGF0YSwgY2FsbGJhY2t9XSlcbiAgICB9KVxuICB9XG5cbiAgdW5sb2FkKCl7XG4gICAgaWYodGhpcy51bmxvYWRlZCl7IHJldHVybiB9XG4gICAgaWYodGhpcy5tYWluICYmIHRoaXMuaXNDb25uZWN0ZWQoKSl7IHRoaXMubG9nKHRoaXMubWFpbiwgXCJzb2NrZXRcIiwgKCkgPT4gW1wiZGlzY29ubmVjdCBmb3IgcGFnZSBuYXZcIl0pIH1cbiAgICB0aGlzLnVubG9hZGVkID0gdHJ1ZVxuICAgIHRoaXMuZGVzdHJveUFsbFZpZXdzKClcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICB9XG5cbiAgdHJpZ2dlckRPTShraW5kLCBhcmdzKXsgdGhpcy5kb21DYWxsYmFja3Nba2luZF0oLi4uYXJncykgfVxuXG4gIHRpbWUobmFtZSwgZnVuYyl7XG4gICAgaWYoIXRoaXMuaXNQcm9maWxlRW5hYmxlZCgpIHx8ICFjb25zb2xlLnRpbWUpeyByZXR1cm4gZnVuYygpIH1cbiAgICBjb25zb2xlLnRpbWUobmFtZSlcbiAgICBsZXQgcmVzdWx0ID0gZnVuYygpXG4gICAgY29uc29sZS50aW1lRW5kKG5hbWUpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgbG9nKHZpZXcsIGtpbmQsIG1zZ0NhbGxiYWNrKXtcbiAgICBpZih0aGlzLnZpZXdMb2dnZXIpe1xuICAgICAgbGV0IFttc2csIG9ial0gPSBtc2dDYWxsYmFjaygpXG4gICAgICB0aGlzLnZpZXdMb2dnZXIodmlldywga2luZCwgbXNnLCBvYmopXG4gICAgfSBlbHNlIGlmKHRoaXMuaXNEZWJ1Z0VuYWJsZWQoKSl7XG4gICAgICBsZXQgW21zZywgb2JqXSA9IG1zZ0NhbGxiYWNrKClcbiAgICAgIGRlYnVnKHZpZXcsIGtpbmQsIG1zZywgb2JqKVxuICAgIH1cbiAgfVxuXG4gIHJlcXVlc3RET01VcGRhdGUoY2FsbGJhY2spe1xuICAgIHRoaXMudHJhbnNpdGlvbnMuYWZ0ZXIoY2FsbGJhY2spXG4gIH1cblxuICB0cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSA9IGZ1bmN0aW9uKCl7fSl7XG4gICAgdGhpcy50cmFuc2l0aW9ucy5hZGRUcmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSlcbiAgfVxuXG4gIG9uQ2hhbm5lbChjaGFubmVsLCBldmVudCwgY2Ipe1xuICAgIGNoYW5uZWwub24oZXZlbnQsIGRhdGEgPT4ge1xuICAgICAgbGV0IGxhdGVuY3kgPSB0aGlzLmdldExhdGVuY3lTaW0oKVxuICAgICAgaWYoIWxhdGVuY3kpe1xuICAgICAgICBjYihkYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBjYihkYXRhKSwgbGF0ZW5jeSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcmVsb2FkV2l0aEppdHRlcih2aWV3LCBsb2cpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lcilcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIGxldCBtaW5NcyA9IHRoaXMucmVsb2FkSml0dGVyTWluXG4gICAgbGV0IG1heE1zID0gdGhpcy5yZWxvYWRKaXR0ZXJNYXhcbiAgICBsZXQgYWZ0ZXJNcyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXhNcyAtIG1pbk1zICsgMSkpICsgbWluTXNcbiAgICBsZXQgdHJpZXMgPSBCcm93c2VyLnVwZGF0ZUxvY2FsKHRoaXMubG9jYWxTdG9yYWdlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsIENPTlNFQ1VUSVZFX1JFTE9BRFMsIDAsIGNvdW50ID0+IGNvdW50ICsgMSlcbiAgICBpZih0cmllcyA+PSB0aGlzLm1heFJlbG9hZHMpe1xuICAgICAgYWZ0ZXJNcyA9IHRoaXMuZmFpbHNhZmVKaXR0ZXJcbiAgICB9XG4gICAgdGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIGlmIHZpZXcgaGFzIHJlY292ZXJlZCwgc3VjaCBhcyB0cmFuc3BvcnQgcmVwbGFjZWQsIHRoZW4gY2FuY2VsXG4gICAgICBpZih2aWV3LmlzRGVzdHJveWVkKCkgfHwgdmlldy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIH1cbiAgICAgIHZpZXcuZGVzdHJveSgpXG4gICAgICBsb2cgPyBsb2coKSA6IHRoaXMubG9nKHZpZXcsIFwiam9pblwiLCAoKSA9PiBbYGVuY291bnRlcmVkICR7dHJpZXN9IGNvbnNlY3V0aXZlIHJlbG9hZHNgXSlcbiAgICAgIGlmKHRyaWVzID49IHRoaXMubWF4UmVsb2Fkcyl7XG4gICAgICAgIHRoaXMubG9nKHZpZXcsIFwiam9pblwiLCAoKSA9PiBbYGV4Y2VlZGVkICR7dGhpcy5tYXhSZWxvYWRzfSBjb25zZWN1dGl2ZSByZWxvYWRzLiBFbnRlcmluZyBmYWlsc2FmZSBtb2RlYF0pXG4gICAgICB9XG4gICAgICBpZih0aGlzLmhhc1BlbmRpbmdMaW5rKCkpe1xuICAgICAgICB3aW5kb3cubG9jYXRpb24gPSB0aGlzLnBlbmRpbmdMaW5rXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgIH1cbiAgICB9LCBhZnRlck1zKVxuICB9XG5cbiAgZ2V0SG9va0NhbGxiYWNrcyhuYW1lKXtcbiAgICByZXR1cm4gbmFtZSAmJiBuYW1lLnN0YXJ0c1dpdGgoXCJQaG9lbml4LlwiKSA/IEhvb2tzW25hbWUuc3BsaXQoXCIuXCIpWzFdXSA6IHRoaXMuaG9va3NbbmFtZV1cbiAgfVxuXG4gIGlzVW5sb2FkZWQoKXsgcmV0dXJuIHRoaXMudW5sb2FkZWQgfVxuXG4gIGlzQ29ubmVjdGVkKCl7IHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpIH1cblxuICBnZXRCaW5kaW5nUHJlZml4KCl7IHJldHVybiB0aGlzLmJpbmRpbmdQcmVmaXggfVxuXG4gIGJpbmRpbmcoa2luZCl7IHJldHVybiBgJHt0aGlzLmdldEJpbmRpbmdQcmVmaXgoKX0ke2tpbmR9YCB9XG5cbiAgY2hhbm5lbCh0b3BpYywgcGFyYW1zKXsgcmV0dXJuIHRoaXMuc29ja2V0LmNoYW5uZWwodG9waWMsIHBhcmFtcykgfVxuXG4gIGpvaW5EZWFkVmlldygpe1xuICAgIGxldCBib2R5ID0gZG9jdW1lbnQuYm9keVxuICAgIGlmKGJvZHkgJiYgIXRoaXMuaXNQaHhWaWV3KGJvZHkpICYmICF0aGlzLmlzUGh4Vmlldyhkb2N1bWVudC5maXJzdEVsZW1lbnRDaGlsZCkpe1xuICAgICAgbGV0IHZpZXcgPSB0aGlzLm5ld1Jvb3RWaWV3KGJvZHkpXG4gICAgICB2aWV3LnNldEhyZWYodGhpcy5nZXRIcmVmKCkpXG4gICAgICB2aWV3LmpvaW5EZWFkKClcbiAgICAgIGlmKCF0aGlzLm1haW4peyB0aGlzLm1haW4gPSB2aWV3IH1cbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB2aWV3LmV4ZWNOZXdNb3VudGVkKClcbiAgICAgICAgLy8gcmVzdG9yZSBzY3JvbGwgcG9zaXRpb24gd2hlbiBuYXZpZ2F0aW5nIGZyb20gYW4gZXh0ZXJuYWwgLyBub24tbGl2ZSBwYWdlXG4gICAgICAgIHRoaXMubWF5YmVTY3JvbGwoaGlzdG9yeS5zdGF0ZT8uc2Nyb2xsKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBqb2luUm9vdFZpZXdzKCl7XG4gICAgbGV0IHJvb3RzRm91bmQgPSBmYWxzZVxuICAgIERPTS5hbGwoZG9jdW1lbnQsIGAke1BIWF9WSUVXX1NFTEVDVE9SfTpub3QoWyR7UEhYX1BBUkVOVF9JRH1dKWAsIHJvb3RFbCA9PiB7XG4gICAgICBpZighdGhpcy5nZXRSb290QnlJZChyb290RWwuaWQpKXtcbiAgICAgICAgbGV0IHZpZXcgPSB0aGlzLm5ld1Jvb3RWaWV3KHJvb3RFbClcbiAgICAgICAgdmlldy5zZXRIcmVmKHRoaXMuZ2V0SHJlZigpKVxuICAgICAgICB2aWV3LmpvaW4oKVxuICAgICAgICBpZihyb290RWwuaGFzQXR0cmlidXRlKFBIWF9NQUlOKSl7IHRoaXMubWFpbiA9IHZpZXcgfVxuICAgICAgfVxuICAgICAgcm9vdHNGb3VuZCA9IHRydWVcbiAgICB9KVxuICAgIHJldHVybiByb290c0ZvdW5kXG4gIH1cblxuICByZWRpcmVjdCh0bywgZmxhc2gsIHJlbG9hZFRva2VuKXtcbiAgICBpZihyZWxvYWRUb2tlbil7IEJyb3dzZXIuc2V0Q29va2llKFBIWF9SRUxPQURfU1RBVFVTLCByZWxvYWRUb2tlbiwgNjApIH1cbiAgICB0aGlzLnVubG9hZCgpXG4gICAgQnJvd3Nlci5yZWRpcmVjdCh0bywgZmxhc2gpXG4gIH1cblxuICByZXBsYWNlTWFpbihocmVmLCBmbGFzaCwgY2FsbGJhY2sgPSBudWxsLCBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSl7XG4gICAgbGV0IGxpdmVSZWZlcmVyID0gdGhpcy5jdXJyZW50TG9jYXRpb24uaHJlZlxuICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSB0aGlzLm91dGdvaW5nTWFpbkVsIHx8IHRoaXMubWFpbi5lbFxuICAgIGxldCByZW1vdmVFbHMgPSBET00uYWxsKHRoaXMub3V0Z29pbmdNYWluRWwsIGBbJHt0aGlzLmJpbmRpbmcoXCJyZW1vdmVcIil9XWApXG4gICAgbGV0IG5ld01haW5FbCA9IERPTS5jbG9uZU5vZGUodGhpcy5vdXRnb2luZ01haW5FbCwgXCJcIilcbiAgICB0aGlzLm1haW4uc2hvd0xvYWRlcih0aGlzLmxvYWRlclRpbWVvdXQpXG4gICAgdGhpcy5tYWluLmRlc3Ryb3koKVxuXG4gICAgdGhpcy5tYWluID0gdGhpcy5uZXdSb290VmlldyhuZXdNYWluRWwsIGZsYXNoLCBsaXZlUmVmZXJlcilcbiAgICB0aGlzLm1haW4uc2V0UmVkaXJlY3QoaHJlZilcbiAgICB0aGlzLnRyYW5zaXRpb25SZW1vdmVzKHJlbW92ZUVscywgdHJ1ZSlcbiAgICB0aGlzLm1haW4uam9pbigoam9pbkNvdW50LCBvbkRvbmUpID0+IHtcbiAgICAgIGlmKGpvaW5Db3VudCA9PT0gMSAmJiB0aGlzLmNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpKXtcbiAgICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAvLyByZW1vdmUgcGh4LXJlbW92ZSBlbHMgcmlnaHQgYmVmb3JlIHdlIHJlcGxhY2UgdGhlIG1haW4gZWxlbWVudFxuICAgICAgICAgIHJlbW92ZUVscy5mb3JFYWNoKGVsID0+IGVsLnJlbW92ZSgpKVxuICAgICAgICAgIERPTS5maW5kUGh4U3RpY2t5KGRvY3VtZW50KS5mb3JFYWNoKGVsID0+IG5ld01haW5FbC5hcHBlbmRDaGlsZChlbCkpXG4gICAgICAgICAgdGhpcy5vdXRnb2luZ01haW5FbC5yZXBsYWNlV2l0aChuZXdNYWluRWwpXG4gICAgICAgICAgdGhpcy5vdXRnb2luZ01haW5FbCA9IG51bGxcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhsaW5rUmVmKVxuICAgICAgICAgIG9uRG9uZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHRyYW5zaXRpb25SZW1vdmVzKGVsZW1lbnRzLCBza2lwU3RpY2t5LCBjYWxsYmFjayl7XG4gICAgbGV0IHJlbW92ZUF0dHIgPSB0aGlzLmJpbmRpbmcoXCJyZW1vdmVcIilcbiAgICBpZihza2lwU3RpY2t5KXtcbiAgICAgIGNvbnN0IHN0aWNraWVzID0gRE9NLmZpbmRQaHhTdGlja3koZG9jdW1lbnQpIHx8IFtdXG4gICAgICBlbGVtZW50cyA9IGVsZW1lbnRzLmZpbHRlcihlbCA9PiAhRE9NLmlzQ2hpbGRPZkFueShlbCwgc3RpY2tpZXMpKVxuICAgIH1cbiAgICBsZXQgc2lsZW5jZUV2ZW50cyA9IChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcbiAgICB9XG4gICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAvLyBwcmV2ZW50IGFsbCBsaXN0ZW5lcnMgd2UgY2FyZSBhYm91dCBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvd1xuICAgICAgLy8gc2luY2Ugd2UgYXJlIHJlbW92aW5nIHRoZSBlbGVtZW50XG4gICAgICBmb3IobGV0IGV2ZW50IG9mIHRoaXMuYm91bmRFdmVudE5hbWVzKXtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgc2lsZW5jZUV2ZW50cywgdHJ1ZSlcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhlY0pTKGVsLCBlbC5nZXRBdHRyaWJ1dGUocmVtb3ZlQXR0ciksIFwicmVtb3ZlXCIpXG4gICAgfSlcbiAgICAvLyByZW1vdmUgdGhlIHNpbGVuY2VkIGxpc3RlbmVycyB3aGVuIHRyYW5zaXRpb25zIGFyZSBkb25lIGluY2FzZSB0aGUgZWxlbWVudCBpcyByZS11c2VkXG4gICAgLy8gYW5kIGNhbGwgY2FsbGVyJ3MgY2FsbGJhY2sgYXMgc29vbiBhcyB3ZSBhcmUgZG9uZSB3aXRoIHRyYW5zaXRpb25zXG4gICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBmb3IobGV0IGV2ZW50IG9mIHRoaXMuYm91bmRFdmVudE5hbWVzKXtcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBzaWxlbmNlRXZlbnRzLCB0cnVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgIH0pXG4gIH1cblxuICBpc1BoeFZpZXcoZWwpeyByZXR1cm4gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTikgIT09IG51bGwgfVxuXG4gIG5ld1Jvb3RWaWV3KGVsLCBmbGFzaCwgbGl2ZVJlZmVyZXIpe1xuICAgIGxldCB2aWV3ID0gbmV3IFZpZXcoZWwsIHRoaXMsIG51bGwsIGZsYXNoLCBsaXZlUmVmZXJlcilcbiAgICB0aGlzLnJvb3RzW3ZpZXcuaWRdID0gdmlld1xuICAgIHJldHVybiB2aWV3XG4gIH1cblxuICBvd25lcihjaGlsZEVsLCBjYWxsYmFjayl7XG4gICAgbGV0IHZpZXcgPSBtYXliZShjaGlsZEVsLmNsb3Nlc3QoUEhYX1ZJRVdfU0VMRUNUT1IpLCBlbCA9PiB0aGlzLmdldFZpZXdCeUVsKGVsKSkgfHwgdGhpcy5tYWluXG4gICAgcmV0dXJuIHZpZXcgJiYgY2FsbGJhY2sgPyBjYWxsYmFjayh2aWV3KSA6IHZpZXdcbiAgfVxuXG4gIHdpdGhpbk93bmVycyhjaGlsZEVsLCBjYWxsYmFjayl7XG4gICAgdGhpcy5vd25lcihjaGlsZEVsLCB2aWV3ID0+IGNhbGxiYWNrKHZpZXcsIGNoaWxkRWwpKVxuICB9XG5cbiAgZ2V0Vmlld0J5RWwoZWwpe1xuICAgIGxldCByb290SWQgPSBlbC5nZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQpXG4gICAgcmV0dXJuIG1heWJlKHRoaXMuZ2V0Um9vdEJ5SWQocm9vdElkKSwgcm9vdCA9PiByb290LmdldERlc2NlbmRlbnRCeUVsKGVsKSlcbiAgfVxuXG4gIGdldFJvb3RCeUlkKGlkKXsgcmV0dXJuIHRoaXMucm9vdHNbaWRdIH1cblxuICBkZXN0cm95QWxsVmlld3MoKXtcbiAgICBmb3IobGV0IGlkIGluIHRoaXMucm9vdHMpe1xuICAgICAgdGhpcy5yb290c1tpZF0uZGVzdHJveSgpXG4gICAgICBkZWxldGUgdGhpcy5yb290c1tpZF1cbiAgICB9XG4gICAgdGhpcy5tYWluID0gbnVsbFxuICB9XG5cbiAgZGVzdHJveVZpZXdCeUVsKGVsKXtcbiAgICBsZXQgcm9vdCA9IHRoaXMuZ2V0Um9vdEJ5SWQoZWwuZ2V0QXR0cmlidXRlKFBIWF9ST09UX0lEKSlcbiAgICBpZihyb290ICYmIHJvb3QuaWQgPT09IGVsLmlkKXtcbiAgICAgIHJvb3QuZGVzdHJveSgpXG4gICAgICBkZWxldGUgdGhpcy5yb290c1tyb290LmlkXVxuICAgIH0gZWxzZSBpZihyb290KXtcbiAgICAgIHJvb3QuZGVzdHJveURlc2NlbmRlbnQoZWwuaWQpXG4gICAgfVxuICB9XG5cbiAgZ2V0QWN0aXZlRWxlbWVudCgpe1xuICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gIH1cblxuICBkcm9wQWN0aXZlRWxlbWVudCh2aWV3KXtcbiAgICBpZih0aGlzLnByZXZBY3RpdmUgJiYgdmlldy5vd25zRWxlbWVudCh0aGlzLnByZXZBY3RpdmUpKXtcbiAgICAgIHRoaXMucHJldkFjdGl2ZSA9IG51bGxcbiAgICB9XG4gIH1cblxuICByZXN0b3JlUHJldmlvdXNseUFjdGl2ZUZvY3VzKCl7XG4gICAgaWYodGhpcy5wcmV2QWN0aXZlICYmIHRoaXMucHJldkFjdGl2ZSAhPT0gZG9jdW1lbnQuYm9keSl7XG4gICAgICB0aGlzLnByZXZBY3RpdmUuZm9jdXMoKVxuICAgIH1cbiAgfVxuXG4gIGJsdXJBY3RpdmVFbGVtZW50KCl7XG4gICAgdGhpcy5wcmV2QWN0aXZlID0gdGhpcy5nZXRBY3RpdmVFbGVtZW50KClcbiAgICBpZih0aGlzLnByZXZBY3RpdmUgIT09IGRvY3VtZW50LmJvZHkpeyB0aGlzLnByZXZBY3RpdmUuYmx1cigpIH1cbiAgfVxuXG4gIGJpbmRUb3BMZXZlbEV2ZW50cyh7ZGVhZH0gPSB7fSl7XG4gICAgaWYodGhpcy5ib3VuZFRvcExldmVsRXZlbnRzKXsgcmV0dXJuIH1cblxuICAgIHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cyA9IHRydWVcbiAgICAvLyBlbnRlciBmYWlsc2FmZSByZWxvYWQgaWYgc2VydmVyIGhhcyBnb25lIGF3YXkgaW50ZW50aW9uYWxseSwgc3VjaCBhcyBcImRpc2Nvbm5lY3RcIiBicm9hZGNhc3RcbiAgICB0aGlzLnNlcnZlckNsb3NlUmVmID0gdGhpcy5zb2NrZXQub25DbG9zZShldmVudCA9PiB7XG4gICAgICAvLyBmYWlsc2FmZSByZWxvYWQgaWYgbm9ybWFsIGNsb3N1cmUgYW5kIHdlIHN0aWxsIGhhdmUgYSBtYWluIExWXG4gICAgICBpZihldmVudCAmJiBldmVudC5jb2RlID09PSAxMDAwICYmIHRoaXMubWFpbil7IHJldHVybiB0aGlzLnJlbG9hZFdpdGhKaXR0ZXIodGhpcy5tYWluKSB9XG4gICAgfSlcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKXsgfSkgLy8gZW5zdXJlIGFsbCBjbGljayBldmVudHMgYnViYmxlIGZvciBtb2JpbGUgU2FmYXJpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCBlID0+IHtcbiAgICAgIGlmKGUucGVyc2lzdGVkKXsgLy8gcmVsb2FkIHBhZ2UgaWYgYmVpbmcgcmVzdG9yZWQgZnJvbSBiYWNrL2ZvcndhcmQgY2FjaGVcbiAgICAgICAgdGhpcy5nZXRTb2NrZXQoKS5kaXNjb25uZWN0KClcbiAgICAgICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoe3RvOiB3aW5kb3cubG9jYXRpb24uaHJlZiwga2luZDogXCJyZWRpcmVjdFwifSlcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICB9XG4gICAgfSwgdHJ1ZSlcbiAgICBpZighZGVhZCl7IHRoaXMuYmluZE5hdigpIH1cbiAgICB0aGlzLmJpbmRDbGlja3MoKVxuICAgIGlmKCFkZWFkKXsgdGhpcy5iaW5kRm9ybXMoKSB9XG4gICAgdGhpcy5iaW5kKHtrZXl1cDogXCJrZXl1cFwiLCBrZXlkb3duOiBcImtleWRvd25cIn0sIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgcGh4RXZlbnQsIF9waHhUYXJnZXQpID0+IHtcbiAgICAgIGxldCBtYXRjaEtleSA9IHRhcmdldEVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0tFWSkpXG4gICAgICBsZXQgcHJlc3NlZEtleSA9IGUua2V5ICYmIGUua2V5LnRvTG93ZXJDYXNlKCkgLy8gY2hyb21lIGNsaWNrZWQgYXV0b2NvbXBsZXRlcyBzZW5kIGEga2V5ZG93biB3aXRob3V0IGtleVxuICAgICAgaWYobWF0Y2hLZXkgJiYgbWF0Y2hLZXkudG9Mb3dlckNhc2UoKSAhPT0gcHJlc3NlZEtleSl7IHJldHVybiB9XG5cbiAgICAgIGxldCBkYXRhID0ge2tleTogZS5rZXksIC4uLnRoaXMuZXZlbnRNZXRhKHR5cGUsIGUsIHRhcmdldEVsKX1cbiAgICAgIEpTLmV4ZWMoZSwgdHlwZSwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldEVsLCBbXCJwdXNoXCIsIHtkYXRhfV0pXG4gICAgfSlcbiAgICB0aGlzLmJpbmQoe2JsdXI6IFwiZm9jdXNvdXRcIiwgZm9jdXM6IFwiZm9jdXNpblwifSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldEVsLCBwaHhFdmVudCwgcGh4VGFyZ2V0KSA9PiB7XG4gICAgICBpZighcGh4VGFyZ2V0KXtcbiAgICAgICAgbGV0IGRhdGEgPSB7a2V5OiBlLmtleSwgLi4udGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpfVxuICAgICAgICBKUy5leGVjKGUsIHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7ZGF0YX1dKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5iaW5kKHtibHVyOiBcImJsdXJcIiwgZm9jdXM6IFwiZm9jdXNcIn0sIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgcGh4RXZlbnQsIHBoeFRhcmdldCkgPT4ge1xuICAgICAgLy8gYmx1ciBhbmQgZm9jdXMgYXJlIHRyaWdnZXJlZCBvbiBkb2N1bWVudCBhbmQgd2luZG93LiBEaXNjYXJkIG9uZSB0byBhdm9pZCBkdXBzXG4gICAgICBpZihwaHhUYXJnZXQgPT09IFwid2luZG93XCIpe1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZXZlbnRNZXRhKHR5cGUsIGUsIHRhcmdldEVsKVxuICAgICAgICBKUy5leGVjKGUsIHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7ZGF0YX1dKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5vbihcImRyYWdvdmVyXCIsIGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpKVxuICAgIHRoaXMub24oXCJkcm9wXCIsIGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBsZXQgZHJvcFRhcmdldElkID0gbWF5YmUoY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIHRoaXMuYmluZGluZyhQSFhfRFJPUF9UQVJHRVQpKSwgdHJ1ZVRhcmdldCA9PiB7XG4gICAgICAgIHJldHVybiB0cnVlVGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0RST1BfVEFSR0VUKSlcbiAgICAgIH0pXG4gICAgICBsZXQgZHJvcFRhcmdldCA9IGRyb3BUYXJnZXRJZCAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkcm9wVGFyZ2V0SWQpXG4gICAgICBsZXQgZmlsZXMgPSBBcnJheS5mcm9tKGUuZGF0YVRyYW5zZmVyLmZpbGVzIHx8IFtdKVxuICAgICAgaWYoIWRyb3BUYXJnZXQgfHwgZHJvcFRhcmdldC5kaXNhYmxlZCB8fCBmaWxlcy5sZW5ndGggPT09IDAgfHwgIShkcm9wVGFyZ2V0LmZpbGVzIGluc3RhbmNlb2YgRmlsZUxpc3QpKXsgcmV0dXJuIH1cblxuICAgICAgTGl2ZVVwbG9hZGVyLnRyYWNrRmlsZXMoZHJvcFRhcmdldCwgZmlsZXMsIGUuZGF0YVRyYW5zZmVyKVxuICAgICAgZHJvcFRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIsIHtidWJibGVzOiB0cnVlfSkpXG4gICAgfSlcbiAgICB0aGlzLm9uKFBIWF9UUkFDS19VUExPQURTLCBlID0+IHtcbiAgICAgIGxldCB1cGxvYWRUYXJnZXQgPSBlLnRhcmdldFxuICAgICAgaWYoIURPTS5pc1VwbG9hZElucHV0KHVwbG9hZFRhcmdldCkpeyByZXR1cm4gfVxuICAgICAgbGV0IGZpbGVzID0gQXJyYXkuZnJvbShlLmRldGFpbC5maWxlcyB8fCBbXSkuZmlsdGVyKGYgPT4gZiBpbnN0YW5jZW9mIEZpbGUgfHwgZiBpbnN0YW5jZW9mIEJsb2IpXG4gICAgICBMaXZlVXBsb2FkZXIudHJhY2tGaWxlcyh1cGxvYWRUYXJnZXQsIGZpbGVzKVxuICAgICAgdXBsb2FkVGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIiwge2J1YmJsZXM6IHRydWV9KSlcbiAgICB9KVxuICB9XG5cbiAgZXZlbnRNZXRhKGV2ZW50TmFtZSwgZSwgdGFyZ2V0RWwpe1xuICAgIGxldCBjYWxsYmFjayA9IHRoaXMubWV0YWRhdGFDYWxsYmFja3NbZXZlbnROYW1lXVxuICAgIHJldHVybiBjYWxsYmFjayA/IGNhbGxiYWNrKGUsIHRhcmdldEVsKSA6IHt9XG4gIH1cblxuICBzZXRQZW5kaW5nTGluayhocmVmKXtcbiAgICB0aGlzLmxpbmtSZWYrK1xuICAgIHRoaXMucGVuZGluZ0xpbmsgPSBocmVmXG4gICAgdGhpcy5yZXNldFJlbG9hZFN0YXR1cygpXG4gICAgcmV0dXJuIHRoaXMubGlua1JlZlxuICB9XG5cbiAgLy8gYW55dGltZSB3ZSBhcmUgbmF2aWdhdGluZyBvciBjb25uZWN0aW5nLCBkcm9wIHJlbG9hZCBjb29raWUgaW4gY2FzZVxuICAvLyB3ZSBpc3N1ZSB0aGUgY29va2llIGJ1dCB0aGUgbmV4dCByZXF1ZXN0IHdhcyBpbnRlcnJ1cHRlZCBhbmQgdGhlIHNlcnZlciBuZXZlciBkcm9wcGVkIGl0XG4gIHJlc2V0UmVsb2FkU3RhdHVzKCl7IEJyb3dzZXIuZGVsZXRlQ29va2llKFBIWF9SRUxPQURfU1RBVFVTKSB9XG5cbiAgY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZil7XG4gICAgaWYodGhpcy5saW5rUmVmICE9PSBsaW5rUmVmKXtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhyZWYgPSB0aGlzLnBlbmRpbmdMaW5rXG4gICAgICB0aGlzLnBlbmRpbmdMaW5rID0gbnVsbFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBnZXRIcmVmKCl7IHJldHVybiB0aGlzLmhyZWYgfVxuXG4gIGhhc1BlbmRpbmdMaW5rKCl7IHJldHVybiAhIXRoaXMucGVuZGluZ0xpbmsgfVxuXG4gIGJpbmQoZXZlbnRzLCBjYWxsYmFjayl7XG4gICAgZm9yKGxldCBldmVudCBpbiBldmVudHMpe1xuICAgICAgbGV0IGJyb3dzZXJFdmVudE5hbWUgPSBldmVudHNbZXZlbnRdXG5cbiAgICAgIHRoaXMub24oYnJvd3NlckV2ZW50TmFtZSwgZSA9PiB7XG4gICAgICAgIGxldCBiaW5kaW5nID0gdGhpcy5iaW5kaW5nKGV2ZW50KVxuICAgICAgICBsZXQgd2luZG93QmluZGluZyA9IHRoaXMuYmluZGluZyhgd2luZG93LSR7ZXZlbnR9YClcbiAgICAgICAgbGV0IHRhcmdldFBoeEV2ZW50ID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlICYmIGUudGFyZ2V0LmdldEF0dHJpYnV0ZShiaW5kaW5nKVxuICAgICAgICBpZih0YXJnZXRQaHhFdmVudCl7XG4gICAgICAgICAgdGhpcy5kZWJvdW5jZShlLnRhcmdldCwgZSwgYnJvd3NlckV2ZW50TmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZS50YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICAgICAgICBjYWxsYmFjayhlLCBldmVudCwgdmlldywgZS50YXJnZXQsIHRhcmdldFBoeEV2ZW50LCBudWxsKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIERPTS5hbGwoZG9jdW1lbnQsIGBbJHt3aW5kb3dCaW5kaW5nfV1gLCBlbCA9PiB7XG4gICAgICAgICAgICBsZXQgcGh4RXZlbnQgPSBlbC5nZXRBdHRyaWJ1dGUod2luZG93QmluZGluZylcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2UoZWwsIGUsIGJyb3dzZXJFdmVudE5hbWUsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZWwsIHZpZXcgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGV2ZW50LCB2aWV3LCBlbCwgcGh4RXZlbnQsIFwid2luZG93XCIpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgYmluZENsaWNrcygpe1xuICAgIHRoaXMub24oXCJtb3VzZWRvd25cIiwgZSA9PiB0aGlzLmNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gZS50YXJnZXQpXG4gICAgdGhpcy5iaW5kQ2xpY2soXCJjbGlja1wiLCBcImNsaWNrXCIpXG4gIH1cblxuICBiaW5kQ2xpY2soZXZlbnROYW1lLCBiaW5kaW5nTmFtZSl7XG4gICAgbGV0IGNsaWNrID0gdGhpcy5iaW5kaW5nKGJpbmRpbmdOYW1lKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZSA9PiB7XG4gICAgICBsZXQgdGFyZ2V0ID0gbnVsbFxuICAgICAgLy8gYSBzeW50aGV0aWMgY2xpY2sgZXZlbnQgKGRldGFpbCAwKSB3aWxsIG5vdCBoYXZlIGNhdXNlZCBhIG1vdXNlZG93biBldmVudCxcbiAgICAgIC8vIHRoZXJlZm9yZSB0aGUgY2xpY2tTdGFydGVkQXRUYXJnZXQgaXMgc3RhbGVcbiAgICAgIGlmKGUuZGV0YWlsID09PSAwKSB0aGlzLmNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gZS50YXJnZXRcbiAgICAgIGxldCBjbGlja1N0YXJ0ZWRBdFRhcmdldCA9IHRoaXMuY2xpY2tTdGFydGVkQXRUYXJnZXQgfHwgZS50YXJnZXRcbiAgICAgIC8vIHdoZW4gc2VhcmNoaW5nIHRoZSB0YXJnZXQgZm9yIHRoZSBjbGljayBldmVudCwgd2UgYWx3YXlzIHdhbnQgdG9cbiAgICAgIC8vIHVzZSB0aGUgYWN0dWFsIGV2ZW50IHRhcmdldCwgc2VlICMzMzcyXG4gICAgICB0YXJnZXQgPSBjbG9zZXN0UGh4QmluZGluZyhlLnRhcmdldCwgY2xpY2spXG4gICAgICB0aGlzLmRpc3BhdGNoQ2xpY2tBd2F5KGUsIGNsaWNrU3RhcnRlZEF0VGFyZ2V0KVxuICAgICAgdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCA9IG51bGxcbiAgICAgIGxldCBwaHhFdmVudCA9IHRhcmdldCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKGNsaWNrKVxuICAgICAgaWYoIXBoeEV2ZW50KXtcbiAgICAgICAgaWYoRE9NLmlzTmV3UGFnZUNsaWNrKGUsIHdpbmRvdy5sb2NhdGlvbikpeyB0aGlzLnVubG9hZCgpIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIil7IGUucHJldmVudERlZmF1bHQoKSB9XG5cbiAgICAgIC8vIG5vb3AgaWYgd2UgYXJlIGluIHRoZSBtaWRkbGUgb2YgYXdhaXRpbmcgYW4gYWNrIGZvciB0aGlzIGVsIGFscmVhZHlcbiAgICAgIGlmKHRhcmdldC5oYXNBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpKXsgcmV0dXJuIH1cblxuICAgICAgdGhpcy5kZWJvdW5jZSh0YXJnZXQsIGUsIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLndpdGhpbk93bmVycyh0YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICAgIEpTLmV4ZWMoZSwgXCJjbGlja1wiLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0LCBbXCJwdXNoXCIsIHtkYXRhOiB0aGlzLmV2ZW50TWV0YShcImNsaWNrXCIsIGUsIHRhcmdldCl9XSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSwgZmFsc2UpXG4gIH1cblxuICBkaXNwYXRjaENsaWNrQXdheShlLCBjbGlja1N0YXJ0ZWRBdCl7XG4gICAgbGV0IHBoeENsaWNrQXdheSA9IHRoaXMuYmluZGluZyhcImNsaWNrLWF3YXlcIilcbiAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7cGh4Q2xpY2tBd2F5fV1gLCBlbCA9PiB7XG4gICAgICBpZighKGVsLmlzU2FtZU5vZGUoY2xpY2tTdGFydGVkQXQpIHx8IGVsLmNvbnRhaW5zKGNsaWNrU3RhcnRlZEF0KSkpe1xuICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlbCwgdmlldyA9PiB7XG4gICAgICAgICAgbGV0IHBoeEV2ZW50ID0gZWwuZ2V0QXR0cmlidXRlKHBoeENsaWNrQXdheSlcbiAgICAgICAgICBpZihKUy5pc1Zpc2libGUoZWwpICYmIEpTLmlzSW5WaWV3cG9ydChlbCkpe1xuICAgICAgICAgICAgSlMuZXhlYyhlLCBcImNsaWNrXCIsIHBoeEV2ZW50LCB2aWV3LCBlbCwgW1wicHVzaFwiLCB7ZGF0YTogdGhpcy5ldmVudE1ldGEoXCJjbGlja1wiLCBlLCBlLnRhcmdldCl9XSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGJpbmROYXYoKXtcbiAgICBpZighQnJvd3Nlci5jYW5QdXNoU3RhdGUoKSl7IHJldHVybiB9XG4gICAgaWYoaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbil7IGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiIH1cbiAgICBsZXQgc2Nyb2xsVGltZXIgPSBudWxsXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgX2UgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFRpbWVyKVxuICAgICAgc2Nyb2xsVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgQnJvd3Nlci51cGRhdGVDdXJyZW50U3RhdGUoc3RhdGUgPT4gT2JqZWN0LmFzc2lnbihzdGF0ZSwge3Njcm9sbDogd2luZG93LnNjcm9sbFl9KSlcbiAgICAgIH0sIDEwMClcbiAgICB9KVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgZXZlbnQgPT4ge1xuICAgICAgaWYoIXRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pKXsgcmV0dXJuIH1cbiAgICAgIGxldCB7dHlwZSwgYmFja1R5cGUsIGlkLCByb290LCBzY3JvbGwsIHBvc2l0aW9ufSA9IGV2ZW50LnN0YXRlIHx8IHt9XG4gICAgICBsZXQgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG5cbiAgICAgIC8vIENvbXBhcmUgcG9zaXRpb25zIHRvIGRldGVybWluZSBkaXJlY3Rpb25cbiAgICAgIGxldCBpc0ZvcndhcmQgPSBwb3NpdGlvbiA+IHRoaXMuY3VycmVudEhpc3RvcnlQb3NpdGlvblxuXG4gICAgICB0eXBlID0gaXNGb3J3YXJkID8gdHlwZSA6IChiYWNrVHlwZSB8fCB0eXBlKVxuXG4gICAgICAvLyBVcGRhdGUgY3VycmVudCBwb3NpdGlvblxuICAgICAgdGhpcy5jdXJyZW50SGlzdG9yeVBvc2l0aW9uID0gcG9zaXRpb24gfHwgMFxuICAgICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9ISVNUT1JZX1BPU0lUSU9OLCB0aGlzLmN1cnJlbnRIaXN0b3J5UG9zaXRpb24udG9TdHJpbmcoKSlcblxuICAgICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpuYXZpZ2F0ZVwiLCB7ZGV0YWlsOiB7aHJlZiwgcGF0Y2g6IHR5cGUgPT09IFwicGF0Y2hcIiwgcG9wOiB0cnVlLCBkaXJlY3Rpb246IGlzRm9yd2FyZCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwifX0pXG4gICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBpZih0aGlzLm1haW4uaXNDb25uZWN0ZWQoKSAmJiAodHlwZSA9PT0gXCJwYXRjaFwiICYmIGlkID09PSB0aGlzLm1haW4uaWQpKXtcbiAgICAgICAgICB0aGlzLm1haW4ucHVzaExpbmtQYXRjaChldmVudCwgaHJlZiwgbnVsbCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYXliZVNjcm9sbChzY3JvbGwpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlcGxhY2VNYWluKGhyZWYsIG51bGwsICgpID0+IHtcbiAgICAgICAgICAgIGlmKHJvb3QpeyB0aGlzLnJlcGxhY2VSb290SGlzdG9yeSgpIH1cbiAgICAgICAgICAgIHRoaXMubWF5YmVTY3JvbGwoc2Nyb2xsKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSwgZmFsc2UpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBlID0+IHtcbiAgICAgIGxldCB0YXJnZXQgPSBjbG9zZXN0UGh4QmluZGluZyhlLnRhcmdldCwgUEhYX0xJVkVfTElOSylcbiAgICAgIGxldCB0eXBlID0gdGFyZ2V0ICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoUEhYX0xJVkVfTElOSylcbiAgICAgIGlmKCF0eXBlIHx8ICF0aGlzLmlzQ29ubmVjdGVkKCkgfHwgIXRoaXMubWFpbiB8fCBET00ud2FudHNOZXdUYWIoZSkpeyByZXR1cm4gfVxuXG4gICAgICAvLyBXaGVuIHdyYXBwaW5nIGFuIFNWRyBlbGVtZW50IGluIGFuIGFuY2hvciB0YWcsIHRoZSBocmVmIGNhbiBiZSBhbiBTVkdBbmltYXRlZFN0cmluZ1xuICAgICAgbGV0IGhyZWYgPSB0YXJnZXQuaHJlZiBpbnN0YW5jZW9mIFNWR0FuaW1hdGVkU3RyaW5nID8gdGFyZ2V0LmhyZWYuYmFzZVZhbCA6IHRhcmdldC5ocmVmXG5cbiAgICAgIGxldCBsaW5rU3RhdGUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFBIWF9MSU5LX1NUQVRFKVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIC8vIGRvIG5vdCBidWJibGUgY2xpY2sgdG8gcmVndWxhciBwaHgtY2xpY2sgYmluZGluZ3NcbiAgICAgIGlmKHRoaXMucGVuZGluZ0xpbmsgPT09IGhyZWYpeyByZXR1cm4gfVxuXG4gICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBpZih0eXBlID09PSBcInBhdGNoXCIpe1xuICAgICAgICAgIHRoaXMucHVzaEhpc3RvcnlQYXRjaChlLCBocmVmLCBsaW5rU3RhdGUsIHRhcmdldClcbiAgICAgICAgfSBlbHNlIGlmKHR5cGUgPT09IFwicmVkaXJlY3RcIil7XG4gICAgICAgICAgdGhpcy5oaXN0b3J5UmVkaXJlY3QoZSwgaHJlZiwgbGlua1N0YXRlLCBudWxsLCB0YXJnZXQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke1BIWF9MSVZFX0xJTkt9IHRvIGJlIFwicGF0Y2hcIiBvciBcInJlZGlyZWN0XCIsIGdvdDogJHt0eXBlfWApXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBoeENsaWNrID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjbGlja1wiKSlcbiAgICAgICAgaWYocGh4Q2xpY2spe1xuICAgICAgICAgIHRoaXMucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB0aGlzLmV4ZWNKUyh0YXJnZXQsIHBoeENsaWNrLCBcImNsaWNrXCIpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sIGZhbHNlKVxuICB9XG5cbiAgbWF5YmVTY3JvbGwoc2Nyb2xsKXtcbiAgICBpZih0eXBlb2Yoc2Nyb2xsKSA9PT0gXCJudW1iZXJcIil7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgc2Nyb2xsKVxuICAgICAgfSkgLy8gdGhlIGJvZHkgbmVlZHMgdG8gcmVuZGVyIGJlZm9yZSB3ZSBzY3JvbGwuXG4gICAgfVxuICB9XG5cbiAgZGlzcGF0Y2hFdmVudChldmVudCwgcGF5bG9hZCA9IHt9KXtcbiAgICBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIGBwaHg6JHtldmVudH1gLCB7ZGV0YWlsOiBwYXlsb2FkfSlcbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnRzKGV2ZW50cyl7XG4gICAgZXZlbnRzLmZvckVhY2goKFtldmVudCwgcGF5bG9hZF0pID0+IHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCwgcGF5bG9hZCkpXG4gIH1cblxuICB3aXRoUGFnZUxvYWRpbmcoaW5mbywgY2FsbGJhY2spe1xuICAgIERPTS5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIHtkZXRhaWw6IGluZm99KVxuICAgIGxldCBkb25lID0gKCkgPT4gRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpwYWdlLWxvYWRpbmctc3RvcFwiLCB7ZGV0YWlsOiBpbmZvfSlcbiAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhkb25lKSA6IGRvbmVcbiAgfVxuXG4gIHB1c2hIaXN0b3J5UGF0Y2goZSwgaHJlZiwgbGlua1N0YXRlLCB0YXJnZXRFbCl7XG4gICAgaWYoIXRoaXMuaXNDb25uZWN0ZWQoKSB8fCAhdGhpcy5tYWluLmlzTWFpbigpKXsgcmV0dXJuIEJyb3dzZXIucmVkaXJlY3QoaHJlZikgfVxuXG4gICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoe3RvOiBocmVmLCBraW5kOiBcInBhdGNoXCJ9LCBkb25lID0+IHtcbiAgICAgIHRoaXMubWFpbi5wdXNoTGlua1BhdGNoKGUsIGhyZWYsIHRhcmdldEVsLCBsaW5rUmVmID0+IHtcbiAgICAgICAgdGhpcy5oaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCBsaW5rUmVmKVxuICAgICAgICBkb25lKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGhpc3RvcnlQYXRjaChocmVmLCBsaW5rU3RhdGUsIGxpbmtSZWYgPSB0aGlzLnNldFBlbmRpbmdMaW5rKGhyZWYpKXtcbiAgICBpZighdGhpcy5jb21taXRQZW5kaW5nTGluayhsaW5rUmVmKSl7IHJldHVybiB9XG5cbiAgICAvLyBJbmNyZW1lbnQgcG9zaXRpb24gZm9yIG5ldyBzdGF0ZVxuICAgIHRoaXMuY3VycmVudEhpc3RvcnlQb3NpdGlvbisrXG4gICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9ISVNUT1JZX1BPU0lUSU9OLCB0aGlzLmN1cnJlbnRIaXN0b3J5UG9zaXRpb24udG9TdHJpbmcoKSlcblxuICAgIC8vIHN0b3JlIHRoZSB0eXBlIGZvciBiYWNrIG5hdmlnYXRpb25cbiAgICBCcm93c2VyLnVwZGF0ZUN1cnJlbnRTdGF0ZSgoc3RhdGUpID0+ICh7Li4uc3RhdGUsIGJhY2tUeXBlOiBcInBhdGNoXCJ9KSlcblxuICAgIEJyb3dzZXIucHVzaFN0YXRlKGxpbmtTdGF0ZSwge1xuICAgICAgdHlwZTogXCJwYXRjaFwiLFxuICAgICAgaWQ6IHRoaXMubWFpbi5pZCxcbiAgICAgIHBvc2l0aW9uOiB0aGlzLmN1cnJlbnRIaXN0b3J5UG9zaXRpb25cbiAgICB9LCBocmVmKVxuXG4gICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpuYXZpZ2F0ZVwiLCB7ZGV0YWlsOiB7cGF0Y2g6IHRydWUsIGhyZWYsIHBvcDogZmFsc2UsIGRpcmVjdGlvbjogXCJmb3J3YXJkXCJ9fSlcbiAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKVxuICB9XG5cbiAgaGlzdG9yeVJlZGlyZWN0KGUsIGhyZWYsIGxpbmtTdGF0ZSwgZmxhc2gsIHRhcmdldEVsKXtcbiAgICBpZih0YXJnZXRFbCAmJiBlLmlzVHJ1c3RlZCAmJiBlLnR5cGUgIT09IFwicG9wc3RhdGVcIil7IHRhcmdldEVsLmNsYXNzTGlzdC5hZGQoXCJwaHgtY2xpY2stbG9hZGluZ1wiKSB9XG4gICAgaWYoIXRoaXMuaXNDb25uZWN0ZWQoKSB8fCAhdGhpcy5tYWluLmlzTWFpbigpKXsgcmV0dXJuIEJyb3dzZXIucmVkaXJlY3QoaHJlZiwgZmxhc2gpIH1cblxuICAgIC8vIGNvbnZlcnQgdG8gZnVsbCBocmVmIGlmIG9ubHkgcGF0aCBwcmVmaXhcbiAgICBpZigvXlxcLyR8XlxcL1teXFwvXSsuKiQvLnRlc3QoaHJlZikpe1xuICAgICAgbGV0IHtwcm90b2NvbCwgaG9zdH0gPSB3aW5kb3cubG9jYXRpb25cbiAgICAgIGhyZWYgPSBgJHtwcm90b2NvbH0vLyR7aG9zdH0ke2hyZWZ9YFxuICAgIH1cbiAgICBsZXQgc2Nyb2xsID0gd2luZG93LnNjcm9sbFlcbiAgICB0aGlzLndpdGhQYWdlTG9hZGluZyh7dG86IGhyZWYsIGtpbmQ6IFwicmVkaXJlY3RcIn0sIGRvbmUgPT4ge1xuICAgICAgdGhpcy5yZXBsYWNlTWFpbihocmVmLCBmbGFzaCwgKGxpbmtSZWYpID0+IHtcbiAgICAgICAgaWYobGlua1JlZiA9PT0gdGhpcy5saW5rUmVmKXtcbiAgICAgICAgICAvLyBJbmNyZW1lbnQgcG9zaXRpb24gZm9yIG5ldyBzdGF0ZVxuICAgICAgICAgIHRoaXMuY3VycmVudEhpc3RvcnlQb3NpdGlvbisrXG4gICAgICAgICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9ISVNUT1JZX1BPU0lUSU9OLCB0aGlzLmN1cnJlbnRIaXN0b3J5UG9zaXRpb24udG9TdHJpbmcoKSlcblxuICAgICAgICAgIC8vIHN0b3JlIHRoZSB0eXBlIGZvciBiYWNrIG5hdmlnYXRpb25cbiAgICAgICAgICBCcm93c2VyLnVwZGF0ZUN1cnJlbnRTdGF0ZSgoc3RhdGUpID0+ICh7Li4uc3RhdGUsIGJhY2tUeXBlOiBcInJlZGlyZWN0XCJ9KSlcblxuICAgICAgICAgIEJyb3dzZXIucHVzaFN0YXRlKGxpbmtTdGF0ZSwge1xuICAgICAgICAgICAgdHlwZTogXCJyZWRpcmVjdFwiLFxuICAgICAgICAgICAgaWQ6IHRoaXMubWFpbi5pZCxcbiAgICAgICAgICAgIHNjcm9sbDogc2Nyb2xsLFxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMuY3VycmVudEhpc3RvcnlQb3NpdGlvblxuICAgICAgICAgIH0sIGhyZWYpXG5cbiAgICAgICAgICBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4Om5hdmlnYXRlXCIsIHtkZXRhaWw6IHtocmVmLCBwYXRjaDogZmFsc2UsIHBvcDogZmFsc2UsIGRpcmVjdGlvbjogXCJmb3J3YXJkXCJ9fSlcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKVxuICAgICAgICB9XG4gICAgICAgIGRvbmUoKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgcmVwbGFjZVJvb3RIaXN0b3J5KCl7XG4gICAgQnJvd3Nlci5wdXNoU3RhdGUoXCJyZXBsYWNlXCIsIHtcbiAgICAgIHJvb3Q6IHRydWUsXG4gICAgICB0eXBlOiBcInBhdGNoXCIsXG4gICAgICBpZDogdGhpcy5tYWluLmlkLFxuICAgICAgcG9zaXRpb246IHRoaXMuY3VycmVudEhpc3RvcnlQb3NpdGlvbiAvLyBQcmVzZXJ2ZSBjdXJyZW50IHBvc2l0aW9uXG4gICAgfSlcbiAgfVxuXG4gIHJlZ2lzdGVyTmV3TG9jYXRpb24obmV3TG9jYXRpb24pe1xuICAgIGxldCB7cGF0aG5hbWUsIHNlYXJjaH0gPSB0aGlzLmN1cnJlbnRMb2NhdGlvblxuICAgIGlmKHBhdGhuYW1lICsgc2VhcmNoID09PSBuZXdMb2NhdGlvbi5wYXRobmFtZSArIG5ld0xvY2F0aW9uLnNlYXJjaCl7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBjbG9uZShuZXdMb2NhdGlvbilcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgYmluZEZvcm1zKCl7XG4gICAgbGV0IGl0ZXJhdGlvbnMgPSAwXG4gICAgbGV0IGV4dGVybmFsRm9ybVN1Ym1pdHRlZCA9IGZhbHNlXG5cbiAgICAvLyBkaXNhYmxlIGZvcm1zIG9uIHN1Ym1pdCB0aGF0IHRyYWNrIHBoeC1jaGFuZ2UgYnV0IHBlcmZvcm0gZXh0ZXJuYWwgc3VibWl0XG4gICAgdGhpcy5vbihcInN1Ym1pdFwiLCBlID0+IHtcbiAgICAgIGxldCBwaHhTdWJtaXQgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwic3VibWl0XCIpKVxuICAgICAgbGV0IHBoeENoYW5nZSA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpXG4gICAgICBpZighZXh0ZXJuYWxGb3JtU3VibWl0dGVkICYmIHBoeENoYW5nZSAmJiAhcGh4U3VibWl0KXtcbiAgICAgICAgZXh0ZXJuYWxGb3JtU3VibWl0dGVkID0gdHJ1ZVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZS50YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICAgIHZpZXcuZGlzYWJsZUZvcm0oZS50YXJnZXQpXG4gICAgICAgICAgLy8gc2FmYXJpIG5lZWRzIG5leHQgdGlja1xuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgaWYoRE9NLmlzVW5sb2FkYWJsZUZvcm1TdWJtaXQoZSkpeyB0aGlzLnVubG9hZCgpIH1cbiAgICAgICAgICAgIGUudGFyZ2V0LnN1Ym1pdCgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5vbihcInN1Ym1pdFwiLCBlID0+IHtcbiAgICAgIGxldCBwaHhFdmVudCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJzdWJtaXRcIikpXG4gICAgICBpZighcGh4RXZlbnQpe1xuICAgICAgICBpZihET00uaXNVbmxvYWRhYmxlRm9ybVN1Ym1pdChlKSl7IHRoaXMudW5sb2FkKCkgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgZS50YXJnZXQuZGlzYWJsZWQgPSB0cnVlXG4gICAgICB0aGlzLndpdGhpbk93bmVycyhlLnRhcmdldCwgdmlldyA9PiB7XG4gICAgICAgIEpTLmV4ZWMoZSwgXCJzdWJtaXRcIiwgcGh4RXZlbnQsIHZpZXcsIGUudGFyZ2V0LCBbXCJwdXNoXCIsIHtzdWJtaXR0ZXI6IGUuc3VibWl0dGVyfV0pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBmb3IobGV0IHR5cGUgb2YgW1wiY2hhbmdlXCIsIFwiaW5wdXRcIl0pe1xuICAgICAgdGhpcy5vbih0eXBlLCBlID0+IHtcbiAgICAgICAgaWYoZSBpbnN0YW5jZW9mIEN1c3RvbUV2ZW50ICYmIGUudGFyZ2V0LmZvcm0gPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgLy8gdGhyb3cgb24gaW52YWxpZCBKUy5kaXNwYXRjaCB0YXJnZXQgYW5kIG5vb3AgaWYgQ3VzdG9tRXZlbnQgdHJpZ2dlcmVkIG91dHNpZGUgSlMuZGlzcGF0Y2hcbiAgICAgICAgICBpZihlLmRldGFpbCAmJiBlLmRldGFpbC5kaXNwYXRjaGVyKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzcGF0Y2hpbmcgYSBjdXN0b20gJHt0eXBlfSBldmVudCBpcyBvbmx5IHN1cHBvcnRlZCBvbiBpbnB1dCBlbGVtZW50cyBpbnNpZGUgYSBmb3JtYClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBoeENoYW5nZSA9IHRoaXMuYmluZGluZyhcImNoYW5nZVwiKVxuICAgICAgICBsZXQgaW5wdXQgPSBlLnRhcmdldFxuICAgICAgICAvLyBkbyBub3QgZmlyZSBwaHgtY2hhbmdlIGlmIHdlIGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgY29tcG9zaXRpb24gc2Vzc2lvblxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9pc0NvbXBvc2luZ1xuICAgICAgICAvLyBTYWZhcmkgaGFzIGlzc3VlcyBpZiB0aGUgaW5wdXQgaXMgdXBkYXRlZCB3aGlsZSBjb21wb3NpbmdcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L2lzc3Vlcy8zMzIyXG4gICAgICAgIGlmKGUuaXNDb21wb3Npbmcpe1xuICAgICAgICAgIGNvbnN0IGtleSA9IGBjb21wb3NpdGlvbi1saXN0ZW5lci0ke3R5cGV9YFxuICAgICAgICAgIGlmKCFET00ucHJpdmF0ZShpbnB1dCwga2V5KSl7XG4gICAgICAgICAgICBET00ucHV0UHJpdmF0ZShpbnB1dCwga2V5LCB0cnVlKVxuICAgICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbXBvc2l0aW9uZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgLy8gdHJpZ2dlciBhIG5ldyBpbnB1dC9jaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgICAgaW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQodHlwZSwge2J1YmJsZXM6IHRydWV9KSlcbiAgICAgICAgICAgICAgRE9NLmRlbGV0ZVByaXZhdGUoaW5wdXQsIGtleSlcbiAgICAgICAgICAgIH0sIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlucHV0RXZlbnQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUocGh4Q2hhbmdlKVxuICAgICAgICBsZXQgZm9ybUV2ZW50ID0gaW5wdXQuZm9ybSAmJiBpbnB1dC5mb3JtLmdldEF0dHJpYnV0ZShwaHhDaGFuZ2UpXG4gICAgICAgIGxldCBwaHhFdmVudCA9IGlucHV0RXZlbnQgfHwgZm9ybUV2ZW50XG4gICAgICAgIGlmKCFwaHhFdmVudCl7IHJldHVybiB9XG4gICAgICAgIGlmKGlucHV0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgaW5wdXQudmFsaWRpdHkgJiYgaW5wdXQudmFsaWRpdHkuYmFkSW5wdXQpeyByZXR1cm4gfVxuXG4gICAgICAgIGxldCBkaXNwYXRjaGVyID0gaW5wdXRFdmVudCA/IGlucHV0IDogaW5wdXQuZm9ybVxuICAgICAgICBsZXQgY3VycmVudEl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zXG4gICAgICAgIGl0ZXJhdGlvbnMrK1xuICAgICAgICBsZXQge2F0OiBhdCwgdHlwZTogbGFzdFR5cGV9ID0gRE9NLnByaXZhdGUoaW5wdXQsIFwicHJldi1pdGVyYXRpb25cIikgfHwge31cbiAgICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIGFsd2F5cyBmaXJlIGF0IGxlYXN0IG9uZSBcImlucHV0XCIgZXZlbnQgYmVmb3JlIGV2ZXJ5IFwiY2hhbmdlXCJcbiAgICAgICAgLy8gSWdub3JlIFwiY2hhbmdlXCIgZXZlbnRzLCB1bmxlc3MgdGhlcmUgd2FzIG5vIHByaW9yIFwiaW5wdXRcIiBldmVudC5cbiAgICAgICAgLy8gVGhpcyBjb3VsZCBoYXBwZW4gaWYgdXNlciBjb2RlIHRyaWdnZXJzIGEgXCJjaGFuZ2VcIiBldmVudCwgb3IgaWYgdGhlIGJyb3dzZXIgaXMgbm9uLWNvbmZvcm1pbmcuXG4gICAgICAgIGlmKGF0ID09PSBjdXJyZW50SXRlcmF0aW9ucyAtIDEgJiYgdHlwZSA9PT0gXCJjaGFuZ2VcIiAmJiBsYXN0VHlwZSA9PT0gXCJpbnB1dFwiKXsgcmV0dXJuIH1cblxuICAgICAgICBET00ucHV0UHJpdmF0ZShpbnB1dCwgXCJwcmV2LWl0ZXJhdGlvblwiLCB7YXQ6IGN1cnJlbnRJdGVyYXRpb25zLCB0eXBlOiB0eXBlfSlcblxuICAgICAgICB0aGlzLmRlYm91bmNlKGlucHV0LCBlLCB0eXBlLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZGlzcGF0Y2hlciwgdmlldyA9PiB7XG4gICAgICAgICAgICBET00ucHV0UHJpdmF0ZShpbnB1dCwgUEhYX0hBU19GT0NVU0VELCB0cnVlKVxuICAgICAgICAgICAgSlMuZXhlYyhlLCBcImNoYW5nZVwiLCBwaHhFdmVudCwgdmlldywgaW5wdXQsIFtcInB1c2hcIiwge190YXJnZXQ6IGUudGFyZ2V0Lm5hbWUsIGRpc3BhdGNoZXI6IGRpc3BhdGNoZXJ9XSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy5vbihcInJlc2V0XCIsIChlKSA9PiB7XG4gICAgICBsZXQgZm9ybSA9IGUudGFyZ2V0XG4gICAgICBET00ucmVzZXRGb3JtKGZvcm0pXG4gICAgICBsZXQgaW5wdXQgPSBBcnJheS5mcm9tKGZvcm0uZWxlbWVudHMpLmZpbmQoZWwgPT4gZWwudHlwZSA9PT0gXCJyZXNldFwiKVxuICAgICAgaWYoaW5wdXQpe1xuICAgICAgICAvLyB3YWl0IHVudGlsIG5leHQgdGljayB0byBnZXQgdXBkYXRlZCBpbnB1dCB2YWx1ZVxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIsIHtidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiBmYWxzZX0pKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBkZWJvdW5jZShlbCwgZXZlbnQsIGV2ZW50VHlwZSwgY2FsbGJhY2spe1xuICAgIGlmKGV2ZW50VHlwZSA9PT0gXCJibHVyXCIgfHwgZXZlbnRUeXBlID09PSBcImZvY3Vzb3V0XCIpeyByZXR1cm4gY2FsbGJhY2soKSB9XG5cbiAgICBsZXQgcGh4RGVib3VuY2UgPSB0aGlzLmJpbmRpbmcoUEhYX0RFQk9VTkNFKVxuICAgIGxldCBwaHhUaHJvdHRsZSA9IHRoaXMuYmluZGluZyhQSFhfVEhST1RUTEUpXG4gICAgbGV0IGRlZmF1bHREZWJvdW5jZSA9IHRoaXMuZGVmYXVsdHMuZGVib3VuY2UudG9TdHJpbmcoKVxuICAgIGxldCBkZWZhdWx0VGhyb3R0bGUgPSB0aGlzLmRlZmF1bHRzLnRocm90dGxlLnRvU3RyaW5nKClcblxuICAgIHRoaXMud2l0aGluT3duZXJzKGVsLCB2aWV3ID0+IHtcbiAgICAgIGxldCBhc3luY0ZpbHRlciA9ICgpID0+ICF2aWV3LmlzRGVzdHJveWVkKCkgJiYgZG9jdW1lbnQuYm9keS5jb250YWlucyhlbClcbiAgICAgIERPTS5kZWJvdW5jZShlbCwgZXZlbnQsIHBoeERlYm91bmNlLCBkZWZhdWx0RGVib3VuY2UsIHBoeFRocm90dGxlLCBkZWZhdWx0VGhyb3R0bGUsIGFzeW5jRmlsdGVyLCAoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHNpbGVuY2VFdmVudHMoY2FsbGJhY2spe1xuICAgIHRoaXMuc2lsZW5jZWQgPSB0cnVlXG4gICAgY2FsbGJhY2soKVxuICAgIHRoaXMuc2lsZW5jZWQgPSBmYWxzZVxuICB9XG5cbiAgb24oZXZlbnQsIGNhbGxiYWNrKXtcbiAgICB0aGlzLmJvdW5kRXZlbnROYW1lcy5hZGQoZXZlbnQpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGUgPT4ge1xuICAgICAgaWYoIXRoaXMuc2lsZW5jZWQpeyBjYWxsYmFjayhlKSB9XG4gICAgfSlcbiAgfVxuXG4gIGpzUXVlcnlTZWxlY3RvckFsbChzb3VyY2VFbCwgcXVlcnksIGRlZmF1bHRRdWVyeSl7XG4gICAgbGV0IGFsbCA9IHRoaXMuZG9tQ2FsbGJhY2tzLmpzUXVlcnlTZWxlY3RvckFsbFxuICAgIHJldHVybiBhbGwgPyBhbGwoc291cmNlRWwsIHF1ZXJ5LCBkZWZhdWx0UXVlcnkpIDogZGVmYXVsdFF1ZXJ5KClcbiAgfVxufVxuXG5jbGFzcyBUcmFuc2l0aW9uU2V0IHtcbiAgY29uc3RydWN0b3IoKXtcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gbmV3IFNldCgpXG4gICAgdGhpcy5wZW5kaW5nT3BzID0gW11cbiAgfVxuXG4gIHJlc2V0KCl7XG4gICAgdGhpcy50cmFuc2l0aW9ucy5mb3JFYWNoKHRpbWVyID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcilcbiAgICAgIHRoaXMudHJhbnNpdGlvbnMuZGVsZXRlKHRpbWVyKVxuICAgIH0pXG4gICAgdGhpcy5mbHVzaFBlbmRpbmdPcHMoKVxuICB9XG5cbiAgYWZ0ZXIoY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuc2l6ZSgpID09PSAwKXtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoUGVuZGluZ09wKGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIGFkZFRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKXtcbiAgICBvblN0YXJ0KClcbiAgICBsZXQgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbnMuZGVsZXRlKHRpbWVyKVxuICAgICAgb25Eb25lKClcbiAgICAgIHRoaXMuZmx1c2hQZW5kaW5nT3BzKClcbiAgICB9LCB0aW1lKVxuICAgIHRoaXMudHJhbnNpdGlvbnMuYWRkKHRpbWVyKVxuICB9XG5cbiAgcHVzaFBlbmRpbmdPcChvcCl7IHRoaXMucGVuZGluZ09wcy5wdXNoKG9wKSB9XG5cbiAgc2l6ZSgpeyByZXR1cm4gdGhpcy50cmFuc2l0aW9ucy5zaXplIH1cblxuICBmbHVzaFBlbmRpbmdPcHMoKXtcbiAgICBpZih0aGlzLnNpemUoKSA+IDApeyByZXR1cm4gfVxuICAgIGxldCBvcCA9IHRoaXMucGVuZGluZ09wcy5zaGlmdCgpXG4gICAgaWYob3Ape1xuICAgICAgb3AoKVxuICAgICAgdGhpcy5mbHVzaFBlbmRpbmdPcHMoKVxuICAgIH1cbiAgfVxufVxuIiwgIi8qXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuUGhvZW5peCBMaXZlVmlldyBKYXZhU2NyaXB0IENsaWVudFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuU2VlIHRoZSBoZXhkb2NzIGF0IGBodHRwczovL2hleGRvY3MucG0vcGhvZW5peF9saXZlX3ZpZXdgIGZvciBkb2N1bWVudGF0aW9uLlxuXG4qL1xuXG5pbXBvcnQgTGl2ZVNvY2tldCwge2lzVXNlZElucHV0fSBmcm9tIFwiLi9saXZlX3NvY2tldFwiXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgVmlld0hvb2sgZnJvbSBcIi4vdmlld19ob29rXCJcbmltcG9ydCBWaWV3IGZyb20gXCIuL3ZpZXdcIlxuXG4vKiogQ3JlYXRlcyBhIFZpZXdIb29rIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCBhbmQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gVGhlIGVsZW1lbnQgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGhvb2suXG4gKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrc10gLSBUaGUgbGlzdCBvZiBob29rIGNhbGxiYWNrcywgc3VjaCBhcyBtb3VudGVkLFxuICogICB1cGRhdGVkLCBkZXN0cm95ZWQsIGV0Yy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGNsYXNzIE15Q29tcG9uZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICogICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICogICAgIGxldCBvbkxpdmVWaWV3TW91bnRlZCA9ICgpID0+IHRoaXMuaG9vay5wdXNoRXZlbnQoLi4uKSlcbiAqICAgICB0aGlzLmhvb2sgPSBjcmVhdGVIb29rKHRoaXMsIHttb3VudGVkOiBvbkxpdmVWaWV3TW91bnRlZH0pXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiAqTm90ZSo6IGBjcmVhdGVIb29rYCBtdXN0IGJlIGNhbGxlZCBmcm9tIHRoZSBgY29ubmVjdGVkQ2FsbGJhY2tgIGxpZmVjeWNsZVxuICogd2hpY2ggaXMgdHJpZ2dlcmVkIGFmdGVyIHRoZSBlbGVtZW50IGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBET00uIElmIHlvdSB0cnlcbiAqIHRvIGNhbGwgYGNyZWF0ZUhvb2tgIGZyb20gdGhlIGNvbnN0cnVjdG9yLCBhbiBlcnJvciB3aWxsIGJlIGxvZ2dlZC5cbiAqXG4gKiBAcmV0dXJucyB7Vmlld0hvb2t9IFJldHVybnMgdGhlIFZpZXdIb29rIGluc3RhbmNlIGZvciB0aGUgY3VzdG9tIGVsZW1lbnQuXG4gKi9cbmxldCBjcmVhdGVIb29rID0gKGVsLCBjYWxsYmFja3MgPSB7fSkgPT4ge1xuICBsZXQgZXhpc3RpbmdIb29rID0gRE9NLmdldEN1c3RvbUVsSG9vayhlbClcbiAgaWYoZXhpc3RpbmdIb29rKXsgcmV0dXJuIGV4aXN0aW5nSG9vayB9XG5cbiAgbGV0IGhvb2sgPSBuZXcgVmlld0hvb2soVmlldy5jbG9zZXN0VmlldyhlbCksIGVsLCBjYWxsYmFja3MpXG4gIERPTS5wdXRDdXN0b21FbEhvb2soZWwsIGhvb2spXG4gIHJldHVybiBob29rXG59XG5cbmV4cG9ydCB7XG4gIExpdmVTb2NrZXQsXG4gIGlzVXNlZElucHV0LFxuICBjcmVhdGVIb29rXG59XG4iLCAiLy8gSWYgeW91IHdhbnQgdG8gdXNlIFBob2VuaXggY2hhbm5lbHMsIHJ1biBgbWl4IGhlbHAgcGh4Lmdlbi5jaGFubmVsYFxuLy8gdG8gZ2V0IHN0YXJ0ZWQgYW5kIHRoZW4gdW5jb21tZW50IHRoZSBsaW5lIGJlbG93LlxuLy8gaW1wb3J0IFwiLi91c2VyX3NvY2tldC5qc1wiXG5cbi8vIFlvdSBjYW4gaW5jbHVkZSBkZXBlbmRlbmNpZXMgaW4gdHdvIHdheXMuXG4vL1xuLy8gVGhlIHNpbXBsZXN0IG9wdGlvbiBpcyB0byBwdXQgdGhlbSBpbiBhc3NldHMvdmVuZG9yIGFuZFxuLy8gaW1wb3J0IHRoZW0gdXNpbmcgcmVsYXRpdmUgcGF0aHM6XG4vL1xuLy8gICAgIGltcG9ydCBcIi4uL3ZlbmRvci9zb21lLXBhY2thZ2UuanNcIlxuLy9cbi8vIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gYG5wbSBpbnN0YWxsIHNvbWUtcGFja2FnZSAtLXByZWZpeCBhc3NldHNgIGFuZCBpbXBvcnRcbi8vIHRoZW0gdXNpbmcgYSBwYXRoIHN0YXJ0aW5nIHdpdGggdGhlIHBhY2thZ2UgbmFtZTpcbi8vXG4vLyAgICAgaW1wb3J0IFwic29tZS1wYWNrYWdlXCJcbi8vXG5cbi8vIEluY2x1ZGUgcGhvZW5peF9odG1sIHRvIGhhbmRsZSBtZXRob2Q9UFVUL0RFTEVURSBpbiBmb3JtcyBhbmQgYnV0dG9ucy5cbmltcG9ydCBcInBob2VuaXhfaHRtbFwiXG4vLyBFc3RhYmxpc2ggUGhvZW5peCBTb2NrZXQgYW5kIExpdmVWaWV3IGNvbmZpZ3VyYXRpb24uXG5pbXBvcnQgeyBTb2NrZXQgfSBmcm9tIFwicGhvZW5peFwiXG5pbXBvcnQgeyBMaXZlU29ja2V0IH0gZnJvbSBcInBob2VuaXhfbGl2ZV92aWV3XCJcbmltcG9ydCB0b3BiYXIgZnJvbSBcIi4uL3ZlbmRvci90b3BiYXJcIlxuaW1wb3J0IENoYXJ0IGZyb20gXCJjaGFydC5qcy9hdXRvXCJcbmltcG9ydCBEcmFnSG9vayBmcm9tIFwiLi9kcmFnX2hvb2tcIjtcbmltcG9ydCBcImZsb3diaXRlXCI7XG5cbi8vIC8vIGFkZHMgb3IgcmVtb3ZlcyB0aGUgJ2RhcmsnIGNsYXNzIGZyb20gPGh0bWw+IGJhc2VkIG9uIHRoZSBgdGhlbWVgIGluIGxvY2FsU3RvcmFnZSxcbi8vIC8vIGlmIGdpdmVuLCBvciBkZWZhdWx0IHByZWZlcmVuY2Ugb3RoZXJ3aXNlLlxuLy8gZnVuY3Rpb24gc2V0X3RoZW1lKCkge1xuLy8gICBpZiAobG9jYWxTdG9yYWdlLnRoZW1lID09PSAnZGFyaycgfHwgKCEoJ3RoZW1lJyBpbiBsb2NhbFN0b3JhZ2UpICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJykubWF0Y2hlcykpIHtcbi8vICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZGFyaycpXG4vLyAgIH0gZWxzZSB7XG4vLyAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2RhcmsnKVxuLy8gICB9XG4vLyB9XG5cbi8vIC8vIEV4cG9zZXMgZnVuY3Rpb24gdG8gdG9nZ2xlIGRhcmsgbW9kZSBvbiBhbmQgb2ZmLlxuLy8gd2luZG93LnRvZ2dsZURhcmtNb2RlID0gKCkgPT4ge1xuLy8gICBpZiAobG9jYWxTdG9yYWdlLnRoZW1lID09PSAnZGFyaycgfHwgKCEoJ3RoZW1lJyBpbiBsb2NhbFN0b3JhZ2UpICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJykubWF0Y2hlcykpIHtcbi8vICAgICBsb2NhbFN0b3JhZ2UudGhlbWUgPSAnbGlnaHQnXG4vLyAgIH0gZWxzZSB7XG4vLyAgICAgbG9jYWxTdG9yYWdlLnRoZW1lID0gJ2RhcmsnXG4vLyAgIH1cbi8vICAgc2V0X3RoZW1lKClcbi8vIH1cblxuLy8gLy8gc2V0IHRoZW1lIG9uIHBhZ2UgbG9hZFxuLy8gc2V0X3RoZW1lKClcblxuLy8gRnVuY3Rpb24gdG8gdG9nZ2xlIGRhcmsgbW9kZVxud2luZG93LnRvZ2dsZURhcmtNb2RlID0gKCkgPT4ge1xuICBsZXQgY3VycmVudFRoZW1lID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0aGVtZVwiKTtcblxuICAvLyBEZXRlcm1pbmUgbmV3IHRoZW1lXG4gIGxldCBuZXdUaGVtZSA9IGN1cnJlbnRUaGVtZSA9PT0gXCJkYXJrXCIgPyBcImxpZ2h0XCIgOiBcImRhcmtcIjtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ0aGVtZVwiLCBuZXdUaGVtZSk7XG5cbiAgLy8gQXBwbHkgdGhlIHRoZW1lIGltbWVkaWF0ZWx5XG4gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwiZGFya1wiLCBuZXdUaGVtZSA9PT0gXCJkYXJrXCIpO1xuXG4gIC8vIERpc3BhdGNoIGV2ZW50IHRvIHVwZGF0ZSB0aGUgY2hhcnQgdGhlbWVcbiAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ2NsYXNzQ2hhbmdlJyk7XG4gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn07XG5cblxuLy8gRW5zdXJlIHRoZSBjb3JyZWN0IHRoZW1lIGlzIGFwcGxpZWQgb24gcGFnZSBsb2FkXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gIGxldCBzYXZlZFRoZW1lID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0aGVtZVwiKSB8fCBcImxpZ2h0XCI7XG4gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwiZGFya1wiLCBzYXZlZFRoZW1lID09PSBcImRhcmtcIik7XG59KTtcblxubGV0IGxpdmVTb2NrZXRQYXRoID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gXCIvY3NjaTM3OS0yNXMtaC9saXZlXCIgOiBcIi9saXZlXCI7XG5cbmxldCBjc3JmVG9rZW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibWV0YVtuYW1lPSdjc3JmLXRva2VuJ11cIikuZ2V0QXR0cmlidXRlKFwiY29udGVudFwiKVxuXG4vLyBjcmVhdGUgaG9va3MgZm9yIGxvZ291dFxubGV0IEhvb2tzID0ge307IC8vIHRoaXMgbWF5IGFscmVhZHkgYmUgaGVyZVxuXG5Ib29rcy5Mb2dvdXRCdXR0b24gPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5oYW5kbGVFdmVudChcImxvZ291dFwiLCAoKSA9PiB7XG4gICAgICBsZXQgYnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsb2dvdXQtYnV0dG9uXCIpO1xuICAgICAgaWYgKGJ0bikgYnRuLmNsaWNrKCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbkhvb2tzLkF1dG9TY3JvbGwgPSB7XG4gIHVwZGF0ZWQoKSB7XG4gICAgd2luZG93LnNjcm9sbFRvKHsgdG9wOiBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCwgYmVoYXZpb3I6IFwic21vb3RoXCIgfSk7XG4gIH1cbn07XG5cbi8vIEhvb2tzLkNoYXJ0ID0ge1xuLy8gICBtb3VudGVkKCkge1xuLy8gICAgIHRoaXMuZWwuX2NoYXJ0ID0gbmV3IENoYXJ0KHRoaXMuZWwsIEpTT04ucGFyc2UodGhpcy5lbC5kYXRhc2V0LmNvbmZpZykpO1xuLy8gICAgIC8vIGNhbGwgdXBkYXRlIHRoZW0gbWV0aG9kXG4vLyAgIH0sXG5cbi8vICAgLy8gdXBkYXRlIHRoZW1lIG1ldGhvZCBpZiBkYXJrIG1vZGVcblxuLy8gICB1cGRhdGVkKCkge1xuLy8gICAgIC8vIC5kZXN0cm95IGZpcnN0IGNoYXJ0XG4vLyAgICAgY29uc3QgbmV3X2NvbmZpZyA9IEpTT04ucGFyc2UodGhpcy5lbC5kYXRhc2V0LmNvbmZpZylcbi8vICAgICB0aGlzLmVsLl9jaGFydC5kYXRhID0gbmV3X2NvbmZpZy5kYXRhXG4vLyAgICAgdGhpcy5lbC5fY2hhcnQudXBkYXRlKClcbi8vICAgfVxuLy8gfVxuXG5Ib29rcy5DaGFydCA9IHtcbiAgbW91bnRlZCgpIHtcbiAgICAvLyBJbml0aWFsaXplIGNoYXJ0XG4gICAgdGhpcy5lbC5fY2hhcnQgPSBuZXcgQ2hhcnQodGhpcy5lbCwgSlNPTi5wYXJzZSh0aGlzLmVsLmRhdGFzZXQuY29uZmlnKSk7XG4gICAgdGhpcy51cGRhdGVUaGVtZSgpO1xuXG4gICAgLy8gTGlzdGVuIGZvciB0aGVtZSBjaGFuZ2VzIGJhc2VkIG9uIHRoZSBjbGFzcyBcImRhcmtcIiBpbiA8aHRtbD5cbiAgICB0aGlzLnRoZW1lTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZVRoZW1lKCk7XG4gICAgfTtcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xhc3NDaGFuZ2UnLCB0aGlzLnRoZW1lTGlzdGVuZXIpO1xuICB9LFxuXG4gIHVwZGF0ZWQoKSB7XG4gICAgLy8gRGVidWdnaW5nIGxvZ3MgdG8gdHJhY2sgaWYgdXBkYXRlZCBpcyBiZWluZyB0cmlnZ2VyZWRcbiAgICBjb25zb2xlLmxvZygnQ2hhcnQgdXBkYXRlZCAtIGNoZWNraW5nIGRhdGFzZXQuY29uZmlnOicsIHRoaXMuZWwuZGF0YXNldC5jb25maWcpO1xuXG4gICAgY29uc3QgbmV3Q29uZmlnID0gSlNPTi5wYXJzZSh0aGlzLmVsLmRhdGFzZXQuY29uZmlnKTtcblxuICAgIC8vIERlYnVnZ2luZyBsb2dzIHRvIGVuc3VyZSBuZXdDb25maWcgaXMgY29ycmVjdFxuICAgIGNvbnNvbGUubG9nKCdOZXcgY2hhcnQgY29uZmlndXJhdGlvbjonLCBuZXdDb25maWcpO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNoYXJ0IGFscmVhZHkgZXhpc3RzXG4gICAgaWYgKHRoaXMuZWwuX2NoYXJ0KSB7XG4gICAgICAvLyBMb2cgdGhhdCB3ZSdyZSBkZXN0cm95aW5nIHRoZSBvbGQgY2hhcnRcbiAgICAgIGNvbnNvbGUubG9nKCdEZXN0cm95aW5nIG9sZCBjaGFydC4uLicpO1xuICAgICAgdGhpcy5lbC5fY2hhcnQuZGVzdHJveSgpOyAvLyBEZXN0cm95IG9sZCBjaGFydCBpbnN0YW5jZVxuICAgIH1cblxuICAgIC8vIFJlaW5pdGlhbGl6ZSB0aGUgY2hhcnQgd2l0aCB0aGUgbmV3IGNvbmZpZ1xuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBuZXcgY2hhcnQuLi4nKTtcbiAgICB0aGlzLmVsLl9jaGFydCA9IG5ldyBDaGFydCh0aGlzLmVsLCBuZXdDb25maWcpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSB0aGVtZSBmb3IgdGhlIG5ldyBjaGFydFxuICAgIHRoaXMudXBkYXRlVGhlbWUoKTtcbiAgfSxcblxuICB1cGRhdGVUaGVtZSgpIHtcbiAgICAvLyBDaGVjayBmb3IgZGFyayBtb2RlXG4gICAgY29uc3QgaXNEYXJrTW9kZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJkYXJrXCIpO1xuICAgIGNvbnN0IGNvbG9yID0gaXNEYXJrTW9kZSA/IFwiI2ZmZlwiIDogXCIjMDAwXCI7XG4gICAgY29uc3QgZ3JpZENvbG9yID0gaXNEYXJrTW9kZSA/IFwiIzQ0NFwiIDogXCIjY2NjXCI7XG5cbiAgICAvLyBVcGRhdGUgY2hhcnQgdGV4dCBjb2xvcnMgYmFzZWQgb24gdGhlbWVcbiAgICB0aGlzLmVsLl9jaGFydC5vcHRpb25zLnBsdWdpbnMubGVnZW5kLmxhYmVscy5jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuZWwuX2NoYXJ0Lm9wdGlvbnMucGx1Z2lucy50aXRsZS5jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuZWwuX2NoYXJ0Lm9wdGlvbnMuc2NhbGVzLngudGl0bGUuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmVsLl9jaGFydC5vcHRpb25zLnNjYWxlcy54LnRpY2tzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5lbC5fY2hhcnQub3B0aW9ucy5zY2FsZXMueC5ncmlkLmNvbG9yID0gZ3JpZENvbG9yO1xuICAgIHRoaXMuZWwuX2NoYXJ0Lm9wdGlvbnMuc2NhbGVzLnkudGl0bGUuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmVsLl9jaGFydC5vcHRpb25zLnNjYWxlcy55LnRpY2tzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5lbC5fY2hhcnQub3B0aW9ucy5zY2FsZXMueS5ncmlkLmNvbG9yID0gZ3JpZENvbG9yO1xuXG4gICAgLy8gQXBwbHkgdGhlIGNoYW5nZXMgdG8gdGhlIGNoYXJ0XG4gICAgdGhpcy5lbC5fY2hhcnQudXBkYXRlKCk7XG4gIH0sXG5cbiAgZGVzdHJveWVkKCkge1xuICAgIC8vIENsZWFuIHVwIHRoZSBldmVudCBsaXN0ZW5lciB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsYXNzQ2hhbmdlJywgdGhpcy50aGVtZUxpc3RlbmVyKTtcbiAgfVxufTtcblxuLy8gQ2hlYXBTaGFyayBjaGFydCBob29rIChmb3IgdGhlIGxpbmUgY2hhcnQgc2hvd2luZyBnYW1lIHByaWNlcylcbkhvb2tzLkNoYXJ0RGVhbHMgPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5lbC5fY2hhcnQgPSBuZXcgQ2hhcnQodGhpcy5lbCwgSlNPTi5wYXJzZSh0aGlzLmVsLmRhdGFzZXQuY29uZmlnKSk7XG4gICAgdGhpcy51cGRhdGVUaGVtZSgpO1xuXG4gICAgLy8gTGlzdGVuIGZvciB0aGVtZSBjaGFuZ2VzIGJhc2VkIG9uIHRoZSBjbGFzcyBcImRhcmtcIiBpbiA8aHRtbD5cbiAgICB0aGlzLnRoZW1lTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZVRoZW1lKCk7XG4gICAgfTtcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xhc3NDaGFuZ2UnLCB0aGlzLnRoZW1lTGlzdGVuZXIpO1xuICB9LFxuXG4gIHVwZGF0ZWQoKSB7XG4gICAgY29uc3QgbmV3Q29uZmlnID0gSlNPTi5wYXJzZSh0aGlzLmVsLmRhdGFzZXQuY29uZmlnKTtcbiAgICBpZiAodGhpcy5lbC5fY2hhcnQpIHtcbiAgICAgIHRoaXMuZWwuX2NoYXJ0LmRlc3Ryb3koKTsgLy8gRGVzdHJveSBvbGQgY2hhcnQgaW5zdGFuY2VcbiAgICB9XG5cbiAgICB0aGlzLmVsLl9jaGFydCA9IG5ldyBDaGFydCh0aGlzLmVsLCBuZXdDb25maWcpO1xuICAgIHRoaXMudXBkYXRlVGhlbWUoKTtcbiAgfSxcblxuICB1cGRhdGVUaGVtZSgpIHtcbiAgICBjb25zdCBpc0RhcmtNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImRhcmtcIik7XG4gICAgY29uc3QgY29sb3IgPSBpc0RhcmtNb2RlID8gXCIjZmZmXCIgOiBcIiMwMDBcIjtcbiAgICBjb25zdCBncmlkQ29sb3IgPSBpc0RhcmtNb2RlID8gXCIjNDQ0XCIgOiBcIiNjY2NcIjtcblxuICAgIC8vIFVwZGF0ZSBjaGFydCB0ZXh0IGNvbG9ycyBiYXNlZCBvbiB0aGVtZVxuICAgIHRoaXMuZWwuX2NoYXJ0Lm9wdGlvbnMucGx1Z2lucy5sZWdlbmQubGFiZWxzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5lbC5fY2hhcnQub3B0aW9ucy5wbHVnaW5zLnRpdGxlLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5lbC5fY2hhcnQub3B0aW9ucy5zY2FsZXMueC50aXRsZS5jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuZWwuX2NoYXJ0Lm9wdGlvbnMuc2NhbGVzLngudGlja3MuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmVsLl9jaGFydC5vcHRpb25zLnNjYWxlcy54LmdyaWQuY29sb3IgPSBncmlkQ29sb3I7XG4gICAgdGhpcy5lbC5fY2hhcnQub3B0aW9ucy5zY2FsZXMueS50aXRsZS5jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuZWwuX2NoYXJ0Lm9wdGlvbnMuc2NhbGVzLnkudGlja3MuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmVsLl9jaGFydC5vcHRpb25zLnNjYWxlcy55LmdyaWQuY29sb3IgPSBncmlkQ29sb3I7XG5cbiAgICB0aGlzLmVsLl9jaGFydC51cGRhdGUoKTtcbiAgfSxcblxuICBkZXN0cm95ZWQoKSB7XG4gICAgLy8gQ2xlYW4gdXAgdGhlIGV2ZW50IGxpc3RlbmVyIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWRcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xhc3NDaGFuZ2UnLCB0aGlzLnRoZW1lTGlzdGVuZXIpO1xuICB9XG59XG5cblxuXG4vLyBmaW5hbCBwcm9qZWN0OiB0diAvIG1vdmllIHJhdGVyXG5Ib29rcy5SYXRpbmdWYWxpZGF0b3IgPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKGUpID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuXG4gICAgICAvLyBNYXRjaCBhIG51bWJlciB3aXRoIDEgZGVjaW1hbCBwb2ludCBvciBhbiBpbnRlZ2VyIChlLmcuLCAyLjUsIDIpXG4gICAgICBsZXQgcmVnZXggPSAvXig/OlswLTldfDEwKSg/OlxcLlxcZHswLDF9KT8kLztcblxuICAgICAgLy8gRW5zdXJlIHRoZSB2YWx1ZSBpcyB3aXRoaW4gdGhlIHJhbmdlIG9mIDAgdG8gMTAsIGluY2x1ZGluZyBkZWNpbWFsc1xuICAgICAgaWYgKCFyZWdleC50ZXN0KHZhbHVlKSB8fCBwYXJzZUZsb2F0KHZhbHVlKSA+IDEwIHx8IHBhcnNlRmxvYXQodmFsdWUpIDwgMCkge1xuICAgICAgICBlLnRhcmdldC52YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIC0xKTsgLy8gUmVtb3ZlIGxhc3QgY2hhcmFjdGVyXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbkhvb2tzLlJhdGluZyA9IHtcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJyYXRpbmctY2hhbmdlZFwiLCBlID0+IHtcbiAgICAgIGxldCBuZXdSYXRpbmcgPSBlLmRldGFpbC5yYXRpbmc7XG4gICAgICB0aGlzLnB1c2hFdmVudChcInJhdGluZ191cGRhdGVkXCIsIHsgcmF0aW5nOiBuZXdSYXRpbmcgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuXG5Ib29rcy5EcmFnSG9vayA9IERyYWdIb29rXG5cblxuXG5cbkhvb2tzLkRvd25sb2FkZXIgPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5oYW5kbGVFdmVudChcImRvd25sb2FkX21lZGlhX2JhY2t1cFwiLCAoeyBmaWxlbmFtZSwgY29udGVudCB9KSA9PiB7XG4gICAgICAvLyBjcmVhdGUgYSBibG9iLCB0cmlnZ2VyIGEgZG93bmxvYWRcbiAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbY29udGVudF0sIHsgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSlcbiAgICAgIGNvbnN0IHVybCAgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICBjb25zdCBhICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIilcbiAgICAgIGEuaHJlZiAgICAgPSB1cmxcbiAgICAgIGEuZG93bmxvYWQgPSBmaWxlbmFtZVxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKVxuICAgICAgYS5jbGljaygpXG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGEpXG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybClcbiAgICB9KVxuICB9XG59XG5cblxuXG4vLyBhZGQgaG9vayB0byB5b3VyIExpdmVWaWV3IGNvbm5lY3QgKHRoaXMgbWF5IGFscmVhZHkgYmUgaGVyZSk6XG5sZXQgbGl2ZVNvY2tldCA9IG5ldyBMaXZlU29ja2V0KGxpdmVTb2NrZXRQYXRoLCBTb2NrZXQsIHtcbiAgLy8gbG9uZ1BvbGxGYWxsYmFja01zOiAyNTAwLFxuICBwYXJhbXM6IHsgX2NzcmZfdG9rZW46IGNzcmZUb2tlbiB9LFxuICBob29rczogSG9va3Ncbn0pXG5cblxuLy8gYWxsb3cgbW9kYWxzIHRvIGJlIG9wZW5lZCBmcm9tIHNlcnZlclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6b3Blbi1tb2RhbFwiLCBlID0+IHtcbiAgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlLmRldGFpbC5pZClcbiAgbGl2ZVNvY2tldC5leGVjSlMoZWwsIGVsLmdldEF0dHJpYnV0ZShcImRhdGEtb3BlblwiKSlcbn0pXG5cbi8vIGFsbG93IG1vZGFscyB0byBiZSBjbG9zZWQgZnJvbSBzZXJ2ZXJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OmNsb3NlLW1vZGFsXCIsIGUgPT4ge1xuICBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUuZGV0YWlsLmlkKVxuICBsaXZlU29ja2V0LmV4ZWNKUyhlbCwgZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1jbG9zZVwiKSlcbn0pXG5cbi8vIFNob3cgcHJvZ3Jlc3MgYmFyIG9uIGxpdmUgbmF2aWdhdGlvbiBhbmQgZm9ybSBzdWJtaXRzXG50b3BiYXIuY29uZmlnKHsgYmFyQ29sb3JzOiB7IDA6IFwiIzI5ZFwiIH0sIHNoYWRvd0NvbG9yOiBcInJnYmEoMCwgMCwgMCwgLjMpXCIgfSlcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCBfaW5mbyA9PiB0b3BiYXIuc2hvdygzMDApKVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6cGFnZS1sb2FkaW5nLXN0b3BcIiwgX2luZm8gPT4gdG9wYmFyLmhpZGUoKSlcblxuLy8gY29ubmVjdCBpZiB0aGVyZSBhcmUgYW55IExpdmVWaWV3cyBvbiB0aGUgcGFnZVxubGl2ZVNvY2tldC5jb25uZWN0KClcblxuLy8gZXhwb3NlIGxpdmVTb2NrZXQgb24gd2luZG93IGZvciB3ZWIgY29uc29sZSBkZWJ1ZyBsb2dzIGFuZCBsYXRlbmN5IHNpbXVsYXRpb246XG4vLyA+PiBsaXZlU29ja2V0LmVuYWJsZURlYnVnKClcbi8vID4+IGxpdmVTb2NrZXQuZW5hYmxlTGF0ZW5jeVNpbSgxMDAwKSAgLy8gZW5hYmxlZCBmb3IgZHVyYXRpb24gb2YgYnJvd3NlciBzZXNzaW9uXG4vLyA+PiBsaXZlU29ja2V0LmRpc2FibGVMYXRlbmN5U2ltKClcbndpbmRvdy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldFxuXG4iLCAiLyohXG4gKiBAa3Vya2xlL2NvbG9yIHYwLjMuNFxuICogaHR0cHM6Ly9naXRodWIuY29tL2t1cmtsZS9jb2xvciNyZWFkbWVcbiAqIChjKSAyMDI0IEp1a2thIEt1cmtlbGFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5mdW5jdGlvbiByb3VuZCh2KSB7XG4gIHJldHVybiB2ICsgMC41IHwgMDtcbn1cbmNvbnN0IGxpbSA9ICh2LCBsLCBoKSA9PiBNYXRoLm1heChNYXRoLm1pbih2LCBoKSwgbCk7XG5mdW5jdGlvbiBwMmIodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAyLjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpLCAwLCAxMDApO1xufVxuZnVuY3Rpb24gbjJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIybih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpIC8gMTAwLCAwLCAxKTtcbn1cbmZ1bmN0aW9uIG4ycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDEwMCksIDAsIDEwMCk7XG59XG5cbmNvbnN0IG1hcCQxID0gezA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksIEE6IDEwLCBCOiAxMSwgQzogMTIsIEQ6IDEzLCBFOiAxNCwgRjogMTUsIGE6IDEwLCBiOiAxMSwgYzogMTIsIGQ6IDEzLCBlOiAxNCwgZjogMTV9O1xuY29uc3QgaGV4ID0gWy4uLicwMTIzNDU2Nzg5QUJDREVGJ107XG5jb25zdCBoMSA9IGIgPT4gaGV4W2IgJiAweEZdO1xuY29uc3QgaDIgPSBiID0+IGhleFsoYiAmIDB4RjApID4+IDRdICsgaGV4W2IgJiAweEZdO1xuY29uc3QgZXEgPSBiID0+ICgoYiAmIDB4RjApID4+IDQpID09PSAoYiAmIDB4Rik7XG5jb25zdCBpc1Nob3J0ID0gdiA9PiBlcSh2LnIpICYmIGVxKHYuZykgJiYgZXEodi5iKSAmJiBlcSh2LmEpO1xuZnVuY3Rpb24gaGV4UGFyc2Uoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICB2YXIgcmV0O1xuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAobGVuID09PSA0IHx8IGxlbiA9PT0gNSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiAyNTUgJiBtYXAkMVtzdHJbMV1dICogMTcsXG4gICAgICAgIGc6IDI1NSAmIG1hcCQxW3N0clsyXV0gKiAxNyxcbiAgICAgICAgYjogMjU1ICYgbWFwJDFbc3RyWzNdXSAqIDE3LFxuICAgICAgICBhOiBsZW4gPT09IDUgPyBtYXAkMVtzdHJbNF1dICogMTcgOiAyNTVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDcgfHwgbGVuID09PSA5KSB7XG4gICAgICByZXQgPSB7XG4gICAgICAgIHI6IG1hcCQxW3N0clsxXV0gPDwgNCB8IG1hcCQxW3N0clsyXV0sXG4gICAgICAgIGc6IG1hcCQxW3N0clszXV0gPDwgNCB8IG1hcCQxW3N0cls0XV0sXG4gICAgICAgIGI6IG1hcCQxW3N0cls1XV0gPDwgNCB8IG1hcCQxW3N0cls2XV0sXG4gICAgICAgIGE6IGxlbiA9PT0gOSA/IChtYXAkMVtzdHJbN11dIDw8IDQgfCBtYXAkMVtzdHJbOF1dKSA6IDI1NVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGFscGhhID0gKGEsIGYpID0+IGEgPCAyNTUgPyBmKGEpIDogJyc7XG5mdW5jdGlvbiBoZXhTdHJpbmcodikge1xuICB2YXIgZiA9IGlzU2hvcnQodikgPyBoMSA6IGgyO1xuICByZXR1cm4gdlxuICAgID8gJyMnICsgZih2LnIpICsgZih2LmcpICsgZih2LmIpICsgYWxwaGEodi5hLCBmKVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5jb25zdCBIVUVfUkUgPSAvXihoc2xhP3xod2J8aHN2KVxcKFxccyooWy0rLmVcXGRdKykoPzpkZWcpP1tcXHMsXSsoWy0rLmVcXGRdKyklW1xccyxdKyhbLSsuZVxcZF0rKSUoPzpbXFxzLF0rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gaHNsMnJnYm4oaCwgcywgbCkge1xuICBjb25zdCBhID0gcyAqIE1hdGgubWluKGwsIDEgLSBsKTtcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gMzApICUgMTIpID0+IGwgLSBhICogTWF0aC5tYXgoTWF0aC5taW4oayAtIDMsIDkgLSBrLCAxKSwgLTEpO1xuICByZXR1cm4gW2YoMCksIGYoOCksIGYoNCldO1xufVxuZnVuY3Rpb24gaHN2MnJnYm4oaCwgcywgdikge1xuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyA2MCkgJSA2KSA9PiB2IC0gdiAqIHMgKiBNYXRoLm1heChNYXRoLm1pbihrLCA0IC0gaywgMSksIDApO1xuICByZXR1cm4gW2YoNSksIGYoMyksIGYoMSldO1xufVxuZnVuY3Rpb24gaHdiMnJnYm4oaCwgdywgYikge1xuICBjb25zdCByZ2IgPSBoc2wycmdibihoLCAxLCAwLjUpO1xuICBsZXQgaTtcbiAgaWYgKHcgKyBiID4gMSkge1xuICAgIGkgPSAxIC8gKHcgKyBiKTtcbiAgICB3ICo9IGk7XG4gICAgYiAqPSBpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICByZ2JbaV0gKj0gMSAtIHcgLSBiO1xuICAgIHJnYltpXSArPSB3O1xuICB9XG4gIHJldHVybiByZ2I7XG59XG5mdW5jdGlvbiBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpIHtcbiAgaWYgKHIgPT09IG1heCkge1xuICAgIHJldHVybiAoKGcgLSBiKSAvIGQpICsgKGcgPCBiID8gNiA6IDApO1xuICB9XG4gIGlmIChnID09PSBtYXgpIHtcbiAgICByZXR1cm4gKGIgLSByKSAvIGQgKyAyO1xuICB9XG4gIHJldHVybiAociAtIGcpIC8gZCArIDQ7XG59XG5mdW5jdGlvbiByZ2IyaHNsKHYpIHtcbiAgY29uc3QgcmFuZ2UgPSAyNTU7XG4gIGNvbnN0IHIgPSB2LnIgLyByYW5nZTtcbiAgY29uc3QgZyA9IHYuZyAvIHJhbmdlO1xuICBjb25zdCBiID0gdi5iIC8gcmFuZ2U7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgbGV0IGgsIHMsIGQ7XG4gIGlmIChtYXggIT09IG1pbikge1xuICAgIGQgPSBtYXggLSBtaW47XG4gICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgIGggPSBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpO1xuICAgIGggPSBoICogNjAgKyAwLjU7XG4gIH1cbiAgcmV0dXJuIFtoIHwgMCwgcyB8fCAwLCBsXTtcbn1cbmZ1bmN0aW9uIGNhbGxuKGYsIGEsIGIsIGMpIHtcbiAgcmV0dXJuIChcbiAgICBBcnJheS5pc0FycmF5KGEpXG4gICAgICA/IGYoYVswXSwgYVsxXSwgYVsyXSlcbiAgICAgIDogZihhLCBiLCBjKVxuICApLm1hcChuMmIpO1xufVxuZnVuY3Rpb24gaHNsMnJnYihoLCBzLCBsKSB7XG4gIHJldHVybiBjYWxsbihoc2wycmdibiwgaCwgcywgbCk7XG59XG5mdW5jdGlvbiBod2IycmdiKGgsIHcsIGIpIHtcbiAgcmV0dXJuIGNhbGxuKGh3YjJyZ2JuLCBoLCB3LCBiKTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2IoaCwgcywgdikge1xuICByZXR1cm4gY2FsbG4oaHN2MnJnYm4sIGgsIHMsIHYpO1xufVxuZnVuY3Rpb24gaHVlKGgpIHtcbiAgcmV0dXJuIChoICUgMzYwICsgMzYwKSAlIDM2MDtcbn1cbmZ1bmN0aW9uIGh1ZVBhcnNlKHN0cikge1xuICBjb25zdCBtID0gSFVFX1JFLmV4ZWMoc3RyKTtcbiAgbGV0IGEgPSAyNTU7XG4gIGxldCB2O1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1bNV0gIT09IHYpIHtcbiAgICBhID0gbVs2XSA/IHAyYigrbVs1XSkgOiBuMmIoK21bNV0pO1xuICB9XG4gIGNvbnN0IGggPSBodWUoK21bMl0pO1xuICBjb25zdCBwMSA9ICttWzNdIC8gMTAwO1xuICBjb25zdCBwMiA9ICttWzRdIC8gMTAwO1xuICBpZiAobVsxXSA9PT0gJ2h3YicpIHtcbiAgICB2ID0gaHdiMnJnYihoLCBwMSwgcDIpO1xuICB9IGVsc2UgaWYgKG1bMV0gPT09ICdoc3YnKSB7XG4gICAgdiA9IGhzdjJyZ2IoaCwgcDEsIHAyKTtcbiAgfSBlbHNlIHtcbiAgICB2ID0gaHNsMnJnYihoLCBwMSwgcDIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcjogdlswXSxcbiAgICBnOiB2WzFdLFxuICAgIGI6IHZbMl0sXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcm90YXRlKHYsIGRlZykge1xuICB2YXIgaCA9IHJnYjJoc2wodik7XG4gIGhbMF0gPSBodWUoaFswXSArIGRlZyk7XG4gIGggPSBoc2wycmdiKGgpO1xuICB2LnIgPSBoWzBdO1xuICB2LmcgPSBoWzFdO1xuICB2LmIgPSBoWzJdO1xufVxuZnVuY3Rpb24gaHNsU3RyaW5nKHYpIHtcbiAgaWYgKCF2KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGEgPSByZ2IyaHNsKHYpO1xuICBjb25zdCBoID0gYVswXTtcbiAgY29uc3QgcyA9IG4ycChhWzFdKTtcbiAgY29uc3QgbCA9IG4ycChhWzJdKTtcbiAgcmV0dXJuIHYuYSA8IDI1NVxuICAgID8gYGhzbGEoJHtofSwgJHtzfSUsICR7bH0lLCAke2Iybih2LmEpfSlgXG4gICAgOiBgaHNsKCR7aH0sICR7c30lLCAke2x9JSlgO1xufVxuXG5jb25zdCBtYXAgPSB7XG5cdHg6ICdkYXJrJyxcblx0WjogJ2xpZ2h0Jyxcblx0WTogJ3JlJyxcblx0WDogJ2JsdScsXG5cdFc6ICdncicsXG5cdFY6ICdtZWRpdW0nLFxuXHRVOiAnc2xhdGUnLFxuXHRBOiAnZWUnLFxuXHRUOiAnb2wnLFxuXHRTOiAnb3InLFxuXHRCOiAncmEnLFxuXHRDOiAnbGF0ZWcnLFxuXHREOiAnaWdodHMnLFxuXHRSOiAnaW4nLFxuXHRROiAndHVycXVvaXMnLFxuXHRFOiAnaGknLFxuXHRQOiAncm8nLFxuXHRPOiAnYWwnLFxuXHROOiAnbGUnLFxuXHRNOiAnZGUnLFxuXHRMOiAneWVsbG8nLFxuXHRGOiAnZW4nLFxuXHRLOiAnY2gnLFxuXHRHOiAnYXJrcycsXG5cdEg6ICdlYScsXG5cdEk6ICdpZ2h0ZycsXG5cdEo6ICd3aCdcbn07XG5jb25zdCBuYW1lcyQxID0ge1xuXHRPaWNlWGU6ICdmMGY4ZmYnLFxuXHRhbnRpcXVld0V0ZTogJ2ZhZWJkNycsXG5cdGFxdWE6ICdmZmZmJyxcblx0YXF1YW1hclJlOiAnN2ZmZmQ0Jyxcblx0YXp1WTogJ2YwZmZmZicsXG5cdGJlaWdlOiAnZjVmNWRjJyxcblx0YmlzcXVlOiAnZmZlNGM0Jyxcblx0YmxhY2s6ICcwJyxcblx0YmxhbktlZE9tb25kOiAnZmZlYmNkJyxcblx0WGU6ICdmZicsXG5cdFhldmlUZXQ6ICc4YTJiZTInLFxuXHRiUHduOiAnYTUyYTJhJyxcblx0YnVybHl3b29kOiAnZGViODg3Jyxcblx0Y2FNdFhlOiAnNWY5ZWEwJyxcblx0S2FydFl1c2U6ICc3ZmZmMDAnLFxuXHRLb2NUYXRlOiAnZDI2OTFlJyxcblx0Y1NPOiAnZmY3ZjUwJyxcblx0Y1NuZmxvd2VyWGU6ICc2NDk1ZWQnLFxuXHRjU25zaWxrOiAnZmZmOGRjJyxcblx0Y3JpbXNvbjogJ2RjMTQzYycsXG5cdGN5YW46ICdmZmZmJyxcblx0eFhlOiAnOGInLFxuXHR4Y3lhbjogJzhiOGInLFxuXHR4Z1RNblBkOiAnYjg4NjBiJyxcblx0eFdheTogJ2E5YTlhOScsXG5cdHhnWUY6ICc2NDAwJyxcblx0eGdZeTogJ2E5YTlhOScsXG5cdHhraGFraTogJ2JkYjc2YicsXG5cdHhtYWdGdGE6ICc4YjAwOGInLFxuXHR4VGl2ZWdZRjogJzU1NmIyZicsXG5cdHhTYW5nZTogJ2ZmOGMwMCcsXG5cdHhTY0VkOiAnOTkzMmNjJyxcblx0eFlkOiAnOGIwMDAwJyxcblx0eHNPbW9uOiAnZTk5NjdhJyxcblx0eHNIZ1lGOiAnOGZiYzhmJyxcblx0eFVYZTogJzQ4M2Q4YicsXG5cdHhVV2F5OiAnMmY0ZjRmJyxcblx0eFVnWXk6ICcyZjRmNGYnLFxuXHR4UWU6ICdjZWQxJyxcblx0eHZpVGV0OiAnOTQwMGQzJyxcblx0ZEFwcFJrOiAnZmYxNDkzJyxcblx0ZEFwc2t5WGU6ICdiZmZmJyxcblx0ZGltV2F5OiAnNjk2OTY5Jyxcblx0ZGltZ1l5OiAnNjk2OTY5Jyxcblx0ZG9kZ2VyWGU6ICcxZTkwZmYnLFxuXHRmaVlicmljazogJ2IyMjIyMicsXG5cdGZsU093RXRlOiAnZmZmYWYwJyxcblx0Zm9Zc3RXQW46ICcyMjhiMjInLFxuXHRmdUtzaWE6ICdmZjAwZmYnLFxuXHRnYVJzYlNvOiAnZGNkY2RjJyxcblx0Z2hvc3R3RXRlOiAnZjhmOGZmJyxcblx0Z1RkOiAnZmZkNzAwJyxcblx0Z1RNblBkOiAnZGFhNTIwJyxcblx0V2F5OiAnODA4MDgwJyxcblx0Z1lGOiAnODAwMCcsXG5cdGdZRkx3OiAnYWRmZjJmJyxcblx0Z1l5OiAnODA4MDgwJyxcblx0aG9uZXlNdzogJ2YwZmZmMCcsXG5cdGhvdHBSazogJ2ZmNjliNCcsXG5cdFJkaWFuWWQ6ICdjZDVjNWMnLFxuXHRSZGlnbzogJzRiMDA4MicsXG5cdGl2U3k6ICdmZmZmZjAnLFxuXHRraGFraTogJ2YwZTY4YycsXG5cdGxhdkZNcjogJ2U2ZTZmYScsXG5cdGxhdkZNclhzaDogJ2ZmZjBmNScsXG5cdGxhd25nWUY6ICc3Y2ZjMDAnLFxuXHRObW9uY0VmZm9uOiAnZmZmYWNkJyxcblx0WlhlOiAnYWRkOGU2Jyxcblx0WmNTTzogJ2YwODA4MCcsXG5cdFpjeWFuOiAnZTBmZmZmJyxcblx0WmdUTW5QZEx3OiAnZmFmYWQyJyxcblx0WldheTogJ2QzZDNkMycsXG5cdFpnWUY6ICc5MGVlOTAnLFxuXHRaZ1l5OiAnZDNkM2QzJyxcblx0WnBSazogJ2ZmYjZjMScsXG5cdFpzT21vbjogJ2ZmYTA3YScsXG5cdFpzSGdZRjogJzIwYjJhYScsXG5cdFpza3lYZTogJzg3Y2VmYScsXG5cdFpVV2F5OiAnNzc4ODk5Jyxcblx0WlVnWXk6ICc3Nzg4OTknLFxuXHRac3RBbFhlOiAnYjBjNGRlJyxcblx0Wkx3OiAnZmZmZmUwJyxcblx0bGltZTogJ2ZmMDAnLFxuXHRsaW1lZ1lGOiAnMzJjZDMyJyxcblx0bFJGOiAnZmFmMGU2Jyxcblx0bWFnRnRhOiAnZmYwMGZmJyxcblx0bWFQb246ICc4MDAwMDAnLFxuXHRWYXF1YW1hclJlOiAnNjZjZGFhJyxcblx0VlhlOiAnY2QnLFxuXHRWU2NFZDogJ2JhNTVkMycsXG5cdFZwdXJwTjogJzkzNzBkYicsXG5cdFZzSGdZRjogJzNjYjM3MScsXG5cdFZVWGU6ICc3YjY4ZWUnLFxuXHRWc3ByUmdnWUY6ICdmYTlhJyxcblx0VlFlOiAnNDhkMWNjJyxcblx0VnZpVGV0WWQ6ICdjNzE1ODUnLFxuXHRtaWRuaWdodFhlOiAnMTkxOTcwJyxcblx0bVJ0Y1lhbTogJ2Y1ZmZmYScsXG5cdG1pc3R5UHNlOiAnZmZlNGUxJyxcblx0bW9jY2FzUjogJ2ZmZTRiNScsXG5cdG5hdmFqb3dFdGU6ICdmZmRlYWQnLFxuXHRuYXZ5OiAnODAnLFxuXHRUZGxhY2U6ICdmZGY1ZTYnLFxuXHRUaXZlOiAnODA4MDAwJyxcblx0VGl2ZWRCYjogJzZiOGUyMycsXG5cdFNhbmdlOiAnZmZhNTAwJyxcblx0U2FuZ2VZZDogJ2ZmNDUwMCcsXG5cdFNjRWQ6ICdkYTcwZDYnLFxuXHRwT2VnVE1uUGQ6ICdlZWU4YWEnLFxuXHRwT2VnWUY6ICc5OGZiOTgnLFxuXHRwT2VRZTogJ2FmZWVlZScsXG5cdHBPZXZpVGV0WWQ6ICdkYjcwOTMnLFxuXHRwYXBheWF3RXA6ICdmZmVmZDUnLFxuXHRwSEtwdWZmOiAnZmZkYWI5Jyxcblx0cGVydTogJ2NkODUzZicsXG5cdHBSazogJ2ZmYzBjYicsXG5cdHBsdW06ICdkZGEwZGQnLFxuXHRwb3dNclhlOiAnYjBlMGU2Jyxcblx0cHVycE46ICc4MDAwODAnLFxuXHRZYmVjY2FwdXJwTjogJzY2MzM5OScsXG5cdFlkOiAnZmYwMDAwJyxcblx0UHN5YnJvd246ICdiYzhmOGYnLFxuXHRQeU9YZTogJzQxNjllMScsXG5cdHNhZGROYlB3bjogJzhiNDUxMycsXG5cdHNPbW9uOiAnZmE4MDcyJyxcblx0c2FuZHliUHduOiAnZjRhNDYwJyxcblx0c0hnWUY6ICcyZThiNTcnLFxuXHRzSHNoZWxsOiAnZmZmNWVlJyxcblx0c2lGbmE6ICdhMDUyMmQnLFxuXHRzaWx2ZXI6ICdjMGMwYzAnLFxuXHRza3lYZTogJzg3Y2VlYicsXG5cdFVYZTogJzZhNWFjZCcsXG5cdFVXYXk6ICc3MDgwOTAnLFxuXHRVZ1l5OiAnNzA4MDkwJyxcblx0c25vdzogJ2ZmZmFmYScsXG5cdHNwclJnZ1lGOiAnZmY3ZicsXG5cdHN0QWxYZTogJzQ2ODJiNCcsXG5cdHRhbjogJ2QyYjQ4YycsXG5cdHRlTzogJzgwODAnLFxuXHR0RXN0TjogJ2Q4YmZkOCcsXG5cdHRvbWF0bzogJ2ZmNjM0NycsXG5cdFFlOiAnNDBlMGQwJyxcblx0dmlUZXQ6ICdlZTgyZWUnLFxuXHRKSHQ6ICdmNWRlYjMnLFxuXHR3RXRlOiAnZmZmZmZmJyxcblx0d0V0ZXNtb2tlOiAnZjVmNWY1Jyxcblx0THc6ICdmZmZmMDAnLFxuXHRMd2dZRjogJzlhY2QzMidcbn07XG5mdW5jdGlvbiB1bnBhY2soKSB7XG4gIGNvbnN0IHVucGFja2VkID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhuYW1lcyQxKTtcbiAgY29uc3QgdGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuICBsZXQgaSwgaiwgaywgb2ssIG5rO1xuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIG9rID0gbmsgPSBrZXlzW2ldO1xuICAgIGZvciAoaiA9IDA7IGogPCB0a2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgayA9IHRrZXlzW2pdO1xuICAgICAgbmsgPSBuay5yZXBsYWNlKGssIG1hcFtrXSk7XG4gICAgfVxuICAgIGsgPSBwYXJzZUludChuYW1lcyQxW29rXSwgMTYpO1xuICAgIHVucGFja2VkW25rXSA9IFtrID4+IDE2ICYgMHhGRiwgayA+PiA4ICYgMHhGRiwgayAmIDB4RkZdO1xuICB9XG4gIHJldHVybiB1bnBhY2tlZDtcbn1cblxubGV0IG5hbWVzO1xuZnVuY3Rpb24gbmFtZVBhcnNlKHN0cikge1xuICBpZiAoIW5hbWVzKSB7XG4gICAgbmFtZXMgPSB1bnBhY2soKTtcbiAgICBuYW1lcy50cmFuc3BhcmVudCA9IFswLCAwLCAwLCAwXTtcbiAgfVxuICBjb25zdCBhID0gbmFtZXNbc3RyLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gYSAmJiB7XG4gICAgcjogYVswXSxcbiAgICBnOiBhWzFdLFxuICAgIGI6IGFbMl0sXG4gICAgYTogYS5sZW5ndGggPT09IDQgPyBhWzNdIDogMjU1XG4gIH07XG59XG5cbmNvbnN0IFJHQl9SRSA9IC9ecmdiYT9cXChcXHMqKFstKy5cXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpPyg/OltcXHMsL10rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gcmdiUGFyc2Uoc3RyKSB7XG4gIGNvbnN0IG0gPSBSR0JfUkUuZXhlYyhzdHIpO1xuICBsZXQgYSA9IDI1NTtcbiAgbGV0IHIsIGcsIGI7XG4gIGlmICghbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobVs3XSAhPT0gcikge1xuICAgIGNvbnN0IHYgPSArbVs3XTtcbiAgICBhID0gbVs4XSA/IHAyYih2KSA6IGxpbSh2ICogMjU1LCAwLCAyNTUpO1xuICB9XG4gIHIgPSArbVsxXTtcbiAgZyA9ICttWzNdO1xuICBiID0gK21bNV07XG4gIHIgPSAyNTUgJiAobVsyXSA/IHAyYihyKSA6IGxpbShyLCAwLCAyNTUpKTtcbiAgZyA9IDI1NSAmIChtWzRdID8gcDJiKGcpIDogbGltKGcsIDAsIDI1NSkpO1xuICBiID0gMjU1ICYgKG1bNl0gPyBwMmIoYikgOiBsaW0oYiwgMCwgMjU1KSk7XG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBnOiBnLFxuICAgIGI6IGIsXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcmdiU3RyaW5nKHYpIHtcbiAgcmV0dXJuIHYgJiYgKFxuICAgIHYuYSA8IDI1NVxuICAgICAgPyBgcmdiYSgke3Yucn0sICR7di5nfSwgJHt2LmJ9LCAke2Iybih2LmEpfSlgXG4gICAgICA6IGByZ2IoJHt2LnJ9LCAke3YuZ30sICR7di5ifSlgXG4gICk7XG59XG5cbmNvbnN0IHRvID0gdiA9PiB2IDw9IDAuMDAzMTMwOCA/IHYgKiAxMi45MiA6IE1hdGgucG93KHYsIDEuMCAvIDIuNCkgKiAxLjA1NSAtIDAuMDU1O1xuY29uc3QgZnJvbSA9IHYgPT4gdiA8PSAwLjA0MDQ1ID8gdiAvIDEyLjkyIDogTWF0aC5wb3coKHYgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbmZ1bmN0aW9uIGludGVycG9sYXRlKHJnYjEsIHJnYjIsIHQpIHtcbiAgY29uc3QgciA9IGZyb20oYjJuKHJnYjEucikpO1xuICBjb25zdCBnID0gZnJvbShiMm4ocmdiMS5nKSk7XG4gIGNvbnN0IGIgPSBmcm9tKGIybihyZ2IxLmIpKTtcbiAgcmV0dXJuIHtcbiAgICByOiBuMmIodG8ociArIHQgKiAoZnJvbShiMm4ocmdiMi5yKSkgLSByKSkpLFxuICAgIGc6IG4yYih0byhnICsgdCAqIChmcm9tKGIybihyZ2IyLmcpKSAtIGcpKSksXG4gICAgYjogbjJiKHRvKGIgKyB0ICogKGZyb20oYjJuKHJnYjIuYikpIC0gYikpKSxcbiAgICBhOiByZ2IxLmEgKyB0ICogKHJnYjIuYSAtIHJnYjEuYSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW9kSFNMKHYsIGksIHJhdGlvKSB7XG4gIGlmICh2KSB7XG4gICAgbGV0IHRtcCA9IHJnYjJoc2wodik7XG4gICAgdG1wW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odG1wW2ldICsgdG1wW2ldICogcmF0aW8sIGkgPT09IDAgPyAzNjAgOiAxKSk7XG4gICAgdG1wID0gaHNsMnJnYih0bXApO1xuICAgIHYuciA9IHRtcFswXTtcbiAgICB2LmcgPSB0bXBbMV07XG4gICAgdi5iID0gdG1wWzJdO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZSh2LCBwcm90bykge1xuICByZXR1cm4gdiA/IE9iamVjdC5hc3NpZ24ocHJvdG8gfHwge30sIHYpIDogdjtcbn1cbmZ1bmN0aW9uIGZyb21PYmplY3QoaW5wdXQpIHtcbiAgdmFyIHYgPSB7cjogMCwgZzogMCwgYjogMCwgYTogMjU1fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA+PSAzKSB7XG4gICAgICB2ID0ge3I6IGlucHV0WzBdLCBnOiBpbnB1dFsxXSwgYjogaW5wdXRbMl0sIGE6IDI1NX07XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMykge1xuICAgICAgICB2LmEgPSBuMmIoaW5wdXRbM10pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ID0gY2xvbmUoaW5wdXQsIHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAxfSk7XG4gICAgdi5hID0gbjJiKHYuYSk7XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBmdW5jdGlvblBhcnNlKHN0cikge1xuICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJ3InKSB7XG4gICAgcmV0dXJuIHJnYlBhcnNlKHN0cik7XG4gIH1cbiAgcmV0dXJuIGh1ZVBhcnNlKHN0cik7XG59XG5jbGFzcyBDb2xvciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgICBsZXQgdjtcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHYgPSBmcm9tT2JqZWN0KGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2ID0gaGV4UGFyc2UoaW5wdXQpIHx8IG5hbWVQYXJzZShpbnB1dCkgfHwgZnVuY3Rpb25QYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRoaXMuX3JnYiA9IHY7XG4gICAgdGhpcy5fdmFsaWQgPSAhIXY7XG4gIH1cbiAgZ2V0IHZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZDtcbiAgfVxuICBnZXQgcmdiKCkge1xuICAgIHZhciB2ID0gY2xvbmUodGhpcy5fcmdiKTtcbiAgICBpZiAodikge1xuICAgICAgdi5hID0gYjJuKHYuYSk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG4gIHNldCByZ2Iob2JqKSB7XG4gICAgdGhpcy5fcmdiID0gZnJvbU9iamVjdChvYmopO1xuICB9XG4gIHJnYlN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyByZ2JTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBoZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaGV4U3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaHNsU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhzbFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIG1peChjb2xvciwgd2VpZ2h0KSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb25zdCBjMSA9IHRoaXMucmdiO1xuICAgICAgY29uc3QgYzIgPSBjb2xvci5yZ2I7XG4gICAgICBsZXQgdzI7XG4gICAgICBjb25zdCBwID0gd2VpZ2h0ID09PSB3MiA/IDAuNSA6IHdlaWdodDtcbiAgICAgIGNvbnN0IHcgPSAyICogcCAtIDE7XG4gICAgICBjb25zdCBhID0gYzEuYSAtIGMyLmE7XG4gICAgICBjb25zdCB3MSA9ICgodyAqIGEgPT09IC0xID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcbiAgICAgIHcyID0gMSAtIHcxO1xuICAgICAgYzEuciA9IDB4RkYgJiB3MSAqIGMxLnIgKyB3MiAqIGMyLnIgKyAwLjU7XG4gICAgICBjMS5nID0gMHhGRiAmIHcxICogYzEuZyArIHcyICogYzIuZyArIDAuNTtcbiAgICAgIGMxLmIgPSAweEZGICYgdzEgKiBjMS5iICsgdzIgKiBjMi5iICsgMC41O1xuICAgICAgYzEuYSA9IHAgKiBjMS5hICsgKDEgLSBwKSAqIGMyLmE7XG4gICAgICB0aGlzLnJnYiA9IGMxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbnRlcnBvbGF0ZShjb2xvciwgdCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy5fcmdiID0gaW50ZXJwb2xhdGUodGhpcy5fcmdiLCBjb2xvci5fcmdiLCB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnJnYik7XG4gIH1cbiAgYWxwaGEoYSkge1xuICAgIHRoaXMuX3JnYi5hID0gbjJiKGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyZXIocmF0aW8pIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmdiLmEgKj0gMSAtIHJhdGlvO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdyZXlzY2FsZSgpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgY29uc3QgdmFsID0gcm91bmQocmdiLnIgKiAwLjMgKyByZ2IuZyAqIDAuNTkgKyByZ2IuYiAqIDAuMTEpO1xuICAgIHJnYi5yID0gcmdiLmcgPSByZ2IuYiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvcGFxdWVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgKyByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBuZWdhdGUoKSB7XG4gICAgY29uc3QgdiA9IHRoaXMuX3JnYjtcbiAgICB2LnIgPSAyNTUgLSB2LnI7XG4gICAgdi5nID0gMjU1IC0gdi5nO1xuICAgIHYuYiA9IDI1NSAtIHYuYjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaWdodGVuKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMiwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRhcmtlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCByYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzYXR1cmF0ZShyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDEsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm90YXRlKGRlZykge1xuICAgIHJvdGF0ZSh0aGlzLl9yZ2IsIGRlZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhfZXNtKGlucHV0KSB7XG4gIHJldHVybiBuZXcgQ29sb3IoaW5wdXQpO1xufVxuXG5leHBvcnQgeyBDb2xvciwgYjJuLCBiMnAsIGluZGV4X2VzbSBhcyBkZWZhdWx0LCBoZXhQYXJzZSwgaGV4U3RyaW5nLCBoc2wycmdiLCBoc2xTdHJpbmcsIGhzdjJyZ2IsIGh1ZVBhcnNlLCBod2IycmdiLCBsaW0sIG4yYiwgbjJwLCBuYW1lUGFyc2UsIHAyYiwgcmdiMmhzbCwgcmdiUGFyc2UsIHJnYlN0cmluZywgcm90YXRlLCByb3VuZCB9O1xuIiwgIi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzXG4gKi9cblxuaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge0FjdGl2ZURhdGFQb2ludCwgQ2hhcnRFdmVudH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG4vKipcbiAqIEFuIGVtcHR5IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCBmb3Igb3B0aW9uYWwgY2FsbGJhY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge1xuICAvKiBub29wICovXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHVuaXF1ZSBpZCwgc2VxdWVudGlhbGx5IGdlbmVyYXRlZCBmcm9tIGEgZ2xvYmFsIHZhcmlhYmxlLlxuICovXG5leHBvcnQgY29uc3QgdWlkID0gKCgpID0+IHtcbiAgbGV0IGlkID0gMDtcbiAgcmV0dXJuICgpID0+IGlkKys7XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIG5laXRoZXIgbnVsbCBub3IgdW5kZWZpbmVkLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsT3JVbmRlZih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bGwgfCB1bmRlZmluZWQge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSAoaW5jbHVkaW5nIHR5cGVkIGFycmF5cyksIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5PFQgPSB1bmtub3duPih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFRbXSB7XG4gIGlmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh0eXBlLnNsaWNlKDAsIDcpID09PSAnW29iamVjdCcgJiYgdHlwZS5zbGljZSgtNikgPT09ICdBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCAoZXhjbHVkaW5nIG51bGwpLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBBbnlPYmplY3Qge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIHJldHVybnMgZmFsc2VcbiAqIEBwYXJhbSB2YWx1ZSAgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXJGaW5pdGUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBudW1iZXIge1xuICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIGlzRmluaXRlKCt2YWx1ZSk7XG59XG5leHBvcnQge1xuICBpc051bWJlckZpbml0ZSBhcyBpc0Zpbml0ZSxcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdmFsdWVgIGlmIGZpbml0ZSwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBkZWZpbmVkLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlYCBpcyBub3QgZmluaXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluaXRlT3JEZWZhdWx0KHZhbHVlOiB1bmtub3duLCBkZWZhdWx0VmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gaXNOdW1iZXJGaW5pdGUodmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdmFsdWVgIGlmIGRlZmluZWQsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgZGVmaW5lZC5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVPckRlZmF1bHQ8VD4odmFsdWU6IFQgfCB1bmRlZmluZWQsIGRlZmF1bHRWYWx1ZTogVCkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufVxuXG5leHBvcnQgY29uc3QgdG9QZXJjZW50YWdlID0gKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIGRpbWVuc2lvbjogbnVtYmVyKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwXG4gICAgOiArdmFsdWUgLyBkaW1lbnNpb247XG5cbmV4cG9ydCBjb25zdCB0b0RpbWVuc2lvbiA9ICh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nLCBkaW1lbnNpb246IG51bWJlcikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIGRpbWVuc2lvblxuICAgIDogK3ZhbHVlO1xuXG4vKipcbiAqIENhbGxzIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gYGFyZ3NgIGluIHRoZSBzY29wZSBkZWZpbmVkIGJ5IGB0aGlzQXJnYCBhbmQgcmV0dXJucyB0aGVcbiAqIHZhbHVlIHJldHVybmVkIGJ5IGBmbmAuIElmIGBmbmAgaXMgbm90IGEgZnVuY3Rpb24sIHRoaXMgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLlxuICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCBgZm5gIHNob3VsZCBiZSBjYWxsZWQuXG4gKiBAcGFyYW0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGxiYWNrPFQgZXh0ZW5kcyAodGhpczogVEEsIC4uLnJlc3RBcmdzOiB1bmtub3duW10pID0+IFIsIFRBLCBSPihcbiAgZm46IFQgfCB1bmRlZmluZWQsXG4gIGFyZ3M6IHVua25vd25bXSxcbiAgdGhpc0FyZz86IFRBXG4pOiBSIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGZuICYmIHR5cGVvZiBmbi5jYWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogTm90ZShTQikgZm9yIHBlcmZvcm1hbmNlIHNha2UsIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiBsb29wYWJsZSB0eXBlXG4gKiBpcyB1bmtub3duIG9yIGluIG5vbmUgaW50ZW5zaXZlIGNvZGUgKG5vdCBjYWxsZWQgb2Z0ZW4gYW5kIHNtYWxsIGxvb3BhYmxlKS4gRWxzZVxuICogaXQncyBwcmVmZXJhYmxlIHRvIHVzZSBhIHJlZ3VsYXIgZm9yKCkgbG9vcCBhbmQgc2F2ZSBleHRyYSBmdW5jdGlvbiBjYWxscy5cbiAqIEBwYXJhbSBsb29wYWJsZSAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgaXRlcmF0ZWQuXG4gKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpdGVtLlxuICogQHBhcmFtIFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG4gKiBAcGFyYW0gW3JldmVyc2VdIC0gSWYgdHJ1ZSwgaXRlcmF0ZXMgYmFja3dhcmQgb24gdGhlIGxvb3BhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBSZWNvcmQ8c3RyaW5nLCBUPixcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogc3RyaW5nKSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2g8VCwgVEE+KFxuICBsb29wYWJsZTogVFtdLFxuICBmbjogKHRoaXM6IFRBLCB2OiBULCBpOiBudW1iZXIpID0+IHZvaWQsXG4gIHRoaXNBcmc/OiBUQSxcbiAgcmV2ZXJzZT86IGJvb2xlYW5cbik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBUW10gfCBSZWNvcmQ8c3RyaW5nLCBUPixcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogYW55KSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pIHtcbiAgbGV0IGk6IG51bWJlciwgbGVuOiBudW1iZXIsIGtleXM6IHN0cmluZ1tdO1xuICBpZiAoaXNBcnJheShsb29wYWJsZSkpIHtcbiAgICBsZW4gPSBsb29wYWJsZS5sZW5ndGg7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxvb3BhYmxlKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhsb29wYWJsZSk7XG4gICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2tleXNbaV1dLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBhMGAgYW5kIGBhMWAgYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIGEwIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBhMSAtIFRoZSBhcnJheSB0byBjb21wYXJlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2VsZW1lbnRzRXF1YWwoYTA6IEFjdGl2ZURhdGFQb2ludFtdLCBhMTogQWN0aXZlRGF0YVBvaW50W10pIHtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCB2MDogQWN0aXZlRGF0YVBvaW50LCB2MTogQWN0aXZlRGF0YVBvaW50O1xuXG4gIGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHYwID0gYTBbaV07XG4gICAgdjEgPSBhMVtpXTtcblxuICAgIGlmICh2MC5kYXRhc2V0SW5kZXggIT09IHYxLmRhdGFzZXRJbmRleCB8fCB2MC5pbmRleCAhPT0gdjEuaW5kZXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIGBzb3VyY2VgIHdpdGhvdXQga2VlcGluZyByZWZlcmVuY2VzIG9uIG9iamVjdHMgYW5kIGFycmF5cy5cbiAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZTxUPihzb3VyY2U6IFQpOiBUIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2UubWFwKGNsb25lKSBhcyB1bmtub3duIGFzIFQ7XG4gIH1cblxuICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgY29uc3Qga2xlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBrID0gMDtcblxuICAgIGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICB0YXJnZXRba2V5c1trXV0gPSBjbG9uZShzb3VyY2Vba2V5c1trXV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICByZXR1cm4gc291cmNlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleTogc3RyaW5nKSB7XG4gIHJldHVybiBbJ19fcHJvdG9fXycsICdwcm90b3R5cGUnLCAnY29uc3RydWN0b3InXS5pbmRleE9mKGtleSkgPT09IC0xO1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG1lcmdlciB3aGVuIENoYXJ0LmhlbHBlcnMubWVyZ2UgaXMgY2FsbGVkIHdpdGhvdXQgbWVyZ2VyIG9wdGlvbi5cbiAqIE5vdGUoU0IpOiBhbHNvIHVzZWQgYnkgbWVyZ2VDb25maWcgYW5kIG1lcmdlU2NhbGVDb25maWcgYXMgZmFsbGJhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX21lcmdlcihrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0LCBvcHRpb25zOiBBbnlPYmplY3QpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcblxuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgbWVyZ2UodHZhbCwgc3ZhbCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzdmFsKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lcmdlT3B0aW9ucyB7XG4gIG1lcmdlcj86IChrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0LCBvcHRpb25zPzogQW55T2JqZWN0KSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIG1lcmdlZCBpbnRvLlxuICogQHBhcmFtIHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxuICogQHBhcmFtIFtvcHRpb25zXSAtIE1lcmdpbmcgb3B0aW9uczpcbiAqIEBwYXJhbSBbb3B0aW9ucy5tZXJnZXJdIC0gVGhlIG1lcmdlIG1ldGhvZCAoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcbiAqIEByZXR1cm5zIFRoZSBgdGFyZ2V0YCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogW10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxPih0YXJnZXQ6IFQsIHNvdXJjZTogUzEsIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUICYgUzE7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBbUzFdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxLCBTMj4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzJdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxICYgUzI7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyLCBTMz4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzIsIFMzXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQgJiBTMSAmIFMyICYgUzM7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyLCBTMywgUzQ+KFxuICB0YXJnZXQ6IFQsXG4gIHNvdXJjZTogW1MxLCBTMiwgUzMsIFM0XSxcbiAgb3B0aW9ucz86IE1lcmdlT3B0aW9uc1xuKTogVCAmIFMxICYgUzIgJiBTMyAmIFM0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQ+KHRhcmdldDogVCwgc291cmNlOiBBbnlPYmplY3RbXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IEFueU9iamVjdDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogQW55T2JqZWN0W10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBBbnlPYmplY3Qge1xuICBjb25zdCBzb3VyY2VzID0gaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG4gIGNvbnN0IGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcblxuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0IGFzIEFueU9iamVjdDtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBtZXJnZXIgPSBvcHRpb25zLm1lcmdlciB8fCBfbWVyZ2VyO1xuICBsZXQgY3VycmVudDogQW55T2JqZWN0O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VycmVudCA9IHNvdXJjZXNbaV07XG4gICAgaWYgKCFpc09iamVjdChjdXJyZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGN1cnJlbnQpO1xuICAgIGZvciAobGV0IGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIG1lcmdlcihrZXlzW2tdLCB0YXJnZXQsIGN1cnJlbnQsIG9wdGlvbnMgYXMgQW55T2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCAqb25seSogaWYgbm90IGRlZmluZWQgaW4gdGFyZ2V0LlxuICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cbiAqIEBwYXJhbSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cbiAqIEByZXR1cm5zIFRoZSBgdGFyZ2V0YCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQ+KHRhcmdldDogVCwgc291cmNlOiBbXSk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMT4odGFyZ2V0OiBULCBzb3VyY2U6IFMxKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBbUzFdKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMl0pOiBUICYgUzEgJiBTMjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxLCBTMiwgUzM+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTM10pOiBUICYgUzEgJiBTMiAmIFMzO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyLCBTMywgUzQ+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTMywgUzRdKTogVCAmIFMxICYgUzIgJiBTMyAmIFM0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdKTogQW55T2JqZWN0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdKTogQW55T2JqZWN0IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICByZXR1cm4gbWVyZ2U8VD4odGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IF9tZXJnZXJJZn0pO1xufVxuXG4vKipcbiAqIE1lcmdlcyBzb3VyY2Vba2V5XSBpbiB0YXJnZXRba2V5XSBvbmx5IGlmIHRhcmdldFtrZXldIGlzIHVuZGVmaW5lZC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbWVyZ2VySWYoa2V5OiBzdHJpbmcsIHRhcmdldDogQW55T2JqZWN0LCBzb3VyY2U6IEFueU9iamVjdCkge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIG1lcmdlSWYodHZhbCwgc3ZhbCk7XG4gIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lKHN2YWwpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZXByZWNhdGVkKHNjb3BlOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duLCBwcmV2aW91czogc3RyaW5nLCBjdXJyZW50OiBzdHJpbmcpIHtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oc2NvcGUgKyAnOiBcIicgKyBwcmV2aW91cyArXG4gICAgICAnXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIicgKyBjdXJyZW50ICsgJ1wiIGluc3RlYWQnKTtcbiAgfVxufVxuXG4vLyByZXNvbHZlT2JqZWN0S2V5IHJlc29sdmVyIGNhY2hlXG5jb25zdCBrZXlSZXNvbHZlcnMgPSB7XG4gIC8vIENoYXJ0LmhlbHBlcnMuY29yZSByZXNvbHZlT2JqZWN0S2V5IHNob3VsZCByZXNvbHZlIGVtcHR5IGtleSB0byByb290IG9iamVjdFxuICAnJzogdiA9PiB2LFxuICAvLyBkZWZhdWx0IHJlc29sdmVyc1xuICB4OiBvID0+IG8ueCxcbiAgeTogbyA9PiBvLnlcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zcGxpdEtleShrZXk6IHN0cmluZykge1xuICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICBjb25zdCBrZXlzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgdG1wID0gJyc7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIHRtcCArPSBwYXJ0O1xuICAgIGlmICh0bXAuZW5kc1dpdGgoJ1xcXFwnKSkge1xuICAgICAgdG1wID0gdG1wLnNsaWNlKDAsIC0xKSArICcuJztcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cy5wdXNoKHRtcCk7XG4gICAgICB0bXAgPSAnJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9nZXRLZXlSZXNvbHZlcihrZXk6IHN0cmluZykge1xuICBjb25zdCBrZXlzID0gX3NwbGl0S2V5KGtleSk7XG4gIHJldHVybiBvYmogPT4ge1xuICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICBpZiAoayA9PT0gJycpIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6XG4gICAgICAgIC8vIENoYXJ0LmhlbHBlcnMuY29yZSByZXNvbHZlT2JqZWN0S2V5IHNob3VsZCBicmVhayBhdCBlbXB0eSBrZXlcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvYmogPSBvYmogJiYgb2JqW2tdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU9iamVjdEtleShvYmo6IEFueU9iamVjdCwga2V5OiBzdHJpbmcpOiBhbnkge1xuICBjb25zdCByZXNvbHZlciA9IGtleVJlc29sdmVyc1trZXldIHx8IChrZXlSZXNvbHZlcnNba2V5XSA9IF9nZXRLZXlSZXNvbHZlcihrZXkpKTtcbiAgcmV0dXJuIHJlc29sdmVyKG9iaik7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5cblxuZXhwb3J0IGNvbnN0IGRlZmluZWQgPSAodmFsdWU6IHVua25vd24pID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XG5cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzExMjg4NTUvY29tcGFyaW5nLWVjbWE2LXNldHMtZm9yLWVxdWFsaXR5IzMxMTI5Mzg0XG5leHBvcnQgY29uc3Qgc2V0c0VxdWFsID0gPFQ+KGE6IFNldDxUPiwgYjogU2V0PFQ+KSA9PiB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgaXRlbSBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gZSAtIFRoZSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0NsaWNrRXZlbnQoZTogQ2hhcnRFdmVudCkge1xuICByZXR1cm4gZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ2NvbnRleHRtZW51Jztcbn1cbiIsICJpbXBvcnQgdHlwZSB7UG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQge2lzRmluaXRlIGFzIGlzRmluaXRlTnVtYmVyfSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMubWF0aFxuICogQG5hbWVzcGFjZVxuICovXG5cbmV4cG9ydCBjb25zdCBQSSA9IE1hdGguUEk7XG5leHBvcnQgY29uc3QgVEFVID0gMiAqIFBJO1xuZXhwb3J0IGNvbnN0IFBJVEFVID0gVEFVICsgUEk7XG5leHBvcnQgY29uc3QgSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5leHBvcnQgY29uc3QgUkFEX1BFUl9ERUcgPSBQSSAvIDE4MDtcbmV4cG9ydCBjb25zdCBIQUxGX1BJID0gUEkgLyAyO1xuZXhwb3J0IGNvbnN0IFFVQVJURVJfUEkgPSBQSSAvIDQ7XG5leHBvcnQgY29uc3QgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XG5cbmV4cG9ydCBjb25zdCBsb2cxMCA9IE1hdGgubG9nMTA7XG5leHBvcnQgY29uc3Qgc2lnbiA9IE1hdGguc2lnbjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFsbW9zdEVxdWFscyh4OiBudW1iZXIsIHk6IG51bWJlciwgZXBzaWxvbjogbnVtYmVyKSB7XG4gIHJldHVybiBNYXRoLmFicyh4IC0geSkgPCBlcHNpbG9uO1xufVxuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBuaWNlIG51bWJlciBhbGdvcml0aG0gdXNlZCBpbiBkZXRlcm1pbmluZyB3aGVyZSBheGlzIGxhYmVscyB3aWxsIGdvXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuaWNlTnVtKHJhbmdlOiBudW1iZXIpIHtcbiAgY29uc3Qgcm91bmRlZFJhbmdlID0gTWF0aC5yb3VuZChyYW5nZSk7XG4gIHJhbmdlID0gYWxtb3N0RXF1YWxzKHJhbmdlLCByb3VuZGVkUmFuZ2UsIHJhbmdlIC8gMTAwMCkgPyByb3VuZGVkUmFuZ2UgOiByYW5nZTtcbiAgY29uc3QgbmljZVJhbmdlID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAocmFuZ2UpKSk7XG4gIGNvbnN0IGZyYWN0aW9uID0gcmFuZ2UgLyBuaWNlUmFuZ2U7XG4gIGNvbnN0IG5pY2VGcmFjdGlvbiA9IGZyYWN0aW9uIDw9IDEgPyAxIDogZnJhY3Rpb24gPD0gMiA/IDIgOiBmcmFjdGlvbiA8PSA1ID8gNSA6IDEwO1xuICByZXR1cm4gbmljZUZyYWN0aW9uICogbmljZVJhbmdlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgZmFjdG9ycyBzb3J0ZWQgZnJvbSAxIHRvIHNxcnQodmFsdWUpXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ZhY3Rvcml6ZSh2YWx1ZTogbnVtYmVyKSB7XG4gIGNvbnN0IHJlc3VsdDogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgc3FydCA9IE1hdGguc3FydCh2YWx1ZSk7XG4gIGxldCBpOiBudW1iZXI7XG5cbiAgZm9yIChpID0gMTsgaSA8IHNxcnQ7IGkrKykge1xuICAgIGlmICh2YWx1ZSAlIGkgPT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUgLyBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNxcnQgPT09IChzcXJ0IHwgMCkpIHsgLy8gaWYgdmFsdWUgaXMgYSBzcXVhcmUgbnVtYmVyXG4gICAgcmVzdWx0LnB1c2goc3FydCk7XG4gIH1cblxuICByZXN1bHQuc29ydCgoYSwgYikgPT4gYSAtIGIpLnBvcCgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHRoYXQgYXR0ZW1wdGluZyB0byBjb2VyY2UgbiB0byBzdHJpbmcgb3IgbnVtYmVyIHdvbid0IHRocm93IGEgVHlwZUVycm9yLlxuICovXG5mdW5jdGlvbiBpc05vblByaW1pdGl2ZShuOiB1bmtub3duKSB7XG4gIHJldHVybiB0eXBlb2YgbiA9PT0gJ3N5bWJvbCcgfHwgKHR5cGVvZiBuID09PSAnb2JqZWN0JyAmJiBuICE9PSBudWxsICYmICEoU3ltYm9sLnRvUHJpbWl0aXZlIGluIG4gfHwgJ3RvU3RyaW5nJyBpbiBuIHx8ICd2YWx1ZU9mJyBpbiBuKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcihuOiB1bmtub3duKTogbiBpcyBudW1iZXIge1xuICByZXR1cm4gIWlzTm9uUHJpbWl0aXZlKG4pICYmICFpc05hTihwYXJzZUZsb2F0KG4gYXMgc3RyaW5nKSkgJiYgaXNGaW5pdGUobiBhcyBudW1iZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxtb3N0V2hvbGUoeDogbnVtYmVyLCBlcHNpbG9uOiBudW1iZXIpIHtcbiAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XG4gIHJldHVybiAoKHJvdW5kZWQgLSBlcHNpbG9uKSA8PSB4KSAmJiAoKHJvdW5kZWQgKyBlcHNpbG9uKSA+PSB4KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NldE1pbkFuZE1heEJ5S2V5KFxuICBhcnJheTogUmVjb3JkPHN0cmluZywgbnVtYmVyPltdLFxuICB0YXJnZXQ6IHsgbWluOiBudW1iZXIsIG1heDogbnVtYmVyIH0sXG4gIHByb3BlcnR5OiBzdHJpbmdcbikge1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHZhbHVlOiBudW1iZXI7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIHZhbHVlID0gYXJyYXlbaV1bcHJvcGVydHldO1xuICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICB0YXJnZXQubWluID0gTWF0aC5taW4odGFyZ2V0Lm1pbiwgdmFsdWUpO1xuICAgICAgdGFyZ2V0Lm1heCA9IE1hdGgubWF4KHRhcmdldC5tYXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzOiBudW1iZXIpIHtcbiAgcmV0dXJuIGRlZ3JlZXMgKiAoUEkgLyAxODApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnM6IG51bWJlcikge1xuICByZXR1cm4gcmFkaWFucyAqICgxODAgLyBQSSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gKiBpLmUuIHRoZSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBOdW1iZXIuXG4gKiBAcGFyYW0geCAtIEEgbnVtYmVyLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVjaW1hbFBsYWNlcyh4OiBudW1iZXIpIHtcbiAgaWYgKCFpc0Zpbml0ZU51bWJlcih4KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZSA9IDE7XG4gIGxldCBwID0gMDtcbiAgd2hpbGUgKE1hdGgucm91bmQoeCAqIGUpIC8gZSAhPT0geCkge1xuICAgIGUgKj0gMTA7XG4gICAgcCsrO1xuICB9XG4gIHJldHVybiBwO1xufVxuXG4vLyBHZXRzIHRoZSBhbmdsZSBmcm9tIHZlcnRpY2FsIHVwcmlnaHQgdG8gdGhlIHBvaW50IGFib3V0IGEgY2VudHJlLlxuZXhwb3J0IGZ1bmN0aW9uIGdldEFuZ2xlRnJvbVBvaW50KFxuICBjZW50cmVQb2ludDogUG9pbnQsXG4gIGFuZ2xlUG9pbnQ6IFBvaW50XG4pIHtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVlDZW50ZXIgPSBhbmdsZVBvaW50LnkgLSBjZW50cmVQb2ludC55O1xuICBjb25zdCByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIgPSBNYXRoLnNxcnQoZGlzdGFuY2VGcm9tWENlbnRlciAqIGRpc3RhbmNlRnJvbVhDZW50ZXIgKyBkaXN0YW5jZUZyb21ZQ2VudGVyICogZGlzdGFuY2VGcm9tWUNlbnRlcik7XG5cbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcblxuICBpZiAoYW5nbGUgPCAoLTAuNSAqIFBJKSkge1xuICAgIGFuZ2xlICs9IFRBVTsgLy8gbWFrZSBzdXJlIHRoZSByZXR1cm5lZCBhbmdsZSBpcyBpbiB0aGUgcmFuZ2Ugb2YgKC1QSS8yLCAzUEkvMl1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYW5nbGUsXG4gICAgZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHB0MTogUG9pbnQsIHB0MjogUG9pbnQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcbn1cblxuLyoqXG4gKiBTaG9ydGVzdCBkaXN0YW5jZSBiZXR3ZWVuIGFuZ2xlcywgaW4gZWl0aGVyIGRpcmVjdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYW5nbGVEaWZmKGE6IG51bWJlciwgYjogbnVtYmVyKSB7XG4gIHJldHVybiAoYSAtIGIgKyBQSVRBVSkgJSBUQVUgLSBQSTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYW5nbGUgdG8gYmUgYmV0d2VlbiAwIGFuZCAyKlBJXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX25vcm1hbGl6ZUFuZ2xlKGE6IG51bWJlcikge1xuICByZXR1cm4gKGEgJSBUQVUgKyBUQVUpICUgVEFVO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYW5nbGVCZXR3ZWVuKGFuZ2xlOiBudW1iZXIsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBzYW1lQW5nbGVJc0Z1bGxDaXJjbGU/OiBib29sZWFuKSB7XG4gIGNvbnN0IGEgPSBfbm9ybWFsaXplQW5nbGUoYW5nbGUpO1xuICBjb25zdCBzID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgY29uc3QgZSA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICBjb25zdCBhbmdsZVRvU3RhcnQgPSBfbm9ybWFsaXplQW5nbGUocyAtIGEpO1xuICBjb25zdCBhbmdsZVRvRW5kID0gX25vcm1hbGl6ZUFuZ2xlKGUgLSBhKTtcbiAgY29uc3Qgc3RhcnRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBzKTtcbiAgY29uc3QgZW5kVG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gZSk7XG4gIHJldHVybiBhID09PSBzIHx8IGEgPT09IGUgfHwgKHNhbWVBbmdsZUlzRnVsbENpcmNsZSAmJiBzID09PSBlKVxuICAgIHx8IChhbmdsZVRvU3RhcnQgPiBhbmdsZVRvRW5kICYmIHN0YXJ0VG9BbmdsZSA8IGVuZFRvQW5nbGUpO1xufVxuXG4vKipcbiAqIExpbWl0IGB2YWx1ZWAgYmV0d2VlbiBgbWluYCBhbmQgYG1heGBcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9saW1pdFZhbHVlKHZhbHVlOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ludDE2UmFuZ2UodmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gX2xpbWl0VmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIHN0YXJ0XG4gKiBAcGFyYW0gZW5kXG4gKiBAcGFyYW0gW2Vwc2lsb25dXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2lzQmV0d2Vlbih2YWx1ZTogbnVtYmVyLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgZXBzaWxvbiA9IDFlLTYpIHtcbiAgcmV0dXJuIHZhbHVlID49IE1hdGgubWluKHN0YXJ0LCBlbmQpIC0gZXBzaWxvbiAmJiB2YWx1ZSA8PSBNYXRoLm1heChzdGFydCwgZW5kKSArIGVwc2lsb247XG59XG4iLCAiaW1wb3J0IHtfY2FwaXRhbGl6ZX0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIGNtcFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9sb29rdXAoXG4gIHRhYmxlOiBudW1iZXJbXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wPzogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbik6IHtsbzogbnVtYmVyLCBoaTogbnVtYmVyfTtcbmV4cG9ydCBmdW5jdGlvbiBfbG9va3VwPFQ+KFxuICB0YWJsZTogVFtdLFxuICB2YWx1ZTogbnVtYmVyLFxuICBjbXA6ICh2YWx1ZTogbnVtYmVyKSA9PiBib29sZWFuXG4pOiB7bG86IG51bWJlciwgaGk6IG51bWJlcn07XG5leHBvcnQgZnVuY3Rpb24gX2xvb2t1cChcbiAgdGFibGU6IHVua25vd25bXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wPzogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbikge1xuICBjbXAgPSBjbXAgfHwgKChpbmRleCkgPT4gdGFibGVbaW5kZXhdIDwgdmFsdWUpO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgbG8gPSAwO1xuICBsZXQgbWlkOiBudW1iZXI7XG5cbiAgd2hpbGUgKGhpIC0gbG8gPiAxKSB7XG4gICAgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgaWYgKGNtcChtaWQpKSB7XG4gICAgICBsbyA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtsbywgaGl9O1xufVxuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcGFyYW0gbGFzdCAtIGxvb2t1cCBsYXN0IGluZGV4XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX2xvb2t1cEJ5S2V5ID0gKFxuICB0YWJsZTogUmVjb3JkPHN0cmluZywgbnVtYmVyPltdLFxuICBrZXk6IHN0cmluZyxcbiAgdmFsdWU6IG51bWJlcixcbiAgbGFzdD86IGJvb2xlYW5cbikgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGxhc3RcbiAgICA/IGluZGV4ID0+IHtcbiAgICAgIGNvbnN0IHRpID0gdGFibGVbaW5kZXhdW2tleV07XG4gICAgICByZXR1cm4gdGkgPCB2YWx1ZSB8fCB0aSA9PT0gdmFsdWUgJiYgdGFibGVbaW5kZXggKyAxXVtrZXldID09PSB2YWx1ZTtcbiAgICB9XG4gICAgOiBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA8IHZhbHVlKTtcblxuLyoqXG4gKiBSZXZlcnNlIGJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX3Jsb29rdXBCeUtleSA9IChcbiAgdGFibGU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAga2V5OiBzdHJpbmcsXG4gIHZhbHVlOiBudW1iZXJcbikgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldID49IHZhbHVlKTtcblxuLyoqXG4gKiBSZXR1cm4gc3Vic2V0IG9mIGB2YWx1ZXNgIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIGluY2x1c2l2ZS5cbiAqIFZhbHVlcyBhcmUgYXNzdW1lZCB0byBiZSBpbiBzb3J0ZWQgb3JkZXIuXG4gKiBAcGFyYW0gdmFsdWVzIC0gc29ydGVkIGFycmF5IG9mIHZhbHVlc1xuICogQHBhcmFtIG1pbiAtIG1pbiB2YWx1ZVxuICogQHBhcmFtIG1heCAtIG1heCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ZpbHRlckJldHdlZW4odmFsdWVzOiBudW1iZXJbXSwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChzdGFydCA8IGVuZCAmJiB2YWx1ZXNbc3RhcnRdIDwgbWluKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgdmFsdWVzW2VuZCAtIDFdID4gbWF4KSB7XG4gICAgZW5kLS07XG4gIH1cblxuICByZXR1cm4gc3RhcnQgPiAwIHx8IGVuZCA8IHZhbHVlcy5sZW5ndGhcbiAgICA/IHZhbHVlcy5zbGljZShzdGFydCwgZW5kKVxuICAgIDogdmFsdWVzO1xufVxuXG5jb25zdCBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSBhcyBjb25zdDtcblxuZXhwb3J0IGludGVyZmFjZSBBcnJheUxpc3RlbmVyPFQ+IHtcbiAgX29uRGF0YVB1c2g/KC4uLml0ZW06IFRbXSk6IHZvaWQ7XG4gIF9vbkRhdGFQb3A/KCk6IHZvaWQ7XG4gIF9vbkRhdGFTaGlmdD8oKTogdm9pZDtcbiAgX29uRGF0YVNwbGljZT8oaW5kZXg6IG51bWJlciwgZGVsZXRlQ291bnQ6IG51bWJlciwgLi4uaXRlbXM6IFRbXSk6IHZvaWQ7XG4gIF9vbkRhdGFVbnNoaWZ0PyguLi5pdGVtOiBUW10pOiB2b2lkO1xufVxuXG4vKipcbiAqIEhvb2tzIHRoZSBhcnJheSBtZXRob2RzIHRoYXQgYWRkIG9yIHJlbW92ZSB2YWx1ZXMgKCdwdXNoJywgcG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsXG4gKiAndW5zaGlmdCcpIGFuZCBub3RpZnkgdGhlIGxpc3RlbmVyIEFGVEVSIHRoZSBhcnJheSBoYXMgYmVlbiBhbHRlcmVkLiBMaXN0ZW5lcnMgYXJlXG4gKiBjYWxsZWQgb24gdGhlICdfb25EYXRhKicgY2FsbGJhY2tzIChlLmcuIF9vbkRhdGFQdXNoLCBldGMuKSB3aXRoIHNhbWUgYXJndW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHM8VD4oYXJyYXk6IFRbXSwgbGlzdGVuZXI6IEFycmF5TGlzdGVuZXI8VD4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBpZiAoYXJyYXkuX2NoYXJ0anMpIHtcbiAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB7XG4gICAgICBsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cbiAgICB9XG4gIH0pO1xuXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdfb25EYXRhJyArIF9jYXBpdGFsaXplKGtleSk7XG4gICAgY29uc3QgYmFzZSA9IGFycmF5W2tleV07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJhc2UuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAgICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLmZvckVhY2goKG9iamVjdCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiBhcnJheSBldmVudCBsaXN0ZW5lciBhbmQgY2xlYW51cCBleHRyYSBhdHRhY2hlZCBwcm9wZXJ0aWVzIChzdWNoIGFzXG4gKiB0aGUgX2NoYXJ0anMgc3R1YiBhbmQgb3ZlcnJpZGRlbiBtZXRob2RzKSBpZiBhcnJheSBkb2Vzbid0IGhhdmUgYW55IG1vcmUgbGlzdGVuZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50czxUPihhcnJheTogVFtdLCBsaXN0ZW5lcjogQXJyYXlMaXN0ZW5lcjxUPik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgY29uc3Qgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuICBpZiAoIXN0dWIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcbiAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuXG4gIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGRlbGV0ZSBhcnJheVtrZXldO1xuICB9KTtcblxuICBkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG59XG5cbi8qKlxuICogQHBhcmFtIGl0ZW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYXJyYXlVbmlxdWU8VD4oaXRlbXM6IFRbXSkge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0PFQ+KGl0ZW1zKTtcblxuICBpZiAoc2V0LnNpemUgPT09IGl0ZW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG4iLCAiaW1wb3J0IHR5cGUge0NoYXJ0TWV0YSwgUG9pbnRFbGVtZW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmltcG9ydCB7X2xpbWl0VmFsdWV9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2xvb2t1cEJ5S2V5fSBmcm9tICcuL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZvbnRTdHJpbmcocGl4ZWxTaXplOiBudW1iZXIsIGZvbnRTdHlsZTogc3RyaW5nLCBmb250RmFtaWx5OiBzdHJpbmcpIHtcbiAgcmV0dXJuIGZvbnRTdHlsZSArICcgJyArIHBpeGVsU2l6ZSArICdweCAnICsgZm9udEZhbWlseTtcbn1cblxuLyoqXG4qIFJlcXVlc3QgYW5pbWF0aW9uIHBvbHlmaWxsXG4qL1xuZXhwb3J0IGNvbnN0IHJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbn0oKSk7XG5cbi8qKlxuICogVGhyb3R0bGVzIGNhbGxpbmcgYGZuYCBvbmNlIHBlciBhbmltYXRpb24gZnJhbWVcbiAqIExhdGVzdCBhcmd1bWVudHMgYXJlIHVzZWQgb24gdGhlIGFjdHVhbCBjYWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZWQ8VEFyZ3MgZXh0ZW5kcyBBcnJheTxhbnk+PihcbiAgZm46ICguLi5hcmdzOiBUQXJncykgPT4gdm9pZCxcbiAgdGhpc0FyZzogYW55LFxuKSB7XG4gIGxldCBhcmdzVG9Vc2UgPSBbXSBhcyBUQXJncztcbiAgbGV0IHRpY2tpbmcgPSBmYWxzZTtcblxuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJnczogVEFyZ3MpIHtcbiAgICAvLyBTYXZlIHRoZSBhcmdzIGZvciB1c2UgbGF0ZXJcbiAgICBhcmdzVG9Vc2UgPSBhcmdzO1xuICAgIGlmICghdGlja2luZykge1xuICAgICAgdGlja2luZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICAgIHRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJnc1RvVXNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBEZWJvdW5jZXMgY2FsbGluZyBgZm5gIGZvciBgZGVsYXlgIG1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZTxUQXJncyBleHRlbmRzIEFycmF5PGFueT4+KGZuOiAoLi4uYXJnczogVEFyZ3MpID0+IHZvaWQsIGRlbGF5OiBudW1iZXIpIHtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzOiBUQXJncykge1xuICAgIGlmIChkZWxheSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZm4sIGRlbGF5LCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBkZWxheTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyAnc3RhcnQnIHRvICdsZWZ0JywgJ2VuZCcgdG8gJ3JpZ2h0JyBhbmQgb3RoZXJzIHRvICdjZW50ZXInXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX3RvTGVmdFJpZ2h0Q2VudGVyID0gKGFsaWduOiAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJykgPT4gYWxpZ24gPT09ICdzdGFydCcgPyAnbGVmdCcgOiBhbGlnbiA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2NlbnRlcic7XG5cbi8qKlxuICogUmV0dXJucyBgc3RhcnRgLCBgZW5kYCBvciBgKHN0YXJ0ICsgZW5kKSAvIDJgIGRlcGVuZGluZyBvbiBgYWxpZ25gLiBEZWZhdWx0cyB0byBgY2VudGVyYFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF9hbGlnblN0YXJ0RW5kID0gKGFsaWduOiAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJywgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpID0+IGFsaWduID09PSAnc3RhcnQnID8gc3RhcnQgOiBhbGlnbiA9PT0gJ2VuZCcgPyBlbmQgOiAoc3RhcnQgKyBlbmQpIC8gMjtcblxuLyoqXG4gKiBSZXR1cm5zIGBsZWZ0YCwgYHJpZ2h0YCBvciBgKGxlZnQgKyByaWdodCkgLyAyYCBkZXBlbmRpbmcgb24gYGFsaWduYC4gRGVmYXVsdHMgdG8gYGxlZnRgXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX3RleHRYID0gKGFsaWduOiAnbGVmdCcgfCAncmlnaHQnIHwgJ2NlbnRlcicsIGxlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgcnRsOiBib29sZWFuKSA9PiB7XG4gIGNvbnN0IGNoZWNrID0gcnRsID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgcmV0dXJuIGFsaWduID09PSBjaGVjayA/IHJpZ2h0IDogYWxpZ24gPT09ICdjZW50ZXInID8gKGxlZnQgKyByaWdodCkgLyAyIDogbGVmdDtcbn07XG5cbi8qKlxuICogUmV0dXJuIHN0YXJ0IGFuZCBjb3VudCBvZiB2aXNpYmxlIHBvaW50cy5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhOiBDaGFydE1ldGE8J2xpbmUnIHwgJ3NjYXR0ZXInPiwgcG9pbnRzOiBQb2ludEVsZW1lbnRbXSwgYW5pbWF0aW9uc0Rpc2FibGVkOiBib29sZWFuKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudCA9IHBvaW50Q291bnQ7XG5cbiAgaWYgKG1ldGEuX3NvcnRlZCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgX3BhcnNlZH0gPSBtZXRhO1xuICAgIGNvbnN0IHNwYW5HYXBzID0gbWV0YS5kYXRhc2V0ID8gbWV0YS5kYXRhc2V0Lm9wdGlvbnMgPyBtZXRhLmRhdGFzZXQub3B0aW9ucy5zcGFuR2FwcyA6IG51bGwgOiBudWxsO1xuICAgIGNvbnN0IGF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcblxuICAgIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgICBzdGFydCA9IE1hdGgubWluKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBheGlzLCBtaW4pLmxvLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gZml4IHR5cGVzIG9uIF9sb29rdXBCeUtleVxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyBwb2ludENvdW50IDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWluKSkubG8pO1xuICAgICAgaWYgKHNwYW5HYXBzKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlVG9EZWZpbmVkTG8gPSAoX3BhcnNlZFxuICAgICAgICAgIC5zbGljZSgwLCBzdGFydCArIDEpXG4gICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgIC5maW5kSW5kZXgoXG4gICAgICAgICAgICBwb2ludCA9PiAhaXNOdWxsT3JVbmRlZihwb2ludFt2U2NhbGUuYXhpc10pKSk7XG4gICAgICAgIHN0YXJ0IC09IE1hdGgubWF4KDAsIGRpc3RhbmNlVG9EZWZpbmVkTG8pO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBfbGltaXRWYWx1ZShzdGFydCwgMCwgcG9pbnRDb3VudCAtIDEpO1xuICAgIH1cbiAgICBpZiAobWF4RGVmaW5lZCkge1xuICAgICAgbGV0IGVuZCA9IE1hdGgubWF4KFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBpU2NhbGUuYXhpcywgbWF4LCB0cnVlKS5oaSArIDEsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byBmaXggdHlwZXMgb24gX2xvb2t1cEJ5S2V5XG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IDAgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtYXgpLCB0cnVlKS5oaSArIDEpO1xuICAgICAgaWYgKHNwYW5HYXBzKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlVG9EZWZpbmVkSGkgPSAoX3BhcnNlZFxuICAgICAgICAgIC5zbGljZShlbmQgLSAxKVxuICAgICAgICAgIC5maW5kSW5kZXgoXG4gICAgICAgICAgICBwb2ludCA9PiAhaXNOdWxsT3JVbmRlZihwb2ludFt2U2NhbGUuYXhpc10pKSk7XG4gICAgICAgIGVuZCArPSBNYXRoLm1heCgwLCBkaXN0YW5jZVRvRGVmaW5lZEhpKTtcbiAgICAgIH1cbiAgICAgIGNvdW50ID0gX2xpbWl0VmFsdWUoZW5kLCBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgc2NhbGUgcmFuZ2VzIGhhdmUgY2hhbmdlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhIC0gZGF0YXNldCBtZXRhLlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSB7XG4gIGNvbnN0IHt4U2NhbGUsIHlTY2FsZSwgX3NjYWxlUmFuZ2VzfSA9IG1ldGE7XG4gIGNvbnN0IG5ld1JhbmdlcyA9IHtcbiAgICB4bWluOiB4U2NhbGUubWluLFxuICAgIHhtYXg6IHhTY2FsZS5tYXgsXG4gICAgeW1pbjogeVNjYWxlLm1pbixcbiAgICB5bWF4OiB5U2NhbGUubWF4XG4gIH07XG4gIGlmICghX3NjYWxlUmFuZ2VzKSB7XG4gICAgbWV0YS5fc2NhbGVSYW5nZXMgPSBuZXdSYW5nZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgY2hhbmdlZCA9IF9zY2FsZVJhbmdlcy54bWluICE9PSB4U2NhbGUubWluXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnhtYXggIT09IHhTY2FsZS5tYXhcblx0XHR8fCBfc2NhbGVSYW5nZXMueW1pbiAhPT0geVNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy55bWF4ICE9PSB5U2NhbGUubWF4O1xuXG4gIE9iamVjdC5hc3NpZ24oX3NjYWxlUmFuZ2VzLCBuZXdSYW5nZXMpO1xuICByZXR1cm4gY2hhbmdlZDtcbn1cbiIsICJpbXBvcnQge1BJLCBUQVUsIEhBTEZfUEl9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcblxuY29uc3QgYXRFZGdlID0gKHQ6IG51bWJlcikgPT4gdCA9PT0gMCB8fCB0ID09PSAxO1xuY29uc3QgZWxhc3RpY0luID0gKHQ6IG51bWJlciwgczogbnVtYmVyLCBwOiBudW1iZXIpID0+IC0oTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkpO1xuY29uc3QgZWxhc3RpY091dCA9ICh0OiBudW1iZXIsIHM6IG51bWJlciwgcDogbnVtYmVyKSA9PiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSArIDE7XG5cbi8qKlxuICogRWFzaW5nIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb20gUm9iZXJ0IFBlbm5lcidzIGVhc2luZyBlcXVhdGlvbnMuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuZWFzaW5nLmVmZmVjdHNcbiAqIEBzZWUgaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2luZy9cbiAqL1xuY29uc3QgZWZmZWN0cyA9IHtcbiAgbGluZWFyOiAodDogbnVtYmVyKSA9PiB0LFxuXG4gIGVhc2VJblF1YWQ6ICh0OiBudW1iZXIpID0+IHQgKiB0LFxuXG4gIGVhc2VPdXRRdWFkOiAodDogbnVtYmVyKSA9PiAtdCAqICh0IC0gMiksXG5cbiAgZWFzZUluT3V0UXVhZDogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHRcbiAgICA6IC0wLjUgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSksXG5cbiAgZWFzZUluQ3ViaWM6ICh0OiBudW1iZXIpID0+IHQgKiB0ICogdCxcblxuICBlYXNlT3V0Q3ViaWM6ICh0OiBudW1iZXIpID0+ICh0IC09IDEpICogdCAqIHQgKyAxLFxuXG4gIGVhc2VJbk91dEN1YmljOiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICsgMiksXG5cbiAgZWFzZUluUXVhcnQ6ICh0OiBudW1iZXIpID0+IHQgKiB0ICogdCAqIHQsXG5cbiAgZWFzZU91dFF1YXJ0OiAodDogbnVtYmVyKSA9PiAtKCh0IC09IDEpICogdCAqIHQgKiB0IC0gMSksXG5cbiAgZWFzZUluT3V0UXVhcnQ6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdCAqIHRcbiAgICA6IC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKSxcblxuICBlYXNlSW5RdWludDogKHQ6IG51bWJlcikgPT4gdCAqIHQgKiB0ICogdCAqIHQsXG5cbiAgZWFzZU91dFF1aW50OiAodDogbnVtYmVyKSA9PiAodCAtPSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxLFxuXG4gIGVhc2VJbk91dFF1aW50OiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0ICogdFxuICAgIDogMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpLFxuXG4gIGVhc2VJblNpbmU6ICh0OiBudW1iZXIpID0+IC1NYXRoLmNvcyh0ICogSEFMRl9QSSkgKyAxLFxuXG4gIGVhc2VPdXRTaW5lOiAodDogbnVtYmVyKSA9PiBNYXRoLnNpbih0ICogSEFMRl9QSSksXG5cbiAgZWFzZUluT3V0U2luZTogKHQ6IG51bWJlcikgPT4gLTAuNSAqIChNYXRoLmNvcyhQSSAqIHQpIC0gMSksXG5cbiAgZWFzZUluRXhwbzogKHQ6IG51bWJlcikgPT4gKHQgPT09IDApID8gMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSksXG5cbiAgZWFzZU91dEV4cG86ICh0OiBudW1iZXIpID0+ICh0ID09PSAxKSA/IDEgOiAtTWF0aC5wb3coMiwgLTEwICogdCkgKyAxLFxuXG4gIGVhc2VJbk91dEV4cG86ICh0OiBudW1iZXIpID0+IGF0RWRnZSh0KSA/IHQgOiB0IDwgMC41XG4gICAgPyAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0ICogMiAtIDEpKVxuICAgIDogMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAodCAqIDIgLSAxKSkgKyAyKSxcblxuICBlYXNlSW5DaXJjOiAodDogbnVtYmVyKSA9PiAodCA+PSAxKSA/IHQgOiAtKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSksXG5cbiAgZWFzZU91dENpcmM6ICh0OiBudW1iZXIpID0+IE1hdGguc3FydCgxIC0gKHQgLT0gMSkgKiB0KSxcblxuICBlYXNlSW5PdXRDaXJjOiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSlcbiAgICA6IDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSxcblxuICBlYXNlSW5FbGFzdGljOiAodDogbnVtYmVyKSA9PiBhdEVkZ2UodCkgPyB0IDogZWxhc3RpY0luKHQsIDAuMDc1LCAwLjMpLFxuXG4gIGVhc2VPdXRFbGFzdGljOiAodDogbnVtYmVyKSA9PiBhdEVkZ2UodCkgPyB0IDogZWxhc3RpY091dCh0LCAwLjA3NSwgMC4zKSxcblxuICBlYXNlSW5PdXRFbGFzdGljKHQ6IG51bWJlcikge1xuICAgIGNvbnN0IHMgPSAwLjExMjU7XG4gICAgY29uc3QgcCA9IDAuNDU7XG4gICAgcmV0dXJuIGF0RWRnZSh0KSA/IHQgOlxuICAgICAgdCA8IDAuNVxuICAgICAgICA/IDAuNSAqIGVsYXN0aWNJbih0ICogMiwgcywgcClcbiAgICAgICAgOiAwLjUgKyAwLjUgKiBlbGFzdGljT3V0KHQgKiAyIC0gMSwgcywgcCk7XG4gIH0sXG5cbiAgZWFzZUluQmFjayh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbiAgfSxcblxuICBlYXNlT3V0QmFjayh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gKHQgLT0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xuICB9LFxuXG4gIGVhc2VJbk91dEJhY2sodDogbnVtYmVyKSB7XG4gICAgbGV0IHMgPSAxLjcwMTU4O1xuICAgIGlmICgodCAvPSAwLjUpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSk7XG4gICAgfVxuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMik7XG4gIH0sXG5cbiAgZWFzZUluQm91bmNlOiAodDogbnVtYmVyKSA9PiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KSxcblxuICBlYXNlT3V0Qm91bmNlKHQ6IG51bWJlcikge1xuICAgIGNvbnN0IG0gPSA3LjU2MjU7XG4gICAgY29uc3QgZCA9IDIuNzU7XG4gICAgaWYgKHQgPCAoMSAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqIHQgKiB0O1xuICAgIH1cbiAgICBpZiAodCA8ICgyIC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDEuNSAvIGQpKSAqIHQgKyAwLjc1O1xuICAgIH1cbiAgICBpZiAodCA8ICgyLjUgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiAodCAtPSAoMi4yNSAvIGQpKSAqIHQgKyAwLjkzNzU7XG4gICAgfVxuICAgIHJldHVybiBtICogKHQgLT0gKDIuNjI1IC8gZCkpICogdCArIDAuOTg0Mzc1O1xuICB9LFxuXG4gIGVhc2VJbk91dEJvdW5jZTogKHQ6IG51bWJlcikgPT4gKHQgPCAwLjUpXG4gICAgPyBlZmZlY3RzLmVhc2VJbkJvdW5jZSh0ICogMikgKiAwLjVcbiAgICA6IGVmZmVjdHMuZWFzZU91dEJvdW5jZSh0ICogMiAtIDEpICogMC41ICsgMC41LFxufSBhcyBjb25zdDtcblxuZXhwb3J0IHR5cGUgRWFzaW5nRnVuY3Rpb24gPSBrZXlvZiB0eXBlb2YgZWZmZWN0c1xuXG5leHBvcnQgZGVmYXVsdCBlZmZlY3RzO1xuIiwgImltcG9ydCB7Q29sb3J9IGZyb20gJ0BrdXJrbGUvY29sb3InO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIENhbnZhc1BhdHRlcm4gfCBDYW52YXNHcmFkaWVudCB7XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgdHlwZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJyB8fCB0eXBlID09PSAnW29iamVjdCBDYW52YXNHcmFkaWVudF0nO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29sb3IodmFsdWU6IENhbnZhc0dyYWRpZW50KTogQ2FudmFzR3JhZGllbnQ7XG5leHBvcnQgZnVuY3Rpb24gY29sb3IodmFsdWU6IENhbnZhc1BhdHRlcm4pOiBDYW52YXNQYXR0ZXJuO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKFxuICB2YWx1ZTpcbiAgfCBzdHJpbmdcbiAgfCB7IHI6IG51bWJlcjsgZzogbnVtYmVyOyBiOiBudW1iZXI7IGE6IG51bWJlciB9XG4gIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdXG4gIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl1cbik6IENvbG9yO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSA/IHZhbHVlIDogbmV3IENvbG9yKHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IENhbnZhc0dyYWRpZW50KTogQ2FudmFzR3JhZGllbnQ7XG5leHBvcnQgZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZTogQ2FudmFzUGF0dGVybik6IENhbnZhc1BhdHRlcm47XG5leHBvcnQgZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZTogc3RyaW5nKTogc3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpXG4gICAgPyB2YWx1ZVxuICAgIDogbmV3IENvbG9yKHZhbHVlKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLmhleFN0cmluZygpO1xufVxuIiwgImNvbnN0IG51bWJlcnMgPSBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnLCAndGVuc2lvbiddO1xuY29uc3QgY29sb3JzID0gWydjb2xvcicsICdib3JkZXJDb2xvcicsICdiYWNrZ3JvdW5kQ29sb3InXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5QW5pbWF0aW9uc0RlZmF1bHRzKGRlZmF1bHRzKSB7XG4gIGRlZmF1bHRzLnNldCgnYW5pbWF0aW9uJywge1xuICAgIGRlbGF5OiB1bmRlZmluZWQsXG4gICAgZHVyYXRpb246IDEwMDAsXG4gICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgICBmbjogdW5kZWZpbmVkLFxuICAgIGZyb206IHVuZGVmaW5lZCxcbiAgICBsb29wOiB1bmRlZmluZWQsXG4gICAgdG86IHVuZGVmaW5lZCxcbiAgICB0eXBlOiB1bmRlZmluZWQsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb24nLCB7XG4gICAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdvblByb2dyZXNzJyAmJiBuYW1lICE9PSAnb25Db21wbGV0ZScgJiYgbmFtZSAhPT0gJ2ZuJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuc2V0KCdhbmltYXRpb25zJywge1xuICAgIGNvbG9yczoge1xuICAgICAgdHlwZTogJ2NvbG9yJyxcbiAgICAgIHByb3BlcnRpZXM6IGNvbG9yc1xuICAgIH0sXG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBudW1iZXJzXG4gICAgfSxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbnMnLCB7XG4gICAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuc2V0KCd0cmFuc2l0aW9ucycsIHtcbiAgICBhY3RpdmU6IHtcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICBkdXJhdGlvbjogNDAwXG4gICAgICB9XG4gICAgfSxcbiAgICByZXNpemU6IHtcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgfVxuICAgIH0sXG4gICAgc2hvdzoge1xuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICBmcm9tOiAndHJhbnNwYXJlbnQnXG4gICAgICAgIH0sXG4gICAgICAgIHZpc2libGU6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZHVyYXRpb246IDAgLy8gc2hvdyBpbW1lZGlhdGVseVxuICAgICAgICB9LFxuICAgICAgfVxuICAgIH0sXG4gICAgaGlkZToge1xuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICB0bzogJ3RyYW5zcGFyZW50J1xuICAgICAgICB9LFxuICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgICAgZm46IHYgPT4gdiB8IDAgLy8gZm9yIGtlZXBpbmcgdGhlIGRhdGFzZXQgdmlzaWJsZSBhbGwgdGhlIHdheSB0aHJvdWdoIHRoZSBhbmltYXRpb25cbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBhcHBseUxheW91dHNEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ2xheW91dCcsIHtcbiAgICBhdXRvUGFkZGluZzogdHJ1ZSxcbiAgICBwYWRkaW5nOiB7XG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6IDBcbiAgICB9XG4gIH0pO1xufVxuIiwgIlxuY29uc3QgaW50bENhY2hlID0gbmV3IE1hcDxzdHJpbmcsIEludGwuTnVtYmVyRm9ybWF0PigpO1xuXG5mdW5jdGlvbiBnZXROdW1iZXJGb3JtYXQobG9jYWxlOiBzdHJpbmcsIG9wdGlvbnM/OiBJbnRsLk51bWJlckZvcm1hdE9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGNhY2hlS2V5ID0gbG9jYWxlICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gIGxldCBmb3JtYXR0ZXIgPSBpbnRsQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFmb3JtYXR0ZXIpIHtcbiAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICBpbnRsQ2FjaGUuc2V0KGNhY2hlS2V5LCBmb3JtYXR0ZXIpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtOiBudW1iZXIsIGxvY2FsZTogc3RyaW5nLCBvcHRpb25zPzogSW50bC5OdW1iZXJGb3JtYXRPcHRpb25zKSB7XG4gIHJldHVybiBnZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQobnVtKTtcbn1cbiIsICJpbXBvcnQge2lzQXJyYXl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5pbXBvcnQge2xvZzEwfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cbi8qKlxuICogTmFtZXNwYWNlIHRvIGhvbGQgZm9ybWF0dGVycyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHRpY2tzXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnNcbiAqL1xuY29uc3QgZm9ybWF0dGVycyA9IHtcbiAgLyoqXG4gICAqIEZvcm1hdHRlciBmb3IgdmFsdWUgbGFiZWxzXG4gICAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy52YWx1ZXNcbiAgICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBkaXNwbGF5XG4gICAqIEByZXR1cm4ge3N0cmluZ3xzdHJpbmdbXX0gdGhlIGxhYmVsIHRvIGRpc3BsYXlcbiAgICovXG4gIHZhbHVlcyh2YWx1ZSkge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IC8qKiBAdHlwZSB7c3RyaW5nW119ICovICh2YWx1ZSkgOiAnJyArIHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JtYXR0ZXIgZm9yIG51bWVyaWMgdGlja3NcbiAgICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgICogQHBhcmFtIHRpY2tWYWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4gICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXIgaW4gdGhlIHRpY2tzIGFycmF5XG4gICAqIEBwYXJhbSB0aWNrcyB7b2JqZWN0W119IHRoZSBsaXN0IG9mIHRpY2tzIGJlaW5nIGNvbnZlcnRlZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlclxuICAgKi9cbiAgbnVtZXJpYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7IC8vIG5ldmVyIHNob3cgZGVjaW1hbCBwbGFjZXMgZm9yIDBcbiAgICB9XG5cbiAgICBjb25zdCBsb2NhbGUgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlO1xuICAgIGxldCBub3RhdGlvbjtcbiAgICBsZXQgZGVsdGEgPSB0aWNrVmFsdWU7IC8vIFRoaXMgaXMgdXNlZCB3aGVuIHRoZXJlIGFyZSBsZXNzIHRoYW4gMiB0aWNrcyBhcyB0aGUgdGljayBpbnRlcnZhbC5cblxuICAgIGlmICh0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBhbGwgdGlja3MgYXJlIHNtYWxsIG9yIHRoZXJlIGh1Z2UgbnVtYmVyczsgdXNlIHNjaWVudGlmaWMgbm90YXRpb25cbiAgICAgIGNvbnN0IG1heFRpY2sgPSBNYXRoLm1heChNYXRoLmFicyh0aWNrc1swXS52YWx1ZSksIE1hdGguYWJzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlKSk7XG4gICAgICBpZiAobWF4VGljayA8IDFlLTQgfHwgbWF4VGljayA+IDFlKzE1KSB7XG4gICAgICAgIG5vdGF0aW9uID0gJ3NjaWVudGlmaWMnO1xuICAgICAgfVxuXG4gICAgICBkZWx0YSA9IGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvZ0RlbHRhID0gbG9nMTAoTWF0aC5hYnMoZGVsdGEpKTtcblxuICAgIC8vIFdoZW4gZGF0YXNldHMgaGF2ZSB2YWx1ZXMgYXBwcm9hY2hpbmcgTnVtYmVyLk1BWF9WQUxVRSwgdGhlIHRpY2sgY2FsY3VsYXRpb25zIG1pZ2h0IHJlc3VsdCBpblxuICAgIC8vIGluZmluaXR5IGFuZCBldmVudHVhbGx5IE5hTi4gUGFzc2luZyBOYU4gZm9yIG1pbmltdW1GcmFjdGlvbkRpZ2l0cyBvciBtYXhpbXVtRnJhY3Rpb25EaWdpdHNcbiAgICAvLyB3aWxsIG1ha2UgdGhlIG51bWJlciBmb3JtYXR0ZXIgdGhyb3cuIFNvIGluc3RlYWQgd2UgY2hlY2sgZm9yIGlzTmFOIGFuZCB1c2UgYSBmYWxsYmFjayB2YWx1ZS5cbiAgICAvL1xuICAgIC8vIHRvRml4ZWQgaGFzIGEgbWF4IG9mIDIwIGRlY2ltYWwgcGxhY2VzXG4gICAgY29uc3QgbnVtRGVjaW1hbCA9IGlzTmFOKGxvZ0RlbHRhKSA/IDEgOiBNYXRoLm1heChNYXRoLm1pbigtMSAqIE1hdGguZmxvb3IobG9nRGVsdGEpLCAyMCksIDApO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtub3RhdGlvbiwgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWx9O1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG5cbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHRpY2tWYWx1ZSwgbG9jYWxlLCBvcHRpb25zKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBGb3JtYXR0ZXIgZm9yIGxvZ2FyaXRobWljIHRpY2tzXG4gICAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pY1xuICAgKiBAcGFyYW0gdGlja1ZhbHVlIHtudW1iZXJ9IHRoZSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWRcbiAgICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlciBpbiB0aGUgdGlja3MgYXJyYXlcbiAgICogQHBhcmFtIHRpY2tzIHtvYmplY3RbXX0gdGhlIGxpc3Qgb2YgdGlja3MgYmVpbmcgY29udmVydGVkXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyXG4gICAqL1xuICBsb2dhcml0aG1pYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbiA9IHRpY2tzW2luZGV4XS5zaWduaWZpY2FuZCB8fCAodGlja1ZhbHVlIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWx1ZSkpKSkpO1xuICAgIGlmIChbMSwgMiwgMywgNSwgMTAsIDE1XS5pbmNsdWRlcyhyZW1haW4pIHx8IGluZGV4ID4gMC44ICogdGlja3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5udW1lcmljLmNhbGwodGhpcywgdGlja1ZhbHVlLCBpbmRleCwgdGlja3MpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxufTtcblxuXG5mdW5jdGlvbiBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKSB7XG4gIC8vIEZpZ3VyZSBvdXQgaG93IG1hbnkgZGlnaXRzIHRvIHNob3dcbiAgLy8gVGhlIHNwYWNlIGJldHdlZW4gdGhlIGZpcnN0IHR3byB0aWNrcyBtaWdodCBiZSBzbWFsbGVyIHRoYW4gbm9ybWFsIHNwYWNpbmdcbiAgbGV0IGRlbHRhID0gdGlja3MubGVuZ3RoID4gMyA/IHRpY2tzWzJdLnZhbHVlIC0gdGlja3NbMV0udmFsdWUgOiB0aWNrc1sxXS52YWx1ZSAtIHRpY2tzWzBdLnZhbHVlO1xuXG4gIC8vIElmIHdlIGhhdmUgYSBudW1iZXIgbGlrZSAyLjUgYXMgdGhlIGRlbHRhLCBmaWd1cmUgb3V0IGhvdyBtYW55IGRlY2ltYWwgcGxhY2VzIHdlIG5lZWRcbiAgaWYgKE1hdGguYWJzKGRlbHRhKSA+PSAxICYmIHRpY2tWYWx1ZSAhPT0gTWF0aC5mbG9vcih0aWNrVmFsdWUpKSB7XG4gICAgLy8gbm90IGFuIGludGVnZXJcbiAgICBkZWx0YSA9IHRpY2tWYWx1ZSAtIE1hdGguZmxvb3IodGlja1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG5cbi8qKlxuICogTmFtZXNwYWNlIHRvIGhvbGQgc3RhdGljIHRpY2sgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3NcbiAqL1xuZXhwb3J0IGRlZmF1bHQge2Zvcm1hdHRlcnN9O1xuIiwgImltcG9ydCBUaWNrcyBmcm9tICcuL2NvcmUudGlja3MuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTY2FsZURlZmF1bHRzKGRlZmF1bHRzKSB7XG4gIGRlZmF1bHRzLnNldCgnc2NhbGUnLCB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBvZmZzZXQ6IGZhbHNlLFxuICAgIHJldmVyc2U6IGZhbHNlLFxuICAgIGJlZ2luQXRaZXJvOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIGJvdW5kYXJ5IHN0cmF0ZWd5IChieXBhc3NlZCBieSBtaW4vbWF4IHRpbWUgb3B0aW9ucylcbiAgICAgKiAtIGBkYXRhYDogbWFrZSBzdXJlIGRhdGEgYXJlIGZ1bGx5IHZpc2libGUsIHRpY2tzIG91dHNpZGUgYXJlIHJlbW92ZWRcbiAgICAgKiAtIGB0aWNrc2A6IG1ha2Ugc3VyZSB0aWNrcyBhcmUgZnVsbHkgdmlzaWJsZSwgZGF0YSBvdXRzaWRlIGFyZSB0cnVuY2F0ZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU1NlxuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqL1xuICAgIGJvdW5kczogJ3RpY2tzJyxcblxuICAgIGNsaXA6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBBZGRpdGlvbiBncmFjZSBhZGRlZCB0byBtYXggYW5kIHJlZHVjZWQgZnJvbSBtaW4gZGF0YSB2YWx1ZS5cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKi9cbiAgICBncmFjZTogMCxcblxuICAgIC8vIGdyaWQgbGluZSBzZXR0aW5nc1xuICAgIGdyaWQ6IHtcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICBkcmF3T25DaGFydEFyZWE6IHRydWUsXG4gICAgICBkcmF3VGlja3M6IHRydWUsXG4gICAgICB0aWNrTGVuZ3RoOiA4LFxuICAgICAgdGlja1dpZHRoOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5saW5lV2lkdGgsXG4gICAgICB0aWNrQ29sb3I6IChfY3R4LCBvcHRpb25zKSA9PiBvcHRpb25zLmNvbG9yLFxuICAgICAgb2Zmc2V0OiBmYWxzZSxcbiAgICB9LFxuXG4gICAgYm9yZGVyOiB7XG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgZGFzaDogW10sXG4gICAgICBkYXNoT2Zmc2V0OiAwLjAsXG4gICAgICB3aWR0aDogMVxuICAgIH0sXG5cbiAgICAvLyBzY2FsZSB0aXRsZVxuICAgIHRpdGxlOiB7XG4gICAgICAvLyBkaXNwbGF5IHByb3BlcnR5XG4gICAgICBkaXNwbGF5OiBmYWxzZSxcblxuICAgICAgLy8gYWN0dWFsIGxhYmVsXG4gICAgICB0ZXh0OiAnJyxcblxuICAgICAgLy8gdG9wL2JvdHRvbSBwYWRkaW5nXG4gICAgICBwYWRkaW5nOiB7XG4gICAgICAgIHRvcDogNCxcbiAgICAgICAgYm90dG9tOiA0XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIGxhYmVsIHNldHRpbmdzXG4gICAgdGlja3M6IHtcbiAgICAgIG1pblJvdGF0aW9uOiAwLFxuICAgICAgbWF4Um90YXRpb246IDUwLFxuICAgICAgbWlycm9yOiBmYWxzZSxcbiAgICAgIHRleHRTdHJva2VXaWR0aDogMCxcbiAgICAgIHRleHRTdHJva2VDb2xvcjogJycsXG4gICAgICBwYWRkaW5nOiAzLFxuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGF1dG9Ta2lwOiB0cnVlLFxuICAgICAgYXV0b1NraXBQYWRkaW5nOiAzLFxuICAgICAgbGFiZWxPZmZzZXQ6IDAsXG4gICAgICAvLyBXZSBwYXNzIHRocm91Z2ggYXJyYXlzIHRvIGJlIHJlbmRlcmVkIGFzIG11bHRpbGluZSBsYWJlbHMsIHdlIGNvbnZlcnQgT3RoZXJzIHRvIHN0cmluZ3MgaGVyZS5cbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLnZhbHVlcyxcbiAgICAgIG1pbm9yOiB7fSxcbiAgICAgIG1ham9yOiB7fSxcbiAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgIGNyb3NzQWxpZ246ICduZWFyJyxcblxuICAgICAgc2hvd0xhYmVsQmFja2Ryb3A6IGZhbHNlLFxuICAgICAgYmFja2Ryb3BDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSknLFxuICAgICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuICAgIH1cbiAgfSk7XG5cbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLnRpY2tzJywgJ2NvbG9yJywgJycsICdjb2xvcicpO1xuICBkZWZhdWx0cy5yb3V0ZSgnc2NhbGUuZ3JpZCcsICdjb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLmJvcmRlcicsICdjb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLnRpdGxlJywgJ2NvbG9yJywgJycsICdjb2xvcicpO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZScsIHtcbiAgICBfZmFsbGJhY2s6IGZhbHNlLFxuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnYmVmb3JlJykgJiYgIW5hbWUuc3RhcnRzV2l0aCgnYWZ0ZXInKSAmJiBuYW1lICE9PSAnY2FsbGJhY2snICYmIG5hbWUgIT09ICdwYXJzZXInLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ3RpY2tCb3JkZXJEYXNoJyAmJiBuYW1lICE9PSAnZGFzaCcsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZXMnLCB7XG4gICAgX2ZhbGxiYWNrOiAnc2NhbGUnLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUudGlja3MnLCB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyAmJiBuYW1lICE9PSAnY2FsbGJhY2snLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyxcbiAgfSk7XG59XG4iLCAiaW1wb3J0IHtnZXRIb3ZlckNvbG9yfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sb3IuanMnO1xuaW1wb3J0IHtpc09iamVjdCwgbWVyZ2UsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2FwcGx5QW5pbWF0aW9uc0RlZmF1bHRzfSBmcm9tICcuL2NvcmUuYW5pbWF0aW9ucy5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2FwcGx5TGF5b3V0c0RlZmF1bHRzfSBmcm9tICcuL2NvcmUubGF5b3V0cy5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2FwcGx5U2NhbGVEZWZhdWx0c30gZnJvbSAnLi9jb3JlLnNjYWxlLmRlZmF1bHRzLmpzJztcblxuZXhwb3J0IGNvbnN0IG92ZXJyaWRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5leHBvcnQgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNjb3BlKG5vZGUsIGtleSkge1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgIG5vZGUgPSBub2RlW2tdIHx8IChub2RlW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIHNldChyb290LCBzY29wZSwgdmFsdWVzKSB7XG4gIGlmICh0eXBlb2Ygc2NvcGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1lcmdlKGdldFNjb3BlKHJvb3QsIHNjb3BlKSwgdmFsdWVzKTtcbiAgfVxuICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUocm9vdCwgJycpLCBzY29wZSk7XG59XG5cbi8qKlxuICogUGxlYXNlIHVzZSB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQgd2hpY2ggcHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIE5vdGU6IGNsYXNzIGlzIGV4cG9ydGVkIGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0cyB7XG4gIGNvbnN0cnVjdG9yKF9kZXNjcmlwdG9ycywgX2FwcGxpZXJzKSB7XG4gICAgdGhpcy5hbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5jb2xvciA9ICcjNjY2JztcbiAgICB0aGlzLmRhdGFzZXRzID0ge307XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvID0gKGNvbnRleHQpID0+IGNvbnRleHQuY2hhcnQucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLmV2ZW50cyA9IFtcbiAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgJ21vdXNlb3V0JyxcbiAgICAgICdjbGljaycsXG4gICAgICAndG91Y2hzdGFydCcsXG4gICAgICAndG91Y2htb3ZlJ1xuICAgIF07XG4gICAgdGhpcy5mb250ID0ge1xuICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG4gICAgICBzaXplOiAxMixcbiAgICAgIHN0eWxlOiAnbm9ybWFsJyxcbiAgICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICAgIHdlaWdodDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5ob3ZlciA9IHt9O1xuICAgIHRoaXMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTtcbiAgICB0aGlzLmhvdmVyQm9yZGVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5jb2xvcik7XG4gICAgdGhpcy5pbmRleEF4aXMgPSAneCc7XG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IHtcbiAgICAgIG1vZGU6ICduZWFyZXN0JyxcbiAgICAgIGludGVyc2VjdDogdHJ1ZSxcbiAgICAgIGluY2x1ZGVJbnZpc2libGU6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLm1haW50YWluQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIHRoaXMub25Ib3ZlciA9IG51bGw7XG4gICAgdGhpcy5vbkNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnBhcnNpbmcgPSB0cnVlO1xuICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2l2ZSA9IHRydWU7XG4gICAgdGhpcy5zY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuc2hvd0xpbmUgPSB0cnVlO1xuICAgIHRoaXMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0cnVlO1xuXG4gICAgdGhpcy5kZXNjcmliZShfZGVzY3JpcHRvcnMpO1xuICAgIHRoaXMuYXBwbHkoX2FwcGxpZXJzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHNjb3BlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzXVxuXHQgKi9cbiAgc2V0KHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KHRoaXMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZVxuXHQgKi9cbiAgZ2V0KHNjb3BlKSB7XG4gICAgcmV0dXJuIGdldFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHNjb3BlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzXVxuXHQgKi9cbiAgZGVzY3JpYmUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQoZGVzY3JpcHRvcnMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG5cbiAgb3ZlcnJpZGUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQob3ZlcnJpZGVzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSb3V0ZXMgdGhlIG5hbWVkIGRlZmF1bHRzIHRvIGZhbGxiYWNrIHRvIGFub3RoZXIgc2NvcGUvbmFtZS5cblx0ICogVGhpcyByb3V0aW5nIGlzIHVzZWZ1bCB3aGVuIHRob3NlIHRhcmdldCB2YWx1ZXMsIGxpa2UgZGVmYXVsdHMuY29sb3IsIGFyZSBjaGFuZ2VkIHJ1bnRpbWUuXG5cdCAqIElmIHRoZSB2YWx1ZXMgd291bGQgYmUgY29waWVkLCB0aGUgcnVudGltZSBjaGFuZ2Ugd291bGQgbm90IHRha2UgZWZmZWN0LiBCeSByb3V0aW5nLCB0aGVcblx0ICogZmFsbGJhY2sgaXMgZXZhbHVhdGVkIGF0IGVhY2ggYWNjZXNzLCBzbyBpdHMgYWx3YXlzIHVwIHRvIGRhdGUuXG5cdCAqXG5cdCAqIEV4YW1wbGU6XG5cdCAqXG5cdCAqIFx0ZGVmYXVsdHMucm91dGUoJ2VsZW1lbnRzLmFyYycsICdiYWNrZ3JvdW5kQ29sb3InLCAnJywgJ2NvbG9yJylcblx0ICogICAtIHJlYWRzIHRoZSBiYWNrZ3JvdW5kQ29sb3IgZnJvbSBkZWZhdWx0cy5jb2xvciB3aGVuIHVuZGVmaW5lZCBsb2NhbGx5XG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZSBTY29wZSB0aGlzIHJvdXRlIGFwcGxpZXMgdG8uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFByb3BlcnR5IG5hbWUgdGhhdCBzaG91bGQgYmUgcm91dGVkIHRvIGRpZmZlcmVudCBuYW1lc3BhY2Ugd2hlbiBub3QgZGVmaW5lZCBoZXJlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0U2NvcGUgVGhlIG5hbWVzcGFjZSB3aGVyZSB0aG9zZSBwcm9wZXJ0aWVzIHNob3VsZCBiZSByb3V0ZWQgdG8uXG5cdCAqIEVtcHR5IHN0cmluZyAoJycpIGlzIHRoZSByb290IG9mIGRlZmF1bHRzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0TmFtZSBUaGUgdGFyZ2V0IG5hbWUgaW4gdGhlIHRhcmdldCBzY29wZSB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJvdXRlZCB0by5cblx0ICovXG4gIHJvdXRlKHNjb3BlLCBuYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSkge1xuICAgIGNvbnN0IHNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUodGhpcywgc2NvcGUpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUodGhpcywgdGFyZ2V0U2NvcGUpO1xuICAgIGNvbnN0IHByaXZhdGVOYW1lID0gJ18nICsgbmFtZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjb3BlT2JqZWN0LCB7XG4gICAgICAvLyBBIHByaXZhdGUgcHJvcGVydHkgaXMgZGVmaW5lZCB0byBob2xkIHRoZSBhY3R1YWwgdmFsdWUsIHdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBzZXQgaW4gaXRzIHNjb3BlIChzZXQgaW4gdGhlIHNldHRlcilcbiAgICAgIFtwcml2YXRlTmFtZV06IHtcbiAgICAgICAgdmFsdWU6IHNjb3BlT2JqZWN0W25hbWVdLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIC8vIFRoZSBhY3R1YWwgcHJvcGVydHkgaXMgZGVmaW5lZCBhcyBnZXR0ZXIvc2V0dGVyIHNvIHdlIGNhbiBkbyB0aGUgcm91dGluZyB3aGVuIHZhbHVlIGlzIG5vdCBsb2NhbGx5IHNldC5cbiAgICAgIFtuYW1lXToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3QgbG9jYWwgPSB0aGlzW3ByaXZhdGVOYW1lXTtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRTY29wZU9iamVjdFt0YXJnZXROYW1lXTtcbiAgICAgICAgICBpZiAoaXNPYmplY3QobG9jYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LCBsb2NhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdChsb2NhbCwgdGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdGhpc1twcml2YXRlTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXBwbHkoYXBwbGllcnMpIHtcbiAgICBhcHBsaWVycy5mb3JFYWNoKChhcHBseSkgPT4gYXBwbHkodGhpcykpO1xuICB9XG59XG5cbi8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGRlZmF1bHQgLyogI19fUFVSRV9fICovIG5ldyBEZWZhdWx0cyh7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdldmVudHMnLFxuICBob3Zlcjoge1xuICAgIF9mYWxsYmFjazogJ2ludGVyYWN0aW9uJ1xuICB9LFxuICBpbnRlcmFjdGlvbjoge1xuICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfVxufSwgW2FwcGx5QW5pbWF0aW9uc0RlZmF1bHRzLCBhcHBseUxheW91dHNEZWZhdWx0cywgYXBwbHlTY2FsZURlZmF1bHRzXSk7XG4iLCAiaW1wb3J0IHR5cGUge1xuICBDaGFydCxcbiAgUG9pbnQsXG4gIEZvbnRTcGVjLFxuICBDYW52YXNGb250U3BlYyxcbiAgUG9pbnRTdHlsZSxcbiAgUmVuZGVyVGV4dE9wdHMsXG4gIEJhY2tkcm9wT3B0aW9uc1xufSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7XG4gIFRSQkwsXG4gIFNwbGluZVBvaW50LFxuICBSb3VuZGVkUmVjdCxcbiAgVFJCTENvcm5lcnNcbn0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNOdWxsT3JVbmRlZn0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtQSSwgVEFVLCBIQUxGX1BJLCBRVUFSVEVSX1BJLCBUV09fVEhJUkRTX1BJLCBSQURfUEVSX0RFR30gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBmb250IG9iamVjdCBpbnRvIGEgQ1NTIGZvbnQgc3RyaW5nLlxuICogQHBhcmFtIGZvbnQgLSBBIGZvbnQgb2JqZWN0LlxuICogQHJldHVybiBUaGUgQ1NTIGZvbnQgc3RyaW5nLiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0ZvbnRTdHJpbmcoZm9udDogRm9udFNwZWMpIHtcbiAgaWYgKCFmb250IHx8IGlzTnVsbE9yVW5kZWYoZm9udC5zaXplKSB8fCBpc051bGxPclVuZGVmKGZvbnQuZmFtaWx5KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcblx0XHQrIGZvbnQuc2l6ZSArICdweCAnXG5cdFx0KyBmb250LmZhbWlseTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX21lYXN1cmVUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgZ2M6IHN0cmluZ1tdLFxuICBsb25nZXN0OiBudW1iZXIsXG4gIHN0cmluZzogc3RyaW5nXG4pIHtcbiAgbGV0IHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXTtcbiAgaWYgKCF0ZXh0V2lkdGgpIHtcbiAgICB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ10gPSBjdHgubWVhc3VyZVRleHQoc3RyaW5nKS53aWR0aDtcbiAgICBnYy5wdXNoKHN0cmluZyk7XG4gIH1cbiAgaWYgKHRleHRXaWR0aCA+IGxvbmdlc3QpIHtcbiAgICBsb25nZXN0ID0gdGV4dFdpZHRoO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuXG50eXBlIFRoaW5nID0gc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbFxudHlwZSBUaGluZ3MgPSAoVGhpbmcgfCBUaGluZ1tdKVtdXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBfbG9uZ2VzdFRleHQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBmb250OiBzdHJpbmcsXG4gIGFycmF5T2ZUaGluZ3M6IFRoaW5ncyxcbiAgY2FjaGU/OiB7ZGF0YT86IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sIGdhcmJhZ2VDb2xsZWN0Pzogc3RyaW5nW10sIGZvbnQ/OiBzdHJpbmd9XG4pIHtcbiAgY2FjaGUgPSBjYWNoZSB8fCB7fTtcbiAgbGV0IGRhdGEgPSBjYWNoZS5kYXRhID0gY2FjaGUuZGF0YSB8fCB7fTtcbiAgbGV0IGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcblxuICBpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xuICAgIGRhdGEgPSBjYWNoZS5kYXRhID0ge307XG4gICAgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IFtdO1xuICAgIGNhY2hlLmZvbnQgPSBmb250O1xuICB9XG5cbiAgY3R4LnNhdmUoKTtcblxuICBjdHguZm9udCA9IGZvbnQ7XG4gIGxldCBsb25nZXN0ID0gMDtcbiAgY29uc3QgaWxlbiA9IGFycmF5T2ZUaGluZ3MubGVuZ3RoO1xuICBsZXQgaTogbnVtYmVyLCBqOiBudW1iZXIsIGpsZW46IG51bWJlciwgdGhpbmc6IFRoaW5nIHwgVGhpbmdbXSwgbmVzdGVkVGhpbmc6IFRoaW5nIHwgVGhpbmdbXTtcbiAgZm9yIChpID0gMDsgaSA8IGlsZW47IGkrKykge1xuICAgIHRoaW5nID0gYXJyYXlPZlRoaW5nc1tpXTtcblxuICAgIC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgIGlmICh0aGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KHRoaW5nKSkge1xuICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCB0aGluZyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHRoaW5nKSkge1xuICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0cyBtZWFzdXJlIGVhY2ggZWxlbWVudFxuICAgICAgLy8gdG8gZG8gbWF5YmUgc2ltcGxpZnkgdGhpcyBmdW5jdGlvbiBhIGJpdCBzbyB3ZSBjYW4gZG8gdGhpcyBtb3JlIHJlY3Vyc2l2ZWx5P1xuICAgICAgZm9yIChqID0gMCwgamxlbiA9IHRoaW5nLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICBuZXN0ZWRUaGluZyA9IHRoaW5nW2pdO1xuICAgICAgICAvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICAgICAgaWYgKG5lc3RlZFRoaW5nICE9PSB1bmRlZmluZWQgJiYgbmVzdGVkVGhpbmcgIT09IG51bGwgJiYgIWlzQXJyYXkobmVzdGVkVGhpbmcpKSB7XG4gICAgICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBuZXN0ZWRUaGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjdHgucmVzdG9yZSgpO1xuXG4gIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgaWYgKGdjTGVuID4gYXJyYXlPZlRoaW5ncy5sZW5ndGgpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47IGkrKykge1xuICAgICAgZGVsZXRlIGRhdGFbZ2NbaV1dO1xuICAgIH1cbiAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFsaWduZWQgcGl4ZWwgdmFsdWUgdG8gYXZvaWQgYW50aS1hbGlhc2luZyBibHVyXG4gKiBAcGFyYW0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0gcGl4ZWwgLSBBIHBpeGVsIHZhbHVlLlxuICogQHBhcmFtIHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50LlxuICogQHJldHVybnMgVGhlIGFsaWduZWQgcGl4ZWwgdmFsdWUuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FsaWduUGl4ZWwoY2hhcnQ6IENoYXJ0LCBwaXhlbDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKSB7XG4gIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbztcbiAgY29uc3QgaGFsZldpZHRoID0gd2lkdGggIT09IDAgPyBNYXRoLm1heCh3aWR0aCAvIDIsIDAuNSkgOiAwO1xuICByZXR1cm4gTWF0aC5yb3VuZCgocGl4ZWwgLSBoYWxmV2lkdGgpICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgaGFsZldpZHRoO1xufVxuXG4vKipcbiAqIENsZWFycyB0aGUgZW50aXJlIGNhbnZhcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQ2FudmFzKGNhbnZhcz86IEhUTUxDYW52YXNFbGVtZW50LCBjdHg/OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgaWYgKCFjdHggJiYgIWNhbnZhcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eCA9IGN0eCB8fCBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICBjdHguc2F2ZSgpO1xuICAvLyBjYW52YXMud2lkdGggYW5kIGNhbnZhcy5oZWlnaHQgZG8gbm90IGNvbnNpZGVyIHRoZSBjYW52YXMgdHJhbnNmb3JtLFxuICAvLyB3aGlsZSBjbGVhclJlY3QgZG9lc1xuICBjdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERyYXdQb2ludE9wdGlvbnMge1xuICBwb2ludFN0eWxlOiBQb2ludFN0eWxlO1xuICByb3RhdGlvbj86IG51bWJlcjtcbiAgcmFkaXVzOiBudW1iZXI7XG4gIGJvcmRlcldpZHRoOiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3UG9pbnQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBvcHRpb25zOiBEcmF3UG9pbnRPcHRpb25zLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlclxuKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgZHJhd1BvaW50TGVnZW5kKGN0eCwgb3B0aW9ucywgeCwgeSwgbnVsbCk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gZHJhd1BvaW50TGVnZW5kKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgb3B0aW9uczogRHJhd1BvaW50T3B0aW9ucyxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIHc6IG51bWJlclxuKSB7XG4gIGxldCB0eXBlOiBzdHJpbmcsIHhPZmZzZXQ6IG51bWJlciwgeU9mZnNldDogbnVtYmVyLCBzaXplOiBudW1iZXIsIGNvcm5lclJhZGl1czogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCB4T2Zmc2V0VzogbnVtYmVyLCB5T2Zmc2V0VzogbnVtYmVyO1xuICBjb25zdCBzdHlsZSA9IG9wdGlvbnMucG9pbnRTdHlsZTtcbiAgY29uc3Qgcm90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uO1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cztcbiAgbGV0IHJhZCA9IChyb3RhdGlvbiB8fCAwKSAqIFJBRF9QRVJfREVHO1xuXG4gIGlmIChzdHlsZSAmJiB0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XG4gICAgdHlwZSA9IHN0eWxlLnRvU3RyaW5nKCk7XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGN0eC5yb3RhdGUocmFkKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3R5bGUsIC1zdHlsZS53aWR0aCAvIDIsIC1zdHlsZS5oZWlnaHQgLyAyLCBzdHlsZS53aWR0aCwgc3R5bGUuaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgc3dpdGNoIChzdHlsZSkge1xuICAvLyBEZWZhdWx0IGluY2x1ZGVzIGNpcmNsZVxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodykge1xuICAgICAgICBjdHguZWxsaXBzZSh4LCB5LCB3IC8gMiwgcmFkaXVzLCAwLCAwLCBUQVUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIFRBVSk7XG4gICAgICB9XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0cmlhbmdsZSc6XG4gICAgICB3aWR0aCA9IHcgPyB3IC8gMiA6IHJhZGl1cztcbiAgICAgIGN0eC5tb3ZlVG8oeCArIE1hdGguc2luKHJhZCkgKiB3aWR0aCwgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogd2lkdGgsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHdpZHRoLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyZWN0Um91bmRlZCc6XG4gICAgLy8gTk9URTogdGhlIHJvdW5kZWQgcmVjdCBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIHRvIHVzZSBgYXJjYCBpbnN0ZWFkIG9mXG4gICAgLy8gYHF1YWRyYXRpY0N1cnZlVG9gIHNpbmNlIGl0IGdlbmVyYXRlcyBiZXR0ZXIgcmVzdWx0cyB3aGVuIHJlY3QgaXNcbiAgICAvLyBhbG1vc3QgYSBjaXJjbGUuIDAuNTE2IChpbnN0ZWFkIG9mIDAuNSkgcHJvZHVjZXMgcmVzdWx0cyB3aXRoIHZpc3VhbGx5XG4gICAgLy8gY2xvc2VyIHByb3BvcnRpb24gdG8gdGhlIHByZXZpb3VzIGltcGwgYW5kIGl0IGlzIGluc2NyaWJlZCBpbiB0aGVcbiAgICAvLyBjaXJjbGUgd2l0aCBgcmFkaXVzYC4gRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSBmb2xsb3dpbmcgUFJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81NTk3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU4NThcbiAgICAgIGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xuICAgICAgc2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogKHcgPyB3IC8gMiAtIGNvcm5lclJhZGl1cyA6IHNpemUpO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiAodyA/IHcgLyAyIC0gY29ybmVyUmFkaXVzIDogc2l6ZSk7XG4gICAgICBjdHguYXJjKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIEhBTEZfUEksIHJhZCk7XG4gICAgICBjdHguYXJjKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkLCByYWQgKyBIQUxGX1BJKTtcbiAgICAgIGN0eC5hcmMoeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyZWN0JzpcbiAgICAgIGlmICghcm90YXRpb24pIHtcbiAgICAgICAgc2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcbiAgICAgICAgd2lkdGggPSB3ID8gdyAvIDIgOiBzaXplO1xuICAgICAgICBjdHgucmVjdCh4IC0gd2lkdGgsIHkgLSBzaXplLCAyICogd2lkdGgsIDIgKiBzaXplKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSAncmVjdFJvdCc6XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjcm9zc1JvdCc6XG4gICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSAnY3Jvc3MnOlxuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc3Rhcic6XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgeE9mZnNldCA9IHcgPyB3IC8gMiA6IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Rhc2gnOlxuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKSwgeSArIE1hdGguc2luKHJhZCkgKiByYWRpdXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmYWxzZTpcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgY3R4LmZpbGwoKTtcbiAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIHRlc3RcbiAqIEBwYXJhbSBhcmVhIC0gVGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIG1hcmdpbiAtIGFsbG93ZWQgbWFyZ2luXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2lzUG9pbnRJbkFyZWEoXG4gIHBvaW50OiBQb2ludCxcbiAgYXJlYTogVFJCTCxcbiAgbWFyZ2luPzogbnVtYmVyXG4pIHtcbiAgbWFyZ2luID0gbWFyZ2luIHx8IDAuNTsgLy8gbWFyZ2luIC0gZGVmYXVsdCBpcyB0byBtYXRjaCByb3VuZGVkIGRlY2ltYWxzXG5cbiAgcmV0dXJuICFhcmVhIHx8IChwb2ludCAmJiBwb2ludC54ID4gYXJlYS5sZWZ0IC0gbWFyZ2luICYmIHBvaW50LnggPCBhcmVhLnJpZ2h0ICsgbWFyZ2luICYmXG5cdFx0cG9pbnQueSA+IGFyZWEudG9wIC0gbWFyZ2luICYmIHBvaW50LnkgPCBhcmVhLmJvdHRvbSArIG1hcmdpbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGlwQXJlYShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgYXJlYTogVFJCTCkge1xuICBjdHguc2F2ZSgpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5yZWN0KGFyZWEubGVmdCwgYXJlYS50b3AsIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuICBjdHguY2xpcCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5jbGlwQXJlYShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICBjdHgucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc3RlcHBlZExpbmVUbyhcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHByZXZpb3VzOiBQb2ludCxcbiAgdGFyZ2V0OiBQb2ludCxcbiAgZmxpcD86IGJvb2xlYW4sXG4gIG1vZGU/OiBzdHJpbmdcbikge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBpZiAobW9kZSA9PT0gJ21pZGRsZScpIHtcbiAgICBjb25zdCBtaWRwb2ludCA9IChwcmV2aW91cy54ICsgdGFyZ2V0LngpIC8gMi4wO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHByZXZpb3VzLnkpO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHRhcmdldC55KTtcbiAgfSBlbHNlIGlmIChtb2RlID09PSAnYWZ0ZXInICE9PSAhIWZsaXApIHtcbiAgICBjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVRvKHRhcmdldC54LCBwcmV2aW91cy55KTtcbiAgfVxuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9iZXppZXJDdXJ2ZVRvKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgcHJldmlvdXM6IFNwbGluZVBvaW50LFxuICB0YXJnZXQ6IFNwbGluZVBvaW50LFxuICBmbGlwPzogYm9vbGVhblxuKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF4IDogcHJldmlvdXMuY3AyeCxcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeSA6IHByZXZpb3VzLmNwMnksXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ4IDogdGFyZ2V0LmNwMXgsXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ5IDogdGFyZ2V0LmNwMXksXG4gICAgdGFyZ2V0LngsXG4gICAgdGFyZ2V0LnkpO1xufVxuXG5mdW5jdGlvbiBzZXRSZW5kZXJPcHRzKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBvcHRzOiBSZW5kZXJUZXh0T3B0cykge1xuICBpZiAob3B0cy50cmFuc2xhdGlvbikge1xuICAgIGN0eC50cmFuc2xhdGUob3B0cy50cmFuc2xhdGlvblswXSwgb3B0cy50cmFuc2xhdGlvblsxXSk7XG4gIH1cblxuICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5yb3RhdGlvbikpIHtcbiAgICBjdHgucm90YXRlKG9wdHMucm90YXRpb24pO1xuICB9XG5cbiAgaWYgKG9wdHMuY29sb3IpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0cy5jb2xvcjtcbiAgfVxuXG4gIGlmIChvcHRzLnRleHRBbGlnbikge1xuICAgIGN0eC50ZXh0QWxpZ24gPSBvcHRzLnRleHRBbGlnbjtcbiAgfVxuXG4gIGlmIChvcHRzLnRleHRCYXNlbGluZSkge1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvcHRzLnRleHRCYXNlbGluZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWNvcmF0ZVRleHQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgbGluZTogc3RyaW5nLFxuICBvcHRzOiBSZW5kZXJUZXh0T3B0c1xuKSB7XG4gIGlmIChvcHRzLnN0cmlrZXRocm91Z2ggfHwgb3B0cy51bmRlcmxpbmUpIHtcbiAgICAvKipcbiAgICAgKiBOb3cgdGhhdCBJRTExIHN1cHBvcnQgaGFzIGJlZW4gZHJvcHBlZCwgd2UgY2FuIHVzZSBtb3JlXG4gICAgICogb2YgdGhlIFRleHRNZXRyaWNzIG9iamVjdC4gVGhlIGFjdHVhbCBib3VuZGluZyBib3hlc1xuICAgICAqIGFyZSB1bmZsYWdnZWQgaW4gQ2hyb21lLCBGaXJlZm94LCBFZGdlLCBhbmQgU2FmYXJpIHNvIHRoZXlcbiAgICAgKiBjYW4gYmUgc2FmZWx5IHVzZWQuXG4gICAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UZXh0TWV0cmljcyNCcm93c2VyX2NvbXBhdGliaWxpdHlcbiAgICAgKi9cbiAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmUpO1xuICAgIGNvbnN0IGxlZnQgPSB4IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveExlZnQ7XG4gICAgY29uc3QgcmlnaHQgPSB4ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0O1xuICAgIGNvbnN0IHRvcCA9IHkgLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgIGNvbnN0IGJvdHRvbSA9IHkgKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDtcbiAgICBjb25zdCB5RGVjb3JhdGlvbiA9IG9wdHMuc3RyaWtldGhyb3VnaCA/ICh0b3AgKyBib3R0b20pIC8gMiA6IGJvdHRvbTtcblxuICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLmRlY29yYXRpb25XaWR0aCB8fCAyO1xuICAgIGN0eC5tb3ZlVG8obGVmdCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5saW5lVG8ocmlnaHQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd0JhY2tkcm9wKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBvcHRzOiBCYWNrZHJvcE9wdGlvbnMpIHtcbiAgY29uc3Qgb2xkQ29sb3IgPSBjdHguZmlsbFN0eWxlO1xuXG4gIGN0eC5maWxsU3R5bGUgPSBvcHRzLmNvbG9yIGFzIHN0cmluZztcbiAgY3R4LmZpbGxSZWN0KG9wdHMubGVmdCwgb3B0cy50b3AsIG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgY3R4LmZpbGxTdHlsZSA9IG9sZENvbG9yO1xufVxuXG4vKipcbiAqIFJlbmRlciB0ZXh0IG9udG8gdGhlIGNhbnZhc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyVGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHRleHQ6IHN0cmluZyB8IHN0cmluZ1tdLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgZm9udDogQ2FudmFzRm9udFNwZWMsXG4gIG9wdHM6IFJlbmRlclRleHRPcHRzID0ge31cbikge1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkodGV4dCkgPyB0ZXh0IDogW3RleHRdO1xuICBjb25zdCBzdHJva2UgPSBvcHRzLnN0cm9rZVdpZHRoID4gMCAmJiBvcHRzLnN0cm9rZUNvbG9yICE9PSAnJztcbiAgbGV0IGk6IG51bWJlciwgbGluZTogc3RyaW5nO1xuXG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XG4gIHNldFJlbmRlck9wdHMoY3R4LCBvcHRzKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG5cbiAgICBpZiAob3B0cy5iYWNrZHJvcCkge1xuICAgICAgZHJhd0JhY2tkcm9wKGN0eCwgb3B0cy5iYWNrZHJvcCk7XG4gICAgfVxuXG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgaWYgKG9wdHMuc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0cy5zdHJva2VDb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMuc3Ryb2tlV2lkdGgpKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICB9XG5cbiAgICBjdHguZmlsbFRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgZGVjb3JhdGVUZXh0KGN0eCwgeCwgeSwgbGluZSwgb3B0cyk7XG5cbiAgICB5ICs9IE51bWJlcihmb250LmxpbmVIZWlnaHQpO1xuICB9XG5cbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuLyoqXG4gKiBBZGQgYSBwYXRoIG9mIGEgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzIHRvIHRoZSBjdXJyZW50IHN1Yi1wYXRoXG4gKiBAcGFyYW0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHJlY3QgLSBCb3VuZGluZyByZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRSb3VuZGVkUmVjdFBhdGgoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICByZWN0OiBSb3VuZGVkUmVjdCAmIHsgcmFkaXVzOiBUUkJMQ29ybmVycyB9XG4pIHtcbiAgY29uc3Qge3gsIHksIHcsIGgsIHJhZGl1c30gPSByZWN0O1xuXG4gIC8vIHRvcCBsZWZ0IGFyY1xuICBjdHguYXJjKHggKyByYWRpdXMudG9wTGVmdCwgeSArIHJhZGl1cy50b3BMZWZ0LCByYWRpdXMudG9wTGVmdCwgMS41ICogUEksIFBJLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gdG9wIGxlZnQgdG8gYm90dG9tIGxlZnRcbiAgY3R4LmxpbmVUbyh4LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0KTtcblxuICAvLyBib3R0b20gbGVmdCBhcmNcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLmJvdHRvbUxlZnQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQsIHJhZGl1cy5ib3R0b21MZWZ0LCBQSSwgSEFMRl9QSSwgdHJ1ZSk7XG5cbiAgLy8gbGluZSBmcm9tIGJvdHRvbSBsZWZ0IHRvIGJvdHRvbSByaWdodFxuICBjdHgubGluZVRvKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCk7XG5cbiAgLy8gYm90dG9tIHJpZ2h0IGFyY1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21SaWdodCwgcmFkaXVzLmJvdHRvbVJpZ2h0LCBIQUxGX1BJLCAwLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gYm90dG9tIHJpZ2h0IHRvIHRvcCByaWdodFxuICBjdHgubGluZVRvKHggKyB3LCB5ICsgcmFkaXVzLnRvcFJpZ2h0KTtcblxuICAvLyB0b3AgcmlnaHQgYXJjXG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMudG9wUmlnaHQsIHkgKyByYWRpdXMudG9wUmlnaHQsIHJhZGl1cy50b3BSaWdodCwgMCwgLUhBTEZfUEksIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSB0b3AgcmlnaHQgdG8gdG9wIGxlZnRcbiAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLnRvcExlZnQsIHkpO1xufVxuIiwgImltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9jb3JlL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc09iamVjdCwgdG9EaW1lbnNpb24sIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvRm9udFN0cmluZ30gZnJvbSAnLi9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRBcmVhLCBGb250U3BlYywgUG9pbnR9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtUUkJMLCBUUkJMQ29ybmVyc30gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcblxuY29uc3QgTElORV9IRUlHSFQgPSAvXihub3JtYWx8KFxcZCsoPzpcXC5cXGQrKT8pKHB4fGVtfCUpPykkLztcbmNvbnN0IEZPTlRfU1RZTEUgPSAvXihub3JtYWx8aXRhbGljfGluaXRpYWx8aW5oZXJpdHx1bnNldHwob2JsaXF1ZSggLT9bMC05XT9bMC05XWRlZyk/KSkkLztcblxuLyoqXG4gKiBAYWxpYXMgQ2hhcnQuaGVscGVycy5vcHRpb25zXG4gKiBAbmFtZXNwYWNlXG4gKi9cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGxpbmUgaGVpZ2h0IGB2YWx1ZWAgaW4gcGl4ZWxzIGZvciBhIHNwZWNpZmljIGZvbnQgYHNpemVgLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGxpbmVIZWlnaHQgdG8gcGFyc2UgKGVnLiAxLjYsICcxNHB4JywgJzc1JScsICcxLjZlbScpLlxuICogQHBhcmFtIHNpemUgLSBUaGUgZm9udCBzaXplIChpbiBwaXhlbHMpIHVzZWQgdG8gcmVzb2x2ZSByZWxhdGl2ZSBgdmFsdWVgLlxuICogQHJldHVybnMgVGhlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBpbiBwaXhlbHMgKHNpemUgKiAxLjIgaWYgdmFsdWUgaXMgaW52YWxpZCkuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9saW5lLWhlaWdodFxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0xpbmVIZWlnaHQodmFsdWU6IG51bWJlciB8IHN0cmluZywgc2l6ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgbWF0Y2hlcyA9ICgnJyArIHZhbHVlKS5tYXRjaChMSU5FX0hFSUdIVCk7XG4gIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzWzFdID09PSAnbm9ybWFsJykge1xuICAgIHJldHVybiBzaXplICogMS4yO1xuICB9XG5cbiAgdmFsdWUgPSArbWF0Y2hlc1syXTtcblxuICBzd2l0Y2ggKG1hdGNoZXNbM10pIHtcbiAgICBjYXNlICdweCc6XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY2FzZSAnJSc6XG4gICAgICB2YWx1ZSAvPSAxMDA7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gc2l6ZSAqIHZhbHVlO1xufVxuXG5jb25zdCBudW1iZXJPclplcm8gPSAodjogdW5rbm93bikgPT4gK3YgfHwgMDtcblxuLyoqXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBwcm9wc1xuICovXG5leHBvcnQgZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHM8SyBleHRlbmRzIHN0cmluZz4odmFsdWU6IG51bWJlciB8IFJlY29yZDxLLCBudW1iZXI+LCBwcm9wczogS1tdKTogUmVjb3JkPEssIG51bWJlcj47XG5leHBvcnQgZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHM8SyBleHRlbmRzIHN0cmluZywgVCBleHRlbmRzIHN0cmluZz4odmFsdWU6IG51bWJlciB8IFJlY29yZDxLICYgVCwgbnVtYmVyPiwgcHJvcHM6IFJlY29yZDxULCBLPik6IFJlY29yZDxULCBudW1iZXI+O1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlOiBudW1iZXIgfCBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LCBwcm9wczogc3RyaW5nW10gfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjb25zdCBvYmpQcm9wcyA9IGlzT2JqZWN0KHByb3BzKTtcbiAgY29uc3Qga2V5cyA9IG9ialByb3BzID8gT2JqZWN0LmtleXMocHJvcHMpIDogcHJvcHM7XG4gIGNvbnN0IHJlYWQgPSBpc09iamVjdCh2YWx1ZSlcbiAgICA/IG9ialByb3BzXG4gICAgICA/IHByb3AgPT4gdmFsdWVPckRlZmF1bHQodmFsdWVbcHJvcF0sIHZhbHVlW3Byb3BzW3Byb3BdXSlcbiAgICAgIDogcHJvcCA9PiB2YWx1ZVtwcm9wXVxuICAgIDogKCkgPT4gdmFsdWU7XG5cbiAgZm9yIChjb25zdCBwcm9wIG9mIGtleXMpIHtcbiAgICByZXRbcHJvcF0gPSBudW1iZXJPclplcm8ocmVhZChwcm9wKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIFRSQkwgb2JqZWN0LlxuICogQHBhcmFtIHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29tcG9uZW50LFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogIHggLyB5IGFyZSBzaG9ydGhhbmRzIGZvciBzYW1lIHZhbHVlIGZvciBsZWZ0L3JpZ2h0IGFuZCB0b3AvYm90dG9tLlxuICogQHJldHVybnMgVGhlIHBhZGRpbmcgdmFsdWVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQpXG4gKiBAc2luY2UgMy4wLjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVFJCTCh2YWx1ZTogbnVtYmVyIHwgVFJCTCB8IFBvaW50KSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwge3RvcDogJ3knLCByaWdodDogJ3gnLCBib3R0b206ICd5JywgbGVmdDogJ3gnfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBUUkJMIGNvcm5lcnMgb2JqZWN0IChzaW1pbGFyIHdpdGggY3NzIGJvcmRlci1yYWRpdXMpLlxuICogQHBhcmFtIHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29ybmVyIGNvbXBvbmVudHMsXG4gKiAgZWxzZSwgaWYgYW4gb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG4gKiBAcmV0dXJucyBUaGUgVFJCTCBjb3JuZXIgdmFsdWVzICh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQpXG4gKiBAc2luY2UgMy4wLjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVFJCTENvcm5lcnModmFsdWU6IG51bWJlciB8IFRSQkxDb3JuZXJzKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWyd0b3BMZWZ0JywgJ3RvcFJpZ2h0JywgJ2JvdHRvbUxlZnQnLCAnYm90dG9tUmlnaHQnXSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBwYWRkaW5nIG9iamVjdCB3aXRoIHByZS1jb21wdXRlZCB3aWR0aC9oZWlnaHQuXG4gKiBAcGFyYW0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb21wb25lbnQsXG4gKiAgZWxzZSwgaWYgYW4gb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG4gKiAgeCAvIHkgYXJlIHNob3J0aGFuZHMgZm9yIHNhbWUgdmFsdWUgZm9yIGxlZnQvcmlnaHQgYW5kIHRvcC9ib3R0b20uXG4gKiBAcmV0dXJucyBUaGUgcGFkZGluZyB2YWx1ZXMgKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgd2lkdGgsIGhlaWdodClcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9QYWRkaW5nKHZhbHVlPzogbnVtYmVyIHwgVFJCTCk6IENoYXJ0QXJlYSB7XG4gIGNvbnN0IG9iaiA9IHRvVFJCTCh2YWx1ZSkgYXMgQ2hhcnRBcmVhO1xuXG4gIG9iai53aWR0aCA9IG9iai5sZWZ0ICsgb2JqLnJpZ2h0O1xuICBvYmouaGVpZ2h0ID0gb2JqLnRvcCArIG9iai5ib3R0b207XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBQYXJzZXMgZm9udCBvcHRpb25zIGFuZCByZXR1cm5zIHRoZSBmb250IG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQSBvYmplY3QgdGhhdCBjb250YWlucyBmb250IG9wdGlvbnMgdG8gYmUgcGFyc2VkLlxuICogQHBhcmFtIGZhbGxiYWNrIC0gQSBvYmplY3QgdGhhdCBjb250YWlucyBmYWxsYmFjayBmb250IG9wdGlvbnMuXG4gKiBAcmV0dXJuIFRoZSBmb250IG9iamVjdC5cbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRvRm9udChvcHRpb25zOiBQYXJ0aWFsPEZvbnRTcGVjPiwgZmFsbGJhY2s/OiBQYXJ0aWFsPEZvbnRTcGVjPikge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZmFsbGJhY2sgPSBmYWxsYmFjayB8fCBkZWZhdWx0cy5mb250IGFzIEZvbnRTcGVjO1xuXG4gIGxldCBzaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zaXplLCBmYWxsYmFjay5zaXplKTtcblxuICBpZiAodHlwZW9mIHNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgc2l6ZSA9IHBhcnNlSW50KHNpemUsIDEwKTtcbiAgfVxuICBsZXQgc3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnN0eWxlLCBmYWxsYmFjay5zdHlsZSk7XG4gIGlmIChzdHlsZSAmJiAhKCcnICsgc3R5bGUpLm1hdGNoKEZPTlRfU1RZTEUpKSB7XG4gICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGZvbnQgc3R5bGUgc3BlY2lmaWVkOiBcIicgKyBzdHlsZSArICdcIicpO1xuICAgIHN0eWxlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgZm9udCA9IHtcbiAgICBmYW1pbHk6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZmFtaWx5LCBmYWxsYmFjay5mYW1pbHkpLFxuICAgIGxpbmVIZWlnaHQ6IHRvTGluZUhlaWdodCh2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmxpbmVIZWlnaHQsIGZhbGxiYWNrLmxpbmVIZWlnaHQpLCBzaXplKSxcbiAgICBzaXplLFxuICAgIHN0eWxlLFxuICAgIHdlaWdodDogdmFsdWVPckRlZmF1bHQob3B0aW9ucy53ZWlnaHQsIGZhbGxiYWNrLndlaWdodCksXG4gICAgc3RyaW5nOiAnJ1xuICB9O1xuXG4gIGZvbnQuc3RyaW5nID0gdG9Gb250U3RyaW5nKGZvbnQpO1xuICByZXR1cm4gZm9udDtcbn1cblxuLyoqXG4gKiBFdmFsdWF0ZXMgdGhlIGdpdmVuIGBpbnB1dHNgIHNlcXVlbnRpYWxseSBhbmQgcmV0dXJucyB0aGUgZmlyc3QgZGVmaW5lZCB2YWx1ZS5cbiAqIEBwYXJhbSBpbnB1dHMgLSBBbiBhcnJheSBvZiB2YWx1ZXMsIGZhbGxpbmcgYmFjayB0byB0aGUgbGFzdCB2YWx1ZS5cbiAqIEBwYXJhbSBjb250ZXh0IC0gSWYgZGVmaW5lZCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYSBmdW5jdGlvbiwgdGhlIHZhbHVlXG4gKiBpcyBjYWxsZWQgd2l0aCBgY29udGV4dGAgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHRoZSByZXN1bHQgYmVjb21lcyB0aGUgbmV3IGlucHV0LlxuICogQHBhcmFtIGluZGV4IC0gSWYgZGVmaW5lZCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYW4gYXJyYXksIHRoZSB2YWx1ZVxuICogYXQgYGluZGV4YCBiZWNvbWUgdGhlIG5ldyBpbnB1dC5cbiAqIEBwYXJhbSBpbmZvIC0gb2JqZWN0IHRvIHJldHVybiBpbmZvcm1hdGlvbiBhYm91dCByZXNvbHV0aW9uIGluXG4gKiBAcGFyYW0gaW5mby5jYWNoZWFibGUgLSBXaWxsIGJlIHNldCB0byBgZmFsc2VgIGlmIG9wdGlvbiBpcyBub3QgY2FjaGVhYmxlLlxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlKGlucHV0czogQXJyYXk8dW5rbm93bj4sIGNvbnRleHQ/OiBvYmplY3QsIGluZGV4PzogbnVtYmVyLCBpbmZvPzogeyBjYWNoZWFibGU6IGJvb2xlYW4gfSkge1xuICBsZXQgY2FjaGVhYmxlID0gdHJ1ZTtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCB2YWx1ZTogdW5rbm93bjtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gaW5wdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHZhbHVlID0gaW5wdXRzW2ldO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoY29udGV4dCk7XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVbaW5kZXggJSB2YWx1ZS5sZW5ndGhdO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5mbyAmJiAhY2FjaGVhYmxlKSB7XG4gICAgICAgIGluZm8uY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIG1pbm1heFxuICogQHBhcmFtIGdyYWNlXG4gKiBAcGFyYW0gYmVnaW5BdFplcm9cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYWRkR3JhY2UobWlubWF4OiB7IG1pbjogbnVtYmVyOyBtYXg6IG51bWJlcjsgfSwgZ3JhY2U6IG51bWJlciB8IHN0cmluZywgYmVnaW5BdFplcm86IGJvb2xlYW4pIHtcbiAgY29uc3Qge21pbiwgbWF4fSA9IG1pbm1heDtcbiAgY29uc3QgY2hhbmdlID0gdG9EaW1lbnNpb24oZ3JhY2UsIChtYXggLSBtaW4pIC8gMik7XG4gIGNvbnN0IGtlZXBaZXJvID0gKHZhbHVlOiBudW1iZXIsIGFkZDogbnVtYmVyKSA9PiBiZWdpbkF0WmVybyAmJiB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSArIGFkZDtcbiAgcmV0dXJuIHtcbiAgICBtaW46IGtlZXBaZXJvKG1pbiwgLU1hdGguYWJzKGNoYW5nZSkpLFxuICAgIG1heDoga2VlcFplcm8obWF4LCBjaGFuZ2UpXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY29udGV4dCBpbmhlcml0aW5nIHBhcmVudENvbnRleHRcbiAqIEBwYXJhbSBwYXJlbnRDb250ZXh0XG4gKiBAcGFyYW0gY29udGV4dFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQ8VCBleHRlbmRzIG9iamVjdD4ocGFyZW50Q29udGV4dDogbnVsbCwgY29udGV4dDogVCk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dDxUIGV4dGVuZHMgb2JqZWN0LCBQIGV4dGVuZHMgVD4ocGFyZW50Q29udGV4dDogUCwgY29udGV4dDogVCk6IFAgJiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQocGFyZW50Q29udGV4dDogb2JqZWN0LCBjb250ZXh0OiBvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShwYXJlbnRDb250ZXh0KSwgY29udGV4dCk7XG59XG4iLCAiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5pbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRNZXRhfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7XG4gIFJlc29sdmVyT2JqZWN0S2V5LFxuICBSZXNvbHZlckNhY2hlLFxuICBSZXNvbHZlclByb3h5LFxuICBEZXNjcmlwdG9yRGVmYXVsdHMsXG4gIERlc2NyaXB0b3IsXG4gIENvbnRleHRDYWNoZSxcbiAgQ29udGV4dFByb3h5XG59IGZyb20gJy4vaGVscGVycy5jb25maWcudHlwZXMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgcmVzb2x2ZU9iamVjdEtleSwgX2NhcGl0YWxpemV9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0ICogZnJvbSAnLi9oZWxwZXJzLmNvbmZpZy50eXBlcy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFByb3h5IGZvciByZXNvbHZpbmcgcmF3IHZhbHVlcyBmb3Igb3B0aW9ucy5cbiAqIEBwYXJhbSBzY29wZXMgLSBUaGUgb3B0aW9uIHNjb3BlcyB0byBsb29rIGZvciB2YWx1ZXMsIGluIHJlc29sdXRpb24gb3JkZXJcbiAqIEBwYXJhbSBwcmVmaXhlcyAtIFRoZSBwcmVmaXhlcyBmb3IgdmFsdWVzLCBpbiByZXNvbHV0aW9uIG9yZGVyLlxuICogQHBhcmFtIHJvb3RTY29wZXMgLSBUaGUgcm9vdCBvcHRpb24gc2NvcGVzXG4gKiBAcGFyYW0gZmFsbGJhY2sgLSBQYXJlbnQgc2NvcGVzIGZhbGxiYWNrXG4gKiBAcGFyYW0gZ2V0VGFyZ2V0IC0gY2FsbGJhY2sgZm9yIGdldHRpbmcgdGhlIHRhcmdldCBmb3IgY2hhbmdlZCB2YWx1ZXNcbiAqIEByZXR1cm5zIFByb3h5XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZVJlc29sdmVyPFxuICBUIGV4dGVuZHMgQW55T2JqZWN0W10gPSBBbnlPYmplY3RbXSxcbiAgUiBleHRlbmRzIEFueU9iamVjdFtdID0gVFxuPihcbiAgc2NvcGVzOiBULFxuICBwcmVmaXhlcyA9IFsnJ10sXG4gIHJvb3RTY29wZXM/OiBSLFxuICBmYWxsYmFjaz86IFJlc29sdmVyT2JqZWN0S2V5LFxuICBnZXRUYXJnZXQgPSAoKSA9PiBzY29wZXNbMF1cbikge1xuICBjb25zdCBmaW5hbFJvb3RTY29wZXMgPSByb290U2NvcGVzIHx8IHNjb3BlcztcbiAgaWYgKHR5cGVvZiBmYWxsYmFjayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmYWxsYmFjayA9IF9yZXNvbHZlKCdfZmFsbGJhY2snLCBzY29wZXMpO1xuICB9XG4gIGNvbnN0IGNhY2hlOiBSZXNvbHZlckNhY2hlPFQsIFI+ID0ge1xuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnT2JqZWN0JyxcbiAgICBfY2FjaGVhYmxlOiB0cnVlLFxuICAgIF9zY29wZXM6IHNjb3BlcyxcbiAgICBfcm9vdFNjb3BlczogZmluYWxSb290U2NvcGVzLFxuICAgIF9mYWxsYmFjazogZmFsbGJhY2ssXG4gICAgX2dldFRhcmdldDogZ2V0VGFyZ2V0LFxuICAgIG92ZXJyaWRlOiAoc2NvcGU6IEFueU9iamVjdCkgPT4gX2NyZWF0ZVJlc29sdmVyKFtzY29wZSwgLi4uc2NvcGVzXSwgcHJlZml4ZXMsIGZpbmFsUm9vdFNjb3BlcywgZmFsbGJhY2spLFxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgZGVsZXRlIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcDogc3RyaW5nKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5czsgLy8gcmVtb3ZlIGNhY2hlZCBrZXlzXG4gICAgICBkZWxldGUgc2NvcGVzWzBdW3Byb3BdOyAvLyByZW1vdmUgZnJvbSB0b3AgbGV2ZWwgc2NvcGVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIGdldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldCh0YXJnZXQsIHByb3A6IHN0cmluZykge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCB0YXJnZXQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLlxuICAgICAqIEFsc28gdXNlZCBieSBPYmplY3QuaGFzT3duUHJvcGVydHkuXG4gICAgICovXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5fc2NvcGVzWzBdLCBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YuXG4gICAgICovXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihzY29wZXNbMF0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBpbiBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBoYXModGFyZ2V0LCBwcm9wOiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpLmluY2x1ZGVzKHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIGFuZCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLlxuICAgICAqL1xuICAgIG93bktleXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBzZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBzZXQodGFyZ2V0LCBwcm9wOiBzdHJpbmcsIHZhbHVlKSB7XG4gICAgICBjb25zdCBzdG9yYWdlID0gdGFyZ2V0Ll9zdG9yYWdlIHx8ICh0YXJnZXQuX3N0b3JhZ2UgPSBnZXRUYXJnZXQoKSk7XG4gICAgICB0YXJnZXRbcHJvcF0gPSBzdG9yYWdlW3Byb3BdID0gdmFsdWU7IC8vIHNldCB0byB0b3AgbGV2ZWwgc2NvcGUgKyBjYWNoZVxuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5czsgLy8gcmVtb3ZlIGNhY2hlZCBrZXlzXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pIGFzIFJlc29sdmVyUHJveHk8VCwgUj47XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBQcm94eSBmb3IgcmVzb2x2aW5nIG9wdGlvbiB2YWx1ZXMgd2l0aCBjb250ZXh0LlxuICogQHBhcmFtIHByb3h5IC0gVGhlIFByb3h5IHJldHVybmVkIGJ5IGBfY3JlYXRlUmVzb2x2ZXJgXG4gKiBAcGFyYW0gY29udGV4dCAtIENvbnRleHQgb2JqZWN0IGZvciBzY3JpcHRhYmxlL2luZGV4YWJsZSBvcHRpb25zXG4gKiBAcGFyYW0gc3ViUHJveHkgLSBUaGUgcHJveHkgcHJvdmlkZWQgZm9yIHNjcmlwdGFibGUgb3B0aW9uc1xuICogQHBhcmFtIGRlc2NyaXB0b3JEZWZhdWx0cyAtIERlZmF1bHRzIGZvciBkZXNjcmlwdG9yc1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hdHRhY2hDb250ZXh0PFxuICBUIGV4dGVuZHMgQW55T2JqZWN0W10gPSBBbnlPYmplY3RbXSxcbiAgUiBleHRlbmRzIEFueU9iamVjdFtdID0gVFxuPihcbiAgcHJveHk6IFJlc29sdmVyUHJveHk8VCwgUj4sXG4gIGNvbnRleHQ6IEFueU9iamVjdCxcbiAgc3ViUHJveHk/OiBSZXNvbHZlclByb3h5PFQsIFI+LFxuICBkZXNjcmlwdG9yRGVmYXVsdHM/OiBEZXNjcmlwdG9yRGVmYXVsdHNcbikge1xuICBjb25zdCBjYWNoZTogQ29udGV4dENhY2hlPFQsIFI+ID0ge1xuICAgIF9jYWNoZWFibGU6IGZhbHNlLFxuICAgIF9wcm94eTogcHJveHksXG4gICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgX3N1YlByb3h5OiBzdWJQcm94eSxcbiAgICBfc3RhY2s6IG5ldyBTZXQoKSxcbiAgICBfZGVzY3JpcHRvcnM6IF9kZXNjcmlwdG9ycyhwcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBzZXRDb250ZXh0OiAoY3R4OiBBbnlPYmplY3QpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5LCBjdHgsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIG92ZXJyaWRlOiAoc2NvcGU6IEFueU9iamVjdCkgPT4gX2F0dGFjaENvbnRleHQocHJveHkub3ZlcnJpZGUoc2NvcGUpLCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgZGVsZXRlIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gY2FjaGVcbiAgICAgIGRlbGV0ZSBwcm94eVtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gcHJveHlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIGdldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldCh0YXJnZXQsIHByb3A6IHN0cmluZywgcmVjZWl2ZXIpIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvci5cbiAgICAgKiBBbHNvIHVzZWQgYnkgT2JqZWN0Lmhhc093blByb3BlcnR5LlxuICAgICAqL1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiB0YXJnZXQuX2Rlc2NyaXB0b3JzLmFsbEtleXNcbiAgICAgICAgPyBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCkgPyB7ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSA6IHVuZGVmaW5lZFxuICAgICAgICA6IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YuXG4gICAgICovXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihwcm94eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGluIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgYW5kIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMuXG4gICAgICovXG4gICAgb3duS2V5cygpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMocHJveHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHNldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBwcm94eVtwcm9wXSA9IHZhbHVlOyAvLyBzZXQgdG8gcHJveHlcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07IC8vIHJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pIGFzIENvbnRleHRQcm94eTxULCBSPjtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2Rlc2NyaXB0b3JzKFxuICBwcm94eTogUmVzb2x2ZXJDYWNoZSxcbiAgZGVmYXVsdHM6IERlc2NyaXB0b3JEZWZhdWx0cyA9IHtzY3JpcHRhYmxlOiB0cnVlLCBpbmRleGFibGU6IHRydWV9XG4pOiBEZXNjcmlwdG9yIHtcbiAgY29uc3Qge19zY3JpcHRhYmxlID0gZGVmYXVsdHMuc2NyaXB0YWJsZSwgX2luZGV4YWJsZSA9IGRlZmF1bHRzLmluZGV4YWJsZSwgX2FsbEtleXMgPSBkZWZhdWx0cy5hbGxLZXlzfSA9IHByb3h5O1xuICByZXR1cm4ge1xuICAgIGFsbEtleXM6IF9hbGxLZXlzLFxuICAgIHNjcmlwdGFibGU6IF9zY3JpcHRhYmxlLFxuICAgIGluZGV4YWJsZTogX2luZGV4YWJsZSxcbiAgICBpc1NjcmlwdGFibGU6IGlzRnVuY3Rpb24oX3NjcmlwdGFibGUpID8gX3NjcmlwdGFibGUgOiAoKSA9PiBfc2NyaXB0YWJsZSxcbiAgICBpc0luZGV4YWJsZTogaXNGdW5jdGlvbihfaW5kZXhhYmxlKSA/IF9pbmRleGFibGUgOiAoKSA9PiBfaW5kZXhhYmxlXG4gIH07XG59XG5cbmNvbnN0IHJlYWRLZXkgPSAocHJlZml4OiBzdHJpbmcsIG5hbWU6IHN0cmluZykgPT4gcHJlZml4ID8gcHJlZml4ICsgX2NhcGl0YWxpemUobmFtZSkgOiBuYW1lO1xuY29uc3QgbmVlZHNTdWJSZXNvbHZlciA9IChwcm9wOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgcHJvcCAhPT0gJ2FkYXB0ZXJzJyAmJlxuICAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcblxuZnVuY3Rpb24gX2NhY2hlZChcbiAgdGFyZ2V0OiBBbnlPYmplY3QsXG4gIHByb3A6IHN0cmluZyxcbiAgcmVzb2x2ZTogKCkgPT4gdW5rbm93blxuKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBwcm9wKSB8fCBwcm9wID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gcmVzb2x2ZSgpO1xuICAvLyBjYWNoZSB0aGUgcmVzb2x2ZWQgdmFsdWVcbiAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVXaXRoQ29udGV4dChcbiAgdGFyZ2V0OiBDb250ZXh0Q2FjaGUsXG4gIHByb3A6IHN0cmluZyxcbiAgcmVjZWl2ZXI6IEFueU9iamVjdFxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuICBsZXQgdmFsdWUgPSBfcHJveHlbcHJvcF07IC8vIHJlc29sdmUgZnJvbSBwcm94eVxuXG4gIC8vIHJlc29sdmUgd2l0aCBjb250ZXh0XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSAmJiBkZXNjcmlwdG9ycy5pc1NjcmlwdGFibGUocHJvcCkpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcik7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBkZXNjcmlwdG9ycy5pc0luZGV4YWJsZSk7XG4gIH1cbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgLy8gaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFuIG9iamVjdCwgY3JlYXRlIGEgc3ViIHJlc29sdmVyIGZvciBpdFxuICAgIHZhbHVlID0gX2F0dGFjaENvbnRleHQodmFsdWUsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVNjcmlwdGFibGUoXG4gIHByb3A6IHN0cmluZyxcbiAgZ2V0VmFsdWU6IChjdHg6IEFueU9iamVjdCwgc3ViOiBBbnlPYmplY3QpID0+IHVua25vd24sXG4gIHRhcmdldDogQ29udGV4dENhY2hlLFxuICByZWNlaXZlcjogQW55T2JqZWN0XG4pIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX3N0YWNrfSA9IHRhcmdldDtcbiAgaWYgKF9zdGFjay5oYXMocHJvcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBkZXRlY3RlZDogJyArIEFycmF5LmZyb20oX3N0YWNrKS5qb2luKCctPicpICsgJy0+JyArIHByb3ApO1xuICB9XG4gIF9zdGFjay5hZGQocHJvcCk7XG4gIGxldCB2YWx1ZSA9IGdldFZhbHVlKF9jb250ZXh0LCBfc3ViUHJveHkgfHwgcmVjZWl2ZXIpO1xuICBfc3RhY2suZGVsZXRlKHByb3ApO1xuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcbiAgICAvLyBXaGVuIHNjcmlwdGFibGUgb3B0aW9uIHJldHVybnMgYW4gb2JqZWN0LCBjcmVhdGUgYSByZXNvbHZlciBvbiB0aGF0LlxuICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVBcnJheShcbiAgcHJvcDogc3RyaW5nLFxuICB2YWx1ZTogdW5rbm93bltdLFxuICB0YXJnZXQ6IENvbnRleHRDYWNoZSxcbiAgaXNJbmRleGFibGU6IChrZXk6IHN0cmluZykgPT4gYm9vbGVhblxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuXG4gIGlmICh0eXBlb2YgX2NvbnRleHQuaW5kZXggIT09ICd1bmRlZmluZWQnICYmIGlzSW5kZXhhYmxlKHByb3ApKSB7XG4gICAgcmV0dXJuIHZhbHVlW19jb250ZXh0LmluZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZVswXSkpIHtcbiAgICAvLyBBcnJheSBvZiBvYmplY3RzLCByZXR1cm4gYXJyYXkgb3IgcmVzb2x2ZXJzXG4gICAgY29uc3QgYXJyID0gdmFsdWU7XG4gICAgY29uc3Qgc2NvcGVzID0gX3Byb3h5Ll9zY29wZXMuZmlsdGVyKHMgPT4gcyAhPT0gYXJyKTtcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBfcHJveHksIHByb3AsIGl0ZW0pO1xuICAgICAgdmFsdWUucHVzaChfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZhbGxiYWNrKFxuICBmYWxsYmFjazogUmVzb2x2ZXJPYmplY3RLZXkgfCAoKHByb3A6IFJlc29sdmVyT2JqZWN0S2V5LCB2YWx1ZTogdW5rbm93bikgPT4gUmVzb2x2ZXJPYmplY3RLZXkpLFxuICBwcm9wOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICByZXR1cm4gaXNGdW5jdGlvbihmYWxsYmFjaykgPyBmYWxsYmFjayhwcm9wLCB2YWx1ZSkgOiBmYWxsYmFjaztcbn1cblxuY29uc3QgZ2V0U2NvcGUgPSAoa2V5OiBSZXNvbHZlck9iamVjdEtleSwgcGFyZW50OiBBbnlPYmplY3QpID0+IGtleSA9PT0gdHJ1ZSA/IHBhcmVudFxuICA6IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gcmVzb2x2ZU9iamVjdEtleShwYXJlbnQsIGtleSkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGFkZFNjb3BlcyhcbiAgc2V0OiBTZXQ8QW55T2JqZWN0PixcbiAgcGFyZW50U2NvcGVzOiBBbnlPYmplY3RbXSxcbiAga2V5OiBSZXNvbHZlck9iamVjdEtleSxcbiAgcGFyZW50RmFsbGJhY2s6IFJlc29sdmVyT2JqZWN0S2V5LFxuICB2YWx1ZTogdW5rbm93blxuKSB7XG4gIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudFNjb3Blcykge1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUoa2V5LCBwYXJlbnQpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgc2V0LmFkZChzY29wZSk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhzY29wZS5fZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiBmYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgJiYgZmFsbGJhY2sgIT09IGtleSAmJiBmYWxsYmFjayAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgICAgLy8gV2hlbiB3ZSByZWFjaCB0aGUgZGVzY3JpcHRvciB0aGF0IGRlZmluZXMgYSBuZXcgX2ZhbGxiYWNrLCByZXR1cm4gdGhhdC5cbiAgICAgICAgLy8gVGhlIGZhbGxiYWNrIHdpbGwgcmVzdW1lIHRvIHRoYXQgbmV3IHNjb3BlLlxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY29wZSA9PT0gZmFsc2UgJiYgdHlwZW9mIHBhcmVudEZhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiBrZXkgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBgZmFsc2VgIHJlc3VsdHMgdG8gYGZhbHNlYCwgd2hlbiBmYWxsaW5nIGJhY2sgdG8gZGlmZmVyZW50IGtleS5cbiAgICAgIC8vIEZvciBleGFtcGxlIGBpbnRlcmFjdGlvbmAgZnJvbSBgaG92ZXJgIG9yIGBwbHVnaW5zLnRvb2x0aXBgIGFuZCBgYW5pbWF0aW9uYCBmcm9tIGBhbmltYXRpb25zYFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ViUmVzb2x2ZXIoXG4gIHBhcmVudFNjb3BlczogQW55T2JqZWN0W10sXG4gIHJlc29sdmVyOiBSZXNvbHZlckNhY2hlLFxuICBwcm9wOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBjb25zdCByb290U2NvcGVzID0gcmVzb2x2ZXIuX3Jvb3RTY29wZXM7XG4gIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHJlc29sdmVyLl9mYWxsYmFjaywgcHJvcCwgdmFsdWUpO1xuICBjb25zdCBhbGxTY29wZXMgPSBbLi4ucGFyZW50U2NvcGVzLCAuLi5yb290U2NvcGVzXTtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxBbnlPYmplY3Q+KCk7XG4gIHNldC5hZGQodmFsdWUpO1xuICBsZXQga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgcHJvcCwgZmFsbGJhY2sgfHwgcHJvcCwgdmFsdWUpO1xuICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBwcm9wKSB7XG4gICAga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVSZXNvbHZlcihBcnJheS5mcm9tKHNldCksIFsnJ10sIHJvb3RTY29wZXMsIGZhbGxiYWNrLFxuICAgICgpID0+IHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCBhcyBzdHJpbmcsIHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGFkZFNjb3Blc0Zyb21LZXkoXG4gIHNldDogU2V0PEFueU9iamVjdD4sXG4gIGFsbFNjb3BlczogQW55T2JqZWN0W10sXG4gIGtleTogUmVzb2x2ZXJPYmplY3RLZXksXG4gIGZhbGxiYWNrOiBSZXNvbHZlck9iamVjdEtleSxcbiAgaXRlbTogdW5rbm93blxuKSB7XG4gIHdoaWxlIChrZXkpIHtcbiAgICBrZXkgPSBhZGRTY29wZXMoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2ssIGl0ZW0pO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5cbmZ1bmN0aW9uIHN1YkdldFRhcmdldChcbiAgcmVzb2x2ZXI6IFJlc29sdmVyQ2FjaGUsXG4gIHByb3A6IHN0cmluZyxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5fZ2V0VGFyZ2V0KCk7XG4gIGlmICghKHByb3AgaW4gcGFyZW50KSkge1xuICAgIHBhcmVudFtwcm9wXSA9IHt9O1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IHBhcmVudFtwcm9wXTtcbiAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAvLyBGb3IgYXJyYXkgb2Ygb2JqZWN0cywgdGhlIG9iamVjdCBpcyB1c2VkIHRvIHN0b3JlIHVwZGF0ZWQgdmFsdWVzXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0YXJnZXQgfHwge307XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aFByZWZpeGVzKFxuICBwcm9wOiBzdHJpbmcsXG4gIHByZWZpeGVzOiBzdHJpbmdbXSxcbiAgc2NvcGVzOiBBbnlPYmplY3RbXSxcbiAgcHJveHk6IFJlc29sdmVyUHJveHlcbikge1xuICBsZXQgdmFsdWU6IHVua25vd247XG4gIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZShyZWFkS2V5KHByZWZpeCwgcHJvcCksIHNjb3Blcyk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKVxuICAgICAgICA/IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgcHJveHksIHByb3AsIHZhbHVlKVxuICAgICAgICA6IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZShrZXk6IHN0cmluZywgc2NvcGVzOiBBbnlPYmplY3RbXSkge1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGlmICghc2NvcGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNjb3BlW2tleV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0OiBSZXNvbHZlckNhY2hlKSB7XG4gIGxldCBrZXlzID0gdGFyZ2V0Ll9rZXlzO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gdGFyZ2V0Ll9rZXlzID0gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHRhcmdldC5fc2NvcGVzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHNjb3BlczogQW55T2JqZWN0W10pIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NvcGUpLmZpbHRlcihrID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSkpIHtcbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZShcbiAgbWV0YTogQ2hhcnRNZXRhPCdsaW5lJyB8ICdzY2F0dGVyJz4sXG4gIGRhdGE6IEFueU9iamVjdFtdLFxuICBzdGFydDogbnVtYmVyLFxuICBjb3VudDogbnVtYmVyXG4pIHtcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7a2V5ID0gJ3InfSA9IHRoaXMuX3BhcnNpbmc7XG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheTx7cjogdW5rbm93bn0+KGNvdW50KTtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBpdGVtOiBBbnlPYmplY3Q7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgIHI6IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIGtleSksIGluZGV4KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbiIsICJpbXBvcnQge2FsbW9zdEVxdWFscywgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBzaWdufSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19pc1BvaW50SW5BcmVhfSBmcm9tICcuL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydEFyZWF9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtTcGxpbmVQb2ludH0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcblxuY29uc3QgRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuXG50eXBlIE9wdGlvbmFsU3BsaW5lUG9pbnQgPSBTcGxpbmVQb2ludCB8IGZhbHNlXG5jb25zdCBnZXRQb2ludCA9IChwb2ludHM6IFNwbGluZVBvaW50W10sIGk6IG51bWJlcik6IE9wdGlvbmFsU3BsaW5lUG9pbnQgPT4gaSA8IHBvaW50cy5sZW5ndGggJiYgIXBvaW50c1tpXS5za2lwICYmIHBvaW50c1tpXTtcbmNvbnN0IGdldFZhbHVlQXhpcyA9IChpbmRleEF4aXM6ICd4JyB8ICd5JykgPT4gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpbmVDdXJ2ZShcbiAgZmlyc3RQb2ludDogU3BsaW5lUG9pbnQsXG4gIG1pZGRsZVBvaW50OiBTcGxpbmVQb2ludCxcbiAgYWZ0ZXJQb2ludDogU3BsaW5lUG9pbnQsXG4gIHQ6IG51bWJlclxuKToge1xuICAgIHByZXZpb3VzOiBTcGxpbmVQb2ludFxuICAgIG5leHQ6IFNwbGluZVBvaW50XG4gIH0ge1xuICAvLyBQcm9wcyB0byBSb2IgU3BlbmNlciBhdCBzY2FsZWQgaW5ub3ZhdGlvbiBmb3IgaGlzIHBvc3Qgb24gc3BsaW5pbmcgYmV0d2VlbiBwb2ludHNcbiAgLy8gaHR0cDovL3NjYWxlZGlubm92YXRpb24uY29tL2FuYWx5dGljcy9zcGxpbmVzL2Fib3V0U3BsaW5lcy5odG1sXG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBtdXN0IGFsc28gcmVzcGVjdCBcInNraXBwZWRcIiBwb2ludHNcblxuICBjb25zdCBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcbiAgY29uc3QgY3VycmVudCA9IG1pZGRsZVBvaW50O1xuICBjb25zdCBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xuICBjb25zdCBkMDEgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoY3VycmVudCwgcHJldmlvdXMpO1xuICBjb25zdCBkMTIgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMobmV4dCwgY3VycmVudCk7XG5cbiAgbGV0IHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xuICBsZXQgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG5cbiAgLy8gSWYgYWxsIHBvaW50cyBhcmUgdGhlIHNhbWUsIHMwMSAmIHMwMiB3aWxsIGJlIGluZlxuICBzMDEgPSBpc05hTihzMDEpID8gMCA6IHMwMTtcbiAgczEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XG5cbiAgY29uc3QgZmEgPSB0ICogczAxOyAvLyBzY2FsaW5nIGZhY3RvciBmb3IgdHJpYW5nbGUgVGFcbiAgY29uc3QgZmIgPSB0ICogczEyO1xuXG4gIHJldHVybiB7XG4gICAgcHJldmlvdXM6IHtcbiAgICAgIHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9LFxuICAgIG5leHQ6IHtcbiAgICAgIHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQWRqdXN0IHRhbmdlbnRzIHRvIGVuc3VyZSBtb25vdG9uaWMgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtb25vdG9uZUFkanVzdChwb2ludHM6IFNwbGluZVBvaW50W10sIGRlbHRhSzogbnVtYmVyW10sIG1LOiBudW1iZXJbXSkge1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBhbHBoYUs6IG51bWJlciwgYmV0YUs6IG51bWJlciwgdGF1SzogbnVtYmVyLCBzcXVhcmVkTWFnbml0dWRlOiBudW1iZXIsIHBvaW50Q3VycmVudDogT3B0aW9uYWxTcGxpbmVQb2ludDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbiAtIDE7ICsraSkge1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50IHx8ICFwb2ludEFmdGVyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoYWxtb3N0RXF1YWxzKGRlbHRhS1tpXSwgMCwgRVBTSUxPTikpIHtcbiAgICAgIG1LW2ldID0gbUtbaSArIDFdID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGFscGhhSyA9IG1LW2ldIC8gZGVsdGFLW2ldO1xuICAgIGJldGFLID0gbUtbaSArIDFdIC8gZGVsdGFLW2ldO1xuICAgIHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuICAgIGlmIChzcXVhcmVkTWFnbml0dWRlIDw9IDkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xuICAgIG1LW2ldID0gYWxwaGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgICBtS1tpICsgMV0gPSBiZXRhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9ub3RvbmVDb21wdXRlKHBvaW50czogU3BsaW5lUG9pbnRbXSwgbUs6IG51bWJlcltdLCBpbmRleEF4aXM6ICd4JyB8ICd5JyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGRlbHRhOiBudW1iZXIsIHBvaW50QmVmb3JlOiBPcHRpb25hbFNwbGluZVBvaW50LCBwb2ludEN1cnJlbnQ6IE9wdGlvbmFsU3BsaW5lUG9pbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGlQaXhlbCA9IHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgIGNvbnN0IHZQaXhlbCA9IHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdO1xuICAgIGlmIChwb2ludEJlZm9yZSkge1xuICAgICAgZGVsdGEgPSAoaVBpeGVsIC0gcG9pbnRCZWZvcmVbaW5kZXhBeGlzXSkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke2luZGV4QXhpc31gXSA9IGlQaXhlbCAtIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCAtIGRlbHRhICogbUtbaV07XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBkZWx0YSA9IChwb2ludEFmdGVyW2luZGV4QXhpc10gLSBpUGl4ZWwpIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgKyBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgKyBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyBCw6l6aWVyIGNvbnRyb2wgcG9pbnRzIGluIGEgc2ltaWxhciB3YXkgdGhhbiB8c3BsaW5lQ3VydmV8LFxuICogYnV0IHByZXNlcnZlcyBtb25vdG9uaWNpdHkgb2YgdGhlIHByb3ZpZGVkIGRhdGEgYW5kIGVuc3VyZXMgbm8gbG9jYWwgZXh0cmVtdW1zIGFyZSBhZGRlZFxuICogYmV0d2VlbiB0aGUgZGF0YXNldCBkaXNjcmV0ZSBwb2ludHMgZHVlIHRvIHRoZSBpbnRlcnBvbGF0aW9uLlxuICogU2VlIDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9ub3RvbmVfY3ViaWNfaW50ZXJwb2xhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHM6IFNwbGluZVBvaW50W10sIGluZGV4QXhpczogJ3gnIHwgJ3knID0gJ3gnKSB7XG4gIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCBkZWx0YUs6IG51bWJlcltdID0gQXJyYXkocG9pbnRzTGVuKS5maWxsKDApO1xuICBjb25zdCBtSzogbnVtYmVyW10gPSBBcnJheShwb2ludHNMZW4pO1xuXG4gIC8vIENhbGN1bGF0ZSBzbG9wZXMgKGRlbHRhSykgYW5kIGluaXRpYWxpemUgdGFuZ2VudHMgKG1LKVxuICBsZXQgaSwgcG9pbnRCZWZvcmU6IE9wdGlvbmFsU3BsaW5lUG9pbnQsIHBvaW50Q3VycmVudDogT3B0aW9uYWxTcGxpbmVQb2ludDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgY29uc3Qgc2xvcGVEZWx0YSA9IHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuXG4gICAgICAvLyBJbiB0aGUgY2FzZSBvZiB0d28gcG9pbnRzIHRoYXQgYXBwZWFyIGF0IHRoZSBzYW1lIHggcGl4ZWwsIHNsb3BlRGVsdGFYIGlzIDBcbiAgICAgIGRlbHRhS1tpXSA9IHNsb3BlRGVsdGEgIT09IDAgPyAocG9pbnRBZnRlclt2YWx1ZUF4aXNdIC0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc10pIC8gc2xvcGVEZWx0YSA6IDA7XG4gICAgfVxuICAgIG1LW2ldID0gIXBvaW50QmVmb3JlID8gZGVsdGFLW2ldXG4gICAgICA6ICFwb2ludEFmdGVyID8gZGVsdGFLW2kgLSAxXVxuICAgICAgICA6IChzaWduKGRlbHRhS1tpIC0gMV0pICE9PSBzaWduKGRlbHRhS1tpXSkpID8gMFxuICAgICAgICAgIDogKGRlbHRhS1tpIC0gMV0gKyBkZWx0YUtbaV0pIC8gMjtcbiAgfVxuXG4gIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSyk7XG5cbiAgbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyk7XG59XG5cbmZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdDogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xufVxuXG5mdW5jdGlvbiBjYXBCZXppZXJQb2ludHMocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBhcmVhOiBDaGFydEFyZWEpIHtcbiAgbGV0IGksIGlsZW4sIHBvaW50LCBpbkFyZWEsIGluQXJlYVByZXY7XG4gIGxldCBpbkFyZWFOZXh0ID0gX2lzUG9pbnRJbkFyZWEocG9pbnRzWzBdLCBhcmVhKTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbkFyZWFQcmV2ID0gaW5BcmVhO1xuICAgIGluQXJlYSA9IGluQXJlYU5leHQ7XG4gICAgaW5BcmVhTmV4dCA9IGkgPCBpbGVuIC0gMSAmJiBfaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLCBhcmVhKTtcbiAgICBpZiAoIWluQXJlYSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgIGlmIChpbkFyZWFQcmV2KSB7XG4gICAgICBwb2ludC5jcDF4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDF5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICAgIGlmIChpbkFyZWFOZXh0KSB7XG4gICAgICBwb2ludC5jcDJ4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDJ5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKFxuICBwb2ludHM6IFNwbGluZVBvaW50W10sXG4gIG9wdGlvbnMsXG4gIGFyZWE6IENoYXJ0QXJlYSxcbiAgbG9vcDogYm9vbGVhbixcbiAgaW5kZXhBeGlzOiAneCcgfCAneSdcbikge1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHBvaW50OiBTcGxpbmVQb2ludCwgY29udHJvbFBvaW50czogUmV0dXJuVHlwZTx0eXBlb2Ygc3BsaW5lQ3VydmU+O1xuXG4gIC8vIE9ubHkgY29uc2lkZXIgcG9pbnRzIHRoYXQgYXJlIGRyYXduIGluIGNhc2UgdGhlIHNwYW5HYXBzIG9wdGlvbiBpcyB1c2VkXG4gIGlmIChvcHRpb25zLnNwYW5HYXBzKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLmZpbHRlcigocHQpID0+ICFwdC5za2lwKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJldiA9IGxvb3AgPyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIDogcG9pbnRzWzBdO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnRyb2xQb2ludHMgPSBzcGxpbmVDdXJ2ZShcbiAgICAgICAgcHJldixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHBvaW50c1tNYXRoLm1pbihpICsgMSwgaWxlbiAtIChsb29wID8gMCA6IDEpKSAlIGlsZW5dLFxuICAgICAgICBvcHRpb25zLnRlbnNpb25cbiAgICAgICk7XG4gICAgICBwb2ludC5jcDF4ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xuICAgICAgcG9pbnQuY3AxeSA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueTtcbiAgICAgIHBvaW50LmNwMnggPSBjb250cm9sUG9pbnRzLm5leHQueDtcbiAgICAgIHBvaW50LmNwMnkgPSBjb250cm9sUG9pbnRzLm5leHQueTtcbiAgICAgIHByZXYgPSBwb2ludDtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5jYXBCZXppZXJQb2ludHMpIHtcbiAgICBjYXBCZXppZXJQb2ludHMocG9pbnRzLCBhcmVhKTtcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtDaGFydEFyZWEsIFNjYWxlfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSBQcml2YXRlQ2hhcnQgZnJvbSAnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0LCBDaGFydEV2ZW50fSBmcm9tICcuLi90eXBlcy5qcyc7XG5pbXBvcnQge0lORklOSVRZfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0RvbVN1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRQYXJlbnROb2RlKGRvbU5vZGU6IEhUTUxDYW52YXNFbGVtZW50KTogSFRNTENhbnZhc0VsZW1lbnQge1xuICBsZXQgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcbiAgICBwYXJlbnQgPSAocGFyZW50IGFzIFNoYWRvd1Jvb3QpLmhvc3Q7XG4gIH1cbiAgcmV0dXJuIHBhcmVudCBhcyBIVE1MQ2FudmFzRWxlbWVudDtcbn1cblxuLyoqXG4gKiBjb252ZXJ0IG1heC13aWR0aC9tYXgtaGVpZ2h0IHZhbHVlcyB0aGF0IG1heSBiZSBwZXJjZW50YWdlcyBpbnRvIGEgbnVtYmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBub2RlOiBIVE1MRWxlbWVudCwgcGFyZW50UHJvcGVydHk6IHN0cmluZykge1xuICBsZXQgdmFsdWVJblBpeGVsczogbnVtYmVyO1xuICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHBhcnNlSW50KHN0eWxlVmFsdWUsIDEwKTtcblxuICAgIGlmIChzdHlsZVZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgIC8vIHBlcmNlbnRhZ2UgKiBzaXplIGluIGRpbWVuc2lvblxuICAgICAgdmFsdWVJblBpeGVscyA9ICh2YWx1ZUluUGl4ZWxzIC8gMTAwKSAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlSW5QaXhlbHM7XG59XG5cbmNvbnN0IGdldENvbXB1dGVkU3R5bGUgPSAoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBDU1NTdHlsZURlY2xhcmF0aW9uID0+XG4gIGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBwcm9wZXJ0eTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xufVxuXG5jb25zdCBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuZnVuY3Rpb24gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlczogQ1NTU3R5bGVEZWNsYXJhdGlvbiwgc3R5bGU6IHN0cmluZywgc3VmZml4Pzogc3RyaW5nKTogQ2hhcnRBcmVhIHtcbiAgY29uc3QgcmVzdWx0ID0ge30gYXMgQ2hhcnRBcmVhO1xuICBzdWZmaXggPSBzdWZmaXggPyAnLScgKyBzdWZmaXggOiAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbaV07XG4gICAgcmVzdWx0W3Bvc10gPSBwYXJzZUZsb2F0KHN0eWxlc1tzdHlsZSArICctJyArIHBvcyArIHN1ZmZpeF0pIHx8IDA7XG4gIH1cbiAgcmVzdWx0LndpZHRoID0gcmVzdWx0LmxlZnQgKyByZXN1bHQucmlnaHQ7XG4gIHJlc3VsdC5oZWlnaHQgPSByZXN1bHQudG9wICsgcmVzdWx0LmJvdHRvbTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgdXNlT2Zmc2V0UG9zID0gKHg6IG51bWJlciwgeTogbnVtYmVyLCB0YXJnZXQ6IEhUTUxFbGVtZW50IHwgRXZlbnRUYXJnZXQpID0+XG4gICh4ID4gMCB8fCB5ID4gMCkgJiYgKCF0YXJnZXQgfHwgISh0YXJnZXQgYXMgSFRNTEVsZW1lbnQpLnNoYWRvd1Jvb3QpO1xuXG4vKipcbiAqIEBwYXJhbSBlXG4gKiBAcGFyYW0gY2FudmFzXG4gKiBAcmV0dXJucyBDYW52YXMgcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FudmFzUG9zaXRpb24oXG4gIGU6IEV2ZW50IHwgVG91Y2hFdmVudCB8IE1vdXNlRXZlbnQsXG4gIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnRcbik6IHtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgIGJveDogYm9vbGVhbjtcbiAgfSB7XG4gIGNvbnN0IHRvdWNoZXMgPSAoZSBhcyBUb3VjaEV2ZW50KS50b3VjaGVzO1xuICBjb25zdCBzb3VyY2UgPSAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA/IHRvdWNoZXNbMF0gOiBlKSBhcyBNb3VzZUV2ZW50O1xuICBjb25zdCB7b2Zmc2V0WCwgb2Zmc2V0WX0gPSBzb3VyY2UgYXMgTW91c2VFdmVudDtcbiAgbGV0IGJveCA9IGZhbHNlO1xuICBsZXQgeCwgeTtcbiAgaWYgKHVzZU9mZnNldFBvcyhvZmZzZXRYLCBvZmZzZXRZLCBlLnRhcmdldCkpIHtcbiAgICB4ID0gb2Zmc2V0WDtcbiAgICB5ID0gb2Zmc2V0WTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHggPSBzb3VyY2UuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICB5ID0gc291cmNlLmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICBib3ggPSB0cnVlO1xuICB9XG4gIHJldHVybiB7eCwgeSwgYm94fTtcbn1cblxuLyoqXG4gKiBHZXRzIGFuIGV2ZW50J3MgeCwgeSBjb29yZGluYXRlcywgcmVsYXRpdmUgdG8gdGhlIGNoYXJ0IGFyZWFcbiAqIEBwYXJhbSBldmVudFxuICogQHBhcmFtIGNoYXJ0XG4gKiBAcmV0dXJucyB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBldmVudFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKFxuICBldmVudDogRXZlbnQgfCBDaGFydEV2ZW50IHwgVG91Y2hFdmVudCB8IE1vdXNlRXZlbnQsXG4gIGNoYXJ0OiBDaGFydCB8IFByaXZhdGVDaGFydFxuKTogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHtcbiAgaWYgKCduYXRpdmUnIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgY29uc3Qge2NhbnZhcywgY3VycmVudERldmljZVBpeGVsUmF0aW99ID0gY2hhcnQ7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBib3JkZXJCb3ggPSBzdHlsZS5ib3hTaXppbmcgPT09ICdib3JkZXItYm94JztcbiAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgY29uc3Qge3gsIHksIGJveH0gPSBnZXRDYW52YXNQb3NpdGlvbihldmVudCwgY2FudmFzKTtcbiAgY29uc3QgeE9mZnNldCA9IHBhZGRpbmdzLmxlZnQgKyAoYm94ICYmIGJvcmRlcnMubGVmdCk7XG4gIGNvbnN0IHlPZmZzZXQgPSBwYWRkaW5ncy50b3AgKyAoYm94ICYmIGJvcmRlcnMudG9wKTtcblxuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY2hhcnQ7XG4gIGlmIChib3JkZXJCb3gpIHtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZCgoeCAtIHhPZmZzZXQpIC8gd2lkdGggKiBjYW52YXMud2lkdGggLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyksXG4gICAgeTogTWF0aC5yb3VuZCgoeSAtIHlPZmZzZXQpIC8gaGVpZ2h0ICogY2FudmFzLmhlaWdodCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250YWluZXJTaXplKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogUGFydGlhbDxTY2FsZT4ge1xuICBsZXQgbWF4V2lkdGg6IG51bWJlciwgbWF4SGVpZ2h0OiBudW1iZXI7XG5cbiAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgd2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICBoZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyB0aGlzIGlzIHRoZSBib3JkZXIgYm94IG9mIHRoZSBjb250YWluZXJcbiAgICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgICAgY29uc3QgY29udGFpbmVyQm9yZGVyID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgICBjb25zdCBjb250YWluZXJQYWRkaW5nID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAncGFkZGluZycpO1xuICAgICAgd2lkdGggPSByZWN0LndpZHRoIC0gY29udGFpbmVyUGFkZGluZy53aWR0aCAtIGNvbnRhaW5lckJvcmRlci53aWR0aDtcbiAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0IC0gY29udGFpbmVyUGFkZGluZy5oZWlnaHQgLSBjb250YWluZXJCb3JkZXIuaGVpZ2h0O1xuICAgICAgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heFdpZHRoLCBjb250YWluZXIsICdjbGllbnRXaWR0aCcpO1xuICAgICAgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhIZWlnaHQsIGNvbnRhaW5lciwgJ2NsaWVudEhlaWdodCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBtYXhXaWR0aDogbWF4V2lkdGggfHwgSU5GSU5JVFksXG4gICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQgfHwgSU5GSU5JVFlcbiAgfTtcbn1cblxuY29uc3Qgcm91bmQxID0gKHY6IG51bWJlcikgPT4gTWF0aC5yb3VuZCh2ICogMTApIC8gMTA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF4aW11bVNpemUoXG4gIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXG4gIGJiV2lkdGg/OiBudW1iZXIsXG4gIGJiSGVpZ2h0PzogbnVtYmVyLFxuICBhc3BlY3RSYXRpbz86IG51bWJlclxuKTogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9IHtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG4gIGNvbnN0IG1hcmdpbnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdtYXJnaW4nKTtcbiAgY29uc3QgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heFdpZHRoLCBjYW52YXMsICdjbGllbnRXaWR0aCcpIHx8IElORklOSVRZO1xuICBjb25zdCBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heEhlaWdodCwgY2FudmFzLCAnY2xpZW50SGVpZ2h0JykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IGNvbnRhaW5lclNpemUgPSBnZXRDb250YWluZXJTaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQpO1xuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY29udGFpbmVyU2l6ZTtcblxuICBpZiAoc3R5bGUuYm94U2l6aW5nID09PSAnY29udGVudC1ib3gnKSB7XG4gICAgY29uc3QgYm9yZGVycyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICAgIHdpZHRoIC09IHBhZGRpbmdzLndpZHRoICsgYm9yZGVycy53aWR0aDtcbiAgICBoZWlnaHQgLT0gcGFkZGluZ3MuaGVpZ2h0ICsgYm9yZGVycy5oZWlnaHQ7XG4gIH1cbiAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCAtIG1hcmdpbnMud2lkdGgpO1xuICBoZWlnaHQgPSBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IHdpZHRoIC8gYXNwZWN0UmF0aW8gOiBoZWlnaHQgLSBtYXJnaW5zLmhlaWdodCk7XG4gIHdpZHRoID0gcm91bmQxKE1hdGgubWluKHdpZHRoLCBtYXhXaWR0aCwgY29udGFpbmVyU2l6ZS5tYXhXaWR0aCkpO1xuICBoZWlnaHQgPSByb3VuZDEoTWF0aC5taW4oaGVpZ2h0LCBtYXhIZWlnaHQsIGNvbnRhaW5lclNpemUubWF4SGVpZ2h0KSk7XG4gIGlmICh3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQ2NTlcbiAgICAvLyBJZiB0aGUgY2FudmFzIGhhcyB3aWR0aCwgYnV0IG5vIGhlaWdodCwgZGVmYXVsdCB0byBhc3BlY3RSYXRpbyBvZiAyIChjYW52YXMgZGVmYXVsdClcbiAgICBoZWlnaHQgPSByb3VuZDEod2lkdGggLyAyKTtcbiAgfVxuXG4gIGNvbnN0IG1haW50YWluSGVpZ2h0ID0gYmJXaWR0aCAhPT0gdW5kZWZpbmVkIHx8IGJiSGVpZ2h0ICE9PSB1bmRlZmluZWQ7XG5cbiAgaWYgKG1haW50YWluSGVpZ2h0ICYmIGFzcGVjdFJhdGlvICYmIGNvbnRhaW5lclNpemUuaGVpZ2h0ICYmIGhlaWdodCA+IGNvbnRhaW5lclNpemUuaGVpZ2h0KSB7XG4gICAgaGVpZ2h0ID0gY29udGFpbmVyU2l6ZS5oZWlnaHQ7XG4gICAgd2lkdGggPSByb3VuZDEoTWF0aC5mbG9vcihoZWlnaHQgKiBhc3BlY3RSYXRpbykpO1xuICB9XG5cbiAgcmV0dXJuIHt3aWR0aCwgaGVpZ2h0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gY2hhcnRcbiAqIEBwYXJhbSBmb3JjZVJhdGlvXG4gKiBAcGFyYW0gZm9yY2VTdHlsZVxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgY2FudmFzIGNvbnRleHQgc2l6ZSBvciB0cmFuc2Zvcm1hdGlvbiBoYXMgY2hhbmdlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldGluYVNjYWxlKFxuICBjaGFydDogQ2hhcnQgfCBQcml2YXRlQ2hhcnQsXG4gIGZvcmNlUmF0aW86IG51bWJlcixcbiAgZm9yY2VTdHlsZT86IGJvb2xlYW5cbik6IGJvb2xlYW4gfCB2b2lkIHtcbiAgY29uc3QgcGl4ZWxSYXRpbyA9IGZvcmNlUmF0aW8gfHwgMTtcbiAgY29uc3QgZGV2aWNlSGVpZ2h0ID0gTWF0aC5mbG9vcihjaGFydC5oZWlnaHQgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlV2lkdGggPSBNYXRoLmZsb29yKGNoYXJ0LndpZHRoICogcGl4ZWxSYXRpbyk7XG5cbiAgKGNoYXJ0IGFzIFByaXZhdGVDaGFydCkuaGVpZ2h0ID0gTWF0aC5mbG9vcihjaGFydC5oZWlnaHQpO1xuICAoY2hhcnQgYXMgUHJpdmF0ZUNoYXJ0KS53aWR0aCA9IE1hdGguZmxvb3IoY2hhcnQud2lkdGgpO1xuXG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcblxuICAvLyBJZiBubyBzdHlsZSBoYXMgYmVlbiBzZXQgb24gdGhlIGNhbnZhcywgdGhlIHJlbmRlciBzaXplIGlzIHVzZWQgYXMgZGlzcGxheSBzaXplLFxuICAvLyBtYWtpbmcgdGhlIGNoYXJ0IHZpc3VhbGx5IGJpZ2dlciwgc28gbGV0J3MgZW5mb3JjZSBpdCB0byB0aGUgXCJjb3JyZWN0XCIgdmFsdWVzLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzM1NzVcbiAgaWYgKGNhbnZhcy5zdHlsZSAmJiAoZm9yY2VTdHlsZSB8fCAoIWNhbnZhcy5zdHlsZS5oZWlnaHQgJiYgIWNhbnZhcy5zdHlsZS53aWR0aCkpKSB7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NoYXJ0LmhlaWdodH1weGA7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7Y2hhcnQud2lkdGh9cHhgO1xuICB9XG5cbiAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBwaXhlbFJhdGlvXG4gICAgICB8fCBjYW52YXMuaGVpZ2h0ICE9PSBkZXZpY2VIZWlnaHRcbiAgICAgIHx8IGNhbnZhcy53aWR0aCAhPT0gZGV2aWNlV2lkdGgpIHtcbiAgICAoY2hhcnQgYXMgUHJpdmF0ZUNoYXJ0KS5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGRldmljZUhlaWdodDtcbiAgICBjYW52YXMud2lkdGggPSBkZXZpY2VXaWR0aDtcbiAgICBjaGFydC5jdHguc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHN1cHBvcnQgZm9yIG9wdGlvbnMgb2JqZWN0IGFyZ3VtZW50IGluIGFkZEV2ZW50TGlzdGVuZXIuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcbiAgbGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYnJvd3NlciBhdHRlbXB0cyB0byBhY2Nlc3MgdGhlIHBhc3NpdmUgcHJvcGVydHkuXG4gICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBhcyBFdmVudExpc3RlbmVyT3B0aW9ucztcblxuICAgIGlmIChfaXNEb21TdXBwb3J0ZWQoKSkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICB9XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufSgpKTtcblxuLyoqXG4gKiBUaGUgXCJ1c2VkXCIgc2l6ZSBpcyB0aGUgZmluYWwgdmFsdWUgb2YgYSBkaW1lbnNpb24gcHJvcGVydHkgYWZ0ZXIgYWxsIGNhbGN1bGF0aW9ucyBoYXZlXG4gKiBiZWVuIHBlcmZvcm1lZC4gVGhpcyBtZXRob2QgdXNlcyB0aGUgY29tcHV0ZWQgc3R5bGUgb2YgYGVsZW1lbnRgIGJ1dCByZXR1cm5zIHVuZGVmaW5lZFxuICogaWYgdGhlIGNvbXB1dGVkIHN0eWxlIGlzIG5vdCBleHByZXNzZWQgaW4gcGl4ZWxzLiBUaGF0IGNhbiBoYXBwZW4gaW4gc29tZSBjYXNlcyB3aGVyZVxuICogYGVsZW1lbnRgIGhhcyBhIHNpemUgcmVsYXRpdmUgdG8gaXRzIHBhcmVudCBhbmQgdGhpcyBsYXN0IG9uZSBpcyBub3QgeWV0IGRpc3BsYXllZCxcbiAqIGZvciBleGFtcGxlIGJlY2F1c2Ugb2YgYGRpc3BsYXk6IG5vbmVgIG9uIGEgcGFyZW50IG5vZGUuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy91c2VkX3ZhbHVlXG4gKiBAcmV0dXJucyBTaXplIGluIHBpeGVscyBvciB1bmRlZmluZWQgaWYgdW5rbm93bi5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmVhZFVzZWRTaXplKFxuICBlbGVtZW50OiBIVE1MRWxlbWVudCxcbiAgcHJvcGVydHk6ICd3aWR0aCcgfCAnaGVpZ2h0J1xuKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgdmFsdWUgPSBnZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSk7XG4gIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyArbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbn1cbiIsICJpbXBvcnQgdHlwZSB7UG9pbnQsIFNwbGluZVBvaW50fSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfcG9pbnRJbkxpbmUocDE6IFBvaW50LCBwMjogUG9pbnQsIHQ6IG51bWJlciwgbW9kZT8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogcDEueSArIHQgKiAocDIueSAtIHAxLnkpXG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zdGVwcGVkSW50ZXJwb2xhdGlvbihcbiAgcDE6IFBvaW50LFxuICBwMjogUG9pbnQsXG4gIHQ6IG51bWJlciwgbW9kZTogJ21pZGRsZScgfCAnYWZ0ZXInIHwgdW5rbm93blxuKSB7XG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IG1vZGUgPT09ICdtaWRkbGUnID8gdCA8IDAuNSA/IHAxLnkgOiBwMi55XG4gICAgICA6IG1vZGUgPT09ICdhZnRlcicgPyB0IDwgMSA/IHAxLnkgOiBwMi55XG4gICAgICAgIDogdCA+IDAgPyBwMi55IDogcDEueVxuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYmV6aWVySW50ZXJwb2xhdGlvbihwMTogU3BsaW5lUG9pbnQsIHAyOiBTcGxpbmVQb2ludCwgdDogbnVtYmVyLCBtb2RlPykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBjb25zdCBjcDEgPSB7eDogcDEuY3AyeCwgeTogcDEuY3AyeX07XG4gIGNvbnN0IGNwMiA9IHt4OiBwMi5jcDF4LCB5OiBwMi5jcDF5fTtcbiAgY29uc3QgYSA9IF9wb2ludEluTGluZShwMSwgY3AxLCB0KTtcbiAgY29uc3QgYiA9IF9wb2ludEluTGluZShjcDEsIGNwMiwgdCk7XG4gIGNvbnN0IGMgPSBfcG9pbnRJbkxpbmUoY3AyLCBwMiwgdCk7XG4gIGNvbnN0IGQgPSBfcG9pbnRJbkxpbmUoYSwgYiwgdCk7XG4gIGNvbnN0IGUgPSBfcG9pbnRJbkxpbmUoYiwgYywgdCk7XG4gIHJldHVybiBfcG9pbnRJbkxpbmUoZCwgZSwgdCk7XG59XG4iLCAiZXhwb3J0IGludGVyZmFjZSBSVExBZGFwdGVyIHtcbiAgeCh4OiBudW1iZXIpOiBudW1iZXI7XG4gIHNldFdpZHRoKHc6IG51bWJlcik6IHZvaWQ7XG4gIHRleHRBbGlnbihhbGlnbjogJ2NlbnRlcicgfCAnbGVmdCcgfCAncmlnaHQnKTogJ2NlbnRlcicgfCAnbGVmdCcgfCAncmlnaHQnO1xuICB4UGx1cyh4OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiBudW1iZXI7XG4gIGxlZnRGb3JMdHIoeDogbnVtYmVyLCBpdGVtV2lkdGg6IG51bWJlcik6IG51bWJlcjtcbn1cblxuY29uc3QgZ2V0UmlnaHRUb0xlZnRBZGFwdGVyID0gZnVuY3Rpb24ocmVjdFg6IG51bWJlciwgd2lkdGg6IG51bWJlcik6IFJUTEFkYXB0ZXIge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHJlY3RYICsgcmVjdFggKyB3aWR0aCAtIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7XG4gICAgICB3aWR0aCA9IHc7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFsaWduO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCAtIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBpdGVtV2lkdGgpIHtcbiAgICAgIHJldHVybiB4IC0gaXRlbVdpZHRoO1xuICAgIH0sXG4gIH07XG59O1xuXG5jb25zdCBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIgPSBmdW5jdGlvbigpOiBSVExBZGFwdGVyIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIHJldHVybiBhbGlnbjtcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCArIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBfaXRlbVdpZHRoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJ0bEFkYXB0ZXIocnRsOiBib29sZWFuLCByZWN0WDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKSB7XG4gIHJldHVybiBydGwgPyBnZXRSaWdodFRvTGVmdEFkYXB0ZXIocmVjdFgsIHdpZHRoKSA6IGdldExlZnRUb1JpZ2h0QWRhcHRlcigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBkaXJlY3Rpb246ICdsdHInIHwgJ3J0bCcpIHtcbiAgbGV0IHN0eWxlOiBDU1NTdHlsZURlY2xhcmF0aW9uLCBvcmlnaW5hbDogW3N0cmluZywgc3RyaW5nXTtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ2x0cicgfHwgZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHN0eWxlID0gY3R4LmNhbnZhcy5zdHlsZTtcbiAgICBvcmlnaW5hbCA9IFtcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpLFxuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eSgnZGlyZWN0aW9uJyksXG4gICAgXTtcblxuICAgIHN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBkaXJlY3Rpb24sICdpbXBvcnRhbnQnKTtcbiAgICAoY3R4IGFzIHsgcHJldlRleHREaXJlY3Rpb24/OiBbc3RyaW5nLCBzdHJpbmddIH0pLnByZXZUZXh0RGlyZWN0aW9uID0gb3JpZ2luYWw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBvcmlnaW5hbD86IFtzdHJpbmcsIHN0cmluZ10pIHtcbiAgaWYgKG9yaWdpbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgKGN0eCBhcyB7IHByZXZUZXh0RGlyZWN0aW9uPzogW3N0cmluZywgc3RyaW5nXSB9KS5wcmV2VGV4dERpcmVjdGlvbjtcbiAgICBjdHguY2FudmFzLnN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBvcmlnaW5hbFswXSwgb3JpZ2luYWxbMV0pO1xuICB9XG59XG4iLCAiaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBfYW5nbGVEaWZmLCBfaXNCZXR3ZWVuLCBfbm9ybWFsaXplQW5nbGV9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dH0gZnJvbSAnLi9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtpc1BhdHRlcm5PckdyYWRpZW50fSBmcm9tICcuL2hlbHBlcnMuY29sb3IuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9lbGVtZW50cy9lbGVtZW50LmxpbmUuanMnKS5kZWZhdWx0IH0gTGluZUVsZW1lbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICogQHR5cGVkZWYge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgbG9vcDogYm9vbGVhbiwgc3R5bGU/OiBhbnl9fSBTZWdtZW50XG4gKi9cblxuZnVuY3Rpb24gcHJvcGVydHlGbihwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogX2FuZ2xlQmV0d2VlbixcbiAgICAgIGNvbXBhcmU6IF9hbmdsZURpZmYsXG4gICAgICBub3JtYWxpemU6IF9ub3JtYWxpemVBbmdsZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgYmV0d2VlbjogX2lzQmV0d2VlbixcbiAgICBjb21wYXJlOiAoYSwgYikgPT4gYSAtIGIsXG4gICAgbm9ybWFsaXplOiB4ID0+IHhcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2VnbWVudCh7c3RhcnQsIGVuZCwgY291bnQsIGxvb3AsIHN0eWxlfSkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCAlIGNvdW50LFxuICAgIGVuZDogZW5kICUgY291bnQsXG4gICAgbG9vcDogbG9vcCAmJiAoZW5kIC0gc3RhcnQgKyAxKSAlIGNvdW50ID09PSAwLFxuICAgIHN0eWxlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IHtiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge3N0YXJ0LCBlbmQsIGxvb3B9ID0gc2VnbWVudDtcbiAgbGV0IGksIGlsZW47XG5cbiAgaWYgKGxvb3ApIHtcbiAgICBzdGFydCArPSBjb3VudDtcbiAgICBlbmQgKz0gY291bnQ7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAoIWJldHdlZW4obm9ybWFsaXplKHBvaW50c1tzdGFydCAlIGNvdW50XVtwcm9wZXJ0eV0pLCBzdGFydEJvdW5kLCBlbmRCb3VuZCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGFydC0tO1xuICAgICAgZW5kLS07XG4gICAgfVxuICAgIHN0YXJ0ICU9IGNvdW50O1xuICAgIGVuZCAlPSBjb3VudDtcbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkge1xuICAgIGVuZCArPSBjb3VudDtcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlOiBzZWdtZW50LnN0eWxlfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdWItc2VnbWVudChzKSBvZiBhIGxpbmUgc2VnbWVudCB0aGF0IGZhbGwgaW4gdGhlIGdpdmVuIGJvdW5kc1xuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50LnN0eWxlXSAtIHNlZ21lbnQgc3R5bGVcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50cyAtIHRoZSBwb2ludHMgdGhhdCB0aGlzIHNlZ21lbnQgcmVmZXJzIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gW2JvdW5kc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZHMucHJvcGVydHkgLSB0aGUgcHJvcGVydHkgb2YgYSBgUG9pbnRFbGVtZW50YCB3ZSBhcmUgYm91bmRpbmcuIGB4YCwgYHlgIG9yIGBhbmdsZWAuXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLnN0YXJ0IC0gc3RhcnQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLmVuZCAtIGVuZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBpZiAoIWJvdW5kcykge1xuICAgIHJldHVybiBbc2VnbWVudF07XG4gIH1cblxuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7Y29tcGFyZSwgYmV0d2Vlbiwgbm9ybWFsaXplfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICBjb25zdCB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGV9ID0gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcyk7XG5cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgbGV0IHN1YlN0YXJ0ID0gbnVsbDtcbiAgbGV0IHZhbHVlLCBwb2ludCwgcHJldlZhbHVlO1xuXG4gIGNvbnN0IHN0YXJ0SXNCZWZvcmUgPSAoKSA9PiBiZXR3ZWVuKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpICYmIGNvbXBhcmUoc3RhcnRCb3VuZCwgcHJldlZhbHVlKSAhPT0gMDtcbiAgY29uc3QgZW5kSXNCZWZvcmUgPSAoKSA9PiBjb21wYXJlKGVuZEJvdW5kLCB2YWx1ZSkgPT09IDAgfHwgYmV0d2VlbihlbmRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSk7XG4gIGNvbnN0IHNob3VsZFN0YXJ0ID0gKCkgPT4gaW5zaWRlIHx8IHN0YXJ0SXNCZWZvcmUoKTtcbiAgY29uc3Qgc2hvdWxkU3RvcCA9ICgpID0+ICFpbnNpZGUgfHwgZW5kSXNCZWZvcmUoKTtcblxuICBmb3IgKGxldCBpID0gc3RhcnQsIHByZXYgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW2kgJSBjb3VudF07XG5cbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFsdWUgPSBub3JtYWxpemUocG9pbnRbcHJvcGVydHldKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gcHJldlZhbHVlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpbnNpZGUgPSBiZXR3ZWVuKHZhbHVlLCBzdGFydEJvdW5kLCBlbmRCb3VuZCk7XG5cbiAgICBpZiAoc3ViU3RhcnQgPT09IG51bGwgJiYgc2hvdWxkU3RhcnQoKSkge1xuICAgICAgc3ViU3RhcnQgPSBjb21wYXJlKHZhbHVlLCBzdGFydEJvdW5kKSA9PT0gMCA/IGkgOiBwcmV2O1xuICAgIH1cblxuICAgIGlmIChzdWJTdGFydCAhPT0gbnVsbCAmJiBzaG91bGRTdG9wKCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kOiBpLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XG4gICAgICBzdWJTdGFydCA9IG51bGw7XG4gICAgfVxuICAgIHByZXYgPSBpO1xuICAgIHByZXZWYWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQsIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzZWdtZW50cyBvZiB0aGUgbGluZSB0aGF0IGFyZSBpbnNpZGUgZ2l2ZW4gYm91bmRzXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gW2JvdW5kc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZHMucHJvcGVydHkgLSB0aGUgcHJvcGVydHkgd2UgYXJlIGJvdW5kaW5nIHdpdGguIGB4YCwgYHlgIG9yIGBhbmdsZWAuXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLnN0YXJ0IC0gc3RhcnQgdmFsdWUgb2YgdGhlIGBwcm9wZXJ0eWBcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMuZW5kIC0gZW5kIHZhbHVlIG9mIHRoZSBgcHJvcGVydHlgXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JvdW5kU2VnbWVudHMobGluZSwgYm91bmRzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN1YiA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudHNbaV0sIGxpbmUucG9pbnRzLCBib3VuZHMpO1xuICAgIGlmIChzdWIubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaCguLi5zdWIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEZpbmQgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiBhIGxpbmUuXG4gKi9cbmZ1bmN0aW9uIGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcykge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gY291bnQgLSAxO1xuXG4gIGlmIChsb29wICYmICFzcGFuR2Fwcykge1xuICAgIC8vIGxvb3AgYW5kIG5vdCBzcGFubmluZyBnYXBzLCBmaXJzdCBmaW5kIGEgZ2FwIHRvIHN0YXJ0IGZyb21cbiAgICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiAhcG9pbnRzW3N0YXJ0XS5za2lwKSB7XG4gICAgICBzdGFydCsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpbmQgZmlyc3Qgbm9uIHNraXBwZWQgcG9pbnQgKGFmdGVyIHRoZSBmaXJzdCBnYXAgcG9zc2libHkpXG4gIHdoaWxlIChzdGFydCA8IGNvdW50ICYmIHBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgIHN0YXJ0Kys7XG4gIH1cblxuICAvLyBpZiB3ZSBsb29wZWQgdG8gY291bnQsIHN0YXJ0IG5lZWRzIHRvIGJlIDBcbiAgc3RhcnQgJT0gY291bnQ7XG5cbiAgaWYgKGxvb3ApIHtcbiAgICAvLyBsb29wIHdpbGwgZ28gcGFzdCBjb3VudCwgaWYgc3RhcnQgPiAwXG4gICAgZW5kICs9IHN0YXJ0O1xuICB9XG5cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHBvaW50c1tlbmQgJSBjb3VudF0uc2tpcCkge1xuICAgIGVuZC0tO1xuICB9XG5cbiAgLy8gZW5kIGNvdWxkIGJlIG1vcmUgdGhhbiBjb3VudCwgbm9ybWFsaXplXG4gIGVuZCAlPSBjb3VudDtcblxuICByZXR1cm4ge3N0YXJ0LCBlbmR9O1xufVxuXG4vKipcbiAqIENvbXB1dGUgc29saWQgc2VnbWVudHMgZnJvbSBQb2ludHMsIHdoZW4gc3BhbkdhcHMgPT09IGZhbHNlXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHMgLSB0aGUgcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIG1heCBpbmRleCAoY2FuIGdvIHBhc3QgY291bnQgb24gYSBsb29wKVxuICogQHBhcmFtIHtib29sZWFufSBsb29wIC0gYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhpcyB3b3VsZCBiZSBhIGxvb3AgaWYgbm8gZ2FwcyBhcmUgZm91bmRcbiAqL1xuZnVuY3Rpb24gc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGxvb3ApIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGxhc3QgPSBzdGFydDtcbiAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnRdO1xuICBsZXQgZW5kO1xuXG4gIGZvciAoZW5kID0gc3RhcnQgKyAxOyBlbmQgPD0gbWF4OyArK2VuZCkge1xuICAgIGNvbnN0IGN1ciA9IHBvaW50c1tlbmQgJSBjb3VudF07XG4gICAgaWYgKGN1ci5za2lwIHx8IGN1ci5zdG9wKSB7XG4gICAgICBpZiAoIXByZXYuc2tpcCkge1xuICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiAoZW5kIC0gMSkgJSBjb3VudCwgbG9vcH0pO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHN0YXJ0ID0gbGFzdCA9IGN1ci5zdG9wID8gZW5kIDogbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IGVuZDtcbiAgICAgIGlmIChwcmV2LnNraXApIHtcbiAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIHByZXYgPSBjdXI7XG4gIH1cblxuICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiBsYXN0ICUgY291bnQsIGxvb3B9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgY29udGludW91cyBzZWdtZW50cyB0aGF0IGRlZmluZSB0aGUgd2hvbGUgbGluZVxuICogVGhlcmUgY2FuIGJlIHNraXBwZWQgcG9pbnRzIHdpdGhpbiBhIHNlZ21lbnQsIGlmIHNwYW5HYXBzIGlzIHRydWUuXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnRPcHRpb25zXVxuICogQHJldHVybiB7U2VnbWVudFtdfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jb21wdXRlU2VnbWVudHMobGluZSwgc2VnbWVudE9wdGlvbnMpIHtcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHNwYW5HYXBzID0gbGluZS5vcHRpb25zLnNwYW5HYXBzO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgaWYgKCFjb3VudCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IGxvb3AgPSAhIWxpbmUuX2xvb3A7XG4gIGNvbnN0IHtzdGFydCwgZW5kfSA9IGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcyk7XG5cbiAgaWYgKHNwYW5HYXBzID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgW3tzdGFydCwgZW5kLCBsb29wfV0sIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3QgbWF4ID0gZW5kIDwgc3RhcnQgPyBlbmQgKyBjb3VudCA6IGVuZDtcbiAgY29uc3QgY29tcGxldGVMb29wID0gISFsaW5lLl9mdWxsTG9vcCAmJiBzdGFydCA9PT0gMCAmJiBlbmQgPT09IGNvdW50IC0gMTtcbiAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGNvbXBsZXRlTG9vcCksIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2VnbWVudFtdfSBzZWdtZW50c1xuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnRPcHRpb25zXVxuICogQHJldHVybiB7U2VnbWVudFtdfVxuICovXG5mdW5jdGlvbiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGlmICghc2VnbWVudE9wdGlvbnMgfHwgIXNlZ21lbnRPcHRpb25zLnNldENvbnRleHQgfHwgIXBvaW50cykge1xuICAgIHJldHVybiBzZWdtZW50cztcbiAgfVxuICByZXR1cm4gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge1NlZ21lbnRbXX0gc2VnbWVudHNcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50c1xuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50T3B0aW9uc11cbiAqIEByZXR1cm4ge1NlZ21lbnRbXX1cbiAqL1xuZnVuY3Rpb24gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0Q29udGV4dCA9IGxpbmUuX2NoYXJ0LmdldENvbnRleHQoKTtcbiAgY29uc3QgYmFzZVN0eWxlID0gcmVhZFN0eWxlKGxpbmUub3B0aW9ucyk7XG4gIGNvbnN0IHtfZGF0YXNldEluZGV4OiBkYXRhc2V0SW5kZXgsIG9wdGlvbnM6IHtzcGFuR2Fwc319ID0gbGluZTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHByZXZTdHlsZSA9IGJhc2VTdHlsZTtcbiAgbGV0IHN0YXJ0ID0gc2VnbWVudHNbMF0uc3RhcnQ7XG4gIGxldCBpID0gc3RhcnQ7XG5cbiAgZnVuY3Rpb24gYWRkU3R5bGUocywgZSwgbCwgc3QpIHtcbiAgICBjb25zdCBkaXIgPSBzcGFuR2FwcyA/IC0xIDogMTtcbiAgICBpZiAocyA9PT0gZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTdHlsZSBjYW4gbm90IHN0YXJ0L2VuZCBvbiBhIHNraXBwZWQgcG9pbnQsIGFkanVzdCBpbmRpY2VzIGFjY29yZGluZ2x5XG4gICAgcyArPSBjb3VudDtcbiAgICB3aGlsZSAocG9pbnRzW3MgJSBjb3VudF0uc2tpcCkge1xuICAgICAgcyAtPSBkaXI7XG4gICAgfVxuICAgIHdoaWxlIChwb2ludHNbZSAlIGNvdW50XS5za2lwKSB7XG4gICAgICBlICs9IGRpcjtcbiAgICB9XG4gICAgaWYgKHMgJSBjb3VudCAhPT0gZSAlIGNvdW50KSB7XG4gICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHMgJSBjb3VudCwgZW5kOiBlICUgY291bnQsIGxvb3A6IGwsIHN0eWxlOiBzdH0pO1xuICAgICAgcHJldlN0eWxlID0gc3Q7XG4gICAgICBzdGFydCA9IGUgJSBjb3VudDtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzdGFydCA9IHNwYW5HYXBzID8gc3RhcnQgOiBzZWdtZW50LnN0YXJ0O1xuICAgIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0ICUgY291bnRdO1xuICAgIGxldCBzdHlsZTtcbiAgICBmb3IgKGkgPSBzdGFydCArIDE7IGkgPD0gc2VnbWVudC5lbmQ7IGkrKykge1xuICAgICAgY29uc3QgcHQgPSBwb2ludHNbaSAlIGNvdW50XTtcbiAgICAgIHN0eWxlID0gcmVhZFN0eWxlKHNlZ21lbnRPcHRpb25zLnNldENvbnRleHQoY3JlYXRlQ29udGV4dChjaGFydENvbnRleHQsIHtcbiAgICAgICAgdHlwZTogJ3NlZ21lbnQnLFxuICAgICAgICBwMDogcHJldixcbiAgICAgICAgcDE6IHB0LFxuICAgICAgICBwMERhdGFJbmRleDogKGkgLSAxKSAlIGNvdW50LFxuICAgICAgICBwMURhdGFJbmRleDogaSAlIGNvdW50LFxuICAgICAgICBkYXRhc2V0SW5kZXhcbiAgICAgIH0pKSk7XG4gICAgICBpZiAoc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpKSB7XG4gICAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgICAgfVxuICAgICAgcHJldiA9IHB0O1xuICAgICAgcHJldlN0eWxlID0gc3R5bGU7XG4gICAgfVxuICAgIGlmIChzdGFydCA8IGkgLSAxKSB7XG4gICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZWFkU3R5bGUob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgYm9yZGVyQ2FwU3R5bGU6IG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUsXG4gICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICBib3JkZXJKb2luU3R5bGU6IG9wdGlvbnMuYm9yZGVySm9pblN0eWxlLFxuICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yXG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSB7XG4gIGlmICghcHJldlN0eWxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNhY2hlID0gW107XG4gIGNvbnN0IHJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGlmICghaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKCFjYWNoZS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgIGNhY2hlLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGUuaW5kZXhPZih2YWx1ZSk7XG4gIH07XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHlsZSwgcmVwbGFjZXIpICE9PSBKU09OLnN0cmluZ2lmeShwcmV2U3R5bGUsIHJlcGxhY2VyKTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7Q2hhcnQsIENoYXJ0QXJlYSwgQ2hhcnRNZXRhLCBTY2FsZSwgVFJCTH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBnZXRTaXplRm9yQXJlYShzY2FsZTogU2NhbGUsIGNoYXJ0QXJlYTogQ2hhcnRBcmVhLCBmaWVsZDoga2V5b2YgQ2hhcnRBcmVhKSB7XG4gIHJldHVybiBzY2FsZS5vcHRpb25zLmNsaXAgPyBzY2FsZVtmaWVsZF0gOiBjaGFydEFyZWFbZmllbGRdO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhc2V0QXJlYShtZXRhOiBDaGFydE1ldGEsIGNoYXJ0QXJlYTogQ2hhcnRBcmVhKTogVFJCTCB7XG4gIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICBpZiAoeFNjYWxlICYmIHlTY2FsZSkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBnZXRTaXplRm9yQXJlYSh4U2NhbGUsIGNoYXJ0QXJlYSwgJ2xlZnQnKSxcbiAgICAgIHJpZ2h0OiBnZXRTaXplRm9yQXJlYSh4U2NhbGUsIGNoYXJ0QXJlYSwgJ3JpZ2h0JyksXG4gICAgICB0b3A6IGdldFNpemVGb3JBcmVhKHlTY2FsZSwgY2hhcnRBcmVhLCAndG9wJyksXG4gICAgICBib3R0b206IGdldFNpemVGb3JBcmVhKHlTY2FsZSwgY2hhcnRBcmVhLCAnYm90dG9tJylcbiAgICB9O1xuICB9XG4gIHJldHVybiBjaGFydEFyZWE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhc2V0Q2xpcEFyZWEoY2hhcnQ6IENoYXJ0LCBtZXRhOiBDaGFydE1ldGEpOiBUUkJMIHwgZmFsc2Uge1xuICBjb25zdCBjbGlwID0gbWV0YS5fY2xpcDtcbiAgaWYgKGNsaXAuZGlzYWJsZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYXJlYSA9IGdldERhdGFzZXRBcmVhKG1ldGEsIGNoYXJ0LmNoYXJ0QXJlYSk7XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBjbGlwLmxlZnQgPT09IGZhbHNlID8gMCA6IGFyZWEubGVmdCAtIChjbGlwLmxlZnQgPT09IHRydWUgPyAwIDogY2xpcC5sZWZ0KSxcbiAgICByaWdodDogY2xpcC5yaWdodCA9PT0gZmFsc2UgPyBjaGFydC53aWR0aCA6IGFyZWEucmlnaHQgKyAoY2xpcC5yaWdodCA9PT0gdHJ1ZSA/IDAgOiBjbGlwLnJpZ2h0KSxcbiAgICB0b3A6IGNsaXAudG9wID09PSBmYWxzZSA/IDAgOiBhcmVhLnRvcCAtIChjbGlwLnRvcCA9PT0gdHJ1ZSA/IDAgOiBjbGlwLnRvcCksXG4gICAgYm90dG9tOiBjbGlwLmJvdHRvbSA9PT0gZmFsc2UgPyBjaGFydC5oZWlnaHQgOiBhcmVhLmJvdHRvbSArIChjbGlwLmJvdHRvbSA9PT0gdHJ1ZSA/IDAgOiBjbGlwLmJvdHRvbSlcbiAgfTtcbn1cbiIsICJpbXBvcnQge3JlcXVlc3RBbmltRnJhbWV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuYW5pbWF0aW9uLmpzJykuZGVmYXVsdCB9IEFuaW1hdGlvblxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuLyoqXG4gKiBQbGVhc2UgdXNlIHRoZSBtb2R1bGUncyBkZWZhdWx0IGV4cG9ydCB3aGljaCBwcm92aWRlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZVxuICogTm90ZTogY2xhc3MgaXMgZXhwb3J0IGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBBbmltYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMuX2NoYXJ0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdERhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCB0eXBlKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gYW5pbXMubGlzdGVuZXJzW3R5cGVdO1xuICAgIGNvbnN0IG51bVN0ZXBzID0gYW5pbXMuZHVyYXRpb247XG5cbiAgICBjYWxsYmFja3MuZm9yRWFjaChmbiA9PiBmbih7XG4gICAgICBjaGFydCxcbiAgICAgIGluaXRpYWw6IGFuaW1zLmluaXRpYWwsXG4gICAgICBudW1TdGVwcyxcbiAgICAgIGN1cnJlbnRTdGVwOiBNYXRoLm1pbihkYXRlIC0gYW5pbXMuc3RhcnQsIG51bVN0ZXBzKVxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3JlZnJlc2goKSB7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlKGRhdGUgPSBEYXRlLm5vdygpKSB7XG4gICAgbGV0IHJlbWFpbmluZyA9IDA7XG5cbiAgICB0aGlzLl9jaGFydHMuZm9yRWFjaCgoYW5pbXMsIGNoYXJ0KSA9PiB7XG4gICAgICBpZiAoIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGRyYXcgPSBmYWxzZTtcbiAgICAgIGxldCBpdGVtO1xuXG4gICAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgIGlmIChpdGVtLl9hY3RpdmUpIHtcbiAgICAgICAgICBpZiAoaXRlbS5fdG90YWwgPiBhbmltcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiBoYXMgYmVlbiB1cGRhdGVkIGFuZCBpdHMgZHVyYXRpb24gcHJvbG9uZ2VkLFxuICAgICAgICAgICAgLy8gdXBkYXRlIHRvIHRvdGFsIGR1cmF0aW9uIG9mIGN1cnJlbnQgYW5pbWF0aW9ucyBydW4gKGZvciBwcm9ncmVzcyBldmVudClcbiAgICAgICAgICAgIGFuaW1zLmR1cmF0aW9uID0gaXRlbS5fdG90YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0udGljayhkYXRlKTtcbiAgICAgICAgICBkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGl0ZW0gYnkgcmVwbGFjaW5nIGl0IHdpdGggbGFzdCBpdGVtIGFuZCByZW1vdmluZyB0aGUgbGFzdFxuICAgICAgICAgIC8vIEEgbG90IGZhc3RlciB0aGFuIHNwbGljZS5cbiAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGl0ZW1zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgIGNoYXJ0LmRyYXcoKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ3Byb2dyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGFuaW1zLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ2NvbXBsZXRlJyk7XG4gICAgICAgIGFuaW1zLmluaXRpYWwgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmVtYWluaW5nICs9IGl0ZW1zLmxlbmd0aDtcbiAgICB9KTtcblxuICAgIHRoaXMuX2xhc3REYXRlID0gZGF0ZTtcblxuICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcbiAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRBbmltcyhjaGFydCkge1xuICAgIGNvbnN0IGNoYXJ0cyA9IHRoaXMuX2NoYXJ0cztcbiAgICBsZXQgYW5pbXMgPSBjaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICBhbmltcyA9IHtcbiAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgY29tcGxldGU6IFtdLFxuICAgICAgICAgIHByb2dyZXNzOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhcnRzLnNldChjaGFydCwgYW5pbXMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbXM7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gZXZlbnQgbmFtZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrXG5cdCAqL1xuICBsaXN0ZW4oY2hhcnQsIGV2ZW50LCBjYikge1xuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5saXN0ZW5lcnNbZXZlbnRdLnB1c2goY2IpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZCBhbmltYXRpb25zXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7QW5pbWF0aW9uW119IGl0ZW1zIC0gYW5pbWF0aW9uc1xuXHQgKi9cbiAgYWRkKGNoYXJ0LCBpdGVtcykge1xuICAgIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMucHVzaCguLi5pdGVtcyk7XG4gIH1cblxuICAvKipcblx0ICogQ291bnRzIG51bWJlciBvZiBhY3RpdmUgYW5pbWF0aW9ucyBmb3IgdGhlIGNoYXJ0XG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICBoYXMoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcblx0ICogU3RhcnQgYW5pbWF0aW5nIChhbGwgY2hhcnRzKVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKi9cbiAgc3RhcnQoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbXMucnVubmluZyA9IHRydWU7XG4gICAgYW5pbXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGFuaW1zLmR1cmF0aW9uID0gYW5pbXMuaXRlbXMucmVkdWNlKChhY2MsIGN1cikgPT4gTWF0aC5tYXgoYWNjLCBjdXIuX2R1cmF0aW9uKSwgMCk7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG5cbiAgcnVubmluZyhjaGFydCkge1xuICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTdG9wIGFsbCBhbmltYXRpb25zIGZvciB0aGUgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcblxuICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgaXRlbXNbaV0uY2FuY2VsKCk7XG4gICAgfVxuICAgIGFuaW1zLml0ZW1zID0gW107XG4gICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgRGF0ZS5ub3coKSwgJ2NvbXBsZXRlJyk7XG4gIH1cblxuICAvKipcblx0ICogUmVtb3ZlIGNoYXJ0IGZyb20gQW5pbWF0b3Jcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIHJlbW92ZShjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgfVxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgQW5pbWF0b3IoKTtcbiIsICJpbXBvcnQgZWZmZWN0cyBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZWFzaW5nLmpzJztcbmltcG9ydCB7cmVzb2x2ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtjb2xvciBhcyBoZWxwZXJzQ29sb3J9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xvci5qcyc7XG5cbmNvbnN0IHRyYW5zcGFyZW50ID0gJ3RyYW5zcGFyZW50JztcbmNvbnN0IGludGVycG9sYXRvcnMgPSB7XG4gIGJvb2xlYW4oZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmYWN0b3IgPiAwLjUgPyB0byA6IGZyb207XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvclxuICAgKi9cbiAgY29sb3IoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIGNvbnN0IGMwID0gaGVscGVyc0NvbG9yKGZyb20gfHwgdHJhbnNwYXJlbnQpO1xuICAgIGNvbnN0IGMxID0gYzAudmFsaWQgJiYgaGVscGVyc0NvbG9yKHRvIHx8IHRyYW5zcGFyZW50KTtcbiAgICByZXR1cm4gYzEgJiYgYzEudmFsaWRcbiAgICAgID8gYzEubWl4KGMwLCBmYWN0b3IpLmhleFN0cmluZygpXG4gICAgICA6IHRvO1xuICB9LFxuICBudW1iZXIoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiBmYWN0b3I7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNmZywgdGFyZ2V0LCBwcm9wLCB0bykge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwcm9wXTtcblxuICAgIHRvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgIGNvbnN0IGZyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuXG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl9mbiA9IGNmZy5mbiB8fCBpbnRlcnBvbGF0b3JzW2NmZy50eXBlIHx8IHR5cGVvZiBmcm9tXTtcbiAgICB0aGlzLl9lYXNpbmcgPSBlZmZlY3RzW2NmZy5lYXNpbmddIHx8IGVmZmVjdHMubGluZWFyO1xuICAgIHRoaXMuX3N0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpICsgKGNmZy5kZWxheSB8fCAwKSk7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbCA9IE1hdGguZmxvb3IoY2ZnLmR1cmF0aW9uKTtcbiAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fcHJvcCA9IHByb3A7XG4gICAgdGhpcy5fZnJvbSA9IGZyb207XG4gICAgdGhpcy5fdG8gPSB0bztcbiAgICB0aGlzLl9wcm9taXNlcyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG5cbiAgdXBkYXRlKGNmZywgdG8sIGRhdGUpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuXG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLl90YXJnZXRbdGhpcy5fcHJvcF07XG4gICAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgICAgY29uc3QgcmVtYWluID0gdGhpcy5fZHVyYXRpb24gLSBlbGFwc2VkO1xuICAgICAgdGhpcy5fc3RhcnQgPSBkYXRlO1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSBNYXRoLmZsb29yKE1hdGgubWF4KHJlbWFpbiwgY2ZnLmR1cmF0aW9uKSk7XG4gICAgICB0aGlzLl90b3RhbCArPSBlbGFwc2VkO1xuICAgICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgICB0aGlzLl90byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcbiAgICAgIHRoaXMuX2Zyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuICAgIH1cbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAvLyB1cGRhdGUgY3VycmVudCBldmFsdWF0ZWQgdmFsdWUsIGZvciBzbW9vdGhlciBhbmltYXRpb25zXG4gICAgICB0aGlzLnRpY2soRGF0ZS5ub3coKSk7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgdGljayhkYXRlKSB7XG4gICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgIGNvbnN0IHByb3AgPSB0aGlzLl9wcm9wO1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLl9mcm9tO1xuICAgIGNvbnN0IGxvb3AgPSB0aGlzLl9sb29wO1xuICAgIGNvbnN0IHRvID0gdGhpcy5fdG87XG4gICAgbGV0IGZhY3RvcjtcblxuICAgIHRoaXMuX2FjdGl2ZSA9IGZyb20gIT09IHRvICYmIChsb29wIHx8IChlbGFwc2VkIDwgZHVyYXRpb24pKTtcblxuICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSB0bztcbiAgICAgIHRoaXMuX25vdGlmeSh0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxhcHNlZCA8IDApIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IGZyb207XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmFjdG9yID0gKGVsYXBzZWQgLyBkdXJhdGlvbikgJSAyO1xuICAgIGZhY3RvciA9IGxvb3AgJiYgZmFjdG9yID4gMSA/IDIgLSBmYWN0b3IgOiBmYWN0b3I7XG4gICAgZmFjdG9yID0gdGhpcy5fZWFzaW5nKE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGZhY3RvcikpKTtcblxuICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRoaXMuX2ZuKGZyb20sIHRvLCBmYWN0b3IpO1xuICB9XG5cbiAgd2FpdCgpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8ICh0aGlzLl9wcm9taXNlcyA9IFtdKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICBwcm9taXNlcy5wdXNoKHtyZXMsIHJlan0pO1xuICAgIH0pO1xuICB9XG5cbiAgX25vdGlmeShyZXNvbHZlZCkge1xuICAgIGNvbnN0IG1ldGhvZCA9IHJlc29sdmVkID8gJ3JlcycgOiAncmVqJztcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb21pc2VzW2ldW21ldGhvZF0oKTtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgYW5pbWF0b3IgZnJvbSAnLi9jb3JlLmFuaW1hdG9yLmpzJztcbmltcG9ydCBBbmltYXRpb24gZnJvbSAnLi9jb3JlLmFuaW1hdGlvbi5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNPYmplY3R9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBjb25maWcpIHtcbiAgICB0aGlzLl9jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb25maWd1cmUoY29uZmlnKTtcbiAgfVxuXG4gIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuYW5pbWF0aW9uKTtcbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcblxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNvbmZpZykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgY2ZnID0gY29uZmlnW2tleV07XG4gICAgICBpZiAoIWlzT2JqZWN0KGNmZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzb2x2ZWQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGFuaW1hdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgcmVzb2x2ZWRbb3B0aW9uXSA9IGNmZ1tvcHRpb25dO1xuICAgICAgfVxuXG4gICAgICAoaXNBcnJheShjZmcucHJvcGVydGllcykgJiYgY2ZnLnByb3BlcnRpZXMgfHwgW2tleV0pLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKHByb3AgPT09IGtleSB8fCAhYW5pbWF0ZWRQcm9wcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICBhbmltYXRlZFByb3BzLnNldChwcm9wLCByZXNvbHZlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgdG8gaGFuZGxlIGFuaW1hdGlvbiBvZiBgb3B0aW9uc2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBuZXdPcHRpb25zID0gdmFsdWVzLm9wdGlvbnM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnMob3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgaWYgKG5ld09wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgLy8gR29pbmcgdG8gc2hhcmVkIG9wdGlvbnM6XG4gICAgICAvLyBBZnRlciBhbGwgYW5pbWF0aW9ucyBhcmUgZG9uZSwgYXNzaWduIHRoZSBzaGFyZWQgb3B0aW9ucyBvYmplY3QgdG8gdGhlIGVsZW1lbnRcbiAgICAgIC8vIFNvIGFueSBuZXcgdXBkYXRlcyB0byB0aGUgc2hhcmVkIG9wdGlvbnMgYXJlIG9ic2VydmVkXG4gICAgICBhd2FpdEFsbCh0YXJnZXQub3B0aW9ucy4kYW5pbWF0aW9ucywgbmV3T3B0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgLy8gcmVqZWN0ZWQsIG5vb3BcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcbiAgICBjb25zdCBydW5uaW5nID0gdGFyZ2V0LiRhbmltYXRpb25zIHx8ICh0YXJnZXQuJGFuaW1hdGlvbnMgPSB7fSk7XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpO1xuICAgIGNvbnN0IGRhdGUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gcHJvcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmIChwcm9wLmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcCA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaCguLi50aGlzLl9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3Byb3BdO1xuICAgICAgbGV0IGFuaW1hdGlvbiA9IHJ1bm5pbmdbcHJvcF07XG4gICAgICBjb25zdCBjZmcgPSBhbmltYXRlZFByb3BzLmdldChwcm9wKTtcblxuICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICBpZiAoY2ZnICYmIGFuaW1hdGlvbi5hY3RpdmUoKSkge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIGFuIGV4aXN0aW5nIGFjdGl2ZSBhbmltYXRpb24sIGxldCdzIHVwZGF0ZSB0aGF0XG4gICAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZShjZmcsIHZhbHVlLCBkYXRlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY2ZnIHx8ICFjZmcuZHVyYXRpb24pIHtcbiAgICAgICAgLy8gbm90IGFuaW1hdGVkLCBzZXQgZGlyZWN0bHkgdG8gbmV3IHZhbHVlXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcnVubmluZ1twcm9wXSA9IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oY2ZnLCB0YXJnZXQsIHByb3AsIHZhbHVlKTtcbiAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG5cbiAgLyoqXG5cdCAqIFVwZGF0ZSBgdGFyZ2V0YCBwcm9wZXJ0aWVzIHRvIG5ldyB2YWx1ZXMsIHVzaW5nIGNvbmZpZ3VyZWQgYW5pbWF0aW9uc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gb2JqZWN0IHRvIHVwZGF0ZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIC0gbmV3IHRhcmdldCBwcm9wZXJ0aWVzXG5cdCAqIEByZXR1cm5zIHtib29sZWFufHVuZGVmaW5lZH0gLSBgdHJ1ZWAgaWYgYW5pbWF0aW9ucyB3ZXJlIHN0YXJ0ZWRcblx0ICoqL1xuICB1cGRhdGUodGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBpZiAodGhpcy5fcHJvcGVydGllcy5zaXplID09PSAwKSB7XG4gICAgICAvLyBOb3RoaW5nIGlzIGFuaW1hdGVkLCBqdXN0IGFwcGx5IHRoZSBuZXcgdmFsdWVzLlxuICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHZhbHVlcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpO1xuXG4gICAgaWYgKGFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBhbmltYXRvci5hZGQodGhpcy5fY2hhcnQsIGFuaW1hdGlvbnMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGF3YWl0QWxsKGFuaW1hdGlvbnMsIHByb3BlcnRpZXMpIHtcbiAgY29uc3QgcnVubmluZyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFuaW0gPSBhbmltYXRpb25zW2tleXNbaV1dO1xuICAgIGlmIChhbmltICYmIGFuaW0uYWN0aXZlKCkpIHtcbiAgICAgIHJ1bm5pbmcucHVzaChhbmltLndhaXQoKSk7XG4gICAgfVxuICB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIFByb21pc2UuYWxsKHJ1bm5pbmcpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpIHtcbiAgaWYgKCFuZXdPcHRpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvcHRpb25zID0gdGFyZ2V0Lm9wdGlvbnM7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9wdGlvbnMuJHNoYXJlZCkge1xuICAgIC8vIEdvaW5nIGZyb20gc2hhcmVkIG9wdGlvbnMgdG8gZGlzdGluY3Qgb25lOlxuICAgIC8vIENyZWF0ZSBuZXcgb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyB0aGUgb2xkIHNoYXJlZCB2YWx1ZXMgYW5kIHN0YXJ0IHVwZGF0aW5nIHRoYXQuXG4gICAgdGFyZ2V0Lm9wdGlvbnMgPSBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyRzaGFyZWQ6IGZhbHNlLCAkYW5pbWF0aW9uczoge319KTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbiIsICJpbXBvcnQgQW5pbWF0aW9ucyBmcm9tICcuL2NvcmUuYW5pbWF0aW9ucy5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNGaW5pdGUsIGlzT2JqZWN0LCB2YWx1ZU9yRGVmYXVsdCwgcmVzb2x2ZU9iamVjdEtleSwgZGVmaW5lZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtsaXN0ZW5BcnJheUV2ZW50cywgdW5saXN0ZW5BcnJheUV2ZW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCBzaWdufSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqL1xuXG5mdW5jdGlvbiBzY2FsZUNsaXAoc2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBjb25zdCBvcHRzID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmV2ZXJzZSA9IG9wdHMucmV2ZXJzZTtcbiAgY29uc3QgbWluID0gb3B0cy5taW4gPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIGNvbnN0IG1heCA9IG9wdHMubWF4ID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiByZXZlcnNlID8gbWF4IDogbWluLFxuICAgIGVuZDogcmV2ZXJzZSA/IG1pbiA6IG1heFxuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q2xpcCh4U2NhbGUsIHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGlmIChhbGxvd2VkT3ZlcmZsb3cgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHggPSBzY2FsZUNsaXAoeFNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuICBjb25zdCB5ID0gc2NhbGVDbGlwKHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcblxuICByZXR1cm4ge1xuICAgIHRvcDogeS5lbmQsXG4gICAgcmlnaHQ6IHguZW5kLFxuICAgIGJvdHRvbTogeS5zdGFydCxcbiAgICBsZWZ0OiB4LnN0YXJ0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRvQ2xpcCh2YWx1ZSkge1xuICBsZXQgdCwgciwgYiwgbDtcblxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdCA9IHZhbHVlLnRvcDtcbiAgICByID0gdmFsdWUucmlnaHQ7XG4gICAgYiA9IHZhbHVlLmJvdHRvbTtcbiAgICBsID0gdmFsdWUubGVmdDtcbiAgfSBlbHNlIHtcbiAgICB0ID0gciA9IGIgPSBsID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogdCxcbiAgICByaWdodDogcixcbiAgICBib3R0b206IGIsXG4gICAgbGVmdDogbCxcbiAgICBkaXNhYmxlZDogdmFsdWUgPT09IGZhbHNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCBmaWx0ZXJWaXNpYmxlKSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpO1xuICBsZXQgaSwgaWxlbjtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5cy5wdXNoKG1ldGFzZXRzW2ldLmluZGV4KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIGRzSW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBrZXlzID0gc3RhY2sua2V5cztcbiAgY29uc3Qgc2luZ2xlTW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gJ3NpbmdsZSc7XG4gIGxldCBpLCBpbGVuLCBkYXRhc2V0SW5kZXgsIG90aGVyVmFsdWU7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGZvdW5kID0gZmFsc2U7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGRhdGFzZXRJbmRleCA9ICtrZXlzW2ldO1xuICAgIGlmIChkYXRhc2V0SW5kZXggPT09IGRzSW5kZXgpIHtcbiAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIGlmIChvcHRpb25zLmFsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvdGhlclZhbHVlID0gc3RhY2sudmFsdWVzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKGlzRmluaXRlKG90aGVyVmFsdWUpICYmIChzaW5nbGVNb2RlIHx8ICh2YWx1ZSA9PT0gMCB8fCBzaWduKHZhbHVlKSA9PT0gc2lnbihvdGhlclZhbHVlKSkpKSB7XG4gICAgICB2YWx1ZSArPSBvdGhlclZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghZm91bmQgJiYgIW9wdGlvbnMuYWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhLCBtZXRhKSB7XG4gIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICBjb25zdCBpQXhpc0tleSA9IGlTY2FsZS5heGlzID09PSAneCcgPyAneCcgOiAneSc7XG4gIGNvbnN0IHZBeGlzS2V5ID0gdlNjYWxlLmF4aXMgPT09ICd4JyA/ICd4JyA6ICd5JztcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICBjb25zdCBhZGF0YSA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gIGxldCBpLCBpbGVuLCBrZXk7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgYWRhdGFbaV0gPSB7XG4gICAgICBbaUF4aXNLZXldOiBrZXksXG4gICAgICBbdkF4aXNLZXldOiBkYXRhW2tleV1cbiAgICB9O1xuICB9XG4gIHJldHVybiBhZGF0YTtcbn1cblxuZnVuY3Rpb24gaXNTdGFja2VkKHNjYWxlLCBtZXRhKSB7XG4gIGNvbnN0IHN0YWNrZWQgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gIHJldHVybiBzdGFja2VkIHx8IChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhY2tLZXkoaW5kZXhTY2FsZSwgdmFsdWVTY2FsZSwgbWV0YSkge1xuICByZXR1cm4gYCR7aW5kZXhTY2FsZS5pZH0uJHt2YWx1ZVNjYWxlLmlkfS4ke21ldGEuc3RhY2sgfHwgbWV0YS50eXBlfWA7XG59XG5cbmZ1bmN0aW9uIGdldFVzZXJCb3VuZHMoc2NhbGUpIHtcbiAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbkRlZmluZWQgPyBtaW4gOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgbWF4OiBtYXhEZWZpbmVkID8gbWF4IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja0tleSwgaW5kZXhWYWx1ZSkge1xuICBjb25zdCBzdWJTdGFjayA9IHN0YWNrc1tzdGFja0tleV0gfHwgKHN0YWNrc1tzdGFja0tleV0gPSB7fSk7XG4gIHJldHVybiBzdWJTdGFja1tpbmRleFZhbHVlXSB8fCAoc3ViU3RhY2tbaW5kZXhWYWx1ZV0gPSB7fSk7XG59XG5cbmZ1bmN0aW9uIGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgcG9zaXRpdmUsIHR5cGUpIHtcbiAgZm9yIChjb25zdCBtZXRhIG9mIHZTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKS5yZXZlcnNlKCkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0YWNrW21ldGEuaW5kZXhdO1xuICAgIGlmICgocG9zaXRpdmUgJiYgdmFsdWUgPiAwKSB8fCAoIXBvc2l0aXZlICYmIHZhbHVlIDwgMCkpIHtcbiAgICAgIHJldHVybiBtZXRhLmluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdGFja3MoY29udHJvbGxlciwgcGFyc2VkKSB7XG4gIGNvbnN0IHtjaGFydCwgX2NhY2hlZE1ldGE6IG1ldGF9ID0gY29udHJvbGxlcjtcbiAgY29uc3Qgc3RhY2tzID0gY2hhcnQuX3N0YWNrcyB8fCAoY2hhcnQuX3N0YWNrcyA9IHt9KTsgLy8gbWFwIHN0cnVjdHVyZSBpcyB7c3RhY2tLZXk6IHtkYXRhc2V0SW5kZXg6IHZhbHVlfX1cbiAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBpbmRleDogZGF0YXNldEluZGV4fSA9IG1ldGE7XG4gIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gIGNvbnN0IGtleSA9IGdldFN0YWNrS2V5KGlTY2FsZSwgdlNjYWxlLCBtZXRhKTtcbiAgY29uc3QgaWxlbiA9IHBhcnNlZC5sZW5ndGg7XG4gIGxldCBzdGFjaztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IGl0ZW0gPSBwYXJzZWRbaV07XG4gICAgY29uc3Qge1tpQXhpc106IGluZGV4LCBbdkF4aXNdOiB2YWx1ZX0gPSBpdGVtO1xuICAgIGNvbnN0IGl0ZW1TdGFja3MgPSBpdGVtLl9zdGFja3MgfHwgKGl0ZW0uX3N0YWNrcyA9IHt9KTtcbiAgICBzdGFjayA9IGl0ZW1TdGFja3NbdkF4aXNdID0gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIGtleSwgaW5kZXgpO1xuICAgIHN0YWNrW2RhdGFzZXRJbmRleF0gPSB2YWx1ZTtcblxuICAgIHN0YWNrLl90b3AgPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHRydWUsIG1ldGEudHlwZSk7XG4gICAgc3RhY2suX2JvdHRvbSA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgZmFsc2UsIG1ldGEudHlwZSk7XG5cbiAgICBjb25zdCB2aXN1YWxWYWx1ZXMgPSBzdGFjay5fdmlzdWFsVmFsdWVzIHx8IChzdGFjay5fdmlzdWFsVmFsdWVzID0ge30pO1xuICAgIHZpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCBheGlzKSB7XG4gIGNvbnN0IHNjYWxlcyA9IGNoYXJ0LnNjYWxlcztcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNjYWxlcykuZmlsdGVyKGtleSA9PiBzY2FsZXNba2V5XS5heGlzID09PSBheGlzKS5zaGlmdCgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXRhc2V0Q29udGV4dChwYXJlbnQsIGluZGV4KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCxcbiAgICB7XG4gICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgZGF0YXNldDogdW5kZWZpbmVkLFxuICAgICAgZGF0YXNldEluZGV4OiBpbmRleCxcbiAgICAgIGluZGV4LFxuICAgICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgICAgdHlwZTogJ2RhdGFzZXQnXG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXRhQ29udGV4dChwYXJlbnQsIGluZGV4LCBlbGVtZW50KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBwYXJzZWQ6IHVuZGVmaW5lZCxcbiAgICByYXc6IHVuZGVmaW5lZCxcbiAgICBlbGVtZW50LFxuICAgIGluZGV4LFxuICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICB0eXBlOiAnZGF0YSdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyU3RhY2tzKG1ldGEsIGl0ZW1zKSB7XG4gIC8vIE5vdCB1c2luZyBtZXRhLmluZGV4IGhlcmUsIGJlY2F1c2UgaXQgbWlnaHQgYmUgYWxyZWFkeSB1cGRhdGVkIGlmIHRoZSBkYXRhc2V0IGNoYW5nZWQgbG9jYXRpb25cbiAgY29uc3QgZGF0YXNldEluZGV4ID0gbWV0YS5jb250cm9sbGVyLmluZGV4O1xuICBjb25zdCBheGlzID0gbWV0YS52U2NhbGUgJiYgbWV0YS52U2NhbGUuYXhpcztcbiAgaWYgKCFheGlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaXRlbXMgPSBpdGVtcyB8fCBtZXRhLl9wYXJzZWQ7XG4gIGZvciAoY29uc3QgcGFyc2VkIG9mIGl0ZW1zKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gcGFyc2VkLl9zdGFja3M7XG4gICAgaWYgKCFzdGFja3MgfHwgc3RhY2tzW2F4aXNdID09PSB1bmRlZmluZWQgfHwgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKHN0YWNrc1theGlzXS5fdmlzdWFsVmFsdWVzICE9PSB1bmRlZmluZWQgJiYgc3RhY2tzW2F4aXNdLl92aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWxldGUgc3RhY2tzW2F4aXNdLl92aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaXNEaXJlY3RVcGRhdGVNb2RlID0gKG1vZGUpID0+IG1vZGUgPT09ICdyZXNldCcgfHwgbW9kZSA9PT0gJ25vbmUnO1xuY29uc3QgY2xvbmVJZk5vdFNoYXJlZCA9IChjYWNoZWQsIHNoYXJlZCkgPT4gc2hhcmVkID8gY2FjaGVkIDogT2JqZWN0LmFzc2lnbih7fSwgY2FjaGVkKTtcbmNvbnN0IGNyZWF0ZVN0YWNrID0gKGNhblN0YWNrLCBtZXRhLCBjaGFydCkgPT4gY2FuU3RhY2sgJiYgIW1ldGEuaGlkZGVuICYmIG1ldGEuX3N0YWNrZWRcbiAgJiYge2tleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSwgdmFsdWVzOiBudWxsfTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge307XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhc2V0IChlLmcuIENoYXJ0LmVsZW1lbnQuTGluZUVsZW1lbnQpLlxuICAgKi9cbiAgc3RhdGljIGRhdGFzZXRFbGVtZW50VHlwZSA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhIChlLmcuIENoYXJ0LmVsZW1lbnQuUG9pbnRFbGVtZW50KS5cbiAgICovXG4gIHN0YXRpYyBkYXRhRWxlbWVudFR5cGUgPSBudWxsO1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGF0YXNldEluZGV4XG5cdCAqL1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX2N0eCA9IGNoYXJ0LmN0eDtcbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gICAgdGhpcy5fY2FjaGVkTWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuICAgIHRoaXMuX3R5cGUgPSB0aGlzLl9jYWNoZWRNZXRhLnR5cGU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IG9iamVjdH0gKi9cbiAgICB0aGlzLl9wYXJzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vYmplY3REYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NoYXJlZE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IG5ldy50YXJnZXQuZGF0YXNldEVsZW1lbnRUeXBlO1xuICAgIHRoaXMuZGF0YUVsZW1lbnRUeXBlID0gbmV3LnRhcmdldC5kYXRhRWxlbWVudFR5cGU7XG5cbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy5jb25maWd1cmUoKTtcbiAgICB0aGlzLmxpbmtTY2FsZXMoKTtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICB0aGlzLmFkZEVsZW1lbnRzKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmZpbGwgJiYgIXRoaXMuY2hhcnQuaXNQbHVnaW5FbmFibGVkKCdmaWxsZXInKSkge1xuICAgICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gdXNlIHRoZSAnZmlsbCcgb3B0aW9uIHdpdGhvdXQgdGhlICdGaWxsZXInIHBsdWdpbiBlbmFibGVkLiBQbGVhc2UgaW1wb3J0IGFuZCByZWdpc3RlciB0aGUgJ0ZpbGxlcicgcGx1Z2luIGFuZCBtYWtlIHN1cmUgaXQgaXMgbm90IGRpc2FibGVkIGluIHRoZSBvcHRpb25zXCIpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUluZGV4KGRhdGFzZXRJbmRleCkge1xuICAgIGlmICh0aGlzLmluZGV4ICE9PSBkYXRhc2V0SW5kZXgpIHtcbiAgICAgIGNsZWFyU3RhY2tzKHRoaXMuX2NhY2hlZE1ldGEpO1xuICAgIH1cbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICB9XG5cbiAgbGlua1NjYWxlcygpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuXG4gICAgY29uc3QgY2hvb3NlSWQgPSAoYXhpcywgeCwgeSwgcikgPT4gYXhpcyA9PT0gJ3gnID8geCA6IGF4aXMgPT09ICdyJyA/IHIgOiB5O1xuXG4gICAgY29uc3QgeGlkID0gbWV0YS54QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC54QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd4JykpO1xuICAgIGNvbnN0IHlpZCA9IG1ldGEueUF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueUF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneScpKTtcbiAgICBjb25zdCByaWQgPSBtZXRhLnJBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnJBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3InKSk7XG4gICAgY29uc3QgaW5kZXhBeGlzID0gbWV0YS5pbmRleEF4aXM7XG4gICAgY29uc3QgaWlkID0gbWV0YS5pQXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB4aWQsIHlpZCwgcmlkKTtcbiAgICBjb25zdCB2aWQgPSBtZXRhLnZBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHlpZCwgeGlkLCByaWQpO1xuICAgIG1ldGEueFNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHhpZCk7XG4gICAgbWV0YS55U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeWlkKTtcbiAgICBtZXRhLnJTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChyaWQpO1xuICAgIG1ldGEuaVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKGlpZCk7XG4gICAgbWV0YS52U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQodmlkKTtcbiAgfVxuXG4gIGdldERhdGFzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0aGlzLmluZGV4XTtcbiAgfVxuXG4gIGdldE1ldGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNjYWxlSURcblx0ICogQHJldHVybiB7U2NhbGV9XG5cdCAqL1xuICBnZXRTY2FsZUZvcklkKHNjYWxlSUQpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5zY2FsZXNbc2NhbGVJRF07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRPdGhlclNjYWxlKHNjYWxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgcmV0dXJuIHNjYWxlID09PSBtZXRhLmlTY2FsZVxuICAgICAgPyBtZXRhLnZTY2FsZVxuICAgICAgOiBtZXRhLmlTY2FsZTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3VwZGF0ZSgncmVzZXQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2Rlc3Ryb3koKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHVubGlzdGVuQXJyYXlFdmVudHModGhpcy5fZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kYXRhQ2hlY2soKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcbiAgICBjb25zdCBfZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAvLyBJbiBvcmRlciB0byBjb3JyZWN0bHkgaGFuZGxlIGRhdGEgYWRkaXRpb24vZGVsZXRpb24gYW5pbWF0aW9uIChhbmQgdGh1cyBzaW11bGF0ZVxuICAgIC8vIHJlYWwtdGltZSBjaGFydHMpLCB3ZSBuZWVkIHRvIG1vbml0b3IgdGhlc2UgZGF0YSBtb2RpZmljYXRpb25zIGFuZCBzeW5jaHJvbml6ZVxuICAgIC8vIHRoZSBpbnRlcm5hbCBtZXRhZGF0YSBhY2NvcmRpbmdseS5cblxuICAgIGlmIChpc09iamVjdChkYXRhKSkge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICB0aGlzLl9kYXRhID0gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEsIG1ldGEpO1xuICAgIH0gZWxzZSBpZiAoX2RhdGEgIT09IGRhdGEpIHtcbiAgICAgIGlmIChfZGF0YSkge1xuICAgICAgICAvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IGluc3RhbmNlLlxuICAgICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKF9kYXRhLCB0aGlzKTtcbiAgICAgICAgLy8gRGlzY2FyZCBvbGQgcGFyc2VkIGRhdGEgYW5kIHN0YWNrc1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICAgIG1ldGEuX3BhcnNlZCA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuICAgICAgICBsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cblxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcblxuICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuXG4gICAgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICBtZXRhLmRhdGFzZXQgPSBuZXcgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUoKTtcbiAgICB9XG4gIH1cblxuICBidWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBsZXQgc3RhY2tDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcblxuICAgIC8vIG1ha2Ugc3VyZSBjYWNoZWQgX3N0YWNrZWQgc3RhdHVzIGlzIGN1cnJlbnRcbiAgICBjb25zdCBvbGRTdGFja2VkID0gbWV0YS5fc3RhY2tlZDtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcblxuICAgIC8vIGRldGVjdCBjaGFuZ2UgaW4gc3RhY2sgb3B0aW9uXG4gICAgaWYgKG1ldGEuc3RhY2sgIT09IGRhdGFzZXQuc3RhY2spIHtcbiAgICAgIHN0YWNrQ2hhbmdlZCA9IHRydWU7XG4gICAgICAvLyByZW1vdmUgdmFsdWVzIGZyb20gb2xkIHN0YWNrXG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgIG1ldGEuc3RhY2sgPSBkYXRhc2V0LnN0YWNrO1xuICAgIH1cblxuICAgIC8vIFJlLXN5bmMgbWV0YSBkYXRhIGluIGNhc2UgdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgb3IgaWYgd2UgbWlzc2VkXG4gICAgLy8gYW55IHVwZGF0ZXMgYW5kIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBudW1iZXIgb2YgZGF0YXBvaW50cyBjaGFuZ2luZy5cbiAgICB0aGlzLl9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKTtcblxuICAgIC8vIGlmIHN0YWNrIGNoYW5nZWQsIHVwZGF0ZSBzdGFjayB2YWx1ZXMgZm9yIHRoZSB3aG9sZSBkYXRhc2V0XG4gICAgaWYgKHN0YWNrQ2hhbmdlZCB8fCBvbGRTdGFja2VkICE9PSBtZXRhLl9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgbWV0YS5fcGFyc2VkKTtcbiAgICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBNZXJnZXMgdXNlci1zdXBwbGllZCBhbmQgZGVmYXVsdCBkYXRhc2V0LWxldmVsIG9wdGlvbnNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldFNjb3BlS2V5cyh0aGlzLl90eXBlKTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMsIHRydWUpO1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLl9wYXJzaW5nID0gdGhpcy5vcHRpb25zLnBhcnNpbmc7XG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG5cdCAqL1xuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7X2NhY2hlZE1ldGE6IG1ldGEsIF9kYXRhOiBkYXRhfSA9IHRoaXM7XG4gICAgY29uc3Qge2lTY2FsZSwgX3N0YWNrZWR9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuXG4gICAgbGV0IHNvcnRlZCA9IHN0YXJ0ID09PSAwICYmIGNvdW50ID09PSBkYXRhLmxlbmd0aCA/IHRydWUgOiBtZXRhLl9zb3J0ZWQ7XG4gICAgbGV0IHByZXYgPSBzdGFydCA+IDAgJiYgbWV0YS5fcGFyc2VkW3N0YXJ0IC0gMV07XG4gICAgbGV0IGksIGN1ciwgcGFyc2VkO1xuXG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgICAgbWV0YS5fc29ydGVkID0gdHJ1ZTtcbiAgICAgIHBhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0FycmF5KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYgPSAoKSA9PiBjdXJbaUF4aXNdID09PSBudWxsIHx8IChwcmV2ICYmIGN1cltpQXhpc10gPCBwcmV2W2lBeGlzXSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBtZXRhLl9wYXJzZWRbaSArIHN0YXJ0XSA9IGN1ciA9IHBhcnNlZFtpXTtcbiAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgIGlmIChpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldigpKSB7XG4gICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWV0YS5fc29ydGVkID0gc29ydGVkO1xuICAgIH1cblxuICAgIGlmIChfc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIHBhcnNlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIHByaW1pdGl2ZSB2YWx1ZXNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgWzEsMyw0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLlxuXHQgKiBFeGFtcGxlOiB7eFNjYWxlMDogMCwgeVNjYWxlMDogMX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleDtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIFtpQXhpc106IHNpbmdsZVNjYWxlIHx8IGlTY2FsZS5wYXJzZShsYWJlbHNbaW5kZXhdLCBpbmRleCksXG4gICAgICAgIFt2QXhpc106IHZTY2FsZS5wYXJzZShkYXRhW2luZGV4XSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIGFycmF5c1xuXHQgKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YVxuXHQgKiBAcGFyYW0ge2FycmF5fSBkYXRhIC0gZGF0YSBhcnJheS4gRXhhbXBsZSBbWzEsMl0sWzMsNF1dXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIG51bWJlciBvZiBpdGVtcyB0byBwYXJzZVxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXJzZWQgaXRlbSAtIGl0ZW0gY29udGFpbmluZyBpbmRleCBhbmQgYSBwYXJzZWQgdmFsdWVcblx0ICogZm9yIGVhY2ggc2NhbGUgaWQuXG5cdCAqIEV4YW1wbGU6IHt4OiAwLCB5OiAxfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIHg6IHhTY2FsZS5wYXJzZShpdGVtWzBdLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShpdGVtWzFdLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2Ygb2JqZWN0c1xuXHQgKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YVxuXHQgKiBAcGFyYW0ge2FycmF5fSBkYXRhIC0gZGF0YSBhcnJheS4gRXhhbXBsZSBbe3g6MSwgeTo1fSwge3g6MiwgeToxMH1dXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIG51bWJlciBvZiBpdGVtcyB0byBwYXJzZVxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXJzZWQgaXRlbSAtIGl0ZW0gY29udGFpbmluZyBpbmRleCBhbmQgYSBwYXJzZWQgdmFsdWVcblx0ICogZm9yIGVhY2ggc2NhbGUgaWQuIF9jdXN0b20gaXMgb3B0aW9uYWxcblx0ICogRXhhbXBsZToge3hTY2FsZTA6IDAsIHlTY2FsZTA6IDEsIF9jdXN0b206IHtyOiAxMCwgZm9vOiAnYmFyJ319XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB4QXhpc0tleSksIGluZGV4KSxcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeUF4aXNLZXkpLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0UGFyc2VkKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZFtpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0RGF0YUVsZW1lbnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBhcHBseVN0YWNrKHNjYWxlLCBwYXJzZWQsIG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgY29uc3Qgc3RhY2sgPSB7XG4gICAgICBrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksXG4gICAgICB2YWx1ZXM6IHBhcnNlZC5fc3RhY2tzW3NjYWxlLmF4aXNdLl92aXN1YWxWYWx1ZXNcbiAgICB9O1xuICAgIHJldHVybiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgbWV0YS5pbmRleCwge21vZGV9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkVmFsdWUgPT09IG51bGwgPyBOYU4gOiBwYXJzZWRWYWx1ZTtcbiAgICBjb25zdCB2YWx1ZXMgPSBzdGFjayAmJiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXTtcbiAgICBpZiAoc3RhY2sgJiYgdmFsdWVzKSB7XG4gICAgICBzdGFjay52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICB2YWx1ZSA9IGFwcGx5U3RhY2soc3RhY2ssIHBhcnNlZFZhbHVlLCB0aGlzLl9jYWNoZWRNZXRhLmluZGV4KTtcbiAgICB9XG4gICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCB2YWx1ZSk7XG4gICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCB2YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWluTWF4KHNjYWxlLCBjYW5TdGFjaykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IF9wYXJzZWQgPSBtZXRhLl9wYXJzZWQ7XG4gICAgY29uc3Qgc29ydGVkID0gbWV0YS5fc29ydGVkICYmIHNjYWxlID09PSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBpbGVuID0gX3BhcnNlZC5sZW5ndGg7XG4gICAgY29uc3Qgb3RoZXJTY2FsZSA9IHRoaXMuX2dldE90aGVyU2NhbGUoc2NhbGUpO1xuICAgIGNvbnN0IHN0YWNrID0gY3JlYXRlU3RhY2soY2FuU3RhY2ssIG1ldGEsIHRoaXMuY2hhcnQpO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG4gICAgY29uc3Qge21pbjogb3RoZXJNaW4sIG1heDogb3RoZXJNYXh9ID0gZ2V0VXNlckJvdW5kcyhvdGhlclNjYWxlKTtcbiAgICBsZXQgaSwgcGFyc2VkO1xuXG4gICAgZnVuY3Rpb24gX3NraXAoKSB7XG4gICAgICBwYXJzZWQgPSBfcGFyc2VkW2ldO1xuICAgICAgY29uc3Qgb3RoZXJWYWx1ZSA9IHBhcnNlZFtvdGhlclNjYWxlLmF4aXNdO1xuICAgICAgcmV0dXJuICFpc0Zpbml0ZShwYXJzZWRbc2NhbGUuYXhpc10pIHx8IG90aGVyTWluID4gb3RoZXJWYWx1ZSB8fCBvdGhlck1heCA8IG90aGVyVmFsdWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAvLyBpZiB0aGUgZGF0YSBpcyBzb3J0ZWQsIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZnVydGhlciBmcm9tIHRoaXMgZW5kIG9mIGFycmF5XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc29ydGVkKSB7XG4gICAgICAvLyBpbiB0aGUgc29ydGVkIGNhc2UsIGZpbmQgZmlyc3Qgbm9uLXNraXBwZWQgdmFsdWUgZnJvbSBvdGhlciBlbmQgb2YgYXJyYXlcbiAgICAgIGZvciAoaSA9IGlsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICBnZXRBbGxQYXJzZWRWYWx1ZXMoc2NhbGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWQ7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgbGV0IGksIGlsZW4sIHZhbHVlO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHBhcnNlZC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VkW2ldW3NjYWxlLmF4aXNdO1xuICAgICAgaWYgKGlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7bnVtYmVyfGJvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogaVNjYWxlID8gJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSA6ICcnLFxuICAgICAgdmFsdWU6IHZTY2FsZSA/ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSkgOiAnJ1xuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlKG1vZGUgfHwgJ2RlZmF1bHQnKTtcbiAgICBtZXRhLl9jbGlwID0gdG9DbGlwKHZhbHVlT3JEZWZhdWx0KHRoaXMub3B0aW9ucy5jbGlwLCBkZWZhdWx0Q2xpcChtZXRhLnhTY2FsZSwgbWV0YS55U2NhbGUsIHRoaXMuZ2V0TWF4T3ZlcmZsb3coKSkpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbW9kZVxuXHQgKi9cbiAgdXBkYXRlKG1vZGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICBkcmF3KCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuX2N0eDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBhY3RpdmUgPSBbXTtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2RyYXdTdGFydCB8fCAwO1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fZHJhd0NvdW50IHx8IChlbGVtZW50cy5sZW5ndGggLSBzdGFydCk7XG4gICAgY29uc3QgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0aGlzLm9wdGlvbnMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3A7XG4gICAgbGV0IGk7XG5cbiAgICBpZiAobWV0YS5kYXRhc2V0KSB7XG4gICAgICBtZXRhLmRhdGFzZXQuZHJhdyhjdHgsIGFyZWEsIHN0YXJ0LCBjb3VudCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmIChlbGVtZW50LmhpZGRlbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50LmFjdGl2ZSAmJiBkcmF3QWN0aXZlRWxlbWVudHNPblRvcCkge1xuICAgICAgICBhY3RpdmUucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuZHJhdyhjdHgsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFjdGl2ZVtpXS5kcmF3KGN0eCwgYXJlYSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSBzZXQgb2YgcHJlZGVmaW5lZCBzdHlsZSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBkYXRhc2V0XG5cdCAqIG9yIHRoZSBkYXRhIGlmIHRoZSBpbmRleCBpcyBzcGVjaWZpZWRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gZGF0YSBpbmRleFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFthY3RpdmVdIC0gdHJ1ZSBpZiBob3ZlclxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IHN0eWxlIG9iamVjdFxuXHQgKi9cbiAgZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSkge1xuICAgIGNvbnN0IG1vZGUgPSBhY3RpdmUgPyAnYWN0aXZlJyA6ICdkZWZhdWx0JztcbiAgICByZXR1cm4gaW5kZXggPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXRcbiAgICAgID8gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpXG4gICAgICA6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCB8fCAwLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIG1vZGUpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IGNvbnRleHQ7XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQgPSBlbGVtZW50LiRjb250ZXh0IHx8XG4gICAgICAgIChlbGVtZW50LiRjb250ZXh0ID0gY3JlYXRlRGF0YUNvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBlbGVtZW50KSk7XG4gICAgICBjb250ZXh0LnBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICAgIGNvbnRleHQucmF3ID0gZGF0YXNldC5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFJbmRleCA9IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gdGhpcy4kY29udGV4dCB8fFxuICAgICAgICAodGhpcy4kY29udGV4dCA9IGNyZWF0ZURhdGFzZXRDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLmluZGV4KSk7XG4gICAgICBjb250ZXh0LmRhdGFzZXQgPSBkYXRhc2V0O1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB9XG5cbiAgICBjb250ZXh0LmFjdGl2ZSA9ICEhYWN0aXZlO1xuICAgIGNvbnRleHQubW9kZSA9IG1vZGU7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlXVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlLmlkLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlXVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFFbGVtZW50VHlwZS5pZCwgbW9kZSwgaW5kZXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGVsZW1lbnRUeXBlLCBtb2RlID0gJ2RlZmF1bHQnLCBpbmRleCkge1xuICAgIGNvbnN0IGFjdGl2ZSA9IG1vZGUgPT09ICdhY3RpdmUnO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkRGF0YU9wdHM7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBlbGVtZW50VHlwZSArICctJyArIG1vZGU7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGNvbnN0IHNoYXJpbmcgPSB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgJiYgZGVmaW5lZChpbmRleCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNsb25lSWZOb3RTaGFyZWQoY2FjaGVkLCBzaGFyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKHRoaXMuX3R5cGUsIGVsZW1lbnRUeXBlKTtcbiAgICBjb25zdCBwcmVmaXhlcyA9IGFjdGl2ZSA/IFtgJHtlbGVtZW50VHlwZX1Ib3ZlcmAsICdob3ZlcicsIGVsZW1lbnRUeXBlLCAnJ10gOiBbZWxlbWVudFR5cGUsICcnXTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuZWxlbWVudHNbZWxlbWVudFR5cGVdKTtcbiAgICAvLyBjb250ZXh0IGlzIHByb3ZpZGVkIGFzIGEgZnVuY3Rpb24sIGFuZCBpcyBjYWxsZWQgb25seSBpZiBuZWVkZWQsXG4gICAgLy8gc28gd2UgZG9uJ3QgY3JlYXRlIGEgY29udGV4dCBmb3IgZWFjaCBlbGVtZW50IGlmIG5vdCBuZWVkZWQuXG4gICAgY29uc3QgY29udGV4dCA9ICgpID0+IHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBjb25maWcucmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyk7XG5cbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIC8vIGAkc2hhcmVkYCBpbmRpY2F0ZXMgdGhpcyBzZXQgb2Ygb3B0aW9ucyBjYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgZWxlbWVudHMuXG4gICAgICAvLyBTaGFyaW5nIGlzIHVzZWQgdG8gcmVkdWNlIG51bWJlciBvZiBwcm9wZXJ0aWVzIHRvIGNoYW5nZSBkdXJpbmcgYW5pbWF0aW9uLlxuICAgICAgdmFsdWVzLiRzaGFyZWQgPSBzaGFyaW5nO1xuXG4gICAgICAvLyBXZSBjYWNoZSBvcHRpb25zIGJ5IGBtb2RlYCwgd2hpY2ggY2FuIGJlICdhY3RpdmUnIGZvciBleGFtcGxlLiBUaGlzIGVuYWJsZXMgdXNcbiAgICAgIC8vIHRvIGhhdmUgdGhlICdhY3RpdmUnIGVsZW1lbnQgb3B0aW9ucyBhbmQgJ2RlZmF1bHQnIG9wdGlvbnMgdG8gc3dpdGNoIGJldHdlZW5cbiAgICAgIC8vIHdoZW4gaW50ZXJhY3RpbmcuXG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGNsb25lSWZOb3RTaGFyZWQodmFsdWVzLCBzaGFyaW5nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIHRyYW5zaXRpb24sIGFjdGl2ZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYGFuaW1hdGlvbi0ke3RyYW5zaXRpb259YDtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyh0aGlzLl90eXBlLCB0cmFuc2l0aW9uKTtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgICBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIHRyYW5zaXRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKGNoYXJ0LCBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5fY2FjaGVhYmxlKSB7XG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciBnZXR0aW5nIHRoZSBvcHRpb25zIG9iamVjdCBzaGFyZWQgYmV0d2VlbiBlbGVtZW50c1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2hhcmVkT3B0aW9ucyB8fCAodGhpcy5fc2hhcmVkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciBkZXRlcm1pbmluZyBpZiBgb3B0aW9uc2Agc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSB1cGRhdGVkIHByb3BlcnRpZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykge1xuICAgIHJldHVybiAhc2hhcmVkT3B0aW9ucyB8fCBpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkgfHwgdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0b2RvIHY0LCByZW5hbWUgdG8gZ2V0U2hhcmVkT3B0aW9ucyBhbmQgcmVtb3ZlIGV4Y2VzcyBmdW5jdGlvbnNcbiAgICovXG4gIF9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKSB7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyA9IHRoaXMuX3NoYXJlZE9wdGlvbnM7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKSB8fCAoc2hhcmVkT3B0aW9ucyAhPT0gcHJldmlvdXNseVNoYXJlZE9wdGlvbnMpO1xuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICAgIHJldHVybiB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9O1xuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgZm9yIHVwZGF0aW5nIGFuIGVsZW1lbnQgd2l0aCBuZXcgcHJvcGVydGllcywgdXNpbmcgYW5pbWF0aW9ucyB3aGVuIGFwcHJvcHJpYXRlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVFbGVtZW50KGVsZW1lbnQsIGluZGV4LCBwcm9wZXJ0aWVzLCBtb2RlKSB7XG4gICAgaWYgKGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUpLnVwZGF0ZShlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSB0byBhbmltYXRlIHRoZSBzaGFyZWQgb3B0aW9ucywgdGhhdCBhcmUgcG90ZW50aWFsbHkgYWZmZWN0aW5nIG11bHRpcGxlIGVsZW1lbnRzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIG5ld09wdGlvbnMpIHtcbiAgICBpZiAoc2hhcmVkT3B0aW9ucyAmJiAhaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpLnVwZGF0ZShzaGFyZWRPcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgbW9kZSwgYWN0aXZlKSB7XG4gICAgZWxlbWVudC5hY3RpdmUgPSBhY3RpdmU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSk7XG4gICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUsIGFjdGl2ZSkudXBkYXRlKGVsZW1lbnQsIHtcbiAgICAgIC8vIFdoZW4gZ29pbmcgZnJvbSBhY3RpdmUgdG8gaW5hY3RpdmUsIHdlIG5lZWQgdG8gdXBkYXRlIHRvIHRoZSBzaGFyZWQgb3B0aW9ucy5cbiAgICAgIC8vIFRoaXMgd2F5IHRoZSBvbmNlIGhvdmVyZWQgZWxlbWVudCB3aWxsIGVuZCB1cCB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNoYXJlZCBvcHRpb25zIGluc3RhbmNlLCBhZnRlciBhbmltYXRpb24uXG4gICAgICBvcHRpb25zOiAoIWFjdGl2ZSAmJiB0aGlzLmdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykpIHx8IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIHJlbW92ZUhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgZmFsc2UpO1xuICB9XG5cbiAgc2V0SG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3NldERhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgLy8gQXBwbHkgY2hhbmdlcyBkZXRlY3RlZCB0aHJvdWdoIGFycmF5IGxpc3RlbmVyc1xuICAgIGZvciAoY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gb2YgdGhpcy5fc3luY0xpc3QpIHtcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcblxuICAgIGNvbnN0IG51bU1ldGEgPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGNvdW50ID0gTWF0aC5taW4obnVtRGF0YSwgbnVtTWV0YSk7XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIC8vIFRPRE86IEl0IGlzIG5vdCBvcHRpbWFsIHRvIGFsd2F5cyBwYXJzZSB0aGUgb2xkIGRhdGFcbiAgICAgIC8vIFRoaXMgaXMgZG9uZSBiZWNhdXNlIHdlIGFyZSBub3QgZGV0ZWN0aW5nIGRpcmVjdCBhc3NpZ25tZW50czpcbiAgICAgIC8vIGNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YVs1XSA9IDEwO1xuICAgICAgLy8gY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhWzVdLnkgPSAxMDtcbiAgICAgIHRoaXMucGFyc2UoMCwgY291bnQpO1xuICAgIH1cblxuICAgIGlmIChudW1EYXRhID4gbnVtTWV0YSkge1xuICAgICAgdGhpcy5faW5zZXJ0RWxlbWVudHMobnVtTWV0YSwgbnVtRGF0YSAtIG51bU1ldGEsIHJlc2V0TmV3RWxlbWVudHMpO1xuICAgIH0gZWxzZSBpZiAobnVtRGF0YSA8IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnRzKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9pbnNlcnRFbGVtZW50cyhzdGFydCwgY291bnQsIHJlc2V0TmV3RWxlbWVudHMgPSB0cnVlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgIGxldCBpO1xuXG4gICAgY29uc3QgbW92ZSA9IChhcnIpID0+IHtcbiAgICAgIGFyci5sZW5ndGggKz0gY291bnQ7XG4gICAgICBmb3IgKGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSBlbmQ7IGktLSkge1xuICAgICAgICBhcnJbaV0gPSBhcnJbaSAtIGNvdW50XTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1vdmUoZGF0YSk7XG5cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBkYXRhW2ldID0gbmV3IHRoaXMuZGF0YUVsZW1lbnRUeXBlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIG1vdmUobWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZShzdGFydCwgY291bnQpO1xuXG4gICAgaWYgKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMoZGF0YSwgc3RhcnQsIGNvdW50LCAncmVzZXQnKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhlbGVtZW50LCBzdGFydCwgY291bnQsIG1vZGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVFbGVtZW50cyhzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IG1ldGEuX3BhcnNlZC5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEsIHJlbW92ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBtZXRhLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcbiAgICovXG4gIF9zeW5jKGFyZ3MpIHtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgdGhpcy5fc3luY0xpc3QucHVzaChhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gPSBhcmdzO1xuICAgICAgdGhpc1ttZXRob2RdKGFyZzEsIGFyZzIpO1xuICAgIH1cbiAgICB0aGlzLmNoYXJ0Ll9kYXRhQ2hhbmdlcy5wdXNoKFt0aGlzLmluZGV4LCAuLi5hcmdzXSk7XG4gIH1cblxuICBfb25EYXRhUHVzaCgpIHtcbiAgICBjb25zdCBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gY291bnQsIGNvdW50XSk7XG4gIH1cblxuICBfb25EYXRhUG9wKCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoIC0gMSwgMV0pO1xuICB9XG5cbiAgX29uRGF0YVNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCAwLCAxXSk7XG4gIH1cblxuICBfb25EYXRhU3BsaWNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGlmIChjb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHN0YXJ0LCBjb3VudF0pO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIGlmIChuZXdDb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHN0YXJ0LCBuZXdDb3VudF0pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkRhdGFVbnNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCAwLCBhcmd1bWVudHMubGVuZ3RoXSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7XG4gIF9hcnJheVVuaXF1ZSwgaXNBcnJheSwgaXNOdWxsT3JVbmRlZixcbiAgdmFsdWVPckRlZmF1bHQsIHJlc29sdmVPYmplY3RLZXksIHNpZ24sIGRlZmluZWRcbn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCB0eXBlKSB7XG4gIGlmICghc2NhbGUuX2NhY2hlLiRiYXIpIHtcbiAgICBjb25zdCB2aXNpYmxlTWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKTtcbiAgICBsZXQgdmFsdWVzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHZpc2libGVNZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodmlzaWJsZU1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSk7XG4gICAgfVxuICAgIHNjYWxlLl9jYWNoZS4kYmFyID0gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYikpO1xuICB9XG4gIHJldHVybiBzY2FsZS5fY2FjaGUuJGJhcjtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgXCJvcHRpbWFsXCIgc2FtcGxlIHNpemUgdG8gbWFpbnRhaW4gYmFycyBlcXVhbGx5IHNpemVkIHdoaWxlIHByZXZlbnRpbmcgb3ZlcmxhcC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpIHtcbiAgY29uc3Qgc2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdmFsdWVzID0gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIG1ldGEudHlwZSk7XG4gIGxldCBtaW4gPSBzY2FsZS5fbGVuZ3RoO1xuICBsZXQgaSwgaWxlbiwgY3VyciwgcHJldjtcbiAgY29uc3QgdXBkYXRlTWluQW5kUHJldiA9ICgpID0+IHtcbiAgICBpZiAoY3VyciA9PT0gMzI3NjcgfHwgY3VyciA9PT0gLTMyNzY4KSB7XG4gICAgICAvLyBJZ25vcmUgdHJ1bmNhdGVkIHBpeGVsc1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChwcmV2KSkge1xuICAgICAgLy8gY3VyciAtIHByZXYgPT09IDAgaXMgaWdub3JlZFxuICAgICAgbWluID0gTWF0aC5taW4obWluLCBNYXRoLmFicyhjdXJyIC0gcHJldikgfHwgbWluKTtcbiAgICB9XG4gICAgcHJldiA9IGN1cnI7XG4gIH07XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZXNbaV0pO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuXG4gIHByZXYgPSB1bmRlZmluZWQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBzY2FsZS50aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGkpO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuXG4gIHJldHVybiBtaW47XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gXCJpZGVhbFwiIGNhdGVnb3J5IGJhc2VkIG9uIHRoZSBhYnNvbHV0ZSBiYXIgdGhpY2tuZXNzIG9yLCBpZiB1bmRlZmluZWQgb3IgbnVsbCxcbiAqIHVzZXMgdGhlIHNtYWxsZXN0IGludGVydmFsIChzZWUgY29tcHV0ZU1pblNhbXBsZVNpemUpIHRoYXQgcHJldmVudHMgYmFyIG92ZXJsYXBwaW5nLiBUaGlzXG4gKiBtb2RlIGN1cnJlbnRseSBhbHdheXMgZ2VuZXJhdGVzIGJhcnMgZXF1YWxseSBzaXplZCAodW50aWwgd2UgaW50cm9kdWNlIHNjcmlwdGFibGUgb3B0aW9ucz8pLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCB0aGlja25lc3MgPSBvcHRpb25zLmJhclRoaWNrbmVzcztcbiAgbGV0IHNpemUsIHJhdGlvO1xuXG4gIGlmIChpc051bGxPclVuZGVmKHRoaWNrbmVzcykpIHtcbiAgICBzaXplID0gcnVsZXIubWluICogb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG4gICAgcmF0aW8gPSBvcHRpb25zLmJhclBlcmNlbnRhZ2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiBiYXIgdGhpY2tuZXNzIGlzIGVuZm9yY2VkLCBjYXRlZ29yeSBhbmQgYmFyIHBlcmNlbnRhZ2VzIGFyZSBpZ25vcmVkLlxuICAgIC8vIE5vdGUoU0IpOiB3ZSBjb3VsZCBhZGQgc3VwcG9ydCBmb3IgcmVsYXRpdmUgYmFyIHRoaWNrbmVzcyAoZS5nLiBiYXJUaGlja25lc3M6ICc1MCUnKVxuICAgIC8vIGFuZCBkZXByZWNhdGUgYmFyUGVyY2VudGFnZSBzaW5jZSB0aGlzIHZhbHVlIGlzIGlnbm9yZWQgd2hlbiB0aGlja25lc3MgaXMgYWJzb2x1dGUuXG4gICAgc2l6ZSA9IHRoaWNrbmVzcyAqIHN0YWNrQ291bnQ7XG4gICAgcmF0aW8gPSAxO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW8sXG4gICAgc3RhcnQ6IHJ1bGVyLnBpeGVsc1tpbmRleF0gLSAoc2l6ZSAvIDIpXG4gIH07XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gXCJvcHRpbWFsXCIgY2F0ZWdvcnkgdGhhdCBnbG9iYWxseSBhcnJhbmdlcyBiYXJzIHNpZGUgYnkgc2lkZSAobm8gZ2FwIHdoZW5cbiAqIHBlcmNlbnRhZ2Ugb3B0aW9ucyBhcmUgMSksIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBhbmQgZm9sbG93aW5nIGNhdGVnb3JpZXMuIFRoaXMgbW9kZVxuICogZ2VuZXJhdGVzIGJhcnMgd2l0aCBkaWZmZXJlbnQgd2lkdGhzIHdoZW4gZGF0YSBhcmUgbm90IGV2ZW5seSBzcGFjZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCBwaXhlbHMgPSBydWxlci5waXhlbHM7XG4gIGNvbnN0IGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xuICBsZXQgcHJldiA9IGluZGV4ID4gMCA/IHBpeGVsc1tpbmRleCAtIDFdIDogbnVsbDtcbiAgbGV0IG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xuICBjb25zdCBwZXJjZW50ID0gb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG5cbiAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAvLyBmaXJzdCBkYXRhOiBpdHMgc2l6ZSBpcyBkb3VibGUgYmFzZWQgb24gdGhlIG5leHQgcG9pbnQgb3IsXG4gICAgLy8gaWYgaXQncyBhbHNvIHRoZSBsYXN0IGRhdGEsIHdlIHVzZSB0aGUgc2NhbGUgc2l6ZS5cbiAgICBwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XG4gIH1cblxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIC8vIGxhc3QgZGF0YTogaXRzIHNpemUgaXMgYWxzbyBkb3VibGUgYmFzZWQgb24gdGhlIHByZXZpb3VzIHBvaW50LlxuICAgIG5leHQgPSBjdXJyICsgY3VyciAtIHByZXY7XG4gIH1cblxuICBjb25zdCBzdGFydCA9IGN1cnIgLSAoY3VyciAtIE1hdGgubWluKHByZXYsIG5leHQpKSAvIDIgKiBwZXJjZW50O1xuICBjb25zdCBzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XG5cbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW86IG9wdGlvbnMuYmFyUGVyY2VudGFnZSxcbiAgICBzdGFydFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgY29uc3Qgc3RhcnRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVswXSwgaSk7XG4gIGNvbnN0IGVuZFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzFdLCBpKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4oc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBjb25zdCBtYXggPSBNYXRoLm1heChzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gIGxldCBiYXJTdGFydCA9IG1pbjtcbiAgbGV0IGJhckVuZCA9IG1heDtcblxuICBpZiAoTWF0aC5hYnMobWluKSA+IE1hdGguYWJzKG1heCkpIHtcbiAgICBiYXJTdGFydCA9IG1heDtcbiAgICBiYXJFbmQgPSBtaW47XG4gIH1cblxuICAvLyBTdG9yZSBgYmFyRW5kYCAoZnVydGhlc3QgYXdheSBmcm9tIG9yaWdpbikgYXMgcGFyc2VkIHZhbHVlLFxuICAvLyB0byBtYWtlIHN0YWNraW5nIHN0cmFpZ2h0IGZvcndhcmRcbiAgaXRlbVt2U2NhbGUuYXhpc10gPSBiYXJFbmQ7XG5cbiAgaXRlbS5fY3VzdG9tID0ge1xuICAgIGJhclN0YXJ0LFxuICAgIGJhckVuZCxcbiAgICBzdGFydDogc3RhcnRWYWx1ZSxcbiAgICBlbmQ6IGVuZFZhbHVlLFxuICAgIG1pbixcbiAgICBtYXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGlmIChpc0FycmF5KGVudHJ5KSkge1xuICAgIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSk7XG4gIH0gZWxzZSB7XG4gICAgaXRlbVt2U2NhbGUuYXhpc10gPSB2U2NhbGUucGFyc2UoZW50cnksIGkpO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuXG5mdW5jdGlvbiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xuICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGl0ZW0sIGVudHJ5O1xuXG4gIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGVudHJ5ID0gZGF0YVtpXTtcbiAgICBpdGVtID0ge307XG4gICAgaXRlbVtpU2NhbGUuYXhpc10gPSBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2ldLCBpKTtcbiAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuXG5mdW5jdGlvbiBpc0Zsb2F0QmFyKGN1c3RvbSkge1xuICByZXR1cm4gY3VzdG9tICYmIGN1c3RvbS5iYXJTdGFydCAhPT0gdW5kZWZpbmVkICYmIGN1c3RvbS5iYXJFbmQgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpIHtcbiAgaWYgKHNpemUgIT09IDApIHtcbiAgICByZXR1cm4gc2lnbihzaXplKTtcbiAgfVxuICByZXR1cm4gKHZTY2FsZS5pc0hvcml6b250YWwoKSA/IDEgOiAtMSkgKiAodlNjYWxlLm1pbiA+PSBhY3R1YWxCYXNlID8gMSA6IC0xKTtcbn1cblxuZnVuY3Rpb24gYm9yZGVyUHJvcHMocHJvcGVydGllcykge1xuICBsZXQgcmV2ZXJzZSwgc3RhcnQsIGVuZCwgdG9wLCBib3R0b207XG4gIGlmIChwcm9wZXJ0aWVzLmhvcml6b250YWwpIHtcbiAgICByZXZlcnNlID0gcHJvcGVydGllcy5iYXNlID4gcHJvcGVydGllcy54O1xuICAgIHN0YXJ0ID0gJ2xlZnQnO1xuICAgIGVuZCA9ICdyaWdodCc7XG4gIH0gZWxzZSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA8IHByb3BlcnRpZXMueTtcbiAgICBzdGFydCA9ICdib3R0b20nO1xuICAgIGVuZCA9ICd0b3AnO1xuICB9XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgdG9wID0gJ2VuZCc7XG4gICAgYm90dG9tID0gJ3N0YXJ0JztcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSAnc3RhcnQnO1xuICAgIGJvdHRvbSA9ICdlbmQnO1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219O1xufVxuXG5mdW5jdGlvbiBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCkge1xuICBsZXQgZWRnZSA9IG9wdGlvbnMuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgcmVzID0ge307XG5cbiAgaWYgKCFlZGdlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlZGdlID09PSB0cnVlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0ge3RvcDogdHJ1ZSwgcmlnaHQ6IHRydWUsIGJvdHRvbTogdHJ1ZSwgbGVmdDogdHJ1ZX07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfSA9IGJvcmRlclByb3BzKHByb3BlcnRpZXMpO1xuXG4gIGlmIChlZGdlID09PSAnbWlkZGxlJyAmJiBzdGFjaykge1xuICAgIHByb3BlcnRpZXMuZW5hYmxlQm9yZGVyUmFkaXVzID0gdHJ1ZTtcbiAgICBpZiAoKHN0YWNrLl90b3AgfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH0gZWxzZSBpZiAoKHN0YWNrLl9ib3R0b20gfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbcGFyc2VFZGdlKGJvdHRvbSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfVxuICB9XG5cbiAgcmVzW3BhcnNlRWRnZShlZGdlLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRWRnZShlZGdlLCBhLCBiLCByZXZlcnNlKSB7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgZWRnZSA9IHN3YXAoZWRnZSwgYSwgYik7XG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGIsIGEpO1xuICB9IGVsc2Uge1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBhLCBiKTtcbiAgfVxuICByZXR1cm4gZWRnZTtcbn1cblxuZnVuY3Rpb24gc3dhcChvcmlnLCB2MSwgdjIpIHtcbiAgcmV0dXJuIG9yaWcgPT09IHYxID8gdjIgOiBvcmlnID09PSB2MiA/IHYxIDogb3JpZztcbn1cblxuZnVuY3Rpb24gc3RhcnRFbmQodiwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogdiA9PT0gJ2VuZCcgPyBlbmQgOiB2O1xufVxuXG5mdW5jdGlvbiBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIHtpbmZsYXRlQW1vdW50fSwgcmF0aW8pIHtcbiAgcHJvcGVydGllcy5pbmZsYXRlQW1vdW50ID0gaW5mbGF0ZUFtb3VudCA9PT0gJ2F1dG8nXG4gICAgPyByYXRpbyA9PT0gMSA/IDAuMzMgOiAwXG4gICAgOiBpbmZsYXRlQW1vdW50O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdiYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAnYmFyJyxcblxuICAgIGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxuICAgIGJhclBlcmNlbnRhZ2U6IDAuOSxcbiAgICBncm91cGVkOiB0cnVlLFxuXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgc2NhbGVzOiB7XG4gICAgICBfaW5kZXhfOiB7XG4gICAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICAgIG9mZnNldDogdHJ1ZSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIG9mZnNldDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3ZhbHVlXzoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRpbmcgcHJpbWl0aXZlIGRhdGEgcGFyc2luZyBzaW5jZSB3ZSBzdXBwb3J0IG1peGVkIHByaW1pdGl2ZS9hcnJheVxuXHQgKiBkYXRhIGZvciBmbG9hdCBiYXJzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICAvKipcblx0ICogT3ZlcnJpZGluZyBhcnJheSBkYXRhIHBhcnNpbmcgc2luY2Ugd2Ugc3VwcG9ydCBtaXhlZCBwcmltaXRpdmUvYXJyYXlcblx0ICogZGF0YSBmb3IgZmxvYXQgYmFyc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICAvKipcblx0ICogT3ZlcnJpZGluZyBvYmplY3QgZGF0YSBwYXJzaW5nIHNpbmNlIHdlIHN1cHBvcnQgbWl4ZWQgcHJpbWl0aXZlL2FycmF5XG5cdCAqIHZhbHVlLXNjYWxlIGRhdGEgZm9yIGZsb2F0IGJhcnNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHt4QXhpc0tleSA9ICd4JywgeUF4aXNLZXkgPSAneSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICBjb25zdCBpQXhpc0tleSA9IGlTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHZBeGlzS2V5ID0gdlNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgY29uc3QgcGFyc2VkID0gW107XG4gICAgbGV0IGksIGlsZW4sIGl0ZW0sIG9iajtcbiAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG9iaiA9IGRhdGFbaV07XG4gICAgICBpdGVtID0ge307XG4gICAgICBpdGVtW2lTY2FsZS5heGlzXSA9IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgaUF4aXNLZXkpLCBpKTtcbiAgICAgIHBhcnNlZC5wdXNoKHBhcnNlVmFsdWUocmVzb2x2ZU9iamVjdEtleShvYmosIHZBeGlzS2V5KSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIHN1cGVyLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGlmIChjdXN0b20gJiYgc2NhbGUgPT09IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlKSB7XG4gICAgICAvLyBmbG9hdCBiYXI6IG9ubHkgb25lIGVuZCBvZiB0aGUgYmFyIGlzIGNvbnNpZGVyZWQgYnkgYHN1cGVyYFxuICAgICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCBjdXN0b20ubWluKTtcbiAgICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgY3VzdG9tLm1heCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcnxib29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IHZhbHVlID0gaXNGbG9hdEJhcihjdXN0b20pXG4gICAgICA/ICdbJyArIGN1c3RvbS5zdGFydCArICcsICcgKyBjdXN0b20uZW5kICsgJ10nXG4gICAgICA6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSksXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG5cbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG5cbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLnN0YWNrID0gdGhpcy5nZXREYXRhc2V0KCkuc3RhY2s7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMobWV0YS5kYXRhLCAwLCBtZXRhLmRhdGEubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKGJhcnMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aW5kZXgsIF9jYWNoZWRNZXRhOiB7dlNjYWxlfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJhc2UgPSB2U2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHZTY2FsZS5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBydWxlciA9IHRoaXMuX2dldFJ1bGVyKCk7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHZwaXhlbHMgPSByZXNldCB8fCBpc051bGxPclVuZGVmKHBhcnNlZFt2U2NhbGUuYXhpc10pID8ge2Jhc2UsIGhlYWQ6IGJhc2V9IDogdGhpcy5fY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaSk7XG4gICAgICBjb25zdCBpcGl4ZWxzID0gdGhpcy5fY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaSwgcnVsZXIpO1xuICAgICAgY29uc3Qgc3RhY2sgPSAocGFyc2VkLl9zdGFja3MgfHwge30pW3ZTY2FsZS5heGlzXTtcblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgaG9yaXpvbnRhbCxcbiAgICAgICAgYmFzZTogdnBpeGVscy5iYXNlLFxuICAgICAgICBlbmFibGVCb3JkZXJSYWRpdXM6ICFzdGFjayB8fCBpc0Zsb2F0QmFyKHBhcnNlZC5fY3VzdG9tKSB8fCAoaW5kZXggPT09IHN0YWNrLl90b3AgfHwgaW5kZXggPT09IHN0YWNrLl9ib3R0b20pLFxuICAgICAgICB4OiBob3Jpem9udGFsID8gdnBpeGVscy5oZWFkIDogaXBpeGVscy5jZW50ZXIsXG4gICAgICAgIHk6IGhvcml6b250YWwgPyBpcGl4ZWxzLmNlbnRlciA6IHZwaXhlbHMuaGVhZCxcbiAgICAgICAgaGVpZ2h0OiBob3Jpem9udGFsID8gaXBpeGVscy5zaXplIDogTWF0aC5hYnModnBpeGVscy5zaXplKSxcbiAgICAgICAgd2lkdGg6IGhvcml6b250YWwgPyBNYXRoLmFicyh2cGl4ZWxzLnNpemUpIDogaXBpeGVscy5zaXplXG4gICAgICB9O1xuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYmFyc1tpXS5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHByb3BlcnRpZXMub3B0aW9ucyB8fCBiYXJzW2ldLm9wdGlvbnM7XG4gICAgICBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCk7XG4gICAgICBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIG9wdGlvbnMsIHJ1bGVyLnJhdGlvKTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChiYXJzW2ldLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc3RhY2tzIGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbGFzdF0gLSBUaGUgZGF0YXNldCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF0gLSBUaGUgZGF0YSBpbmRleCBvZiB0aGUgcnVsZXJcblx0ICogQHJldHVybnMge3N0cmluZ1tdfSBUaGUgbGlzdCBvZiBzdGFjayBJRHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRTdGFja3MobGFzdCwgZGF0YUluZGV4KSB7XG4gICAgY29uc3Qge2lTY2FsZX0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gaVNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHRoaXMuX3R5cGUpXG4gICAgICAuZmlsdGVyKG1ldGEgPT4gbWV0YS5jb250cm9sbGVyLm9wdGlvbnMuZ3JvdXBlZCk7XG4gICAgY29uc3Qgc3RhY2tlZCA9IGlTY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gICAgY29uc3Qgc3RhY2tzID0gW107XG4gICAgY29uc3QgY3VycmVudFBhcnNlZCA9IHRoaXMuX2NhY2hlZE1ldGEuY29udHJvbGxlci5nZXRQYXJzZWQoZGF0YUluZGV4KTtcbiAgICBjb25zdCBpU2NhbGVWYWx1ZSA9IGN1cnJlbnRQYXJzZWQgJiYgY3VycmVudFBhcnNlZFtpU2NhbGUuYXhpc107XG5cbiAgICBjb25zdCBza2lwTnVsbCA9IChtZXRhKSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBtZXRhLl9wYXJzZWQuZmluZChpdGVtID0+IGl0ZW1baVNjYWxlLmF4aXNdID09PSBpU2NhbGVWYWx1ZSk7XG4gICAgICBjb25zdCB2YWwgPSBwYXJzZWQgJiYgcGFyc2VkW21ldGEudlNjYWxlLmF4aXNdO1xuXG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWwpIHx8IGlzTmFOKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAoY29uc3QgbWV0YSBvZiBtZXRhc2V0cykge1xuICAgICAgaWYgKGRhdGFJbmRleCAhPT0gdW5kZWZpbmVkICYmIHNraXBOdWxsKG1ldGEpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBzdGFja2VkICAgfCBtZXRhLnN0YWNrXG4gICAgICAvLyAgICAgICAgICAgfCBmb3VuZCB8IG5vdCBmb3VuZCB8IHVuZGVmaW5lZFxuICAgICAgLy8gZmFsc2UgICAgIHwgICB4ICAgfCAgICAgeCAgICAgfCAgICAgeFxuICAgICAgLy8gdHJ1ZSAgICAgIHwgICAgICAgfCAgICAgeCAgICAgfFxuICAgICAgLy8gdW5kZWZpbmVkIHwgICAgICAgfCAgICAgeCAgICAgfCAgICAgeFxuICAgICAgaWYgKHN0YWNrZWQgPT09IGZhbHNlIHx8IHN0YWNrcy5pbmRleE9mKG1ldGEuc3RhY2spID09PSAtMSB8fFxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgc3RhY2tzLnB1c2gobWV0YS5zdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAobWV0YS5pbmRleCA9PT0gbGFzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyBzdGFja3M/IHRoYXQgbWVhbnMgdGhlcmUgaXMgbm8gdmlzaWJsZSBkYXRhLiBMZXQncyBzdGlsbCBpbml0aWFsaXplIGFuIGB1bmRlZmluZWRgXG4gICAgLy8gc3RhY2sgd2hlcmUgcG9zc2libGUgaW52aXNpYmxlIGJhcnMgd2lsbCBiZSBsb2NhdGVkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy82MzY4XG4gICAgaWYgKCFzdGFja3MubGVuZ3RoKSB7XG4gICAgICBzdGFja3MucHVzaCh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFja3M7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgZWZmZWN0aXZlIG51bWJlciBvZiBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRTdGFja0NvdW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0YWNrcyh1bmRlZmluZWQsIGluZGV4KS5sZW5ndGg7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc3RhY2sgaW5kZXggZm9yIHRoZSBnaXZlbiBkYXRhc2V0IGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YXNldEluZGV4XSAtIFRoZSBkYXRhc2V0IGluZGV4XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gLSBUaGUgc3RhY2sgbmFtZSB0byBmaW5kXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YUluZGV4XVxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc3RhY2sgaW5kZXhcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRTdGFja0luZGV4KGRhdGFzZXRJbmRleCwgbmFtZSwgZGF0YUluZGV4KSB7XG4gICAgY29uc3Qgc3RhY2tzID0gdGhpcy5fZ2V0U3RhY2tzKGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KTtcbiAgICBjb25zdCBpbmRleCA9IChuYW1lICE9PSB1bmRlZmluZWQpXG4gICAgICA/IHN0YWNrcy5pbmRleE9mKG5hbWUpXG4gICAgICA6IC0xOyAvLyBpbmRleE9mIHJldHVybnMgLTEgaWYgZWxlbWVudCBpcyBub3QgcHJlc2VudFxuXG4gICAgcmV0dXJuIChpbmRleCA9PT0gLTEpXG4gICAgICA/IHN0YWNrcy5sZW5ndGggLSAxXG4gICAgICA6IGluZGV4O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UnVsZXIoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBwaXhlbHMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhLmRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwaXhlbHMucHVzaChpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpKVtpU2NhbGUuYXhpc10sIGkpKTtcbiAgICB9XG5cbiAgICBjb25zdCBiYXJUaGlja25lc3MgPSBvcHRzLmJhclRoaWNrbmVzcztcbiAgICBjb25zdCBtaW4gPSBiYXJUaGlja25lc3MgfHwgY29tcHV0ZU1pblNhbXBsZVNpemUobWV0YSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluLFxuICAgICAgcGl4ZWxzLFxuICAgICAgc3RhcnQ6IGlTY2FsZS5fc3RhcnRQaXhlbCxcbiAgICAgIGVuZDogaVNjYWxlLl9lbmRQaXhlbCxcbiAgICAgIHN0YWNrQ291bnQ6IHRoaXMuX2dldFN0YWNrQ291bnQoKSxcbiAgICAgIHNjYWxlOiBpU2NhbGUsXG4gICAgICBncm91cGVkOiBvcHRzLmdyb3VwZWQsXG4gICAgICAvLyBiYXIgdGhpY2tuZXNzIHJhdGlvIHVzZWQgZm9yIG5vbi1ncm91cGVkIGJhcnNcbiAgICAgIHJhdGlvOiBiYXJUaGlja25lc3MgPyAxIDogb3B0cy5jYXRlZ29yeVBlcmNlbnRhZ2UgKiBvcHRzLmJhclBlcmNlbnRhZ2VcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIE5vdGU6IHBpeGVsIHZhbHVlcyBhcmUgbm90IGNsYW1wZWQgdG8gdGhlIHNjYWxlIGFyZWEuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaW5kZXgpIHtcbiAgICBjb25zdCB7X2NhY2hlZE1ldGE6IHt2U2NhbGUsIF9zdGFja2VkLCBpbmRleDogZGF0YXNldEluZGV4fSwgb3B0aW9uczoge2Jhc2U6IGJhc2VWYWx1ZSwgbWluQmFyTGVuZ3RofX0gPSB0aGlzO1xuICAgIGNvbnN0IGFjdHVhbEJhc2UgPSBiYXNlVmFsdWUgfHwgMDtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgY29uc3QgZmxvYXRpbmcgPSBpc0Zsb2F0QmFyKGN1c3RvbSk7XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkW3ZTY2FsZS5heGlzXTtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBsZW5ndGggPSBfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogdmFsdWU7XG4gICAgbGV0IGhlYWQsIHNpemU7XG5cbiAgICBpZiAobGVuZ3RoICE9PSB2YWx1ZSkge1xuICAgICAgc3RhcnQgPSBsZW5ndGggLSB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChmbG9hdGluZykge1xuICAgICAgdmFsdWUgPSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICBsZW5ndGggPSBjdXN0b20uYmFyRW5kIC0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgLy8gYmFycyBjcm9zc2luZyBvcmlnaW4gYXJlIG5vdCBzdGFja2VkXG4gICAgICBpZiAodmFsdWUgIT09IDAgJiYgc2lnbih2YWx1ZSkgIT09IHNpZ24oY3VzdG9tLmJhckVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgKz0gdmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRWYWx1ZSA9ICFpc051bGxPclVuZGVmKGJhc2VWYWx1ZSkgJiYgIWZsb2F0aW5nID8gYmFzZVZhbHVlIDogc3RhcnQ7XG4gICAgbGV0IGJhc2UgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydFZhbHVlKTtcblxuICAgIGlmICh0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgaGVhZCA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0ICsgbGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2hlbiBub3QgdmlzaWJsZSwgbm8gaGVpZ2h0XG4gICAgICBoZWFkID0gYmFzZTtcbiAgICB9XG5cbiAgICBzaXplID0gaGVhZCAtIGJhc2U7XG5cbiAgICBpZiAoTWF0aC5hYnMoc2l6ZSkgPCBtaW5CYXJMZW5ndGgpIHtcbiAgICAgIHNpemUgPSBiYXJTaWduKHNpemUsIHZTY2FsZSwgYWN0dWFsQmFzZSkgKiBtaW5CYXJMZW5ndGg7XG4gICAgICBpZiAodmFsdWUgPT09IGFjdHVhbEJhc2UpIHtcbiAgICAgICAgYmFzZSAtPSBzaXplIC8gMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0UGl4ZWwgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDApO1xuICAgICAgY29uc3QgZW5kUGl4ZWwgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDEpO1xuICAgICAgY29uc3QgbWluID0gTWF0aC5taW4oc3RhcnRQaXhlbCwgZW5kUGl4ZWwpO1xuICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRQaXhlbCwgZW5kUGl4ZWwpO1xuICAgICAgYmFzZSA9IE1hdGgubWF4KE1hdGgubWluKGJhc2UsIG1heCksIG1pbik7XG4gICAgICBoZWFkID0gYmFzZSArIHNpemU7XG5cbiAgICAgIGlmIChfc3RhY2tlZCAmJiAhZmxvYXRpbmcpIHtcbiAgICAgICAgLy8gdmlzdWFsIGRhdGEgY29vcmRpbmF0ZXMgYWZ0ZXIgYXBwbHlpbmcgbWluQmFyTGVuZ3RoXG4gICAgICAgIHBhcnNlZC5fc3RhY2tzW3ZTY2FsZS5heGlzXS5fdmlzdWFsVmFsdWVzW2RhdGFzZXRJbmRleF0gPSB2U2NhbGUuZ2V0VmFsdWVGb3JQaXhlbChoZWFkKSAtIHZTY2FsZS5nZXRWYWx1ZUZvclBpeGVsKGJhc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiYXNlID09PSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShhY3R1YWxCYXNlKSkge1xuICAgICAgY29uc3QgaGFsZkdyaWQgPSBzaWduKHNpemUpICogdlNjYWxlLmdldExpbmVXaWR0aEZvclZhbHVlKGFjdHVhbEJhc2UpIC8gMjtcbiAgICAgIGJhc2UgKz0gaGFsZkdyaWQ7XG4gICAgICBzaXplIC09IGhhbGZHcmlkO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzaXplLFxuICAgICAgYmFzZSxcbiAgICAgIGhlYWQsXG4gICAgICBjZW50ZXI6IGhlYWQgKyBzaXplIC8gMlxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhpbmRleCwgcnVsZXIpIHtcbiAgICBjb25zdCBzY2FsZSA9IHJ1bGVyLnNjYWxlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2tpcE51bGwgPSBvcHRpb25zLnNraXBOdWxsO1xuICAgIGNvbnN0IG1heEJhclRoaWNrbmVzcyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubWF4QmFyVGhpY2tuZXNzLCBJbmZpbml0eSk7XG4gICAgbGV0IGNlbnRlciwgc2l6ZTtcbiAgICBpZiAocnVsZXIuZ3JvdXBlZCkge1xuICAgICAgY29uc3Qgc3RhY2tDb3VudCA9IHNraXBOdWxsID8gdGhpcy5fZ2V0U3RhY2tDb3VudChpbmRleCkgOiBydWxlci5zdGFja0NvdW50O1xuICAgICAgY29uc3QgcmFuZ2UgPSBvcHRpb25zLmJhclRoaWNrbmVzcyA9PT0gJ2ZsZXgnXG4gICAgICAgID8gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpXG4gICAgICAgIDogY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCk7XG5cbiAgICAgIGNvbnN0IHN0YWNrSW5kZXggPSB0aGlzLl9nZXRTdGFja0luZGV4KHRoaXMuaW5kZXgsIHRoaXMuX2NhY2hlZE1ldGEuc3RhY2ssIHNraXBOdWxsID8gaW5kZXggOiB1bmRlZmluZWQpO1xuICAgICAgY2VudGVyID0gcmFuZ2Uuc3RhcnQgKyAocmFuZ2UuY2h1bmsgKiBzdGFja0luZGV4KSArIChyYW5nZS5jaHVuayAvIDIpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBub24tZ3JvdXBlZCBiYXIgY2hhcnRzLCBleGFjdCBwaXhlbCB2YWx1ZXMgYXJlIHVzZWRcbiAgICAgIGNlbnRlciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaW5kZXgpW3NjYWxlLmF4aXNdLCBpbmRleCk7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCBydWxlci5taW4gKiBydWxlci5yYXRpbyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2U6IGNlbnRlciAtIHNpemUgLyAyLFxuICAgICAgaGVhZDogY2VudGVyICsgc2l6ZSAvIDIsXG4gICAgICBjZW50ZXIsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgY29uc3QgcmVjdHMgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgaWxlbiA9IHJlY3RzLmxlbmd0aDtcbiAgICBsZXQgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKHRoaXMuZ2V0UGFyc2VkKGkpW3ZTY2FsZS5heGlzXSAhPT0gbnVsbCAmJiAhcmVjdHNbaV0uaGlkZGVuKSB7XG4gICAgICAgIHJlY3RzW2ldLmRyYXcodGhpcy5fY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHt2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWJibGVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdidWJibGUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJ11cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIHNjYWxlczoge1xuICAgICAgeDoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBwcmltaXRpdmUgdmFsdWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXM7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2YgYXJyYXlzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW1bMl0sIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2Ygb2JqZWN0c1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW0gJiYgaXRlbS5yICYmICtpdGVtLnIsIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgfVxuICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5jaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcbiAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuICAgIGNvbnN0IHIgPSBwYXJzZWQuX2N1c3RvbTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlOiAnKCcgKyB4ICsgJywgJyArIHkgKyAociA/ICcsICcgKyByIDogJycpICsgJyknXG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgLy8gVXBkYXRlIFBvaW50c1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gIXJlc2V0ICYmIHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSByZXNldCA/IGlTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMC41KSA6IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10pO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFt2QXhpc10pO1xuXG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCk7XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuXG4gICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgIHByb3BlcnRpZXMub3B0aW9ucy5yYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW21vZGVdXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgbGV0IHZhbHVlcyA9IHN1cGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpO1xuXG4gICAgLy8gSW4gY2FzZSB2YWx1ZXMgd2VyZSBjYWNoZWQgKGFuZCB0aHVzIGZyb3plbiksIHdlIG5lZWQgdG8gY2xvbmUgdGhlIHZhbHVlc1xuICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgdmFsdWVzID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWVzLCB7JHNoYXJlZDogZmFsc2V9KTtcbiAgICB9XG5cbiAgICAvLyBDdXN0b20gcmFkaXVzIHJlc29sdXRpb25cbiAgICBjb25zdCByYWRpdXMgPSB2YWx1ZXMucmFkaXVzO1xuICAgIGlmIChtb2RlICE9PSAnYWN0aXZlJykge1xuICAgICAgdmFsdWVzLnJhZGl1cyA9IDA7XG4gICAgfVxuICAgIHZhbHVlcy5yYWRpdXMgKz0gdmFsdWVPckRlZmF1bHQocGFyc2VkICYmIHBhcnNlZC5fY3VzdG9tLCByYWRpdXMpO1xuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtpc09iamVjdCwgcmVzb2x2ZU9iamVjdEtleSwgdG9QZXJjZW50YWdlLCB0b0RpbWVuc2lvbiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5pbXBvcnQge3RvUmFkaWFucywgUEksIFRBVSwgSEFMRl9QSSwgX2FuZ2xlQmV0d2Vlbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbmZ1bmN0aW9uIGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpIHtcbiAgbGV0IHJhdGlvWCA9IDE7XG4gIGxldCByYXRpb1kgPSAxO1xuICBsZXQgb2Zmc2V0WCA9IDA7XG4gIGxldCBvZmZzZXRZID0gMDtcbiAgLy8gSWYgdGhlIGNoYXJ0J3MgY2lyY3VtZmVyZW5jZSBpc24ndCBhIGZ1bGwgY2lyY2xlLCBjYWxjdWxhdGUgc2l6ZSBhcyBhIHJhdGlvIG9mIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGFyY1xuICBpZiAoY2lyY3VtZmVyZW5jZSA8IFRBVSkge1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSByb3RhdGlvbjtcbiAgICBjb25zdCBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlO1xuICAgIGNvbnN0IHN0YXJ0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IHN0YXJ0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IGVuZFggPSBNYXRoLmNvcyhlbmRBbmdsZSk7XG4gICAgY29uc3QgZW5kWSA9IE1hdGguc2luKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBjYWxjTWF4ID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAxIDogTWF0aC5tYXgoYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XG4gICAgY29uc3QgY2FsY01pbiA9IChhbmdsZSwgYSwgYikgPT4gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gLTEgOiBNYXRoLm1pbihhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBtYXhYID0gY2FsY01heCgwLCBzdGFydFgsIGVuZFgpO1xuICAgIGNvbnN0IG1heFkgPSBjYWxjTWF4KEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgY29uc3QgbWluWCA9IGNhbGNNaW4oUEksIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWluWSA9IGNhbGNNaW4oUEkgKyBIQUxGX1BJLCBzdGFydFksIGVuZFkpO1xuICAgIHJhdGlvWCA9IChtYXhYIC0gbWluWCkgLyAyO1xuICAgIHJhdGlvWSA9IChtYXhZIC0gbWluWSkgLyAyO1xuICAgIG9mZnNldFggPSAtKG1heFggKyBtaW5YKSAvIDI7XG4gICAgb2Zmc2V0WSA9IC0obWF4WSArIG1pblkpIC8gMjtcbiAgfVxuICByZXR1cm4ge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG91Z2hudXRDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdkb3VnaG51dCc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdhcmMnLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgLy8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIERvdWdobnV0XG4gICAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgICAgLy8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSBzY2FsaW5nIHRoZSBEb3VnaG51dCBmcm9tIHRoZSBjZW50cmVcbiAgICAgIGFuaW1hdGVTY2FsZTogZmFsc2VcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsnY2lyY3VtZmVyZW5jZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cycsICdzdGFydEFuZ2xlJywgJ3gnLCAneScsICdvZmZzZXQnLCAnYm9yZGVyV2lkdGgnLCAnc3BhY2luZyddXG4gICAgICB9LFxuICAgIH0sXG4gICAgLy8gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNoYXJ0IHRoYXQgd2UgY3V0IG91dCBvZiB0aGUgbWlkZGxlLlxuICAgIGN1dG91dDogJzUwJScsXG5cbiAgICAvLyBUaGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0LCB3aGVyZSB0aGUgZmlyc3QgZGF0YSBhcmMgYmVnaW5zLlxuICAgIHJvdGF0aW9uOiAwLFxuXG4gICAgLy8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxuICAgIGNpcmN1bWZlcmVuY2U6IDM2MCxcblxuICAgIC8vIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNoYXJ0XG4gICAgcmFkaXVzOiAnMTAwJScsXG5cbiAgICAvLyBTcGFjaW5nIGJldHdlZW4gYXJjc1xuICAgIHNwYWNpbmc6IDAsXG5cbiAgICBpbmRleEF4aXM6ICdyJyxcbiAgfTtcblxuICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnc3BhY2luZycsXG4gICAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyAmJiAhbmFtZS5zdGFydHNXaXRoKCdib3JkZXJEYXNoJykgJiYgIW5hbWUuc3RhcnRzV2l0aCgnaG92ZXJCb3JkZXJEYXNoJyksXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIGFzcGVjdFJhdGlvOiAxLFxuXG4gICAgLy8gTmVlZCB0byBvdmVycmlkZSB0aGVzZSB0byBnaXZlIGEgbmljZSBkZWZhdWx0XG4gICAgcGx1Z2luczoge1xuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGUsIGNvbG9yfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcblxuICAgICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG5cbiAgICAgICAgICAgICAgICAgIC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcblxuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsaW5rU2NhbGVzKCkge31cblxuICAvKipcblx0ICogT3ZlcnJpZGUgZGF0YSBwYXJzaW5nLCBzaW5jZSB3ZSBhcmUgbm90IHVzaW5nIHNjYWxlc1xuXHQgKi9cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YXNldCgpLmRhdGE7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG5cbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIG1ldGEuX3BhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBnZXR0ZXIgPSAoaSkgPT4gK2RhdGFbaV07XG5cbiAgICAgIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgY29uc3Qge2tleSA9ICd2YWx1ZSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICAgICAgZ2V0dGVyID0gKGkpID0+ICtyZXNvbHZlT2JqZWN0S2V5KGRhdGFbaV0sIGtleSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIG1ldGEuX3BhcnNlZFtpXSA9IGdldHRlcihpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5yb3RhdGlvbiAtIDkwKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldENpcmN1bWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMuY2lyY3VtZmVyZW5jZSk7XG4gIH1cblxuICAvKipcblx0ICogR2V0IHRoZSBtYXhpbWFsIHJvdGF0aW9uICYgY2lyY3VtZmVyZW5jZSBleHRlbnRzXG5cdCAqIGFjcm9zcyBhbGwgdmlzaWJsZSBkYXRhc2V0cy5cblx0ICovXG4gIF9nZXRSb3RhdGlvbkV4dGVudHMoKSB7XG4gICAgbGV0IG1pbiA9IFRBVTtcbiAgICBsZXQgbWF4ID0gLVRBVTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSkudHlwZSA9PT0gdGhpcy5fdHlwZSkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGNvbnRyb2xsZXIuX2dldFJvdGF0aW9uKCk7XG4gICAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSBjb250cm9sbGVyLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG5cbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByb3RhdGlvbik7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcm90YXRpb24gKyBjaXJjdW1mZXJlbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRpb246IG1pbixcbiAgICAgIGNpcmN1bWZlcmVuY2U6IG1heCAtIG1pbixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlXG5cdCAqL1xuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCB7Y2hhcnRBcmVhfSA9IGNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgY29uc3Qgc3BhY2luZyA9IHRoaXMuZ2V0TWF4Qm9yZGVyV2lkdGgoKSArIHRoaXMuZ2V0TWF4T2Zmc2V0KGFyY3MpICsgdGhpcy5vcHRpb25zLnNwYWNpbmc7XG4gICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KChNYXRoLm1pbihjaGFydEFyZWEud2lkdGgsIGNoYXJ0QXJlYS5oZWlnaHQpIC0gc3BhY2luZykgLyAyLCAwKTtcbiAgICBjb25zdCBjdXRvdXQgPSBNYXRoLm1pbih0b1BlcmNlbnRhZ2UodGhpcy5vcHRpb25zLmN1dG91dCwgbWF4U2l6ZSksIDEpO1xuICAgIGNvbnN0IGNoYXJ0V2VpZ2h0ID0gdGhpcy5fZ2V0UmluZ1dlaWdodCh0aGlzLmluZGV4KTtcblxuICAgIC8vIENvbXB1dGUgdGhlIG1heGltYWwgcm90YXRpb24gJiBjaXJjdW1mZXJlbmNlIGxpbWl0cy5cbiAgICAvLyBJZiB3ZSBvbmx5IGNvbnNpZGVyIG91ciBkYXRhc2V0LCB0aGlzIGNhbiBjYXVzZSBwcm9ibGVtcyB3aGVuIHR3byBkYXRhc2V0c1xuICAgIC8vIGFyZSBib3RoIGxlc3MgdGhhbiBhIGNpcmNsZSB3aXRoIGRpZmZlcmVudCByb3RhdGlvbnMgKHN0YXJ0aW5nIGFuZ2xlcylcbiAgICBjb25zdCB7Y2lyY3VtZmVyZW5jZSwgcm90YXRpb259ID0gdGhpcy5fZ2V0Um90YXRpb25FeHRlbnRzKCk7XG4gICAgY29uc3Qge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfSA9IGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFdpZHRoID0gKGNoYXJ0QXJlYS53aWR0aCAtIHNwYWNpbmcpIC8gcmF0aW9YO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IChjaGFydEFyZWEuaGVpZ2h0IC0gc3BhY2luZykgLyByYXRpb1k7XG4gICAgY29uc3QgbWF4UmFkaXVzID0gTWF0aC5tYXgoTWF0aC5taW4obWF4V2lkdGgsIG1heEhlaWdodCkgLyAyLCAwKTtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IHRvRGltZW5zaW9uKHRoaXMub3B0aW9ucy5yYWRpdXMsIG1heFJhZGl1cyk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvdXRlclJhZGl1cyAqIGN1dG91dCwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gdGhpcy5fZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpO1xuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFggKiBvdXRlclJhZGl1cztcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZICogb3V0ZXJSYWRpdXM7XG5cbiAgICBtZXRhLnRvdGFsID0gdGhpcy5jYWxjdWxhdGVUb3RhbCgpO1xuXG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gTWF0aC5tYXgodGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcblxuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2lyY3VtZmVyZW5jZShpLCByZXNldCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICBpZiAoKHJlc2V0ICYmIG9wdHMuYW5pbWF0aW9uLmFuaW1hdGVSb3RhdGUpIHx8ICF0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpIHx8IG1ldGEuX3BhcnNlZFtpXSA9PT0gbnVsbCB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShtZXRhLl9wYXJzZWRbaV0gKiBjaXJjdW1mZXJlbmNlIC8gVEFVKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBjZW50ZXJYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyO1xuICAgIGNvbnN0IGFuaW1hdGVTY2FsZSA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMuaW5uZXJSYWRpdXM7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5vdXRlclJhZGl1cztcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgbGV0IHN0YXJ0QW5nbGUgPSB0aGlzLl9nZXRSb3RhdGlvbigpO1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIHN0YXJ0QW5nbGUgKz0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYICsgdGhpcy5vZmZzZXRYLFxuICAgICAgICB5OiBjZW50ZXJZICsgdGhpcy5vZmZzZXRZLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZTogc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBpbm5lclJhZGl1c1xuICAgICAgfTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0QW5nbGUgKz0gY2lyY3VtZmVyZW5jZTtcblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlVG90YWwoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbWV0YURhdGEgPSBtZXRhLmRhdGE7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBtZXRhRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBtZXRhLl9wYXJzZWRbaV07XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgIWlzTmFOKHZhbHVlKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpICYmICFtZXRhRGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgICAgdG90YWwgKz0gTWF0aC5hYnModmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuXG4gIGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UodmFsdWUpIHtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuX2NhY2hlZE1ldGEudG90YWw7XG4gICAgaWYgKHRvdGFsID4gMCAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gVEFVICogKE1hdGguYWJzKHZhbHVlKSAvIHRvdGFsKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0sIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cblxuICBnZXRNYXhCb3JkZXJXaWR0aChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGxldCBpLCBpbGVuLCBtZXRhLCBjb250cm9sbGVyLCBvcHRpb25zO1xuXG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICAvLyBGaW5kIHRoZSBvdXRtb3N0IHZpc2libGUgZGF0YXNldFxuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgICAgIGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgICAgICAgY29udHJvbGxlciA9IG1ldGEuY29udHJvbGxlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYXJjcykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvcHRpb25zID0gY29udHJvbGxlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgaWYgKG9wdGlvbnMuYm9yZGVyQWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLmJvcmRlcldpZHRoIHx8IDAsIG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCB8fCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuXG4gIGdldE1heE9mZnNldChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLm9mZnNldCB8fCAwLCBvcHRpb25zLmhvdmVyT2Zmc2V0IHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldCByYWRpdXMgbGVuZ3RoIG9mZnNldCBvZiB0aGUgZGF0YXNldCBpbiByZWxhdGlvbiB0byB0aGUgdmlzaWJsZSBkYXRhc2V0cyB3ZWlnaHRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSaW5nV2VpZ2h0T2Zmc2V0KGRhdGFzZXRJbmRleCkge1xuICAgIGxldCByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgcmluZ1dlaWdodE9mZnNldCArPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByaW5nV2VpZ2h0T2Zmc2V0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UmluZ1dlaWdodChkYXRhc2V0SW5kZXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodmFsdWVPckRlZmF1bHQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0ud2VpZ2h0LCAxKSwgMCk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc3VtIG9mIGFsbCB2aXNpYmxlIGRhdGEgc2V0IHdlaWdodHMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKSB8fCAxO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtpc051bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cywgX3NjYWxlUmFuZ2VzQ2hhbmdlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdsaW5lJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG5cbiAgICBzaG93TGluZTogdHJ1ZSxcbiAgICBzcGFuR2FwczogZmFsc2UsXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIHNjYWxlczoge1xuICAgICAgX2luZGV4Xzoge1xuICAgICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgICAgfSxcbiAgICAgIF92YWx1ZV86IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICB9LFxuICAgIH1cbiAgfTtcblxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIGRhdGE6IHBvaW50cyA9IFtdLCBfZGF0YXNldH0gPSBtZXRhO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBhbmltYXRpb25zRGlzYWJsZWQgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuXG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gY291bnQ7XG5cbiAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBMaW5lXG4gICAgbGluZS5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgfVxuICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xuICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHtcbiAgICAgIGFuaW1hdGVkOiAhYW5pbWF0aW9uc0Rpc2FibGVkLFxuICAgICAgb3B0aW9uc1xuICAgIH0sIG1vZGUpO1xuXG4gICAgLy8gVXBkYXRlIFBvaW50c1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgIGNvbnN0IHBvaW50c0NvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNDb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuXG4gICAgICBpZiAoaSA8IHN0YXJ0IHx8IGkgPj0gZW5kKSB7XG4gICAgICAgIHByb3BlcnRpZXMuc2tpcCA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuXG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAoTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSkgPiBtYXhHYXBMZW5ndGg7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBib3JkZXIgPSBkYXRhc2V0Lm9wdGlvbnMgJiYgZGF0YXNldC5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYm9yZGVyO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gZGF0YVswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLmRhdGFzZXQudXBkYXRlQ29udHJvbFBvaW50cyh0aGlzLmNoYXJ0LmNoYXJ0QXJlYSwgbWV0YS5pU2NhbGUuYXhpcyk7XG4gICAgc3VwZXIuZHJhdygpO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge3RvUmFkaWFucywgUEksIGZvcm1hdE51bWJlciwgX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9sYXJBcmVhQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAncG9sYXJBcmVhJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdhcmMnLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICAgIGFuaW1hdGVTY2FsZTogdHJ1ZVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnc3RhcnRBbmdsZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cyddXG4gICAgICB9LFxuICAgIH0sXG4gICAgaW5kZXhBeGlzOiAncicsXG4gICAgc3RhcnRBbmdsZTogMCxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgYXNwZWN0UmF0aW86IDEsXG5cbiAgICBwbHVnaW5zOiB7XG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZSwgY29sb3J9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuXG4gICAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcblxuICAgICAgICAgICAgICAgICAgLy8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXG4gICAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2NhbGVzOiB7XG4gICAgICByOiB7XG4gICAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgICAgICBhbmdsZUxpbmVzOiB7XG4gICAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBjaXJjdWxhcjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBwb2ludExhYmVsczoge1xuICAgICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0QW5nbGU6IDBcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xuXG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLnIsIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cblxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZS5iaW5kKHRoaXMpKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGFyY3MgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG5cbiAgICB0aGlzLl91cGRhdGVSYWRpdXMoKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRNaW5NYXgoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgcmFuZ2UgPSB7bWluOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1heDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZfTtcblxuICAgIG1ldGEuZGF0YS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpLnI7XG5cbiAgICAgIGlmICghaXNOYU4ocGFyc2VkKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICBpZiAocGFyc2VkIDwgcmFuZ2UubWluKSB7XG4gICAgICAgICAgcmFuZ2UubWluID0gcGFyc2VkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlZCA+IHJhbmdlLm1heCkge1xuICAgICAgICAgIHJhbmdlLm1heCA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlUmFkaXVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XG5cbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KG1pblNpemUgLyAyLCAwKTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KG9wdHMuY3V0b3V0UGVyY2VudGFnZSA/IChvdXRlclJhZGl1cyAvIDEwMCkgKiAob3B0cy5jdXRvdXRQZXJjZW50YWdlKSA6IDEsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIGNoYXJ0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcblxuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIChyYWRpdXNMZW5ndGggKiB0aGlzLmluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aDtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgY29uc3QgY2VudGVyWCA9IHNjYWxlLnhDZW50ZXI7XG4gICAgY29uc3QgY2VudGVyWSA9IHNjYWxlLnlDZW50ZXI7XG4gICAgY29uc3QgZGF0YXNldFN0YXJ0QW5nbGUgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKDApIC0gMC41ICogUEk7XG4gICAgbGV0IGFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgbGV0IGk7XG5cbiAgICBjb25zdCBkZWZhdWx0QW5nbGUgPSAzNjAgLyB0aGlzLmNvdW50VmlzaWJsZUVsZW1lbnRzKCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgYW5nbGUgKz0gdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgbGV0IHN0YXJ0QW5nbGUgPSBhbmdsZTtcbiAgICAgIGxldCBlbmRBbmdsZSA9IGFuZ2xlICsgdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgICBsZXQgb3V0ZXJSYWRpdXMgPSBjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSA/IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGkpLnIpIDogMDtcbiAgICAgIGFuZ2xlID0gZW5kQW5nbGU7XG5cbiAgICAgIGlmIChyZXNldCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUpIHtcbiAgICAgICAgICBvdXRlclJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSkge1xuICAgICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHg6IGNlbnRlclgsXG4gICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgIGlubmVyUmFkaXVzOiAwLFxuICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKVxuICAgICAgfTtcblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgY291bnRWaXNpYmxlRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIG1ldGEuZGF0YS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKCFpc05hTih0aGlzLmdldFBhcnNlZChpbmRleCkucikgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVBbmdsZShpbmRleCwgbW9kZSwgZGVmYXVsdEFuZ2xlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpXG4gICAgICA/IHRvUmFkaWFucyh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpLmFuZ2xlIHx8IGRlZmF1bHRBbmdsZSlcbiAgICAgIDogMDtcbiAgfVxufVxuIiwgImltcG9ydCBEb3VnaG51dENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyLmRvdWdobnV0LmpzJztcblxuLy8gUGllIGNoYXJ0cyBhcmUgRG91Z2hudXQgY2hhcnQgd2l0aCBkaWZmZXJlbnQgZGVmYXVsdHNcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBpZUNvbnRyb2xsZXIgZXh0ZW5kcyBEb3VnaG51dENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdwaWUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC8vIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaGFydCB0aGF0IHdlIGN1dCBvdXQgb2YgdGhlIG1pZGRsZS5cbiAgICBjdXRvdXQ6IDAsXG5cbiAgICAvLyBUaGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0LCB3aGVyZSB0aGUgZmlyc3QgZGF0YSBhcmMgYmVnaW5zLlxuICAgIHJvdGF0aW9uOiAwLFxuXG4gICAgLy8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxuICAgIGNpcmN1bWZlcmVuY2U6IDM2MCxcblxuICAgIC8vIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNoYXJ0XG4gICAgcmFkaXVzOiAnMTAwJSdcbiAgfTtcbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7X3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdyYWRhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICAgIGluZGV4QXhpczogJ3InLFxuICAgIHNob3dMaW5lOiB0cnVlLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBsaW5lOiB7XG4gICAgICAgIGZpbGw6ICdzdGFydCdcbiAgICAgIH1cbiAgICB9LFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBhc3BlY3RSYXRpbzogMSxcblxuICAgIHNjYWxlczoge1xuICAgICAgcjoge1xuICAgICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCB2U2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IHZTY2FsZS5nZXRMYWJlbHMoKVtpbmRleF0sXG4gICAgICB2YWx1ZTogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKVxuICAgIH07XG4gIH1cblxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZS5iaW5kKHRoaXMpKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGxhYmVscyA9IG1ldGEuaVNjYWxlLmdldExhYmVscygpO1xuXG4gICAgLy8gVXBkYXRlIExpbmVcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICAvLyBJbiByZXNpemUgbW9kZSBvbmx5IHBvaW50IGxvY2F0aW9ucyBjaGFuZ2UsIHNvIG5vIG5lZWQgdG8gc2V0IHRoZSBwb2ludHMgb3Igb3B0aW9ucy5cbiAgICBpZiAobW9kZSAhPT0gJ3Jlc2l6ZScpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgX2xvb3A6IHRydWUsXG4gICAgICAgIF9mdWxsTG9vcDogbGFiZWxzLmxlbmd0aCA9PT0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIFBvaW50c1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB0aGlzLmdldFBhcnNlZChpKS5yKTtcblxuICAgICAgY29uc3QgeCA9IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueDtcbiAgICAgIGNvbnN0IHkgPSByZXNldCA/IHNjYWxlLnlDZW50ZXIgOiBwb2ludFBvc2l0aW9uLnk7XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGFuZ2xlOiBwb2ludFBvc2l0aW9uLmFuZ2xlLFxuICAgICAgICBza2lwOiBpc05hTih4KSB8fCBpc05hTih5KSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge2lzTnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzLCBfc2NhbGVSYW5nZXNDaGFuZ2VkfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NhdHRlckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3NjYXR0ZXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICAgIHNob3dMaW5lOiBmYWxzZSxcbiAgICBmaWxsOiBmYWxzZVxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcblxuICAgIGludGVyYWN0aW9uOiB7XG4gICAgICBtb2RlOiAncG9pbnQnXG4gICAgfSxcblxuICAgIHNjYWxlczoge1xuICAgICAgeDoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCB4ID0geFNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLngpO1xuICAgIGNvbnN0IHkgPSB5U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZTogJygnICsgeCArICcsICcgKyB5ICsgJyknXG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2RhdGE6IHBvaW50cyA9IFtdfSA9IG1ldGE7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG5cbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcblxuICAgIGlmIChfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMTEzMzNcbiAgICAgIGlmICghdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUpIHtcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50cygpO1xuICAgICAgfVxuICAgICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIF9kYXRhc2V0fSA9IG1ldGE7XG5cbiAgICAgIC8vIFVwZGF0ZSBMaW5lXG4gICAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICBsaW5lLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG5cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICBvcHRpb25zLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudDtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHtcbiAgICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0sIG1vZGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhc2V0RWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8xMTMzM1xuICAgICAgZGVsZXRlIG1ldGEuZGF0YXNldDtcbiAgICAgIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIFBvaW50c1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpO1xuICB9XG5cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3Qge3Nob3dMaW5lfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICghdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgJiYgc2hvd0xpbmUpIHtcbiAgICAgIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gdGhpcy5jaGFydC5yZWdpc3RyeS5nZXRFbGVtZW50KCdsaW5lJyk7XG4gICAgfVxuXG4gICAgc3VwZXIuYWRkRWxlbWVudHMoKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgX3N0YWNrZWQsIF9kYXRhc2V0fSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCB7c3BhbkdhcHMsIHNlZ21lbnR9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1heEdhcExlbmd0aCA9IGlzTnVtYmVyKHNwYW5HYXBzKSA/IHNwYW5HYXBzIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGNvbnN0IGRpcmVjdFVwZGF0ZSA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZCB8fCByZXNldCB8fCBtb2RlID09PSAnbm9uZSc7XG4gICAgbGV0IHByZXZQYXJzZWQgPSBzdGFydCA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoc3RhcnQgLSAxKTtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG5cbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChNYXRoLmFicyhwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGEgfHwgW107XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgbGV0IG1heCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF4ID4gMCAmJiBtYXg7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YXNldCA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBib3JkZXIgPSBkYXRhc2V0Lm9wdGlvbnMgJiYgZGF0YXNldC5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG5cbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYm9yZGVyO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cbn1cbiIsICIvKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuX2FkYXB0ZXJzXG4gKiBAc2luY2UgMi44LjBcbiAqIEBwcml2YXRlXG4gKi9cblxuaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0T3B0aW9uc30gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5leHBvcnQgdHlwZSBUaW1lVW5pdCA9ICdtaWxsaXNlY29uZCcgfCAnc2Vjb25kJyB8ICdtaW51dGUnIHwgJ2hvdXInIHwgJ2RheScgfCAnd2VlaycgfCAnbW9udGgnIHwgJ3F1YXJ0ZXInIHwgJ3llYXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVBZGFwdGVyPFQgZXh0ZW5kcyBBbnlPYmplY3QgPSBBbnlPYmplY3Q+IHtcbiAgcmVhZG9ubHkgb3B0aW9uczogVDtcbiAgLyoqXG4gICAqIFdpbGwgY2FsbGVkIHdpdGggY2hhcnQgb3B0aW9ucyBhZnRlciBhZGFwdGVyIGNyZWF0aW9uLlxuICAgKi9cbiAgaW5pdCh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgY2hhcnRPcHRpb25zOiBDaGFydE9wdGlvbnMpOiB2b2lkO1xuICAvKipcbiAgICogUmV0dXJucyBhIG1hcCBvZiB0aW1lIGZvcm1hdHMgZm9yIHRoZSBzdXBwb3J0ZWQgZm9ybWF0dGluZyB1bml0cyBkZWZpbmVkXG4gICAqIGluIFVuaXQgYXMgd2VsbCBhcyAnZGF0ZXRpbWUnIHJlcHJlc2VudGluZyBhIGRldGFpbGVkIGRhdGUvdGltZSBzdHJpbmcuXG4gICAqL1xuICBmb3JtYXRzKHRoaXM6IERhdGVBZGFwdGVyPFQ+KTogUmVjb3JkPFRpbWVVbml0IHwgJ2RhdGV0aW1lJywgc3RyaW5nPjtcbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZ2l2ZW4gYHZhbHVlYCBhbmQgcmV0dXJuIHRoZSBhc3NvY2lhdGVkIHRpbWVzdGFtcC5cbiAgICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlIHRvIHBhcnNlICh1c3VhbGx5IGNvbWVzIGZyb20gdGhlIGRhdGEpXG4gICAqIEBwYXJhbSBbZm9ybWF0XSAtIHRoZSBleHBlY3RlZCBkYXRhIGZvcm1hdFxuICAgKi9cbiAgcGFyc2UodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHZhbHVlOiB1bmtub3duLCBmb3JtYXQ/OiBzdHJpbmcpOiBudW1iZXIgfCBudWxsO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgZm9ybWF0dGVkIGRhdGUgaW4gdGhlIHNwZWNpZmllZCBgZm9ybWF0YCBmb3IgYSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSB0aW1lc3RhbXAgdG8gZm9ybWF0XG4gICAqIEBwYXJhbSBmb3JtYXQgLSB0aGUgZGF0ZS90aW1lIHRva2VuXG4gICAqL1xuICBmb3JtYXQodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCBmb3JtYXQ6IHN0cmluZyk6IHN0cmluZztcbiAgLyoqXG4gICAqIEFkZHMgdGhlIHNwZWNpZmllZCBgYW1vdW50YCBvZiBgdW5pdGAgdG8gdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuICAgKiBAcGFyYW0gYW1vdW50IC0gdGhlIGFtb3VudCB0byBhZGRcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICovXG4gIGFkZCh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdGltZXN0YW1wOiBudW1iZXIsIGFtb3VudDogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCk6IG51bWJlcjtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBgdW5pdGAgYmV0d2VlbiB0aGUgZ2l2ZW4gdGltZXN0YW1wcy5cbiAgICogQHBhcmFtIGEgLSB0aGUgaW5wdXQgdGltZXN0YW1wIChyZWZlcmVuY2UpXG4gICAqIEBwYXJhbSBiIC0gdGhlIHRpbWVzdGFtcCB0byBzdWJ0cmFjdFxuICAgKiBAcGFyYW0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuICAgKi9cbiAgZGlmZih0aGlzOiBEYXRlQWRhcHRlcjxUPiwgYTogbnVtYmVyLCBiOiBudW1iZXIsIHVuaXQ6IFRpbWVVbml0KTogbnVtYmVyO1xuICAvKipcbiAgICogUmV0dXJucyBzdGFydCBvZiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICogQHBhcmFtIFt3ZWVrZGF5XSAtIHRoZSBJU08gZGF5IG9mIHRoZSB3ZWVrIHdpdGggMSBiZWluZyBNb25kYXlcbiAgICogYW5kIDcgYmVpbmcgU3VuZGF5IChvbmx5IG5lZWRlZCBpZiBwYXJhbSAqdW5pdCogaXMgYGlzb1dlZWtgKS5cbiAgICovXG4gIHN0YXJ0T2YodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCB8ICdpc29XZWVrJywgd2Vla2RheT86IG51bWJlciB8IGJvb2xlYW4pOiBudW1iZXI7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGVuZCBvZiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICovXG4gIGVuZE9mKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgdW5pdDogVGltZVVuaXQpOiBudW1iZXI7XG59XG5cbmZ1bmN0aW9uIGFic3RyYWN0PFQgPSB2b2lkPigpOiBUIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQ6IENoZWNrIHRoYXQgYSBjb21wbGV0ZSBkYXRlIGFkYXB0ZXIgaXMgcHJvdmlkZWQuJyk7XG59XG5cbi8qKlxuICogRGF0ZSBhZGFwdGVyIChjdXJyZW50IHVzZWQgYnkgdGhlIHRpbWUgc2NhbGUpXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZVxuICogQG1lbWJlcm9mIENoYXJ0Ll9hZGFwdGVyc1xuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRGF0ZUFkYXB0ZXJCYXNlIGltcGxlbWVudHMgRGF0ZUFkYXB0ZXIge1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBkZWZhdWx0IGRhdGUgYWRhcHRlciBtZXRob2RzLlxuICAgKiBBY2NlcHRzIHR5cGUgcGFyYW1ldGVyIHRvIGRlZmluZSBvcHRpb25zIHR5cGUuXG4gICAqIEBleGFtcGxlXG4gICAqIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZS5vdmVycmlkZTx7bXlBZGFwdGVyT3B0aW9uOiBzdHJpbmd9Pih7XG4gICAqICAgaW5pdCgpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKHRoaXMub3B0aW9ucy5teUFkYXB0ZXJPcHRpb24pO1xuICAgKiAgIH1cbiAgICogfSlcbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZTxUIGV4dGVuZHMgQW55T2JqZWN0ID0gQW55T2JqZWN0PihcbiAgICBtZW1iZXJzOiBQYXJ0aWFsPE9taXQ8RGF0ZUFkYXB0ZXI8VD4sICdvcHRpb25zJz4+XG4gICkge1xuICAgIE9iamVjdC5hc3NpZ24oRGF0ZUFkYXB0ZXJCYXNlLnByb3RvdHlwZSwgbWVtYmVycyk7XG4gIH1cblxuICByZWFkb25seSBvcHRpb25zOiBBbnlPYmplY3Q7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucz86IEFueU9iamVjdCkge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gIGluaXQoKSB7fVxuXG4gIGZvcm1hdHMoKTogUmVjb3JkPFRpbWVVbml0IHwgJ2RhdGV0aW1lJywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBwYXJzZSgpOiBudW1iZXIgfCBudWxsIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIGZvcm1hdCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgYWRkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBkaWZmKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBzdGFydE9mKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBlbmRPZigpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX2RhdGU6IERhdGVBZGFwdGVyQmFzZSBhcyB7XG4gICAgbmV3IChvcHRpb25zPzogQW55T2JqZWN0KTogRGF0ZUFkYXB0ZXI7XG4gICAgb3ZlcnJpZGU8VCBleHRlbmRzIEFueU9iamVjdCA9IEFueU9iamVjdD4oXG4gICAgICBtZW1iZXJzOiBQYXJ0aWFsPE9taXQ8RGF0ZUFkYXB0ZXI8VD4sICdvcHRpb25zJz4+XG4gICAgKTogdm9pZDtcbiAgfVxufTtcbiIsICJpbXBvcnQge19sb29rdXBCeUtleSwgX3Jsb29rdXBCeUtleX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHtnZXRSZWxhdGl2ZVBvc2l0aW9ufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZG9tLmpzJztcbmltcG9ydCB7X2FuZ2xlQmV0d2VlbiwgZ2V0QW5nbGVGcm9tUG9pbnR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2lzUG9pbnRJbkFyZWEsIGlzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqIEB0eXBlZGVmIHt7YXhpcz86IHN0cmluZywgaW50ZXJzZWN0PzogYm9vbGVhbiwgaW5jbHVkZUludmlzaWJsZT86IGJvb2xlYW59fSBJbnRlcmFjdGlvbk9wdGlvbnNcbiAqIEB0eXBlZGVmIHt7ZGF0YXNldEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXIsIGVsZW1lbnQ6IGltcG9ydCgnLi9jb3JlLmVsZW1lbnQuanMnKS5kZWZhdWx0fX0gSW50ZXJhY3Rpb25JdGVtXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5Qb2ludCB9IFBvaW50XG4gKi9cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZG8gYmluYXJ5IHNlYXJjaCB3aGVuIHBvc3NpYmxlXG4gKiBAcGFyYW0ge29iamVjdH0gbWV0YXNldCAtIHRoZSBkYXRhc2V0IG1ldGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBmaW5kXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gc2hvdWxkIHRoZSBlbGVtZW50IGludGVyc2VjdFxuICogQHJldHVybnMge3tsbzpudW1iZXIsIGhpOm51bWJlcn19IGluZGljZXMgdG8gc2VhcmNoIGRhdGEgYXJyYXkgYmV0d2VlblxuICovXG5mdW5jdGlvbiBiaW5hcnlTZWFyY2gobWV0YXNldCwgYXhpcywgdmFsdWUsIGludGVyc2VjdCkge1xuICBjb25zdCB7Y29udHJvbGxlciwgZGF0YSwgX3NvcnRlZH0gPSBtZXRhc2V0O1xuICBjb25zdCBpU2NhbGUgPSBjb250cm9sbGVyLl9jYWNoZWRNZXRhLmlTY2FsZTtcbiAgY29uc3Qgc3BhbkdhcHMgPSBtZXRhc2V0LmRhdGFzZXQgPyBtZXRhc2V0LmRhdGFzZXQub3B0aW9ucyA/IG1ldGFzZXQuZGF0YXNldC5vcHRpb25zLnNwYW5HYXBzIDogbnVsbCA6IG51bGw7XG5cbiAgaWYgKGlTY2FsZSAmJiBheGlzID09PSBpU2NhbGUuYXhpcyAmJiBheGlzICE9PSAncicgJiYgX3NvcnRlZCAmJiBkYXRhLmxlbmd0aCkge1xuICAgIGNvbnN0IGxvb2t1cE1ldGhvZCA9IGlTY2FsZS5fcmV2ZXJzZVBpeGVscyA/IF9ybG9va3VwQnlLZXkgOiBfbG9va3VwQnlLZXk7XG4gICAgaWYgKCFpbnRlcnNlY3QpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSk7XG4gICAgICBpZiAoc3BhbkdhcHMpIHtcbiAgICAgICAgY29uc3Qge3ZTY2FsZX0gPSBjb250cm9sbGVyLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCB7X3BhcnNlZH0gPSBtZXRhc2V0O1xuXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlVG9EZWZpbmVkTG8gPSAoX3BhcnNlZFxuICAgICAgICAgIC5zbGljZSgwLCByZXN1bHQubG8gKyAxKVxuICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAuZmluZEluZGV4KFxuICAgICAgICAgICAgcG9pbnQgPT4gIWlzTnVsbE9yVW5kZWYocG9pbnRbdlNjYWxlLmF4aXNdKSkpO1xuICAgICAgICByZXN1bHQubG8gLT0gTWF0aC5tYXgoMCwgZGlzdGFuY2VUb0RlZmluZWRMbyk7XG5cbiAgICAgICAgY29uc3QgZGlzdGFuY2VUb0RlZmluZWRIaSA9IChfcGFyc2VkXG4gICAgICAgICAgLnNsaWNlKHJlc3VsdC5oaSlcbiAgICAgICAgICAuZmluZEluZGV4KFxuICAgICAgICAgICAgcG9pbnQgPT4gIWlzTnVsbE9yVW5kZWYocG9pbnRbdlNjYWxlLmF4aXNdKSkpO1xuICAgICAgICByZXN1bHQuaGkgKz0gTWF0aC5tYXgoMCwgZGlzdGFuY2VUb0RlZmluZWRIaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlci5fc2hhcmVkT3B0aW9ucykge1xuICAgICAgLy8gX3NoYXJlZE9wdGlvbnMgaW5kaWNhdGVzIHRoYXQgZWFjaCBlbGVtZW50IGhhcyBlcXVhbCBvcHRpb25zIC0+IGVxdWFsIHByb3BvcnRpb25zXG4gICAgICAvLyBTbyB3ZSBjYW4gZG8gYSByYW5nZWQgYmluYXJ5IHNlYXJjaCBiYXNlZCBvbiB0aGUgcmFuZ2Ugb2YgZmlyc3QgZWxlbWVudCBhbmRcbiAgICAgIC8vIGJlIGNvbmZpZGVudCB0byBnZXQgdGhlIGZ1bGwgcmFuZ2Ugb2YgaW5kaWNlcyB0aGF0IGNhbiBpbnRlcnNlY3Qgd2l0aCB0aGUgdmFsdWUuXG4gICAgICBjb25zdCBlbCA9IGRhdGFbMF07XG4gICAgICBjb25zdCByYW5nZSA9IHR5cGVvZiBlbC5nZXRSYW5nZSA9PT0gJ2Z1bmN0aW9uJyAmJiBlbC5nZXRSYW5nZShheGlzKTtcbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSAtIHJhbmdlKTtcbiAgICAgICAgY29uc3QgZW5kID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlICsgcmFuZ2UpO1xuICAgICAgICByZXR1cm4ge2xvOiBzdGFydC5sbywgaGk6IGVuZC5oaX07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIERlZmF1bHQgdG8gYWxsIGVsZW1lbnRzLCB3aGVuIGJpbmFyeSBzZWFyY2ggY2FuIG5vdCBiZSB1c2VkLlxuICByZXR1cm4ge2xvOiAwLCBoaTogZGF0YS5sZW5ndGggLSAxfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gc2VsZWN0IGNhbmRpZGF0ZSBlbGVtZW50cyBmb3IgaW50ZXJhY3Rpb25cbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0XG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIHRoZSBjYWxsYmFjayB0byBleGVjdXRlIGZvciBlYWNoIHZpc2libGUgaXRlbVxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIGNvbnNpZGVyIGludGVyc2VjdGluZyBpdGVtc1xuICovXG5mdW5jdGlvbiBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBoYW5kbGVyLCBpbnRlcnNlY3QpIHtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bYXhpc107XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3Qge2luZGV4LCBkYXRhfSA9IG1ldGFzZXRzW2ldO1xuICAgIGNvbnN0IHtsbywgaGl9ID0gYmluYXJ5U2VhcmNoKG1ldGFzZXRzW2ldLCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KTtcbiAgICBmb3IgKGxldCBqID0gbG87IGogPD0gaGk7ICsraikge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGRhdGFbal07XG4gICAgICBpZiAoIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICBoYW5kbGVyKGVsZW1lbnQsIGluZGV4LCBqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYSBkaXN0YW5jZSBtZXRyaWMgZnVuY3Rpb24gZm9yIHR3byBwb2ludHMgYmFzZWQgb24gdGhlXG4gKiBheGlzIG1vZGUgc2V0dGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHl8clxuICovXG5mdW5jdGlvbiBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcykge1xuICBjb25zdCB1c2VYID0gYXhpcy5pbmRleE9mKCd4JykgIT09IC0xO1xuICBjb25zdCB1c2VZID0gYXhpcy5pbmRleE9mKCd5JykgIT09IC0xO1xuXG4gIHJldHVybiBmdW5jdGlvbihwdDEsIHB0Mikge1xuICAgIGNvbnN0IGRlbHRhWCA9IHVzZVggPyBNYXRoLmFicyhwdDEueCAtIHB0Mi54KSA6IDA7XG4gICAgY29uc3QgZGVsdGFZID0gdXNlWSA/IE1hdGguYWJzKHB0MS55IC0gcHQyLnkpIDogMDtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRlbHRhWCwgMikgKyBNYXRoLnBvdyhkZWx0YVksIDIpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgZXZlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0XG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHl8clxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUludmlzaWJsZV0gLSBpbmNsdWRlIGludmlzaWJsZSBwb2ludHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgY2hhcnQgYXJlYVxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuXG4gIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhY2hhcnQuaXNQb2ludEluQXJlYShwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICBjb25zdCBldmFsdWF0aW9uRnVuYyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIV9pc1BvaW50SW5BcmVhKGVsZW1lbnQsIGNoYXJ0LmNoYXJ0QXJlYSwgMCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfTtcblxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYywgdHJ1ZSk7XG4gIHJldHVybiBpdGVtcztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvbiBmb3IgYSByYWRpYWwgY2hhcnRcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4ZXMgYWxvbmcgd2hpY2ggdG8gbWVhc3VyZSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgbGV0IGl0ZW1zID0gW107XG5cbiAgZnVuY3Rpb24gZXZhbHVhdGlvbkZ1bmMoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZX0gPSBlbGVtZW50LmdldFByb3BzKFsnc3RhcnRBbmdsZScsICdlbmRBbmdsZSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7YW5nbGV9ID0gZ2V0QW5nbGVGcm9tUG9pbnQoZWxlbWVudCwge3g6IHBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnl9KTtcblxuICAgIGlmIChfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH1cblxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XG4gIHJldHVybiBpdGVtcztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvbiBmb3IgYSBjYXJ0ZXNpYW4gY2hhcnRcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4ZXMgYWxvbmcgd2hpY2ggdG8gbWVhc3VyZSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIGlmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSW52aXNpYmxlXSAtIGluY2x1ZGUgaW52aXNpYmxlIHBvaW50cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBjaGFydCBhcmVhXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGxldCBpdGVtcyA9IFtdO1xuICBjb25zdCBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKTtcbiAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCBpblJhbmdlID0gZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGlmIChpbnRlcnNlY3QgJiYgIWluUmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjZW50ZXIgPSBlbGVtZW50LmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHBvaW50SW5BcmVhID0gISFpbmNsdWRlSW52aXNpYmxlIHx8IGNoYXJ0LmlzUG9pbnRJbkFyZWEoY2VudGVyKTtcbiAgICBpZiAoIXBvaW50SW5BcmVhICYmICFpblJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlzdGFuY2UgPSBkaXN0YW5jZU1ldHJpYyhwb3NpdGlvbiwgY2VudGVyKTtcbiAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgaXRlbXMgPSBbe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9XTtcbiAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcbiAgICAgIC8vIENhbiBoYXZlIG11bHRpcGxlIGl0ZW1zIGF0IHRoZSBzYW1lIGRpc3RhbmNlIGluIHdoaWNoIGNhc2Ugd2Ugc29ydCBieSBzaXplXG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gY29uc2lkZXJpbmcgYWxsIHZpc2libGUgaXRlbXMgaW4gdGhlIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGVzIGFsb25nIHdoaWNoIHRvIG1lYXN1cmUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUludmlzaWJsZV0gLSBpbmNsdWRlIGludmlzaWJsZSBwb2ludHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgY2hhcnQgYXJlYVxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIWNoYXJ0LmlzUG9pbnRJbkFyZWEocG9zaXRpb24pKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIGF4aXMgPT09ICdyJyAmJiAhaW50ZXJzZWN0XG4gICAgPyBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKVxuICAgIDogZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBtYXRjaGluZyBhbG9uZyB0aGUgZ2l2ZW4gWCBvciBZIGF4aXNcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBjb25zdCByYW5nZU1ldGhvZCA9IGF4aXMgPT09ICd4JyA/ICdpblhSYW5nZScgOiAnaW5ZUmFuZ2UnO1xuICBsZXQgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcblxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCAoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkgPT4ge1xuICAgIGlmIChlbGVtZW50W3JhbmdlTWV0aG9kXSAmJiBlbGVtZW50W3JhbmdlTWV0aG9kXShwb3NpdGlvbltheGlzXSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICAgIGludGVyc2VjdHNJdGVtID0gaW50ZXJzZWN0c0l0ZW0gfHwgZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSWYgd2Ugd2FudCB0byB0cmlnZ2VyIG9uIGFuIGludGVyc2VjdCBhbmQgd2UgZG9uJ3QgaGF2ZSBhbnkgaXRlbXNcbiAgLy8gdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uLCByZXR1cm4gbm90aGluZ1xuICBpZiAoaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG5cbi8qKlxuICogQ29udGFpbnMgaW50ZXJhY3Rpb24gcmVsYXRlZCBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuSW50ZXJhY3Rpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvLyBQYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIHRvIGZhY2lsaXRhdGUgZGV2ZWxvcGVycyBjcmVhdGluZyB0aGVpciBvd24gbW9kZXNcbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zLFxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgZGlmZmVyZW50IG1vZGVzXG4gIG1vZGVzOiB7XG4gICAgLyoqXG5cdFx0ICogUmV0dXJucyBpdGVtcyBhdCB0aGUgc2FtZSBpbmRleC4gSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IHBhcmFtZXRlciBpcyB0cnVlLCB3ZSBvbmx5IHJldHVybiBpdGVtcyBpZiB3ZSBpbnRlcnNlY3Qgc29tZXRoaW5nXG5cdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IG1vZGUgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBhdCB0aGUgc2FtZSBpbmRleCBhcyB0aGF0IGl0ZW1cblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW5kZXhcblx0XHQgKiBAc2luY2UgdjIuNC4wXG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIGluZGV4KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgLy8gRGVmYXVsdCBheGlzIGZvciBpbmRleCBtb2RlIGlzICd4JyB0byBtYXRjaCBvbGQgYmVoYXZpb3VyXG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICBjb25zdCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKVxuICAgICAgICA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG5cbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmZvckVhY2goKG1ldGEpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpdGVtc1swXS5pbmRleDtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IG1ldGEuZGF0YVtpbmRleF07XG5cbiAgICAgICAgLy8gZG9uJ3QgY291bnQgaXRlbXMgdGhhdCBhcmUgc2tpcHBlZCAobnVsbCBkYXRhKVxuICAgICAgICBpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5za2lwKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4LCBpbmRleH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGluIHRoZSBzYW1lIGRhdGFzZXQuIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGluIHRoYXQgZGF0YXNldFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5kYXRhc2V0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIGRhdGFzZXQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgbGV0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIDpcbiAgICAgICAgZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuXG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0SW5kZXggPSBpdGVtc1swXS5kYXRhc2V0SW5kZXg7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmRhdGE7XG4gICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQ6IGRhdGFbaV0sIGRhdGFzZXRJbmRleCwgaW5kZXg6IGl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIFBvaW50IG1vZGUgcmV0dXJucyBhbGwgZWxlbWVudHMgdGhhdCBoaXQgdGVzdCBiYXNlZCBvbiB0aGUgZXZlbnQgcG9zaXRpb25cblx0XHQgKiBvZiB0aGUgZXZlbnRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIHBvaW50KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIHJldHVybiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiBuZWFyZXN0IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudCBjbG9zZXN0IHRvIHRoZSBwb2ludFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3Rcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgbmVhcmVzdChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiB4IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB4IGNvb3JkaW5hdGVcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICB4KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sICd4Jywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiB5IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB5IGNvb3JkaW5hdGVcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueVxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICB5KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sICd5Jywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgfVxufTtcbiIsICJpbXBvcnQge2RlZmluZWQsIGVhY2gsIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvUGFkZGluZ30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbmNvbnN0IFNUQVRJQ19QT1NJVElPTlMgPSBbJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xuXG5mdW5jdGlvbiBmaWx0ZXJCeVBvc2l0aW9uKGFycmF5LCBwb3NpdGlvbikge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gdi5wb3MgPT09IHBvc2l0aW9uKTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGFycmF5LCBheGlzKSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiBTVEFUSUNfUE9TSVRJT05TLmluZGV4T2Yodi5wb3MpID09PSAtMSAmJiB2LmJveC5heGlzID09PSBheGlzKTtcbn1cblxuZnVuY3Rpb24gc29ydEJ5V2VpZ2h0KGFycmF5LCByZXZlcnNlKSB7XG4gIHJldHVybiBhcnJheS5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgdjAgPSByZXZlcnNlID8gYiA6IGE7XG4gICAgY29uc3QgdjEgPSByZXZlcnNlID8gYSA6IGI7XG4gICAgcmV0dXJuIHYwLndlaWdodCA9PT0gdjEud2VpZ2h0ID9cbiAgICAgIHYwLmluZGV4IC0gdjEuaW5kZXggOlxuICAgICAgdjAud2VpZ2h0IC0gdjEud2VpZ2h0O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gd3JhcEJveGVzKGJveGVzKSB7XG4gIGNvbnN0IGxheW91dEJveGVzID0gW107XG4gIGxldCBpLCBpbGVuLCBib3gsIHBvcywgc3RhY2ssIHN0YWNrV2VpZ2h0O1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSAoYm94ZXMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGJveCA9IGJveGVzW2ldO1xuICAgICh7cG9zaXRpb246IHBvcywgb3B0aW9uczoge3N0YWNrLCBzdGFja1dlaWdodCA9IDF9fSA9IGJveCk7XG4gICAgbGF5b3V0Qm94ZXMucHVzaCh7XG4gICAgICBpbmRleDogaSxcbiAgICAgIGJveCxcbiAgICAgIHBvcyxcbiAgICAgIGhvcml6b250YWw6IGJveC5pc0hvcml6b250YWwoKSxcbiAgICAgIHdlaWdodDogYm94LndlaWdodCxcbiAgICAgIHN0YWNrOiBzdGFjayAmJiAocG9zICsgc3RhY2spLFxuICAgICAgc3RhY2tXZWlnaHRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbGF5b3V0Qm94ZXM7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU3RhY2tzKGxheW91dHMpIHtcbiAgY29uc3Qgc3RhY2tzID0ge307XG4gIGZvciAoY29uc3Qgd3JhcCBvZiBsYXlvdXRzKSB7XG4gICAgY29uc3Qge3N0YWNrLCBwb3MsIHN0YWNrV2VpZ2h0fSA9IHdyYXA7XG4gICAgaWYgKCFzdGFjayB8fCAhU1RBVElDX1BPU0lUSU9OUy5pbmNsdWRlcyhwb3MpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgX3N0YWNrID0gc3RhY2tzW3N0YWNrXSB8fCAoc3RhY2tzW3N0YWNrXSA9IHtjb3VudDogMCwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDAsIHNpemU6IDB9KTtcbiAgICBfc3RhY2suY291bnQrKztcbiAgICBfc3RhY2sud2VpZ2h0ICs9IHN0YWNrV2VpZ2h0O1xuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5cbi8qKlxuICogc3RvcmUgZGltZW5zaW9ucyB1c2VkIGluc3RlYWQgb2YgYXZhaWxhYmxlIGNoYXJ0QXJlYSBpbiBmaXRCb3hlc1xuICoqL1xuZnVuY3Rpb24gc2V0TGF5b3V0RGltcyhsYXlvdXRzLCBwYXJhbXMpIHtcbiAgY29uc3Qgc3RhY2tzID0gYnVpbGRTdGFja3MobGF5b3V0cyk7XG4gIGNvbnN0IHt2Qm94TWF4V2lkdGgsIGhCb3hNYXhIZWlnaHR9ID0gcGFyYW1zO1xuICBsZXQgaSwgaWxlbiwgbGF5b3V0O1xuICBmb3IgKGkgPSAwLCBpbGVuID0gbGF5b3V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBsYXlvdXRzW2ldO1xuICAgIGNvbnN0IHtmdWxsU2l6ZX0gPSBsYXlvdXQuYm94O1xuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja107XG4gICAgY29uc3QgZmFjdG9yID0gc3RhY2sgJiYgbGF5b3V0LnN0YWNrV2VpZ2h0IC8gc3RhY2sud2VpZ2h0O1xuICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xuICAgICAgbGF5b3V0LndpZHRoID0gZmFjdG9yID8gZmFjdG9yICogdkJveE1heFdpZHRoIDogZnVsbFNpemUgJiYgcGFyYW1zLmF2YWlsYWJsZVdpZHRoO1xuICAgICAgbGF5b3V0LmhlaWdodCA9IGhCb3hNYXhIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheW91dC53aWR0aCA9IHZCb3hNYXhXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBmYWN0b3IgPyBmYWN0b3IgKiBoQm94TWF4SGVpZ2h0IDogZnVsbFNpemUgJiYgcGFyYW1zLmF2YWlsYWJsZUhlaWdodDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YWNrcztcbn1cblxuZnVuY3Rpb24gYnVpbGRMYXlvdXRCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IHdyYXBCb3hlcyhib3hlcyk7XG4gIGNvbnN0IGZ1bGxTaXplID0gc29ydEJ5V2VpZ2h0KGxheW91dEJveGVzLmZpbHRlcih3cmFwID0+IHdyYXAuYm94LmZ1bGxTaXplKSwgdHJ1ZSk7XG4gIGNvbnN0IGxlZnQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2xlZnQnKSwgdHJ1ZSk7XG4gIGNvbnN0IHJpZ2h0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdyaWdodCcpKTtcbiAgY29uc3QgdG9wID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICd0b3AnKSwgdHJ1ZSk7XG4gIGNvbnN0IGJvdHRvbSA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnYm90dG9tJykpO1xuICBjb25zdCBjZW50ZXJIb3Jpem9udGFsID0gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGxheW91dEJveGVzLCAneCcpO1xuICBjb25zdCBjZW50ZXJWZXJ0aWNhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3knKTtcblxuICByZXR1cm4ge1xuICAgIGZ1bGxTaXplLFxuICAgIGxlZnRBbmRUb3A6IGxlZnQuY29uY2F0KHRvcCksXG4gICAgcmlnaHRBbmRCb3R0b206IHJpZ2h0LmNvbmNhdChjZW50ZXJWZXJ0aWNhbCkuY29uY2F0KGJvdHRvbSkuY29uY2F0KGNlbnRlckhvcml6b250YWwpLFxuICAgIGNoYXJ0QXJlYTogZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2NoYXJ0QXJlYScpLFxuICAgIHZlcnRpY2FsOiBsZWZ0LmNvbmNhdChyaWdodCkuY29uY2F0KGNlbnRlclZlcnRpY2FsKSxcbiAgICBob3Jpem9udGFsOiB0b3AuY29uY2F0KGJvdHRvbSkuY29uY2F0KGNlbnRlckhvcml6b250YWwpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgYSwgYikge1xuICByZXR1cm4gTWF0aC5tYXgobWF4UGFkZGluZ1thXSwgY2hhcnRBcmVhW2FdKSArIE1hdGgubWF4KG1heFBhZGRpbmdbYl0sIGNoYXJ0QXJlYVtiXSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94UGFkZGluZykge1xuICBtYXhQYWRkaW5nLnRvcCA9IE1hdGgubWF4KG1heFBhZGRpbmcudG9wLCBib3hQYWRkaW5nLnRvcCk7XG4gIG1heFBhZGRpbmcubGVmdCA9IE1hdGgubWF4KG1heFBhZGRpbmcubGVmdCwgYm94UGFkZGluZy5sZWZ0KTtcbiAgbWF4UGFkZGluZy5ib3R0b20gPSBNYXRoLm1heChtYXhQYWRkaW5nLmJvdHRvbSwgYm94UGFkZGluZy5ib3R0b20pO1xuICBtYXhQYWRkaW5nLnJpZ2h0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5yaWdodCwgYm94UGFkZGluZy5yaWdodCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKSB7XG4gIGNvbnN0IHtwb3MsIGJveH0gPSBsYXlvdXQ7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuICAvLyBkeW5hbWljYWxseSBwbGFjZWQgYm94ZXMgc2l6ZSBpcyBub3QgY29uc2lkZXJlZFxuICBpZiAoIWlzT2JqZWN0KHBvcykpIHtcbiAgICBpZiAobGF5b3V0LnNpemUpIHtcbiAgICAgIC8vIHRoaXMgbGF5b3V0IHdhcyBhbHJlYWR5IGNvdW50ZWQgZm9yLCBsZXRzIGZpcnN0IHJlZHVjZSBvbGQgc2l6ZVxuICAgICAgY2hhcnRBcmVhW3Bvc10gLT0gbGF5b3V0LnNpemU7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge3NpemU6IDAsIGNvdW50OiAxfTtcbiAgICBzdGFjay5zaXplID0gTWF0aC5tYXgoc3RhY2suc2l6ZSwgbGF5b3V0Lmhvcml6b250YWwgPyBib3guaGVpZ2h0IDogYm94LndpZHRoKTtcbiAgICBsYXlvdXQuc2l6ZSA9IHN0YWNrLnNpemUgLyBzdGFjay5jb3VudDtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBsYXlvdXQuc2l6ZTtcbiAgfVxuXG4gIGlmIChib3guZ2V0UGFkZGluZykge1xuICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94LmdldFBhZGRpbmcoKSk7XG4gIH1cblxuICBjb25zdCBuZXdXaWR0aCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlcldpZHRoIC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAnbGVmdCcsICdyaWdodCcpKTtcbiAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAndG9wJywgJ2JvdHRvbScpKTtcbiAgY29uc3Qgd2lkdGhDaGFuZ2VkID0gbmV3V2lkdGggIT09IGNoYXJ0QXJlYS53O1xuICBjb25zdCBoZWlnaHRDaGFuZ2VkID0gbmV3SGVpZ2h0ICE9PSBjaGFydEFyZWEuaDtcbiAgY2hhcnRBcmVhLncgPSBuZXdXaWR0aDtcbiAgY2hhcnRBcmVhLmggPSBuZXdIZWlnaHQ7XG5cbiAgLy8gcmV0dXJuIGJvb2xlYW5zIG9uIHRoZSBjaGFuZ2VzIHBlciBkaXJlY3Rpb25cbiAgcmV0dXJuIGxheW91dC5ob3Jpem9udGFsXG4gICAgPyB7c2FtZTogd2lkdGhDaGFuZ2VkLCBvdGhlcjogaGVpZ2h0Q2hhbmdlZH1cbiAgICA6IHtzYW1lOiBoZWlnaHRDaGFuZ2VkLCBvdGhlcjogd2lkdGhDaGFuZ2VkfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpIHtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcyhwb3MpIHtcbiAgICBjb25zdCBjaGFuZ2UgPSBNYXRoLm1heChtYXhQYWRkaW5nW3Bvc10gLSBjaGFydEFyZWFbcG9zXSwgMCk7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gY2hhbmdlO1xuICAgIHJldHVybiBjaGFuZ2U7XG4gIH1cbiAgY2hhcnRBcmVhLnkgKz0gdXBkYXRlUG9zKCd0b3AnKTtcbiAgY2hhcnRBcmVhLnggKz0gdXBkYXRlUG9zKCdsZWZ0Jyk7XG4gIHVwZGF0ZVBvcygncmlnaHQnKTtcbiAgdXBkYXRlUG9zKCdib3R0b20nKTtcbn1cblxuZnVuY3Rpb24gZ2V0TWFyZ2lucyhob3Jpem9udGFsLCBjaGFydEFyZWEpIHtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuXG4gIGZ1bmN0aW9uIG1hcmdpbkZvclBvc2l0aW9ucyhwb3NpdGlvbnMpIHtcbiAgICBjb25zdCBtYXJnaW4gPSB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfTtcbiAgICBwb3NpdGlvbnMuZm9yRWFjaCgocG9zKSA9PiB7XG4gICAgICBtYXJnaW5bcG9zXSA9IE1hdGgubWF4KGNoYXJ0QXJlYVtwb3NdLCBtYXhQYWRkaW5nW3Bvc10pO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXJnaW47XG4gIH1cblxuICByZXR1cm4gaG9yaXpvbnRhbFxuICAgID8gbWFyZ2luRm9yUG9zaXRpb25zKFsnbGVmdCcsICdyaWdodCddKVxuICAgIDogbWFyZ2luRm9yUG9zaXRpb25zKFsndG9wJywgJ2JvdHRvbSddKTtcbn1cblxuZnVuY3Rpb24gZml0Qm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgcmVmaXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgbGF5b3V0LCBib3gsIHJlZml0LCBjaGFuZ2VkO1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBib3hlcy5sZW5ndGgsIHJlZml0ID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxheW91dCA9IGJveGVzW2ldO1xuICAgIGJveCA9IGxheW91dC5ib3g7XG5cbiAgICBib3gudXBkYXRlKFxuICAgICAgbGF5b3V0LndpZHRoIHx8IGNoYXJ0QXJlYS53LFxuICAgICAgbGF5b3V0LmhlaWdodCB8fCBjaGFydEFyZWEuaCxcbiAgICAgIGdldE1hcmdpbnMobGF5b3V0Lmhvcml6b250YWwsIGNoYXJ0QXJlYSlcbiAgICApO1xuICAgIGNvbnN0IHtzYW1lLCBvdGhlcn0gPSB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcyk7XG5cbiAgICAvLyBEaW1lbnNpb25zIGNoYW5nZWQgYW5kIHRoZXJlIHdlcmUgbm9uIGZ1bGwgd2lkdGggYm94ZXMgYmVmb3JlIHRoaXNcbiAgICAvLyAtPiB3ZSBoYXZlIHRvIHJlZml0IHRob3NlXG4gICAgcmVmaXQgfD0gc2FtZSAmJiByZWZpdEJveGVzLmxlbmd0aDtcblxuICAgIC8vIENoYXJ0IGFyZWEgY2hhbmdlZCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgb3RoZXI7XG5cbiAgICBpZiAoIWJveC5mdWxsU2l6ZSkgeyAvLyBmdWxsU2l6ZSBib3hlcyBkb24ndCBuZWVkIHRvIGJlIHJlLWZpdHRlZCBpbiBhbnkgY2FzZVxuICAgICAgcmVmaXRCb3hlcy5wdXNoKGxheW91dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlZml0ICYmIGZpdEJveGVzKHJlZml0Qm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHx8IGNoYW5nZWQ7XG59XG5cbmZ1bmN0aW9uIHNldEJveERpbXMoYm94LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgYm94LnRvcCA9IHRvcDtcbiAgYm94LmxlZnQgPSBsZWZ0O1xuICBib3gucmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gIGJveC5ib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gIGJveC53aWR0aCA9IHdpZHRoO1xuICBib3guaGVpZ2h0ID0gaGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBwbGFjZUJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHVzZXJQYWRkaW5nID0gcGFyYW1zLnBhZGRpbmc7XG4gIGxldCB7eCwgeX0gPSBjaGFydEFyZWE7XG5cbiAgZm9yIChjb25zdCBsYXlvdXQgb2YgYm94ZXMpIHtcbiAgICBjb25zdCBib3ggPSBsYXlvdXQuYm94O1xuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge2NvdW50OiAxLCBwbGFjZWQ6IDAsIHdlaWdodDogMX07XG4gICAgY29uc3Qgd2VpZ2h0ID0gKGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodCkgfHwgMTtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gY2hhcnRBcmVhLncgKiB3ZWlnaHQ7XG4gICAgICBjb25zdCBoZWlnaHQgPSBzdGFjay5zaXplIHx8IGJveC5oZWlnaHQ7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeSA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgdXNlclBhZGRpbmcubGVmdCwgeSwgcGFyYW1zLm91dGVyV2lkdGggLSB1c2VyUGFkZGluZy5yaWdodCAtIHVzZXJQYWRkaW5nLmxlZnQsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgY2hhcnRBcmVhLmxlZnQgKyBzdGFjay5wbGFjZWQsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgc3RhY2suc3RhcnQgPSB5O1xuICAgICAgc3RhY2sucGxhY2VkICs9IHdpZHRoO1xuICAgICAgeSA9IGJveC5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGNoYXJ0QXJlYS5oICogd2VpZ2h0O1xuICAgICAgY29uc3Qgd2lkdGggPSBzdGFjay5zaXplIHx8IGJveC53aWR0aDtcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICB4ID0gc3RhY2suc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCB1c2VyUGFkZGluZy50b3AsIHdpZHRoLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSB1c2VyUGFkZGluZy5ib3R0b20gLSB1c2VyUGFkZGluZy50b3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIGNoYXJ0QXJlYS50b3AgKyBzdGFjay5wbGFjZWQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgc3RhY2suc3RhcnQgPSB4O1xuICAgICAgc3RhY2sucGxhY2VkICs9IGhlaWdodDtcbiAgICAgIHggPSBib3gucmlnaHQ7XG4gICAgfVxuICB9XG5cbiAgY2hhcnRBcmVhLnggPSB4O1xuICBjaGFydEFyZWEueSA9IHk7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBMYXlvdXRJdGVtXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBMYXlvdXRJdGVtXG4gKiBAcHJvcCB7c3RyaW5nfSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBpbiB0aGUgY2hhcnQgbGF5b3V0LiBQb3NzaWJsZSB2YWx1ZXMgYXJlXG4gKiAnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgYW5kICdjaGFydEFyZWEnXG4gKiBAcHJvcCB7bnVtYmVyfSB3ZWlnaHQgLSBUaGUgd2VpZ2h0IHVzZWQgdG8gc29ydCB0aGUgaXRlbS4gSGlnaGVyIHdlaWdodHMgYXJlIGZ1cnRoZXIgYXdheSBmcm9tIHRoZSBjaGFydCBhcmVhXG4gKiBAcHJvcCB7Ym9vbGVhbn0gZnVsbFNpemUgLSBpZiB0cnVlLCBhbmQgdGhlIGl0ZW0gaXMgaG9yaXpvbnRhbCwgdGhlbiBwdXNoIHZlcnRpY2FsIGJveGVzIGRvd25cbiAqIEBwcm9wIHtmdW5jdGlvbn0gaXNIb3Jpem9udGFsIC0gcmV0dXJucyB0cnVlIGlmIHRoZSBsYXlvdXQgaXRlbSBpcyBob3Jpem9udGFsIChpZS4gdG9wIG9yIGJvdHRvbSlcbiAqIEBwcm9wIHtmdW5jdGlvbn0gdXBkYXRlIC0gVGFrZXMgdHdvIHBhcmFtZXRlcnM6IHdpZHRoIGFuZCBoZWlnaHQuIFJldHVybnMgc2l6ZSBvZiBpdGVtXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGRyYXcgLSBEcmF3cyB0aGUgZWxlbWVudFxuICogQHByb3Age2Z1bmN0aW9ufSBbZ2V0UGFkZGluZ10gLSAgUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBwYWRkaW5nIG9uIHRoZSBlZGdlc1xuICogQHByb3Age251bWJlcn0gd2lkdGggLSBXaWR0aCBvZiBpdGVtLiBNdXN0IGJlIHZhbGlkIGFmdGVyIHVwZGF0ZSgpXG4gKiBAcHJvcCB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxuICogQHByb3Age251bWJlcn0gbGVmdCAtIExlZnQgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICogQHByb3Age251bWJlcn0gdG9wIC0gVG9wIGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IHJpZ2h0IC0gUmlnaHQgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICogQHByb3Age251bWJlcn0gYm90dG9tIC0gQm90dG9tIGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqL1xuXG4vLyBUaGUgbGF5b3V0IHNlcnZpY2UgaXMgdmVyeSBzZWxmIGV4cGxhbmF0b3J5LiAgSXQncyByZXNwb25zaWJsZSBmb3IgdGhlIGxheW91dCB3aXRoaW4gYSBjaGFydC5cbi8vIFNjYWxlcywgTGVnZW5kcyBhbmQgUGx1Z2lucyBhbGwgcmVseSBvbiB0aGUgbGF5b3V0IHNlcnZpY2UgYW5kIGNhbiBlYXNpbHkgcmVnaXN0ZXIgdG8gYmUgcGxhY2VkIGFueXdoZXJlIHRoZXkgbmVlZFxuLy8gSXQgaXMgdGhpcyBzZXJ2aWNlJ3MgcmVzcG9uc2liaWxpdHkgb2YgY2Fycnlpbmcgb3V0IHRoYXQgbGF5b3V0LlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gIC8qKlxuXHQgKiBSZWdpc3RlciBhIGJveCB0byBhIGNoYXJ0LlxuXHQgKiBBIGJveCBpcyBzaW1wbHkgYSByZWZlcmVuY2UgdG8gYW4gb2JqZWN0IHRoYXQgcmVxdWlyZXMgbGF5b3V0LiBlZy4gU2NhbGVzLCBMZWdlbmQsIFRpdGxlLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byB1c2Vcblx0ICogQHBhcmFtIHtMYXlvdXRJdGVtfSBpdGVtIC0gdGhlIGl0ZW0gdG8gYWRkIHRvIGJlIGxhaWQgb3V0XG5cdCAqL1xuICBhZGRCb3goY2hhcnQsIGl0ZW0pIHtcbiAgICBpZiAoIWNoYXJ0LmJveGVzKSB7XG4gICAgICBjaGFydC5ib3hlcyA9IFtdO1xuICAgIH1cblxuICAgIC8vIGluaXRpYWxpemUgaXRlbSB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgaXRlbS5mdWxsU2l6ZSA9IGl0ZW0uZnVsbFNpemUgfHwgZmFsc2U7XG4gICAgaXRlbS5wb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24gfHwgJ3RvcCc7XG4gICAgaXRlbS53ZWlnaHQgPSBpdGVtLndlaWdodCB8fCAwO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpdGVtLl9sYXllcnMgPSBpdGVtLl9sYXllcnMgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogMCxcbiAgICAgICAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICAgICAgICBpdGVtLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfTtcblxuICAgIGNoYXJ0LmJveGVzLnB1c2goaXRlbSk7XG4gIH0sXG5cbiAgLyoqXG5cdCAqIFJlbW92ZSBhIGxheW91dEl0ZW0gZnJvbSBhIGNoYXJ0XG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIHJlbW92ZSB0aGUgYm94IGZyb21cblx0ICogQHBhcmFtIHtMYXlvdXRJdGVtfSBsYXlvdXRJdGVtIC0gdGhlIGl0ZW0gdG8gcmVtb3ZlIGZyb20gdGhlIGxheW91dFxuXHQgKi9cbiAgcmVtb3ZlQm94KGNoYXJ0LCBsYXlvdXRJdGVtKSB7XG4gICAgY29uc3QgaW5kZXggPSBjaGFydC5ib3hlcyA/IGNoYXJ0LmJveGVzLmluZGV4T2YobGF5b3V0SXRlbSkgOiAtMTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjaGFydC5ib3hlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfSxcblxuICAvKipcblx0ICogU2V0cyAob3IgdXBkYXRlcykgb3B0aW9ucyBvbiB0aGUgZ2l2ZW4gYGl0ZW1gLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCBpbiB3aGljaCB0aGUgaXRlbSBsaXZlcyAob3Igd2lsbCBiZSBhZGRlZCB0bylcblx0ICogQHBhcmFtIHtMYXlvdXRJdGVtfSBpdGVtIC0gdGhlIGl0ZW0gdG8gY29uZmlndXJlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSB0aGUgbmV3IGl0ZW0gb3B0aW9ucy5cblx0ICovXG4gIGNvbmZpZ3VyZShjaGFydCwgaXRlbSwgb3B0aW9ucykge1xuICAgIGl0ZW0uZnVsbFNpemUgPSBvcHRpb25zLmZ1bGxTaXplO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuICAgIGl0ZW0ud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQ7XG4gIH0sXG5cbiAgLyoqXG5cdCAqIEZpdHMgYm94ZXMgb2YgdGhlIGdpdmVuIGNoYXJ0IGludG8gdGhlIGdpdmVuIHNpemUgYnkgaGF2aW5nIGVhY2ggYm94IG1lYXN1cmUgaXRzZWxmXG5cdCAqIHRoZW4gcnVubmluZyBhIGZpdHRpbmcgYWxnb3JpdGhtXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCB0byBmaXQgaW50b1xuXHQgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCB0byBmaXQgaW50b1xuICAgKiBAcGFyYW0ge251bWJlcn0gbWluUGFkZGluZyAtIG1pbmltdW0gcGFkZGluZyByZXF1aXJlZCBmb3IgZWFjaCBzaWRlIG9mIGNoYXJ0IGFyZWFcblx0ICovXG4gIHVwZGF0ZShjaGFydCwgd2lkdGgsIGhlaWdodCwgbWluUGFkZGluZykge1xuICAgIGlmICghY2hhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKGNoYXJ0Lm9wdGlvbnMubGF5b3V0LnBhZGRpbmcpO1xuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gTWF0aC5tYXgod2lkdGggLSBwYWRkaW5nLndpZHRoLCAwKTtcbiAgICBjb25zdCBhdmFpbGFibGVIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQgLSBwYWRkaW5nLmhlaWdodCwgMCk7XG4gICAgY29uc3QgYm94ZXMgPSBidWlsZExheW91dEJveGVzKGNoYXJ0LmJveGVzKTtcbiAgICBjb25zdCB2ZXJ0aWNhbEJveGVzID0gYm94ZXMudmVydGljYWw7XG4gICAgY29uc3QgaG9yaXpvbnRhbEJveGVzID0gYm94ZXMuaG9yaXpvbnRhbDtcblxuICAgIC8vIEJlZm9yZSBhbnkgY2hhbmdlcyBhcmUgbWFkZSwgbm90aWZ5IGJveGVzIHRoYXQgYW4gdXBkYXRlIGlzIGFib3V0IHRvIGJlaW5nXG4gICAgLy8gVGhpcyBpcyB1c2VkIHRvIGNsZWFyIGFueSBjYWNoZWQgZGF0YSAoZS5nLiBzY2FsZSBsaW1pdHMpXG4gICAgZWFjaChjaGFydC5ib3hlcywgYm94ID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYm94LmJlZm9yZUxheW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBib3guYmVmb3JlTGF5b3V0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBFc3NlbnRpYWxseSB3ZSBub3cgaGF2ZSBhbnkgbnVtYmVyIG9mIGJveGVzIG9uIGVhY2ggb2YgdGhlIDQgc2lkZXMuXG4gICAgLy8gT3VyIGNhbnZhcyBsb29rcyBsaWtlIHRoZSBmb2xsb3dpbmcuXG4gICAgLy8gVGhlIGFyZWFzIEwxIGFuZCBMMiBhcmUgdGhlIGxlZnQgYXhlcy4gUjEgaXMgdGhlIHJpZ2h0IGF4aXMsIFQxIGlzIHRoZSB0b3AgYXhpcyBhbmRcbiAgICAvLyBCMSBpcyB0aGUgYm90dG9tIGF4aXNcbiAgICAvLyBUaGVyZSBhcmUgYWxzbyA0IHF1YWRyYW50LWxpa2UgbG9jYXRpb25zIChsZWZ0IHRvIHJpZ2h0IGluc3RlYWQgb2YgY2xvY2t3aXNlKSByZXNlcnZlZCBmb3IgY2hhcnQgb3ZlcmxheXNcbiAgICAvLyBUaGVzZSBsb2NhdGlvbnMgYXJlIHNpbmdsZS1ib3ggbG9jYXRpb25zIG9ubHksIHdoZW4gdHJ5aW5nIHRvIHJlZ2lzdGVyIGEgY2hhcnRBcmVhIGxvY2F0aW9uIHRoYXQgaXMgYWxyZWFkeSB0YWtlbixcbiAgICAvLyBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICAvL1xuICAgIC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgIC8vIHwgICAgICAgICAgICAgICAgICBUMSAoRnVsbCBXaWR0aCkgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgIC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICBUMiAgICAgICAgICAgICAgICAgIHwgICAgfFxuICAgIC8vIHwgICAgfC0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tfFxuICAgIC8vIHwgICAgfCAgICB8IEMxIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEMyIHwgICAgfFxuICAgIC8vIHwgICAgfCAgICB8LS0tLXwgICAgICAgICAgICAgICAgICAgICAgICAgICB8LS0tLXwgICAgfFxuICAgIC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfFxuICAgIC8vIHwgTDEgfCBMMiB8ICAgICAgICAgICBDaGFydEFyZWEgKEMwKSAgICAgICAgICAgIHwgUjEgfFxuICAgIC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfFxuICAgIC8vIHwgICAgfCAgICB8LS0tLXwgICAgICAgICAgICAgICAgICAgICAgICAgICB8LS0tLXwgICAgfFxuICAgIC8vIHwgICAgfCAgICB8IEMzIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEM0IHwgICAgfFxuICAgIC8vIHwgICAgfC0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tfFxuICAgIC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICBCMSAgICAgICAgICAgICAgICAgIHwgICAgfFxuICAgIC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgIC8vIHwgICAgICAgICAgICAgICAgICBCMiAoRnVsbCBXaWR0aCkgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgIC8vXG5cbiAgICBjb25zdCB2aXNpYmxlVmVydGljYWxCb3hDb3VudCA9IHZlcnRpY2FsQm94ZXMucmVkdWNlKCh0b3RhbCwgd3JhcCkgPT5cbiAgICAgIHdyYXAuYm94Lm9wdGlvbnMgJiYgd3JhcC5ib3gub3B0aW9ucy5kaXNwbGF5ID09PSBmYWxzZSA/IHRvdGFsIDogdG90YWwgKyAxLCAwKSB8fCAxO1xuXG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBvdXRlcldpZHRoOiB3aWR0aCxcbiAgICAgIG91dGVySGVpZ2h0OiBoZWlnaHQsXG4gICAgICBwYWRkaW5nLFxuICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICBhdmFpbGFibGVIZWlnaHQsXG4gICAgICB2Qm94TWF4V2lkdGg6IGF2YWlsYWJsZVdpZHRoIC8gMiAvIHZpc2libGVWZXJ0aWNhbEJveENvdW50LFxuICAgICAgaEJveE1heEhlaWdodDogYXZhaWxhYmxlSGVpZ2h0IC8gMlxuICAgIH0pO1xuICAgIGNvbnN0IG1heFBhZGRpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBwYWRkaW5nKTtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIHRvUGFkZGluZyhtaW5QYWRkaW5nKSk7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBtYXhQYWRkaW5nLFxuICAgICAgdzogYXZhaWxhYmxlV2lkdGgsXG4gICAgICBoOiBhdmFpbGFibGVIZWlnaHQsXG4gICAgICB4OiBwYWRkaW5nLmxlZnQsXG4gICAgICB5OiBwYWRkaW5nLnRvcFxuICAgIH0sIHBhZGRpbmcpO1xuXG4gICAgY29uc3Qgc3RhY2tzID0gc2V0TGF5b3V0RGltcyh2ZXJ0aWNhbEJveGVzLmNvbmNhdChob3Jpem9udGFsQm94ZXMpLCBwYXJhbXMpO1xuXG4gICAgLy8gRmlyc3QgZml0IHRoZSBmdWxsU2l6ZSBib3hlcywgdG8gcmVkdWNlIHByb2JhYmlsaXR5IG9mIHJlLWZpdHRpbmcuXG4gICAgZml0Qm94ZXMoYm94ZXMuZnVsbFNpemUsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgLy8gVGhlbiBmaXQgdmVydGljYWwgYm94ZXNcbiAgICBmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcblxuICAgIC8vIFRoZW4gZml0IGhvcml6b250YWwgYm94ZXNcbiAgICBpZiAoZml0Qm94ZXMoaG9yaXpvbnRhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSkge1xuICAgICAgLy8gaWYgdGhlIGFyZWEgY2hhbmdlZCwgcmUtZml0IHZlcnRpY2FsIGJveGVzXG4gICAgICBmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICB9XG5cbiAgICBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSk7XG5cbiAgICAvLyBGaW5hbGx5IHBsYWNlIHRoZSBib3hlcyB0byBjb3JyZWN0IGNvb3JkaW5hdGVzXG4gICAgcGxhY2VCb3hlcyhib3hlcy5sZWZ0QW5kVG9wLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcblxuICAgIC8vIE1vdmUgdG8gb3Bwb3NpdGUgc2lkZSBvZiBjaGFydFxuICAgIGNoYXJ0QXJlYS54ICs9IGNoYXJ0QXJlYS53O1xuICAgIGNoYXJ0QXJlYS55ICs9IGNoYXJ0QXJlYS5oO1xuXG4gICAgcGxhY2VCb3hlcyhib3hlcy5yaWdodEFuZEJvdHRvbSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICBjaGFydC5jaGFydEFyZWEgPSB7XG4gICAgICBsZWZ0OiBjaGFydEFyZWEubGVmdCxcbiAgICAgIHRvcDogY2hhcnRBcmVhLnRvcCxcbiAgICAgIHJpZ2h0OiBjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS53LFxuICAgICAgYm90dG9tOiBjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmgsXG4gICAgICBoZWlnaHQ6IGNoYXJ0QXJlYS5oLFxuICAgICAgd2lkdGg6IGNoYXJ0QXJlYS53LFxuICAgIH07XG5cbiAgICAvLyBGaW5hbGx5IHVwZGF0ZSBib3hlcyBpbiBjaGFydEFyZWEgKHJhZGlhbCBzY2FsZSBmb3IgZXhhbXBsZSlcbiAgICBlYWNoKGJveGVzLmNoYXJ0QXJlYSwgKGxheW91dCkgPT4ge1xuICAgICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICAgIE9iamVjdC5hc3NpZ24oYm94LCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgYm94LnVwZGF0ZShjaGFydEFyZWEudywgY2hhcnRBcmVhLmgsIHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9KTtcbiAgICB9KTtcbiAgfVxufTtcbiIsICJcbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IGFsbG93cyBhYnN0cmFjdGluZyBwbGF0Zm9ybSBkZXBlbmRlbmNpZXMgYXdheSBmcm9tIHRoZSBjaGFydC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZVBsYXRmb3JtIHtcbiAgLyoqXG5cdCAqIENhbGxlZCBhdCBjaGFydCBjb25zdHJ1Y3Rpb24gdGltZSwgcmV0dXJucyBhIGNvbnRleHQyZCBpbnN0YW5jZSBpbXBsZW1lbnRpbmdcblx0ICogdGhlIFtXM0MgQ2FudmFzIDJEIENvbnRleHQgQVBJIHN0YW5kYXJkXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0L30uXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIFRoZSBjYW52YXMgZnJvbSB3aGljaCB0byBhY3F1aXJlIGNvbnRleHQgKHBsYXRmb3JtIHNwZWNpZmljKVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXSAtIFRoZSBjaGFydCBvcHRpb25zXG5cdCAqL1xuICBhY3F1aXJlQ29udGV4dChjYW52YXMsIGFzcGVjdFJhdGlvKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIENhbGxlZCBhdCBjaGFydCBkZXN0cnVjdGlvbiB0aW1lLCByZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFzc29jaWF0ZWQgdG8gdGhlIGNvbnRleHRcblx0ICogcHJldmlvdXNseSByZXR1cm5lZCBieSB0aGUgYWNxdWlyZUNvbnRleHQoKSBtZXRob2QuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IC0gVGhlIGNvbnRleHQyZCBpbnN0YW5jZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgbWV0aG9kIHN1Y2NlZWRlZCwgZWxzZSBmYWxzZVxuXHQgKi9cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlZ2lzdGVycyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIG9uIHRoZSBnaXZlbiBjaGFydC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBDaGFydCBmcm9tIHdoaWNoIHRvIGxpc3RlbiBmb3IgZXZlbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBDaGFydEV2ZW50fSkgdHlwZSB0byBsaXN0ZW4gZm9yXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gUmVjZWl2ZXMgYSBub3RpZmljYXRpb24gKGFuIG9iamVjdCB0aGF0IGltcGxlbWVudHNcblx0ICogdGhlIHtAbGluayBDaGFydEV2ZW50fSBpbnRlcmZhY2UpIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cblx0ICovXG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBhZGRFdmVudExpc3RlbmVyLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIENoYXJ0RXZlbnR9KSB0eXBlIHRvIHJlbW92ZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQgdGFyZ2V0LlxuXHQgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogQHJldHVybnMge251bWJlcn0gdGhlIGN1cnJlbnQgZGV2aWNlUGl4ZWxSYXRpbyBvZiB0aGUgZGV2aWNlIHRoaXMgcGxhdGZvcm0gaXMgY29ubmVjdGVkIHRvLlxuXHQgKi9cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHNpemUgaW4gcGl4ZWxzIG9mIGdpdmVuIGNhbnZhcyBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIC0gY29udGVudCB3aWR0aCBvZiBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF0gLSBjb250ZW50IGhlaWdodCBvZiBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXSAtIGFzcGVjdCByYXRpbyB0byBtYWludGFpblxuXHQgKi9cbiAgZ2V0TWF4aW11bVNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIHx8IGVsZW1lbnQud2lkdGgpO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCBlbGVtZW50LmhlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gTWF0aC5mbG9vcih3aWR0aCAvIGFzcGVjdFJhdGlvKSA6IGhlaWdodClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2FudmFzIGlzIGF0dGFjaGVkIHRvIHRoZSBwbGF0Zm9ybSwgZmFsc2UgaWYgbm90LlxuXHQgKi9cbiAgaXNBdHRhY2hlZChjYW52YXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgY29uZmlnIHdpdGggcGxhdGZvcm0gc3BlY2lmaWMgcmVxdWlyZW1lbnRzXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9jb3JlL2NvcmUuY29uZmlnLmpzJykuZGVmYXVsdH0gY29uZmlnXG4gICAqL1xuICB1cGRhdGVDb25maWcoY29uZmlnKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAvLyBuby1vcFxuICB9XG59XG4iLCAiLyoqXG4gKiBQbGF0Zm9ybSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiAobWluaW1hbCkuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU5MSNpc3N1ZWNvbW1lbnQtMzE5NTc1OTM5XG4gKi9cblxuaW1wb3J0IEJhc2VQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmJhc2UuanMnO1xuXG4vKipcbiAqIFBsYXRmb3JtIGNsYXNzIGZvciBjaGFydHMgd2l0aG91dCBhY2Nlc3MgdG8gdGhlIERPTSBvciB0byBtYW55IGVsZW1lbnQgcHJvcGVydGllc1xuICogVGhpcyBwbGF0Zm9ybSBpcyB1c2VkIGJ5IGRlZmF1bHQgZm9yIGFueSBjaGFydCBwYXNzZWQgYW4gT2Zmc2NyZWVuQ2FudmFzLlxuICogQGV4dGVuZHMgQmFzZVBsYXRmb3JtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2ljUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChpdGVtKSB7XG4gICAgLy8gVG8gcHJldmVudCBjYW52YXMgZmluZ2VycHJpbnRpbmcsIHNvbWUgYWRkLW9ucyB1bmRlZmluZSB0aGUgZ2V0Q29udGV4dFxuICAgIC8vIG1ldGhvZCwgZm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ra2Fwc25lci9DYW52YXNCbG9ja2VyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcbiAgICByZXR1cm4gaXRlbSAmJiBpdGVtLmdldENvbnRleHQgJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpIHx8IG51bGw7XG4gIH1cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZy5vcHRpb25zLmFuaW1hdGlvbiA9IGZhbHNlO1xuICB9XG59XG4iLCAiLyoqXG4gKiBDaGFydC5QbGF0Zm9ybSBpbXBsZW1lbnRhdGlvbiBmb3IgdGFyZ2V0aW5nIGEgd2ViIGJyb3dzZXJcbiAqL1xuXG5pbXBvcnQgQmFzZVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzZS5qcyc7XG5pbXBvcnQge19nZXRQYXJlbnROb2RlLCBnZXRSZWxhdGl2ZVBvc2l0aW9uLCBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zLCByZWFkVXNlZFNpemUsIGdldE1heGltdW1TaXplfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZG9tLmpzJztcbmltcG9ydCB7dGhyb3R0bGVkfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbmNvbnN0IEVYUEFORE9fS0VZID0gJyRjaGFydGpzJztcblxuLyoqXG4gKiBET00gZXZlbnQgdHlwZXMgLT4gQ2hhcnQuanMgZXZlbnQgdHlwZXMuXG4gKiBOb3RlOiBvbmx5IGV2ZW50cyB3aXRoIGRpZmZlcmVudCB0eXBlcyBhcmUgbWFwcGVkLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHNcbiAqL1xuY29uc3QgRVZFTlRfVFlQRVMgPSB7XG4gIHRvdWNoc3RhcnQ6ICdtb3VzZWRvd24nLFxuICB0b3VjaG1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3VjaGVuZDogJ21vdXNldXAnLFxuICBwb2ludGVyZW50ZXI6ICdtb3VzZWVudGVyJyxcbiAgcG9pbnRlcmRvd246ICdtb3VzZWRvd24nLFxuICBwb2ludGVybW92ZTogJ21vdXNlbW92ZScsXG4gIHBvaW50ZXJ1cDogJ21vdXNldXAnLFxuICBwb2ludGVybGVhdmU6ICdtb3VzZW91dCcsXG4gIHBvaW50ZXJvdXQ6ICdtb3VzZW91dCdcbn07XG5cbmNvbnN0IGlzTnVsbE9yRW1wdHkgPSB2YWx1ZSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJyc7XG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBjYW52YXMgc3R5bGUgYW5kIHJlbmRlciBzaXplIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBjYW52YXMgZGlzcGxheSBzaXplLFxuICogc2luY2UgcmVzcG9uc2l2ZW5lc3MgaXMgaGFuZGxlZCBieSB0aGUgY29udHJvbGxlci5yZXNpemUoKSBtZXRob2QuIFRoZSBjb25maWcgaXMgdXNlZFxuICogdG8gZGV0ZXJtaW5lIHRoZSBhc3BlY3QgcmF0aW8gdG8gYXBwbHkgaW4gY2FzZSBubyBleHBsaWNpdCBoZWlnaHQgaGFzIGJlZW4gc3BlY2lmaWVkLlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXVxuICovXG5mdW5jdGlvbiBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgY29uc3Qgc3R5bGUgPSBjYW52YXMuc3R5bGU7XG5cbiAgLy8gTk9URShTQikgY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSAhPT0gY2FudmFzLndpZHRoOiBpbiB0aGUgZmlyc3QgY2FzZSBpdFxuICAvLyByZXR1cm5zIG51bGwgb3IgJycgaWYgbm8gZXhwbGljaXQgdmFsdWUgaGFzIGJlZW4gc2V0IHRvIHRoZSBjYW52YXMgYXR0cmlidXRlLlxuICBjb25zdCByZW5kZXJIZWlnaHQgPSBjYW52YXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcbiAgY29uc3QgcmVuZGVyV2lkdGggPSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuXG4gIC8vIENoYXJ0LmpzIG1vZGlmaWVzIHNvbWUgY2FudmFzIHZhbHVlcyB0aGF0IHdlIHdhbnQgdG8gcmVzdG9yZSBvbiBkZXN0cm95XG4gIGNhbnZhc1tFWFBBTkRPX0tFWV0gPSB7XG4gICAgaW5pdGlhbDoge1xuICAgICAgaGVpZ2h0OiByZW5kZXJIZWlnaHQsXG4gICAgICB3aWR0aDogcmVuZGVyV2lkdGgsXG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxuICAgICAgICBoZWlnaHQ6IHN0eWxlLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IHN0eWxlLndpZHRoXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIEZvcmNlIGNhbnZhcyB0byBkaXNwbGF5IGFzIGJsb2NrIHRvIGF2b2lkIGV4dHJhIHNwYWNlIGNhdXNlZCBieSBpbmxpbmVcbiAgLy8gZWxlbWVudHMsIHdoaWNoIHdvdWxkIGludGVyZmVyZSB3aXRoIHRoZSByZXNwb25zaXZlIHJlc2l6ZSBwcm9jZXNzLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjUzOFxuICBzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xuICAvLyBJbmNsdWRlIHBvc3NpYmxlIGJvcmRlcnMgaW4gdGhlIHNpemVcbiAgc3R5bGUuYm94U2l6aW5nID0gc3R5bGUuYm94U2l6aW5nIHx8ICdib3JkZXItYm94JztcblxuICBpZiAoaXNOdWxsT3JFbXB0eShyZW5kZXJXaWR0aCkpIHtcbiAgICBjb25zdCBkaXNwbGF5V2lkdGggPSByZWFkVXNlZFNpemUoY2FudmFzLCAnd2lkdGgnKTtcbiAgICBpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGRpc3BsYXlXaWR0aDtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNOdWxsT3JFbXB0eShyZW5kZXJIZWlnaHQpKSB7XG4gICAgaWYgKGNhbnZhcy5zdHlsZS5oZWlnaHQgPT09ICcnKSB7XG4gICAgICAvLyBJZiBubyBleHBsaWNpdCByZW5kZXIgaGVpZ2h0IGFuZCBzdHlsZSBoZWlnaHQsIGxldCdzIGFwcGx5IHRoZSBhc3BlY3QgcmF0aW8sXG4gICAgICAvLyB3aGljaCBvbmUgY2FuIGJlIHNwZWNpZmllZCBieSB0aGUgdXNlciBidXQgYWxzbyBieSBjaGFydHMgYXMgZGVmYXVsdCBvcHRpb25cbiAgICAgIC8vIChpLmUuIG9wdGlvbnMuYXNwZWN0UmF0aW8pLiBJZiBub3Qgc3BlY2lmaWVkLCB1c2UgY2FudmFzIGFzcGVjdCByYXRpbyBvZiAyLlxuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCAvIChhc3BlY3RSYXRpbyB8fCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGlzcGxheUhlaWdodCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICdoZWlnaHQnKTtcbiAgICAgIGlmIChkaXNwbGF5SGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNhbnZhcztcbn1cblxuLy8gRGVmYXVsdCBwYXNzaXZlIHRvIHRydWUgYXMgZXhwZWN0ZWQgYnkgQ2hyb21lIGZvciAndG91Y2hzdGFydCcgYW5kICd0b3VjaGVuZCcgZXZlbnRzLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQyODdcbmNvbnN0IGV2ZW50TGlzdGVuZXJPcHRpb25zID0gc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA/IHtwYXNzaXZlOiB0cnVlfSA6IGZhbHNlO1xuXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihub2RlLCB0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAobm9kZSkge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoY2hhcnQgJiYgY2hhcnQuY2FudmFzKSB7XG4gICAgY2hhcnQuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHR5cGUgPSBFVkVOVF9UWVBFU1tldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xuICBjb25zdCB7eCwgeX0gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICBjaGFydCxcbiAgICBuYXRpdmU6IGV2ZW50LFxuICAgIHg6IHggIT09IHVuZGVmaW5lZCA/IHggOiBudWxsLFxuICAgIHk6IHkgIT09IHVuZGVmaW5lZCA/IHkgOiBudWxsLFxuICB9O1xufVxuXG5mdW5jdGlvbiBub2RlTGlzdENvbnRhaW5zKG5vZGVMaXN0LCBjYW52YXMpIHtcbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVMaXN0KSB7XG4gICAgaWYgKG5vZGUgPT09IGNhbnZhcyB8fCBub2RlLmNvbnRhaW5zKGNhbnZhcykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVBdHRhY2hPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGxldCB0cmlnZ2VyID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciB8fCBub2RlTGlzdENvbnRhaW5zKGVudHJ5LmFkZGVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciAmJiAhbm9kZUxpc3RDb250YWlucyhlbnRyeS5yZW1vdmVkTm9kZXMsIGNhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWV9KTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZXRhY2hPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGxldCB0cmlnZ2VyID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciB8fCBub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LmFkZGVkTm9kZXMsIGNhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWV9KTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuXG5jb25zdCBkcnBMaXN0ZW5pbmdDaGFydHMgPSBuZXcgTWFwKCk7XG5sZXQgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IDA7XG5cbmZ1bmN0aW9uIG9uV2luZG93UmVzaXplKCkge1xuICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgaWYgKGRwciA9PT0gb2xkRGV2aWNlUGl4ZWxSYXRpbykge1xuICAgIHJldHVybjtcbiAgfVxuICBvbGREZXZpY2VQaXhlbFJhdGlvID0gZHByO1xuICBkcnBMaXN0ZW5pbmdDaGFydHMuZm9yRWFjaCgocmVzaXplLCBjaGFydCkgPT4ge1xuICAgIGlmIChjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gZHByKSB7XG4gICAgICByZXNpemUoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCwgcmVzaXplKSB7XG4gIGlmICghZHJwTGlzdGVuaW5nQ2hhcnRzLnNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICB9XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5zZXQoY2hhcnQsIHJlc2l6ZSk7XG59XG5cbmZ1bmN0aW9uIHVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQpIHtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gIGlmICghZHJwTGlzdGVuaW5nQ2hhcnRzLnNpemUpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGNhbnZhcyAmJiBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZXNpemUgPSB0aHJvdHRsZWQoKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB3ID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIGxpc3RlbmVyKHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmICh3IDwgY29udGFpbmVyLmNsaWVudFdpZHRoKSB7XG4gICAgICAvLyBJZiB0aGUgY29udGFpbmVyIHNpemUgc2hyYW5rIGR1cmluZyBjaGFydCByZXNpemUsIGxldCdzIGFzc3VtZVxuICAgICAgLy8gc2Nyb2xsYmFyIGFwcGVhcmVkLiBTbyB3ZSByZXNpemUgYWdhaW4gd2l0aCB0aGUgc2Nyb2xsYmFyIHZpc2libGUgLVxuICAgICAgLy8gZWZmZWN0aXZlbHkgbWFraW5nIGNoYXJ0IHNtYWxsZXIgYW5kIHRoZSBzY3JvbGxiYXIgaGlkZGVuIGFnYWluLlxuICAgICAgLy8gQmVjYXVzZSB3ZSBhcmUgaW5zaWRlIGB0aHJvdHRsZWRgLCBhbmQgY3VycmVudGx5IGB0aWNraW5nYCwgc2Nyb2xsXG4gICAgICAvLyBldmVudHMgYXJlIGlnbm9yZWQgZHVyaW5nIHRoaXMgd2hvbGUgMiByZXNpemUgcHJvY2Vzcy5cbiAgICAgIC8vIElmIHdlIGFzc3VtZWQgd3JvbmcgYW5kIHNvbWV0aGluZyBlbHNlIGhhcHBlbmVkLCB3ZSBhcmUgcmVzaXppbmdcbiAgICAgIC8vIHR3aWNlIGluIGEgZnJhbWUgKHBvdGVudGlhbCBwZXJmb3JtYW5jZSBpc3N1ZSlcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9LCB3aW5kb3cpO1xuXG4gIC8vIEB0cy1pZ25vcmUgdW50aWwgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zNzg2MSBpbXBsZW1lbnRlZFxuICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbMF07XG4gICAgY29uc3Qgd2lkdGggPSBlbnRyeS5jb250ZW50UmVjdC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBlbnRyeS5jb250ZW50UmVjdC5oZWlnaHQ7XG4gICAgLy8gV2hlbiBpdHMgY29udGFpbmVyJ3MgZGlzcGxheSBpcyBzZXQgdG8gJ25vbmUnIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGFcbiAgICAvLyBzaXplIG9mICgwLCAwKSwgd2hpY2ggd2lsbCBjYXVzZSB0aGUgY2hhcnQgdG8gbG9zZSBpdHMgb3JpZ2luYWwgaGVpZ2h0LCBzbyBza2lwXG4gICAgLy8gcmVzaXppbmcgaW4gc3VjaCBjYXNlLlxuICAgIGlmICh3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIpO1xuICBsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCwgcmVzaXplKTtcblxuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VPYnNlcnZlcihjaGFydCwgdHlwZSwgb2JzZXJ2ZXIpIHtcbiAgaWYgKG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIGlmICh0eXBlID09PSAncmVzaXplJykge1xuICAgIHVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5QW5kTGlzdGVuKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IHByb3h5ID0gdGhyb3R0bGVkKChldmVudCkgPT4ge1xuICAgIC8vIFRoaXMgY2FzZSBjYW4gb2NjdXIgaWYgdGhlIGNoYXJ0IGlzIGRlc3Ryb3llZCB3aGlsZSB3YWl0aW5nXG4gICAgLy8gZm9yIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gdG8gb2NjdXIuIFdlIHByZXZlbnQgY3Jhc2hlcyBieSBjaGVja2luZ1xuICAgIC8vIGZvciBhIGRlc3Ryb3llZCBjaGFydFxuICAgIGlmIChjaGFydC5jdHggIT09IG51bGwpIHtcbiAgICAgIGxpc3RlbmVyKGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpKTtcbiAgICB9XG4gIH0sIGNoYXJ0KTtcblxuICBhZGRMaXN0ZW5lcihjYW52YXMsIHR5cGUsIHByb3h5KTtcblxuICByZXR1cm4gcHJveHk7XG59XG5cbi8qKlxuICogUGxhdGZvcm0gY2xhc3MgZm9yIGNoYXJ0cyB0aGF0IGNhbiBhY2Nlc3MgdGhlIERPTSBhbmQgZ2xvYmFsIHdpbmRvdy9kb2N1bWVudCBwcm9wZXJ0aWVzXG4gKiBAZXh0ZW5kcyBCYXNlUGxhdGZvcm1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9tUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb11cblx0ICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfG51bGx9XG5cdCAqL1xuICBhY3F1aXJlQ29udGV4dChjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gICAgLy8gVG8gcHJldmVudCBjYW52YXMgZmluZ2VycHJpbnRpbmcsIHNvbWUgYWRkLW9ucyB1bmRlZmluZSB0aGUgZ2V0Q29udGV4dFxuICAgIC8vIG1ldGhvZCwgZm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ra2Fwc25lci9DYW52YXNCbG9ja2VyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0ICYmIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgLy8gYGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEYCBmYWlscyB3aGVuIHRoZSBjYW52YXMgaXNcbiAgICAvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIHdoZW4gcnVubmluZyBpbiBhIHByb3RlY3RlZCBlbnZpcm9ubWVudC4gV2UgY291bGQgZ3Vlc3MgdGhlXG4gICAgLy8gdHlwZXMgZnJvbSB0aGVpciB0b1N0cmluZygpIHZhbHVlIGJ1dCBsZXQncyBrZWVwIHRoaW5ncyBmbGV4aWJsZSBhbmQgYXNzdW1lIGl0J3NcbiAgICAvLyBhIHN1ZmZpY2llbnQgY29uZGl0aW9uIGlmIHRoZSBjYW52YXMgaGFzIGEgY29udGV4dDJEIHdoaWNoIGhhcyBjYW52YXMgYXMgYGNhbnZhc2AuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzM4ODdcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDEwMlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTUyXG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5jYW52YXMgPT09IGNhbnZhcykge1xuICAgICAgLy8gTG9hZCBwbGF0Zm9ybSByZXNvdXJjZXMgb24gZmlyc3QgY2hhcnQgY3JlYXRpb24sIHRvIG1ha2UgaXQgcG9zc2libGUgdG9cbiAgICAgIC8vIGltcG9ydCB0aGUgbGlicmFyeSBiZWZvcmUgc2V0dGluZyBwbGF0Zm9ybSBvcHRpb25zLlxuICAgICAgaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKTtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0XG5cdCAqL1xuICByZWxlYXNlQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgaWYgKCFjYW52YXNbRVhQQU5ET19LRVldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgaW5pdGlhbCA9IGNhbnZhc1tFWFBBTkRPX0tFWV0uaW5pdGlhbDtcbiAgICBbJ2hlaWdodCcsICd3aWR0aCddLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gaW5pdGlhbFtwcm9wXTtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgICBjYW52YXMucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShwcm9wLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBzdHlsZSA9IGluaXRpYWwuc3R5bGUgfHwge307XG4gICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY2FudmFzLnN0eWxlW2tleV0gPSBzdHlsZVtrZXldO1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIGNhbnZhcyByZW5kZXIgc2l6ZSBtaWdodCBoYXZlIGJlZW4gY2hhbmdlZCAoYW5kIHRodXMgdGhlIHN0YXRlIHN0YWNrIGRpc2NhcmRlZCksXG4gICAgLy8gd2UgY2FuJ3QgdXNlIHNhdmUoKSBhbmQgcmVzdG9yZSgpIHRvIHJlc3RvcmUgdGhlIGluaXRpYWwgc3RhdGUuIFNvIG1ha2Ugc3VyZSB0aGF0IGF0XG4gICAgLy8gbGVhc3QgdGhlIGNhbnZhcyBjb250ZXh0IGlzIHJlc2V0IHRvIHRoZSBkZWZhdWx0IHN0YXRlIGJ5IHNldHRpbmcgdGhlIGNhbnZhcyB3aWR0aC5cbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAxMS9XRC1odG1sNS0yMDExMDUyNS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcblxuICAgIGRlbGV0ZSBjYW52YXNbRVhQQU5ET19LRVldO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyXG5cdCAqL1xuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgIC8vIENhbiBoYXZlIG9ubHkgb25lIGxpc3RlbmVyIHBlciB0eXBlLCBzbyBtYWtlIHN1cmUgcHJldmlvdXMgaXMgcmVtb3ZlZFxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSk7XG5cbiAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiBjcmVhdGVBdHRhY2hPYnNlcnZlcixcbiAgICAgIGRldGFjaDogY3JlYXRlRGV0YWNoT2JzZXJ2ZXIsXG4gICAgICByZXNpemU6IGNyZWF0ZVJlc2l6ZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgY3JlYXRlUHJveHlBbmRMaXN0ZW47XG4gICAgcHJveGllc1t0eXBlXSA9IGhhbmRsZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG5cdCAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKSB7XG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBwcm94eSA9IHByb3hpZXNbdHlwZV07XG5cbiAgICBpZiAoIXByb3h5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBhdHRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIGRldGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgcmVzaXplOiByZWxlYXNlT2JzZXJ2ZXJcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXSB8fCByZW1vdmVMaXN0ZW5lcjtcbiAgICBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBwcm94eSk7XG4gICAgcHJveGllc1t0eXBlXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSAtIGNvbnRlbnQgd2lkdGggb2YgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIC0gY29udGVudCBoZWlnaHQgb2YgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb10gLSBhc3BlY3QgcmF0aW8gdG8gbWFpbnRhaW5cblx0ICovXG4gIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICByZXR1cm4gZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG5cdCAqL1xuICBpc0F0dGFjaGVkKGNhbnZhcykge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNhbnZhcyAmJiBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIHJldHVybiAhIShjb250YWluZXIgJiYgY29udGFpbmVyLmlzQ29ubmVjdGVkKTtcbiAgfVxufVxuIiwgImltcG9ydCB7X2lzRG9tU3VwcG9ydGVkfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCBCYXNlUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNlLmpzJztcbmltcG9ydCBCYXNpY1BsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzaWMuanMnO1xuaW1wb3J0IERvbVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uZG9tLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIF9kZXRlY3RQbGF0Zm9ybShjYW52YXMpIHtcbiAgaWYgKCFfaXNEb21TdXBwb3J0ZWQoKSB8fCAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSkge1xuICAgIHJldHVybiBCYXNpY1BsYXRmb3JtO1xuICB9XG4gIHJldHVybiBEb21QbGF0Zm9ybTtcbn1cblxuZXhwb3J0IHtCYXNlUGxhdGZvcm0sIEJhc2ljUGxhdGZvcm0sIERvbVBsYXRmb3JtfTtcbiIsICJpbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7UG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQgdHlwZSB7QW5pbWF0aW9ufSBmcm9tICcuLi90eXBlcy9hbmltYXRpb24uanMnO1xuaW1wb3J0IHtpc051bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50PFQgPSBBbnlPYmplY3QsIE8gPSBBbnlPYmplY3Q+IHtcblxuICBzdGF0aWMgZGVmYXVsdHMgPSB7fTtcbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB1bmRlZmluZWQ7XG5cbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIGFjdGl2ZSA9IGZhbHNlO1xuICBvcHRpb25zOiBPO1xuICAkYW5pbWF0aW9uczogUmVjb3JkPGtleW9mIFQsIEFuaW1hdGlvbj47XG5cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pOiBQb2ludCB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9IGFzIFBvaW50O1xuICB9XG5cbiAgaGFzVmFsdWUoKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHRoaXMueCkgJiYgaXNOdW1iZXIodGhpcy55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IG9yIGZpbmFsIHZhbHVlIG9mIGVhY2ggcHJvcC4gQ2FuIHJldHVybiBleHRyYSBwcm9wZXJ0aWVzICh3aG9sZSBvYmplY3QpLlxuICAgKiBAcGFyYW0gcHJvcHMgLSBwcm9wZXJ0aWVzIHRvIGdldFxuICAgKiBAcGFyYW0gW2ZpbmFsXSAtIGdldCB0aGUgZmluYWwgdmFsdWUgKGFuaW1hdGlvbiB0YXJnZXQpXG4gICAqL1xuICBnZXRQcm9wczxQIGV4dGVuZHMgKGtleW9mIFQpW10+KHByb3BzOiBQLCBmaW5hbD86IGJvb2xlYW4pOiBQaWNrPFQsIFBbbnVtYmVyXT47XG4gIGdldFByb3BzPFAgZXh0ZW5kcyBzdHJpbmc+KHByb3BzOiBQW10sIGZpbmFsPzogYm9vbGVhbik6IFBhcnRpYWw8UmVjb3JkPFAsIHVua25vd24+PjtcbiAgZ2V0UHJvcHMocHJvcHM6IHN0cmluZ1tdLCBmaW5hbD86IGJvb2xlYW4pOiBQYXJ0aWFsPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgIGlmICghZmluYWwgfHwgIWFuaW1zKSB7XG4gICAgICAvLyBsZXQncyBub3QgY3JlYXRlIGFuIG9iamVjdCwgaWYgbm90IG5lZWRlZFxuICAgICAgcmV0dXJuIHRoaXMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgfVxuICAgIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcbiAgICBwcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICByZXRbcHJvcF0gPSBhbmltc1twcm9wXSAmJiBhbmltc1twcm9wXS5hY3RpdmUoKSA/IGFuaW1zW3Byb3BdLl90byA6IHRoaXNbcHJvcCBhcyBzdHJpbmddO1xuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cbiIsICJpbXBvcnQge2lzTnVsbE9yVW5kZWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge19mYWN0b3JpemV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYge3t2YWx1ZTpudW1iZXIgfCBzdHJpbmcsIGxhYmVsPzpzdHJpbmcsIG1ham9yPzpib29sZWFuLCAkY29udGV4dD86YW55fX0gVGlja1xuICovXG5cbi8qKlxuICogUmV0dXJucyBhIHN1YnNldCBvZiB0aWNrcyB0byBiZSBwbG90dGVkIHRvIGF2b2lkIG92ZXJsYXBwaW5nIGxhYmVscy5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0fSBzY2FsZVxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcmV0dXJuIHtUaWNrW119XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXV0b1NraXAoc2NhbGUsIHRpY2tzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gc2NhbGUub3B0aW9ucy50aWNrcztcbiAgY29uc3QgZGV0ZXJtaW5lZE1heFRpY2tzID0gZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpO1xuICBjb25zdCB0aWNrc0xpbWl0ID0gTWF0aC5taW4odGlja09wdHMubWF4VGlja3NMaW1pdCB8fCBkZXRlcm1pbmVkTWF4VGlja3MsIGRldGVybWluZWRNYXhUaWNrcyk7XG4gIGNvbnN0IG1ham9ySW5kaWNlcyA9IHRpY2tPcHRzLm1ham9yLmVuYWJsZWQgPyBnZXRNYWpvckluZGljZXModGlja3MpIDogW107XG4gIGNvbnN0IG51bU1ham9ySW5kaWNlcyA9IG1ham9ySW5kaWNlcy5sZW5ndGg7XG4gIGNvbnN0IGZpcnN0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBjb25zdCBsYXN0ID0gbWFqb3JJbmRpY2VzW251bU1ham9ySW5kaWNlcyAtIDFdO1xuICBjb25zdCBuZXdUaWNrcyA9IFtdO1xuXG4gIC8vIElmIHRoZXJlIGFyZSB0b28gbWFueSBtYWpvciB0aWNrcyB0byBkaXNwbGF5IHRoZW0gYWxsXG4gIGlmIChudW1NYWpvckluZGljZXMgPiB0aWNrc0xpbWl0KSB7XG4gICAgc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgbnVtTWFqb3JJbmRpY2VzIC8gdGlja3NMaW1pdCk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG5cbiAgY29uc3Qgc3BhY2luZyA9IGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCk7XG5cbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IDApIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBjb25zdCBhdmdNYWpvclNwYWNpbmcgPSBudW1NYWpvckluZGljZXMgPiAxID8gTWF0aC5yb3VuZCgobGFzdCAtIGZpcnN0KSAvIChudW1NYWpvckluZGljZXMgLSAxKSkgOiBudWxsO1xuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyAwIDogZmlyc3QgLSBhdmdNYWpvclNwYWNpbmcsIGZpcnN0KTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbnVtTWFqb3JJbmRpY2VzIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9ySW5kaWNlc1tpXSwgbWFqb3JJbmRpY2VzW2kgKyAxXSk7XG4gICAgfVxuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBsYXN0LCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyB0aWNrcy5sZW5ndGggOiBsYXN0ICsgYXZnTWFqb3JTcGFjaW5nKTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cbiAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcpO1xuICByZXR1cm4gbmV3VGlja3M7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZU1heFRpY2tzKHNjYWxlKSB7XG4gIGNvbnN0IG9mZnNldCA9IHNjYWxlLm9wdGlvbnMub2Zmc2V0O1xuICBjb25zdCB0aWNrTGVuZ3RoID0gc2NhbGUuX3RpY2tTaXplKCk7XG4gIGNvbnN0IG1heFNjYWxlID0gc2NhbGUuX2xlbmd0aCAvIHRpY2tMZW5ndGggKyAob2Zmc2V0ID8gMCA6IDEpO1xuICBjb25zdCBtYXhDaGFydCA9IHNjYWxlLl9tYXhMZW5ndGggLyB0aWNrTGVuZ3RoO1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1pbihtYXhTY2FsZSwgbWF4Q2hhcnQpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcltdfSBtYWpvckluZGljZXNcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHBhcmFtIHtudW1iZXJ9IHRpY2tzTGltaXRcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KSB7XG4gIGNvbnN0IGV2ZW5NYWpvclNwYWNpbmcgPSBnZXRFdmVuU3BhY2luZyhtYWpvckluZGljZXMpO1xuICBjb25zdCBzcGFjaW5nID0gdGlja3MubGVuZ3RoIC8gdGlja3NMaW1pdDtcblxuICAvLyBJZiB0aGUgbWFqb3IgdGlja3MgYXJlIGV2ZW5seSBzcGFjZWQgYXBhcnQsIHBsYWNlIHRoZSBtaW5vciB0aWNrc1xuICAvLyBzbyB0aGF0IHRoZXkgZGl2aWRlIHRoZSBtYWpvciB0aWNrcyBpbnRvIGV2ZW4gY2h1bmtzXG4gIGlmICghZXZlbk1ham9yU3BhY2luZykge1xuICAgIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbiAgfVxuXG4gIGNvbnN0IGZhY3RvcnMgPSBfZmFjdG9yaXplKGV2ZW5NYWpvclNwYWNpbmcpO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGZhY3RvcnMubGVuZ3RoIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgIGNvbnN0IGZhY3RvciA9IGZhY3RvcnNbaV07XG4gICAgaWYgKGZhY3RvciA+IHNwYWNpbmcpIHtcbiAgICAgIHJldHVybiBmYWN0b3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqL1xuZnVuY3Rpb24gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIGlmICh0aWNrc1tpXS5tYWpvcikge1xuICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcGFyYW0ge1RpY2tbXX0gbmV3VGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyW119IG1ham9ySW5kaWNlc1xuICogQHBhcmFtIHtudW1iZXJ9IHNwYWNpbmdcbiAqL1xuZnVuY3Rpb24gc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgc3BhY2luZykge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbmV4dCA9IG1ham9ySW5kaWNlc1swXTtcbiAgbGV0IGk7XG5cbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgZm9yIChpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBtYWpvckluZGljZXNbY291bnQgKiBzcGFjaW5nXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqIEBwYXJhbSB7VGlja1tdfSBuZXdUaWNrc1xuICogQHBhcmFtIHtudW1iZXJ9IHNwYWNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWFqb3JTdGFydF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWFqb3JFbmRdXG4gKi9cbmZ1bmN0aW9uIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvclN0YXJ0LCBtYWpvckVuZCkge1xuICBjb25zdCBzdGFydCA9IHZhbHVlT3JEZWZhdWx0KG1ham9yU3RhcnQsIDApO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbih2YWx1ZU9yRGVmYXVsdChtYWpvckVuZCwgdGlja3MubGVuZ3RoKSwgdGlja3MubGVuZ3RoKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IGxlbmd0aCwgaSwgbmV4dDtcblxuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICBpZiAobWFqb3JFbmQpIHtcbiAgICBsZW5ndGggPSBtYWpvckVuZCAtIG1ham9yU3RhcnQ7XG4gICAgc3BhY2luZyA9IGxlbmd0aCAvIE1hdGguZmxvb3IobGVuZ3RoIC8gc3BhY2luZyk7XG4gIH1cblxuICBuZXh0ID0gc3RhcnQ7XG5cbiAgd2hpbGUgKG5leHQgPCAwKSB7XG4gICAgY291bnQrKztcbiAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gIH1cblxuICBmb3IgKGkgPSBNYXRoLm1heChzdGFydCwgMCk7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcltdfSBhcnJcbiAqL1xuZnVuY3Rpb24gZ2V0RXZlblNwYWNpbmcoYXJyKSB7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpLCBkaWZmO1xuXG4gIGlmIChsZW4gPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChkaWZmID0gYXJyWzBdLCBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFycltpXSAtIGFycltpIC0gMV0gIT09IGRpZmYpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtfYWxpZ25QaXhlbCwgX21lYXN1cmVUZXh0LCByZW5kZXJUZXh0LCBjbGlwQXJlYSwgdW5jbGlwQXJlYX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge2NhbGxiYWNrIGFzIGNhbGwsIGVhY2gsIGZpbml0ZU9yRGVmYXVsdCwgaXNBcnJheSwgaXNGaW5pdGUsIGlzTnVsbE9yVW5kZWYsIGlzT2JqZWN0LCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0RlZ3JlZXMsIHRvUmFkaWFucywgX2ludDE2UmFuZ2UsIF9saW1pdFZhbHVlLCBIQUxGX1BJfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19hbGlnblN0YXJ0RW5kLCBfdG9MZWZ0UmlnaHRDZW50ZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCB0b0ZvbnQsIHRvUGFkZGluZywgX2FkZEdyYWNlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2F1dG9Ta2lwfSBmcm9tICcuL2NvcmUuc2NhbGUuYXV0b3NraXAuanMnO1xuXG5jb25zdCByZXZlcnNlQWxpZ24gPSAoYWxpZ24pID0+IGFsaWduID09PSAnbGVmdCcgPyAncmlnaHQnIDogYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiBhbGlnbjtcbmNvbnN0IG9mZnNldEZyb21FZGdlID0gKHNjYWxlLCBlZGdlLCBvZmZzZXQpID0+IGVkZ2UgPT09ICd0b3AnIHx8IGVkZ2UgPT09ICdsZWZ0JyA/IHNjYWxlW2VkZ2VdICsgb2Zmc2V0IDogc2NhbGVbZWRnZV0gLSBvZmZzZXQ7XG5jb25zdCBnZXRUaWNrc0xpbWl0ID0gKHRpY2tzTGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSA9PiBNYXRoLm1pbihtYXhUaWNrc0xpbWl0IHx8IHRpY2tzTGVuZ3RoLCB0aWNrc0xlbmd0aCk7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnQgfSBDaGFydFxuICogQHR5cGVkZWYge3t2YWx1ZTpudW1iZXIgfCBzdHJpbmcsIGxhYmVsPzpzdHJpbmcsIG1ham9yPzpib29sZWFuLCAkY29udGV4dD86YW55fX0gVGlja1xuICovXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBhcnJheSBjb250YWluaW5nIG51bUl0ZW1zIGZyb20gYXJyXG4gKiBAcGFyYW0ge2FueVtdfSBhcnJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1JdGVtc1xuICovXG5mdW5jdGlvbiBzYW1wbGUoYXJyLCBudW1JdGVtcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgaW5jcmVtZW50ID0gYXJyLmxlbmd0aCAvIG51bUl0ZW1zO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBsZW47IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgcmVzdWx0LnB1c2goYXJyW01hdGguZmxvb3IoaSldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb2Zmc2V0R3JpZExpbmVzXG4gKi9cbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUudGlja3MubGVuZ3RoO1xuICBjb25zdCB2YWxpZEluZGV4ID0gTWF0aC5taW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICBjb25zdCBzdGFydCA9IHNjYWxlLl9zdGFydFBpeGVsO1xuICBjb25zdCBlbmQgPSBzY2FsZS5fZW5kUGl4ZWw7XG4gIGNvbnN0IGVwc2lsb24gPSAxZS02OyAvLyAxZS02IGlzIG1hcmdpbiBpbiBwaXhlbHMgZm9yIGFjY3VtdWxhdGVkIGVycm9yLlxuICBsZXQgbGluZVZhbHVlID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXgpO1xuICBsZXQgb2Zmc2V0O1xuXG4gIGlmIChvZmZzZXRHcmlkTGluZXMpIHtcbiAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICBvZmZzZXQgPSBNYXRoLm1heChsaW5lVmFsdWUgLSBzdGFydCwgZW5kIC0gbGluZVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBvZmZzZXQgPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCAtIDEpKSAvIDI7XG4gICAgfVxuICAgIGxpbmVWYWx1ZSArPSB2YWxpZEluZGV4IDwgaW5kZXggPyBvZmZzZXQgOiAtb2Zmc2V0O1xuXG4gICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgcGl4ZWwgaXMgb3V0IG9mIHRoZSByYW5nZVxuICAgIGlmIChsaW5lVmFsdWUgPCBzdGFydCAtIGVwc2lsb24gfHwgbGluZVZhbHVlID4gZW5kICsgZXBzaWxvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZVZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjYWNoZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcbiAgZWFjaChjYWNoZXMsIChjYWNoZSkgPT4ge1xuICAgIGNvbnN0IGdjID0gY2FjaGUuZ2M7XG4gICAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICAgIGxldCBpO1xuICAgIGlmIChnY0xlbiA+IGxlbmd0aCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyArK2kpIHtcbiAgICAgICAgZGVsZXRlIGNhY2hlLmRhdGFbZ2NbaV1dO1xuICAgICAgfVxuICAgICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZHJhd1RpY2tzID8gb3B0aW9ucy50aWNrTGVuZ3RoIDogMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRUaXRsZUhlaWdodChvcHRpb25zLCBmYWxsYmFjaykge1xuICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgY29uc3QgZm9udCA9IHRvRm9udChvcHRpb25zLmZvbnQsIGZhbGxiYWNrKTtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkob3B0aW9ucy50ZXh0KSA/IG9wdGlvbnMudGV4dC5sZW5ndGggOiAxO1xuXG4gIHJldHVybiAobGluZXMgKiBmb250LmxpbmVIZWlnaHQpICsgcGFkZGluZy5oZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlQ29udGV4dChwYXJlbnQsIHNjYWxlKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHNjYWxlLFxuICAgIHR5cGU6ICdzY2FsZSdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpY2tDb250ZXh0KHBhcmVudCwgaW5kZXgsIHRpY2spIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdGljayxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAndGljaydcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSB7XG4gIC8qKiBAdHlwZSB7Q2FudmFzVGV4dEFsaWdufSAqL1xuICBsZXQgcmV0ID0gX3RvTGVmdFJpZ2h0Q2VudGVyKGFsaWduKTtcbiAgaWYgKChyZXZlcnNlICYmIHBvc2l0aW9uICE9PSAncmlnaHQnKSB8fCAoIXJldmVyc2UgJiYgcG9zaXRpb24gPT09ICdyaWdodCcpKSB7XG4gICAgcmV0ID0gcmV2ZXJzZUFsaWduKHJldCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gdGl0bGVBcmdzKHNjYWxlLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbikge1xuICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBjaGFydH0gPSBzY2FsZTtcbiAgY29uc3Qge2NoYXJ0QXJlYSwgc2NhbGVzfSA9IGNoYXJ0O1xuICBsZXQgcm90YXRpb24gPSAwO1xuICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuXG4gIGlmIChzY2FsZS5pc0hvcml6b250YWwoKSkge1xuICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG5cbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVZID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVZID0gKGNoYXJ0QXJlYS5ib3R0b20gKyBjaGFydEFyZWEudG9wKSAvIDIgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWSA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWCA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVYID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgIHJvdGF0aW9uID0gcG9zaXRpb24gPT09ICdsZWZ0JyA/IC1IQUxGX1BJIDogSEFMRl9QSTtcbiAgfVxuICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2FsZSBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5pZCA9IGNmZy5pZDtcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzLnR5cGUgPSBjZmcudHlwZTtcbiAgICAvKiogQHR5cGUge2FueX0gKi9cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICovXG4gICAgdGhpcy5jdHggPSBjZmcuY3R4O1xuICAgIC8qKiBAdHlwZSB7Q2hhcnR9ICovXG4gICAgdGhpcy5jaGFydCA9IGNmZy5jaGFydDtcblxuICAgIC8vIGltcGxlbWVudHMgYm94XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHNjYWxlLXNwZWNpZmljIHByb3BlcnRpZXNcbiAgICAvKiogQHR5cGUge3N0cmluZz19ICovXG4gICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyPX0gKi9cbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5taW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtUaWNrW119ICovXG4gICAgdGhpcy50aWNrcyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7b2JqZWN0W118bnVsbH0gKi9cbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICAvKiogQHR5cGUge29iamVjdFtdfG51bGx9ICovXG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtvYmplY3R8bnVsbH0gKi9cbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX21heExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbG9uZ2VzdFRleHRDYWNoZSA9IHt9O1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fZW5kUGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZXJNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdXNlck1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IDA7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge2FueX0gb3B0aW9uc1xuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuXG4gICAgdGhpcy5heGlzID0gb3B0aW9ucy5heGlzO1xuXG4gICAgLy8gcGFyc2UgbWluL21heCB2YWx1ZSwgc28gd2UgY2FuIHByb3Blcmx5IGRldGVybWluZSBtaW4vbWF4IGZvciBvdGhlciBzY2FsZXNcbiAgICB0aGlzLl91c2VyTWluID0gdGhpcy5wYXJzZShvcHRpb25zLm1pbik7XG4gICAgdGhpcy5fdXNlck1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5tYXgpO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNaW4pO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNYXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGEgc3VwcG9ydGVkIGlucHV0IHZhbHVlIHRvIGludGVybmFsIHJlcHJlc2VudGF0aW9uLlxuXHQgKiBAcGFyYW0geyp9IHJhd1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gcmF3O1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXIsIG1pbkRlZmluZWQ6IGJvb2xlYW4sIG1heERlZmluZWQ6IGJvb2xlYW59fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAzLjBcblx0ICovXG4gIGdldFVzZXJCb3VuZHMoKSB7XG4gICAgbGV0IHtfdXNlck1pbiwgX3VzZXJNYXgsIF9zdWdnZXN0ZWRNaW4sIF9zdWdnZXN0ZWRNYXh9ID0gdGhpcztcbiAgICBfdXNlck1pbiA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfdXNlck1heCA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWluID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1heCA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgX3N1Z2dlc3RlZE1pbiksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgX3N1Z2dlc3RlZE1heCksXG4gICAgICBtaW5EZWZpbmVkOiBpc0Zpbml0ZShfdXNlck1pbiksXG4gICAgICBtYXhEZWZpbmVkOiBpc0Zpbml0ZShfdXNlck1heClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuU3RhY2tcblx0ICogQHJldHVybiB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgZ2V0TWluTWF4KGNhblN0YWNrKSB7XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgcmFuZ2U7XG5cbiAgICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkKSB7XG4gICAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcmFuZ2UgPSBtZXRhc1tpXS5jb250cm9sbGVyLmdldE1pbk1heCh0aGlzLCBjYW5TdGFjayk7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByYW5nZS5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcmFuZ2UubWF4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgbWluIDw9IG1heCB3aGVuIG9ubHkgbWluIG9yIG1heCBpcyBkZWZpbmVkIGJ5IHVzZXIgYW5kIHRoZSBkYXRhIGlzIG91dHNpZGUgdGhhdCByYW5nZVxuICAgIG1pbiA9IG1heERlZmluZWQgJiYgbWluID4gbWF4ID8gbWF4IDogbWluO1xuICAgIG1heCA9IG1pbkRlZmluZWQgJiYgbWluID4gbWF4ID8gbWluIDogbWF4O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KG1pbiwgZmluaXRlT3JEZWZhdWx0KG1heCwgbWluKSksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChtYXgsIGZpbml0ZU9yRGVmYXVsdChtaW4sIG1heCkpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgdGhlIHBhZGRpbmcgbmVlZGVkIGZvciB0aGUgc2NhbGVcblx0ICogQHJldHVybiB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCByaWdodDogbnVtYmVyfX0gdGhlIG5lY2Vzc2FyeSBwYWRkaW5nXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBnZXRQYWRkaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnBhZGRpbmdMZWZ0IHx8IDAsXG4gICAgICB0b3A6IHRoaXMucGFkZGluZ1RvcCB8fCAwLFxuICAgICAgcmlnaHQ6IHRoaXMucGFkZGluZ1JpZ2h0IHx8IDAsXG4gICAgICBib3R0b206IHRoaXMucGFkZGluZ0JvdHRvbSB8fCAwXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzY2FsZSB0aWNrIG9iamVjdHNcblx0ICogQHJldHVybiB7VGlja1tdfVxuXHQgKiBAc2luY2UgMi43XG5cdCAqL1xuICBnZXRUaWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50aWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtzdHJpbmdbXX1cblx0ICovXG4gIGdldExhYmVscygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWxzIHx8ICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gZGF0YS54TGFiZWxzIDogZGF0YS55TGFiZWxzKSB8fCBkYXRhLmxhYmVscyB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4uL3R5cGVzLmpzJykuTGFiZWxJdGVtW119XG4gICAqL1xuICBnZXRMYWJlbEl0ZW1zKGNoYXJ0QXJlYSA9IHRoaXMuY2hhcnQuY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9sYWJlbEl0ZW1zIHx8ICh0aGlzLl9sYWJlbEl0ZW1zID0gdGhpcy5fY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgLy8gV2hlbiBhIG5ldyBsYXlvdXQgaXMgY3JlYXRlZCwgcmVzZXQgdGhlIGRhdGEgbGltaXRzIGNhY2hlXG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5Y2xlLiBVdGlsaXRpZXMgdGhlbiBmb2xsb3cuXG4gIC8vIEFueSBmdW5jdGlvbiBkZWZpbmVkIGhlcmUgaXMgaW5oZXJpdGVkIGJ5IGFsbCBzY2FsZSB0eXBlcy5cbiAgLy8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgc2NhbGUgdHlwZVxuXG4gIGJlZm9yZVVwZGF0ZSgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVVcGRhdGUsIFt0aGlzXSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heFdpZHRoIC0gdGhlIG1heCB3aWR0aCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heEhlaWdodCAtIHRoZSBtYXggaGVpZ2h0IGluIHBpeGVsc1xuXHQgKiBAcGFyYW0ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCBib3R0b206IG51bWJlciwgcmlnaHQ6IG51bWJlcn19IG1hcmdpbnMgLSB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgZWRnZSBvZiB0aGUgb3RoZXIgc2NhbGVzIGFuZCBlZGdlIG9mIHRoZSBjaGFydFxuXHQgKiAgIFRoaXMgc3BhY2UgY29tZXMgZnJvbSB0d28gc291cmNlczpcblx0ICogICAgIC0gcGFkZGluZyAtIHNwYWNlIHRoYXQncyByZXF1aXJlZCB0byBzaG93IHRoZSBsYWJlbHMgYXQgdGhlIGVkZ2VzIG9mIHRoZSBzY2FsZVxuXHQgKiAgICAgLSB0aGlja25lc3Mgb2Ygc2NhbGVzIG9yIGxlZ2VuZHMgaW4gYW5vdGhlciBvcmllbnRhdGlvblxuXHQgKi9cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICBjb25zdCB7YmVnaW5BdFplcm8sIGdyYWNlLCB0aWNrczogdGlja09wdHN9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aWNrT3B0cy5zYW1wbGVTaXplO1xuXG4gICAgLy8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcbiAgICB0aGlzLmJlZm9yZVVwZGF0ZSgpO1xuXG4gICAgLy8gQWJzb3JiIHRoZSBtYXN0ZXIgbWVhc3VyZW1lbnRzXG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9LCBtYXJnaW5zKTtcblxuICAgIHRoaXMudGlja3MgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuXG4gICAgLy8gRGltZW5zaW9uc1xuICAgIHRoaXMuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG5cbiAgICB0aGlzLl9tYXhMZW5ndGggPSB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IHRoaXMud2lkdGggKyBtYXJnaW5zLmxlZnQgKyBtYXJnaW5zLnJpZ2h0XG4gICAgICA6IHRoaXMuaGVpZ2h0ICsgbWFyZ2lucy50b3AgKyBtYXJnaW5zLmJvdHRvbTtcblxuICAgIC8vIERhdGEgbWluL21heFxuICAgIGlmICghdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCkge1xuICAgICAgdGhpcy5iZWZvcmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmRldGVybWluZURhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuYWZ0ZXJEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLl9yYW5nZSA9IF9hZGRHcmFjZSh0aGlzLCBncmFjZSwgYmVnaW5BdFplcm8pO1xuICAgICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5iZWZvcmVCdWlsZFRpY2tzKCk7XG5cbiAgICB0aGlzLnRpY2tzID0gdGhpcy5idWlsZFRpY2tzKCkgfHwgW107XG5cbiAgICAvLyBBbGxvdyBtb2RpZmljYXRpb24gb2YgdGlja3MgaW4gY2FsbGJhY2suXG4gICAgdGhpcy5hZnRlckJ1aWxkVGlja3MoKTtcblxuICAgIC8vIENvbXB1dGUgdGljayByb3RhdGlvbiBhbmQgZml0IHVzaW5nIGEgc2FtcGxlZCBzdWJzZXQgb2YgbGFiZWxzXG4gICAgLy8gV2UgZ2VuZXJhbGx5IGRvbid0IG5lZWQgdG8gY29tcHV0ZSB0aGUgc2l6ZSBvZiBldmVyeSBzaW5nbGUgbGFiZWwgZm9yIGRldGVybWluaW5nIHNjYWxlIHNpemVcbiAgICBjb25zdCBzYW1wbGluZ0VuYWJsZWQgPSBzYW1wbGVTaXplIDwgdGhpcy50aWNrcy5sZW5ndGg7XG4gICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHMoc2FtcGxpbmdFbmFibGVkID8gc2FtcGxlKHRoaXMudGlja3MsIHNhbXBsZVNpemUpIDogdGhpcy50aWNrcyk7XG5cbiAgICAvLyBjb25maWd1cmUgaXMgY2FsbGVkIHR3aWNlLCBvbmNlIGhlcmUsIG9uY2UgZnJvbSBjb3JlLmNvbnRyb2xsZXIudXBkYXRlTGF5b3V0LlxuICAgIC8vIEhlcmUgd2UgaGF2ZW4ndCBiZWVuIHBvc2l0aW9uZWQgeWV0LCBidXQgZGltZW5zaW9ucyBhcmUgY29ycmVjdC5cbiAgICAvLyBWYXJpYWJsZXMgc2V0IGluIGNvbmZpZ3VyZSBhcmUgbmVlZGVkIGZvciBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBhbmRcbiAgICAvLyBpdCdzIG9rIHRoYXQgY29vcmRpbmF0ZXMgYXJlIG5vdCBjb3JyZWN0IHRoZXJlLCBvbmx5IGRpbWVuc2lvbnMgbWF0dGVyLlxuICAgIHRoaXMuY29uZmlndXJlKCk7XG5cbiAgICAvLyBUaWNrIFJvdGF0aW9uXG4gICAgdGhpcy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgdGhpcy5jYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7IC8vIFByZWNvbmRpdGlvbnM6IG51bWJlciBvZiB0aWNrcyBhbmQgc2l6ZXMgb2YgbGFyZ2VzdCBsYWJlbHMgbXVzdCBiZSBjYWxjdWxhdGVkIGJlZm9yZWhhbmRcbiAgICB0aGlzLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuXG4gICAgLy8gQXV0by1za2lwXG4gICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgKHRpY2tPcHRzLmF1dG9Ta2lwIHx8IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2F1dG8nKSkge1xuICAgICAgdGhpcy50aWNrcyA9IGF1dG9Ta2lwKHRoaXMsIHRoaXMudGlja3MpO1xuICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgICB0aGlzLmFmdGVyQXV0b1NraXAoKTtcbiAgICB9XG5cbiAgICBpZiAoc2FtcGxpbmdFbmFibGVkKSB7XG4gICAgICAvLyBHZW5lcmF0ZSBsYWJlbHMgdXNpbmcgYWxsIG5vbi1za2lwcGVkIHRpY2tzXG4gICAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyh0aGlzLnRpY2tzKTtcbiAgICB9XG5cbiAgICB0aGlzLmJlZm9yZUZpdCgpO1xuICAgIHRoaXMuZml0KCk7IC8vIFByZWNvbmRpdGlvbnM6IGxhYmVsIHJvdGF0aW9uIGFuZCBsYWJlbCBzaXplcyBtdXN0IGJlIGNhbGN1bGF0ZWQgYmVmb3JlaGFuZFxuICAgIHRoaXMuYWZ0ZXJGaXQoKTtcblxuICAgIC8vIElNUE9SVEFOVDogYWZ0ZXIgdGhpcyBwb2ludCwgd2UgY29uc2lkZXIgdGhhdCBgdGhpcy50aWNrc2Agd2lsbCBORVZFUiBjaGFuZ2UhXG5cbiAgICB0aGlzLmFmdGVyVXBkYXRlKCk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29uZmlndXJlKCkge1xuICAgIGxldCByZXZlcnNlUGl4ZWxzID0gdGhpcy5vcHRpb25zLnJldmVyc2U7XG4gICAgbGV0IHN0YXJ0UGl4ZWwsIGVuZFBpeGVsO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHN0YXJ0UGl4ZWwgPSB0aGlzLmxlZnQ7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UGl4ZWwgPSB0aGlzLnRvcDtcbiAgICAgIGVuZFBpeGVsID0gdGhpcy5ib3R0b207XG4gICAgICAvLyBieSBkZWZhdWx0IHZlcnRpY2FsIHNjYWxlcyBhcmUgZnJvbSBib3R0b20gdG8gdG9wLCBzbyBwaXhlbHMgYXJlIHJldmVyc2VkXG4gICAgICByZXZlcnNlUGl4ZWxzID0gIXJldmVyc2VQaXhlbHM7XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSBzdGFydFBpeGVsO1xuICAgIHRoaXMuX2VuZFBpeGVsID0gZW5kUGl4ZWw7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IHJldmVyc2VQaXhlbHM7XG4gICAgdGhpcy5fbGVuZ3RoID0gZW5kUGl4ZWwgLSBzdGFydFBpeGVsO1xuICAgIHRoaXMuX2FsaWduVG9QaXhlbHMgPSB0aGlzLm9wdGlvbnMuYWxpZ25Ub1BpeGVscztcbiAgfVxuXG4gIGFmdGVyVXBkYXRlKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyVXBkYXRlLCBbdGhpc10pO1xuICB9XG5cbiAgLy9cblxuICBiZWZvcmVTZXREaW1lbnNpb25zKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZVNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICAvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gMDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuXG4gICAgICAvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cbiAgICAgIHRoaXMudG9wID0gMDtcbiAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgcGFkZGluZ1xuICAgIHRoaXMucGFkZGluZ0xlZnQgPSAwO1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSAwO1xuICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IDA7XG4gIH1cbiAgYWZ0ZXJTZXREaW1lbnNpb25zKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuXG4gIF9jYWxsSG9va3MobmFtZSkge1xuICAgIHRoaXMuY2hhcnQubm90aWZ5UGx1Z2lucyhuYW1lLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnNbbmFtZV0sIFt0aGlzXSk7XG4gIH1cblxuICAvLyBEYXRhIGxpbWl0c1xuICBiZWZvcmVEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlRGF0YUxpbWl0cycpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7fVxuICBhZnRlckRhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckRhdGFMaW1pdHMnKTtcbiAgfVxuXG4gIC8vXG4gIGJlZm9yZUJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVCdWlsZFRpY2tzJyk7XG4gIH1cbiAgLyoqXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfSB0aGUgdGlja3Ncblx0ICovXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGFmdGVyQnVpbGRUaWNrcygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyQnVpbGRUaWNrcycpO1xuICB9XG5cbiAgYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuICAvKipcblx0ICogQ29udmVydCB0aWNrcyB0byBsYWJlbCBzdHJpbmdzXG5cdCAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuXHQgKi9cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IGNhbGwodGlja09wdHMuY2FsbGJhY2ssIFt0aWNrLnZhbHVlLCBpLCB0aWNrc10sIHRoaXMpO1xuICAgIH1cbiAgfVxuICBhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vXG5cbiAgYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICB9XG4gIGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgbnVtVGlja3MgPSBnZXRUaWNrc0xpbWl0KHRoaXMudGlja3MubGVuZ3RoLCBvcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQpO1xuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdGlja09wdHMubWluUm90YXRpb24gfHwgMDtcbiAgICBjb25zdCBtYXhSb3RhdGlvbiA9IHRpY2tPcHRzLm1heFJvdGF0aW9uO1xuICAgIGxldCBsYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgbGV0IHRpY2tXaWR0aCwgbWF4SGVpZ2h0LCBtYXhMYWJlbERpYWdvbmFsO1xuXG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhdGlja09wdHMuZGlzcGxheSB8fCBtaW5Sb3RhdGlvbiA+PSBtYXhSb3RhdGlvbiB8fCBudW1UaWNrcyA8PSAxIHx8ICF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IG1heExhYmVsV2lkdGggPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcbiAgICBjb25zdCBtYXhMYWJlbEhlaWdodCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQ7XG5cbiAgICAvLyBFc3RpbWF0ZSB0aGUgd2lkdGggb2YgZWFjaCBncmlkIGJhc2VkIG9uIHRoZSBjYW52YXMgd2lkdGgsIHRoZSBtYXhpbXVtXG4gICAgLy8gbGFiZWwgd2lkdGggYW5kIHRoZSBudW1iZXIgb2YgdGljayBpbnRlcnZhbHNcbiAgICBjb25zdCBtYXhXaWR0aCA9IF9saW1pdFZhbHVlKHRoaXMuY2hhcnQud2lkdGggLSBtYXhMYWJlbFdpZHRoLCAwLCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aWNrV2lkdGggPSBvcHRpb25zLm9mZnNldCA/IHRoaXMubWF4V2lkdGggLyBudW1UaWNrcyA6IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gMSk7XG5cbiAgICAvLyBBbGxvdyAzIHBpeGVscyB4MiBwYWRkaW5nIGVpdGhlciBzaWRlIGZvciBsYWJlbCByZWFkYWJpbGl0eVxuICAgIGlmIChtYXhMYWJlbFdpZHRoICsgNiA+IHRpY2tXaWR0aCkge1xuICAgICAgdGlja1dpZHRoID0gbWF4V2lkdGggLyAobnVtVGlja3MgLSAob3B0aW9ucy5vZmZzZXQgPyAwLjUgOiAxKSk7XG4gICAgICBtYXhIZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZClcblx0XHRcdFx0LSB0aWNrT3B0cy5wYWRkaW5nIC0gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucy50aXRsZSwgdGhpcy5jaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgbWF4TGFiZWxEaWFnb25hbCA9IE1hdGguc3FydChtYXhMYWJlbFdpZHRoICogbWF4TGFiZWxXaWR0aCArIG1heExhYmVsSGVpZ2h0ICogbWF4TGFiZWxIZWlnaHQpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IHRvRGVncmVlcyhNYXRoLm1pbihcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKChsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgNikgLyB0aWNrV2lkdGgsIC0xLCAxKSksXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpIC0gTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heExhYmVsSGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKVxuICAgICAgKSk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gTWF0aC5tYXgobWluUm90YXRpb24sIE1hdGgubWluKG1heFJvdGF0aW9uLCBsYWJlbFJvdGF0aW9uKSk7XG4gICAgfVxuXG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbGFiZWxSb3RhdGlvbjtcbiAgfVxuICBhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICB9XG4gIGFmdGVyQXV0b1NraXAoKSB7fVxuXG4gIC8vXG5cbiAgYmVmb3JlRml0KCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcbiAgfVxuICBmaXQoKSB7XG4gICAgLy8gUmVzZXRcbiAgICBjb25zdCBtaW5TaXplID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuXG4gICAgY29uc3Qge2NoYXJ0LCBvcHRpb25zOiB7dGlja3M6IHRpY2tPcHRzLCB0aXRsZTogdGl0bGVPcHRzLCBncmlkOiBncmlkT3B0c319ID0gdGhpcztcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5faXNWaXNpYmxlKCk7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcblxuICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICBjb25zdCB0aXRsZUhlaWdodCA9IGdldFRpdGxlSGVpZ2h0KHRpdGxlT3B0cywgY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG4gICAgICAgIG1pblNpemUud2lkdGggPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgYm90aGVyIGZpdHRpbmcgdGhlIHRpY2tzIGlmIHdlIGFyZSBub3Qgc2hvd2luZyB0aGUgbGFiZWxzXG4gICAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiB0aGlzLnRpY2tzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHdpZGVzdCwgaGlnaGVzdH0gPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgICAgIGNvbnN0IHRpY2tQYWRkaW5nID0gdGlja09wdHMucGFkZGluZyAqIDI7XG4gICAgICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuXG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgLy8gQSBob3Jpem9udGFsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgaGVpZ2h0LlxuICAgICAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gdGlja09wdHMubWlycm9yID8gMCA6IHNpbiAqIHdpZGVzdC53aWR0aCArIGNvcyAqIGhpZ2hlc3QuaGVpZ2h0O1xuICAgICAgICAgIG1pblNpemUuaGVpZ2h0ID0gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIG1pblNpemUuaGVpZ2h0ICsgbGFiZWxIZWlnaHQgKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEEgdmVydGljYWwgYXhpcyBpcyBtb3JlIGNvbnN0cmFpbmVkIGJ5IHRoZSB3aWR0aC4gTGFiZWxzIGFyZSB0aGVcbiAgICAgICAgLy8gZG9taW5hbnQgZmFjdG9yIGhlcmUsIHNvIGdldCB0aGF0IGxlbmd0aCBmaXJzdCBhbmQgYWNjb3VudCBmb3IgcGFkZGluZ1xuICAgICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogY29zICogd2lkZXN0LndpZHRoICsgc2luICogaGlnaGVzdC5oZWlnaHQ7XG5cbiAgICAgICAgICBtaW5TaXplLndpZHRoID0gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhYmVsV2lkdGggKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2hhbmRsZU1hcmdpbnMoKTtcblxuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLl9sZW5ndGggPSBjaGFydC53aWR0aCAtIHRoaXMuX21hcmdpbnMubGVmdCAtIHRoaXMuX21hcmdpbnMucmlnaHQ7XG4gICAgICB0aGlzLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gbWluU2l6ZS53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQuaGVpZ2h0IC0gdGhpcy5fbWFyZ2lucy50b3AgLSB0aGlzLl9tYXJnaW5zLmJvdHRvbTtcbiAgICB9XG4gIH1cblxuICBfY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpIHtcbiAgICBjb25zdCB7dGlja3M6IHthbGlnbiwgcGFkZGluZ30sIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBpc1JvdGF0ZWQgPSB0aGlzLmxhYmVsUm90YXRpb24gIT09IDA7XG4gICAgY29uc3QgbGFiZWxzQmVsb3dUaWNrcyA9IHBvc2l0aW9uICE9PSAndG9wJyAmJiB0aGlzLmF4aXMgPT09ICd4JztcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gdGhpcy5nZXRQaXhlbEZvclRpY2soMCkgLSB0aGlzLmxlZnQ7XG4gICAgICBjb25zdCBvZmZzZXRSaWdodCA9IHRoaXMucmlnaHQgLSB0aGlzLmdldFBpeGVsRm9yVGljayh0aGlzLnRpY2tzLmxlbmd0aCAtIDEpO1xuICAgICAgbGV0IHBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgIGxldCBwYWRkaW5nUmlnaHQgPSAwO1xuXG4gICAgICAvLyBFbnN1cmUgdGhhdCBvdXIgdGlja3MgYXJlIGFsd2F5cyBpbnNpZGUgdGhlIGNhbnZhcy4gV2hlbiByb3RhdGVkLCB0aWNrcyBhcmUgcmlnaHQgYWxpZ25lZFxuICAgICAgLy8gd2hpY2ggbWVhbnMgdGhhdCB0aGUgcmlnaHQgcGFkZGluZyBpcyBkb21pbmF0ZWQgYnkgdGhlIGZvbnQgaGVpZ2h0XG4gICAgICBpZiAoaXNSb3RhdGVkKSB7XG4gICAgICAgIGlmIChsYWJlbHNCZWxvd1RpY2tzKSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBjb3MgKiBmaXJzdC53aWR0aDtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBzaW4gKiBsYXN0LmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IHNpbiAqIGZpcnN0LmhlaWdodDtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBjb3MgKiBsYXN0LndpZHRoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiAhPT0gJ2lubmVyJykge1xuICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoIC8gMjtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aCAvIDI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkanVzdCBwYWRkaW5nIHRha2luZyBpbnRvIGFjY291bnQgY2hhbmdlcyBpbiBvZmZzZXRzXG4gICAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgoKHBhZGRpbmdMZWZ0IC0gb2Zmc2V0TGVmdCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0TGVmdCksIDApO1xuICAgICAgdGhpcy5wYWRkaW5nUmlnaHQgPSBNYXRoLm1heCgocGFkZGluZ1JpZ2h0IC0gb2Zmc2V0UmlnaHQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldFJpZ2h0KSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQgLyAyO1xuICAgICAgbGV0IHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQgLyAyO1xuXG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IDA7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQ7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wICsgcGFkZGluZztcbiAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b20gKyBwYWRkaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgbWFyZ2lucyBhbmQgcGFkZGluZyBpbnRlcmFjdGlvbnNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9oYW5kbGVNYXJnaW5zKCkge1xuICAgIGlmICh0aGlzLl9tYXJnaW5zKSB7XG4gICAgICB0aGlzLl9tYXJnaW5zLmxlZnQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdMZWZ0LCB0aGlzLl9tYXJnaW5zLmxlZnQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy50b3AgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdUb3AsIHRoaXMuX21hcmdpbnMudG9wKTtcbiAgICAgIHRoaXMuX21hcmdpbnMucmlnaHQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdSaWdodCwgdGhpcy5fbWFyZ2lucy5yaWdodCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLmJvdHRvbSA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0JvdHRvbSwgdGhpcy5fbWFyZ2lucy5ib3R0b20pO1xuICAgIH1cbiAgfVxuXG4gIGFmdGVyRml0KCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbdGhpc10pO1xuICB9XG5cbiAgLy8gU2hhcmVkIE1ldGhvZHNcbiAgLyoqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3Qge2F4aXMsIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBheGlzID09PSAneCc7XG4gIH1cbiAgLyoqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuICBpc0Z1bGxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnVsbFNpemU7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29udmVydFRpY2tzVG9MYWJlbHModGlja3MpIHtcbiAgICB0aGlzLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuXG4gICAgdGhpcy5nZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpO1xuXG4gICAgLy8gVGlja3Mgc2hvdWxkIGJlIHNraXBwZWQgd2hlbiBjYWxsYmFjayByZXR1cm5zIG51bGwgb3IgdW5kZWYsIHNvIGxldHMgcmVtb3ZlIHRob3NlLlxuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHRpY2tzW2ldLmxhYmVsKSkge1xuICAgICAgICB0aWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGlsZW4tLTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHt7IGZpcnN0OiBvYmplY3QsIGxhc3Q6IG9iamVjdCwgd2lkZXN0OiBvYmplY3QsIGhpZ2hlc3Q6IG9iamVjdCwgd2lkdGhzOiBBcnJheSwgaGVpZ2h0czogYXJyYXkgfX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbFNpemVzKCkge1xuICAgIGxldCBsYWJlbFNpemVzID0gdGhpcy5fbGFiZWxTaXplcztcblxuICAgIGlmICghbGFiZWxTaXplcykge1xuICAgICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWNrcy5zYW1wbGVTaXplO1xuICAgICAgbGV0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICAgIGlmIChzYW1wbGVTaXplIDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICAgIHRpY2tzID0gc2FtcGxlKHRpY2tzLCBzYW1wbGVTaXplKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IGxhYmVsU2l6ZXMgPSB0aGlzLl9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgdGlja3MubGVuZ3RoLCB0aGlzLm9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsU2l6ZXM7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB7d2lkdGgsIGhlaWdodCwgb2Zmc2V0fSBvYmplY3RzIGZvciB0aGUgZmlyc3QsIGxhc3QsIHdpZGVzdCwgaGlnaGVzdCB0aWNrXG5cdCAqIGxhYmVscyB3aGVyZSBvZmZzZXQgaW5kaWNhdGVzIHRoZSBhbmNob3IgcG9pbnQgb2Zmc2V0IGZyb20gdGhlIHRvcCBpbiBwaXhlbHMuXG5cdCAqIEByZXR1cm4ge3sgZmlyc3Q6IG9iamVjdCwgbGFzdDogb2JqZWN0LCB3aWRlc3Q6IG9iamVjdCwgaGlnaGVzdDogb2JqZWN0LCB3aWR0aHM6IEFycmF5LCBoZWlnaHRzOiBhcnJheSB9fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVMYWJlbFNpemVzKHRpY2tzLCBsZW5ndGgsIG1heFRpY2tzTGltaXQpIHtcbiAgICBjb25zdCB7Y3R4LCBfbG9uZ2VzdFRleHRDYWNoZTogY2FjaGVzfSA9IHRoaXM7XG4gICAgY29uc3Qgd2lkdGhzID0gW107XG4gICAgY29uc3QgaGVpZ2h0cyA9IFtdO1xuICAgIGNvbnN0IGluY3JlbWVudCA9IE1hdGguZmxvb3IobGVuZ3RoIC8gZ2V0VGlja3NMaW1pdChsZW5ndGgsIG1heFRpY2tzTGltaXQpKTtcbiAgICBsZXQgd2lkZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaGlnaGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGksIGosIGpsZW4sIGxhYmVsLCB0aWNrRm9udCwgZm9udFN0cmluZywgY2FjaGUsIGxpbmVIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIG5lc3RlZExhYmVsO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBpbmNyZW1lbnQpIHtcbiAgICAgIGxhYmVsID0gdGlja3NbaV0ubGFiZWw7XG4gICAgICB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBjdHguZm9udCA9IGZvbnRTdHJpbmcgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICBjYWNoZSA9IGNhY2hlc1tmb250U3RyaW5nXSA9IGNhY2hlc1tmb250U3RyaW5nXSB8fCB7ZGF0YToge30sIGdjOiBbXX07XG4gICAgICBsaW5lSGVpZ2h0ID0gdGlja0ZvbnQubGluZUhlaWdodDtcbiAgICAgIHdpZHRoID0gaGVpZ2h0ID0gMDtcbiAgICAgIC8vIFVuZGVmaW5lZCBsYWJlbHMgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobGFiZWwpICYmICFpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbGFiZWwpO1xuICAgICAgICBoZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICAvLyBpZiBpdCBpcyBhbiBhcnJheSBsZXQncyBtZWFzdXJlIGVhY2ggZWxlbWVudFxuICAgICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGFiZWwubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgICAgbmVzdGVkTGFiZWwgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGxhYmVsW2pdKTtcbiAgICAgICAgICAvLyBVbmRlZmluZWQgbGFiZWxzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihuZXN0ZWRMYWJlbCkgJiYgIWlzQXJyYXkobmVzdGVkTGFiZWwpKSB7XG4gICAgICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbmVzdGVkTGFiZWwpO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aWR0aHMucHVzaCh3aWR0aCk7XG4gICAgICBoZWlnaHRzLnB1c2goaGVpZ2h0KTtcbiAgICAgIHdpZGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KHdpZHRoLCB3aWRlc3RMYWJlbFNpemUpO1xuICAgICAgaGlnaGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KGhlaWdodCwgaGlnaGVzdExhYmVsU2l6ZSk7XG4gICAgfVxuICAgIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKTtcblxuICAgIGNvbnN0IHdpZGVzdCA9IHdpZHRocy5pbmRleE9mKHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgY29uc3QgaGlnaGVzdCA9IGhlaWdodHMuaW5kZXhPZihoaWdoZXN0TGFiZWxTaXplKTtcblxuICAgIGNvbnN0IHZhbHVlQXQgPSAoaWR4KSA9PiAoe3dpZHRoOiB3aWR0aHNbaWR4XSB8fCAwLCBoZWlnaHQ6IGhlaWdodHNbaWR4XSB8fCAwfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZmlyc3Q6IHZhbHVlQXQoMCksXG4gICAgICBsYXN0OiB2YWx1ZUF0KGxlbmd0aCAtIDEpLFxuICAgICAgd2lkZXN0OiB2YWx1ZUF0KHdpZGVzdCksXG4gICAgICBoaWdoZXN0OiB2YWx1ZUF0KGhpZ2hlc3QpLFxuICAgICAgd2lkdGhzLFxuICAgICAgaGVpZ2h0cyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIFVzZWQgdG8gZ2V0IHRoZSBsYWJlbCB0byBkaXNwbGF5IGluIHRoZSB0b29sdGlwIGZvciB0aGUgZ2l2ZW4gdmFsdWVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSBnaXZlbiBkYXRhIHBvaW50LiBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVzZWQgdG8gZ2V0IHRoZSBkYXRhIHZhbHVlIGZyb20gYSBnaXZlbiBwaXhlbC4gVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBnZXRQaXhlbEZvclZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2YgdGhlIHRpY2sgYXQgdGhlIGdpdmVuIGluZGV4XG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgZm9yIGdldHRpbmcgdGhlIHBpeGVsIGxvY2F0aW9uIG9mIGEgcGVyY2VudGFnZSBvZiBzY2FsZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JEZWNpbWFsKGRlY2ltYWwpIHtcbiAgICBpZiAodGhpcy5fcmV2ZXJzZVBpeGVscykge1xuICAgICAgZGVjaW1hbCA9IDEgLSBkZWNpbWFsO1xuICAgIH1cblxuICAgIGNvbnN0IHBpeGVsID0gdGhpcy5fc3RhcnRQaXhlbCArIGRlY2ltYWwgKiB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIF9pbnQxNlJhbmdlKHRoaXMuX2FsaWduVG9QaXhlbHMgPyBfYWxpZ25QaXhlbCh0aGlzLmNoYXJ0LCBwaXhlbCwgMCkgOiBwaXhlbCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSAocGl4ZWwgLSB0aGlzLl9zdGFydFBpeGVsKSAvIHRoaXMuX2xlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZVBpeGVscyA/IDEgLSBkZWNpbWFsIDogZGVjaW1hbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwaXhlbCBmb3IgdGhlIG1pbmltdW0gY2hhcnQgdmFsdWVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldEJhc2VWYWx1ZSgpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcblxuICAgIHJldHVybiBtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuICAgICAgbWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcbiAgICAgIDA7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0Q29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcyB8fCBbXTtcblxuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgICAgcmV0dXJuIHRpY2suJGNvbnRleHQgfHxcblx0XHRcdFx0KHRpY2suJGNvbnRleHQgPSBjcmVhdGVUaWNrQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHRpY2spKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlU2NhbGVDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzKSk7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3RpY2tTaXplKCkge1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHNwYWNlIG5lZWRlZCBieSBsYWJlbCBpbiBheGlzIGRpcmVjdGlvbi5cbiAgICBjb25zdCByb3QgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihyb3QpKTtcblxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgcGFkZGluZyA9IG9wdGlvblRpY2tzLmF1dG9Ta2lwUGFkZGluZyB8fCAwO1xuICAgIGNvbnN0IHcgPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy53aWRlc3Qud2lkdGggKyBwYWRkaW5nIDogMDtcbiAgICBjb25zdCBoID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBwYWRkaW5nIDogMDtcblxuICAgIC8vIENhbGN1bGF0ZSBzcGFjZSBuZWVkZWQgZm9yIDEgdGljayBpbiBheGlzIGRpcmVjdGlvbi5cbiAgICByZXR1cm4gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyBoICogY29zID4gdyAqIHNpbiA/IHcgLyBjb3MgOiBoIC8gc2luXG4gICAgICA6IGggKiBzaW4gPCB3ICogY29zID8gaCAvIGNvcyA6IHcgLyBzaW47XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9pc1Zpc2libGUoKSB7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMub3B0aW9ucy5kaXNwbGF5O1xuXG4gICAgaWYgKGRpc3BsYXkgIT09ICdhdXRvJykge1xuICAgICAgcmV0dXJuICEhZGlzcGxheTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtncmlkLCBwb3NpdGlvbiwgYm9yZGVyfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZ3JpZC5vZmZzZXQ7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgdGlja3NMZW5ndGggPSB0aWNrcy5sZW5ndGggKyAob2Zmc2V0ID8gMSA6IDApO1xuICAgIGNvbnN0IHRsID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZCk7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcblxuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBib3JkZXIuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gYm9yZGVyT3B0cy5kaXNwbGF5ID8gYm9yZGVyT3B0cy53aWR0aCA6IDA7XG4gICAgY29uc3QgYXhpc0hhbGZXaWR0aCA9IGF4aXNXaWR0aCAvIDI7XG4gICAgY29uc3QgYWxpZ25Cb3JkZXJWYWx1ZSA9IGZ1bmN0aW9uKHBpeGVsKSB7XG4gICAgICByZXR1cm4gX2FsaWduUGl4ZWwoY2hhcnQsIHBpeGVsLCBheGlzV2lkdGgpO1xuICAgIH07XG4gICAgbGV0IGJvcmRlclZhbHVlLCBpLCBsaW5lVmFsdWUsIGFsaWduZWRMaW5lVmFsdWU7XG4gICAgbGV0IHR4MSwgdHkxLCB0eDIsIHR5MiwgeDEsIHkxLCB4MiwgeTI7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5ib3R0b20pO1xuICAgICAgdHkxID0gdGhpcy5ib3R0b20gLSB0bDtcbiAgICAgIHR5MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEudG9wKSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnRvcCk7XG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmJvdHRvbSkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHkyID0gdGhpcy50b3AgKyB0bDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnJpZ2h0KTtcbiAgICAgIHR4MSA9IHRoaXMucmlnaHQgLSB0bDtcbiAgICAgIHR4MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEubGVmdCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMubGVmdCk7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5yaWdodCkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdGhpcy5sZWZ0ICsgdGw7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyICsgMC41KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG5cbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHR5MSArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMik7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICB0eDEgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDIgPSB0eDEgLSB0bDtcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9XG5cbiAgICBjb25zdCBsaW1pdCA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCwgdGlja3NMZW5ndGgpO1xuICAgIGNvbnN0IHN0ZXAgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwodGlja3NMZW5ndGggLyBsaW1pdCkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aWNrc0xlbmd0aDsgaSArPSBzdGVwKSB7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KGkpO1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQoY29udGV4dCk7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleEJvcmRlciA9IGJvcmRlci5zZXRDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgICBjb25zdCBsaW5lV2lkdGggPSBvcHRzQXRJbmRleC5saW5lV2lkdGg7XG4gICAgICBjb25zdCBsaW5lQ29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzQXRJbmRleEJvcmRlci5kYXNoIHx8IFtdO1xuICAgICAgY29uc3QgYm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4Qm9yZGVyLmRhc2hPZmZzZXQ7XG5cbiAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IG9wdHNBdEluZGV4LnRpY2tXaWR0aDtcbiAgICAgIGNvbnN0IHRpY2tDb2xvciA9IG9wdHNBdEluZGV4LnRpY2tDb2xvcjtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2ggfHwgW107XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoT2Zmc2V0O1xuXG4gICAgICBsaW5lVmFsdWUgPSBnZXRQaXhlbEZvckdyaWRMaW5lKHRoaXMsIGksIG9mZnNldCk7XG5cbiAgICAgIC8vIFNraXAgaWYgdGhlIHBpeGVsIGlzIG91dCBvZiB0aGUgcmFuZ2VcbiAgICAgIGlmIChsaW5lVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYWxpZ25lZExpbmVWYWx1ZSA9IF9hbGlnblBpeGVsKGNoYXJ0LCBsaW5lVmFsdWUsIGxpbmVXaWR0aCk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgdHgxID0gdHgyID0geDEgPSB4MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eTEgPSB0eTIgPSB5MSA9IHkyID0gYWxpZ25lZExpbmVWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIHR4MSxcbiAgICAgICAgdHkxLFxuICAgICAgICB0eDIsXG4gICAgICAgIHR5MixcbiAgICAgICAgeDEsXG4gICAgICAgIHkxLFxuICAgICAgICB4MixcbiAgICAgICAgeTIsXG4gICAgICAgIHdpZHRoOiBsaW5lV2lkdGgsXG4gICAgICAgIGNvbG9yOiBsaW5lQ29sb3IsXG4gICAgICAgIGJvcmRlckRhc2gsXG4gICAgICAgIGJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgIHRpY2tXaWR0aCxcbiAgICAgICAgdGlja0NvbG9yLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgdGlja0JvcmRlckRhc2hPZmZzZXQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IHRpY2tzTGVuZ3RoO1xuICAgIHRoaXMuX2JvcmRlclZhbHVlID0gYm9yZGVyVmFsdWU7XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczogb3B0aW9uVGlja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB7YWxpZ24sIGNyb3NzQWxpZ24sIHBhZGRpbmcsIG1pcnJvcn0gPSBvcHRpb25UaWNrcztcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZCk7XG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgY29uc3QgaFRpY2tBbmRQYWRkaW5nID0gbWlycm9yID8gLXBhZGRpbmcgOiB0aWNrQW5kUGFkZGluZztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrLCBsYWJlbCwgeCwgeSwgdGV4dEFsaWduLCBwaXhlbCwgZm9udCwgbGluZUhlaWdodCwgbGluZUNvdW50LCB0ZXh0T2Zmc2V0O1xuICAgIGxldCB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHkgPSB0aGlzLmJvdHRvbSAtIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgeSA9IHRoaXMudG9wICsgaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XG4gICAgICB0ZXh0QWxpZ24gPSByZXQudGV4dEFsaWduO1xuICAgICAgeCA9IHJldC54O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICB5ID0gKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICB5ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeCA9ICgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMikgLSB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeCA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpLnRleHRBbGlnbjtcbiAgICB9XG5cbiAgICBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIGxhYmVsID0gdGljay5sYWJlbDtcblxuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBvcHRpb25UaWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpKSk7XG4gICAgICBwaXhlbCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKGkpICsgb3B0aW9uVGlja3MubGFiZWxPZmZzZXQ7XG4gICAgICBmb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGxpbmVIZWlnaHQgPSBmb250LmxpbmVIZWlnaHQ7XG4gICAgICBsaW5lQ291bnQgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsLmxlbmd0aCA6IDE7XG4gICAgICBjb25zdCBoYWxmQ291bnQgPSBsaW5lQ291bnQgLyAyO1xuICAgICAgY29uc3QgY29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZUNvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgICBsZXQgdGlja1RleHRBbGlnbiA9IHRleHRBbGlnbjtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB4ID0gcGl4ZWw7XG5cbiAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2lubmVyJykge1xuICAgICAgICAgIGlmIChpID09PSBpbGVuIC0gMSkge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gIXRoaXMub3B0aW9ucy5yZXZlcnNlID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxpbmVDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodCArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZWx5LWlmXG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC0gbGluZUNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICAgIHRleHRPZmZzZXQgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdGF0aW9uICE9PSAwICYmICFvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICAgIHggKz0gKGxpbmVIZWlnaHQgLyAyKSAqIE1hdGguc2luKHJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHBpeGVsO1xuICAgICAgICB0ZXh0T2Zmc2V0ID0gKDEgLSBsaW5lQ291bnQpICogbGluZUhlaWdodCAvIDI7XG4gICAgICB9XG5cbiAgICAgIGxldCBiYWNrZHJvcDtcblxuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsUGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBsYWJlbFNpemVzLmhlaWdodHNbaV07XG4gICAgICAgIGNvbnN0IHdpZHRoID0gbGFiZWxTaXplcy53aWR0aHNbaV07XG5cbiAgICAgICAgbGV0IHRvcCA9IHRleHRPZmZzZXQgLSBsYWJlbFBhZGRpbmcudG9wO1xuICAgICAgICBsZXQgbGVmdCA9IDAgLSBsYWJlbFBhZGRpbmcubGVmdDtcblxuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRleHRBbGlnbikge1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5uZXInOlxuICAgICAgICAgIGlmIChpID09PSBpbGVuIC0gMSkge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBiYWNrZHJvcCA9IHtcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICB3aWR0aDogd2lkdGggKyBsYWJlbFBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBsYWJlbFBhZGRpbmcuaGVpZ2h0LFxuXG4gICAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3IsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgZm9udCxcbiAgICAgICAgdGV4dE9mZnNldCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIHN0cm9rZUNvbG9yLFxuICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIHRleHRBbGlnbjogdGlja1RleHRBbGlnbixcbiAgICAgICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgdHJhbnNsYXRpb246IFt4LCB5XSxcbiAgICAgICAgICBiYWNrZHJvcCxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKSB7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrc30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG5cbiAgICBpZiAocm90YXRpb24pIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH1cblxuICAgIGxldCBhbGlnbiA9ICdjZW50ZXInO1xuXG4gICAgaWYgKHRpY2tzLmFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnZW5kJykge1xuICAgICAgYWxpZ24gPSAncmlnaHQnO1xuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgIGFsaWduID0gJ2lubmVyJztcbiAgICB9XG5cbiAgICByZXR1cm4gYWxpZ247XG4gIH1cblxuICBfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IHtjcm9zc0FsaWduLCBtaXJyb3IsIHBhZGRpbmd9fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IHdpZGVzdCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuXG4gICAgbGV0IHRleHRBbGlnbjtcbiAgICBsZXQgeDtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0ICsgcGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ICs9IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgLSB0aWNrQW5kUGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICB4ID0gdGhpcy5sZWZ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgcGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICB4IC09IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHRpY2tBbmRQYWRkaW5nO1xuXG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9IHdpZGVzdCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ID0gdGhpcy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgIH1cblxuICAgIHJldHVybiB7dGV4dEFsaWduLCB4fTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVMYWJlbEFyZWEoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aWNrcy5taXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgcmV0dXJuIHt0b3A6IDAsIGxlZnQ6IHRoaXMubGVmdCwgYm90dG9tOiBjaGFydC5oZWlnaHQsIHJpZ2h0OiB0aGlzLnJpZ2h0fTtcbiAgICB9IGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4ge3RvcDogdGhpcy50b3AsIGxlZnQ6IDAsIGJvdHRvbTogdGhpcy5ib3R0b20sIHJpZ2h0OiBjaGFydC53aWR0aH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtiYWNrZ3JvdW5kQ29sb3J9LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHR9ID0gdGhpcztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cblxuICBnZXRMaW5lV2lkdGhGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICFncmlkLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgaW5kZXggPSB0aWNrcy5maW5kSW5kZXgodCA9PiB0LnZhbHVlID09PSB2YWx1ZSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IG9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICByZXR1cm4gb3B0cy5saW5lV2lkdGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdHcmlkKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dyaWRMaW5lSXRlbXMgfHwgKHRoaXMuX2dyaWRMaW5lSXRlbXMgPSB0aGlzLl9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpKTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGNvbnN0IGRyYXdMaW5lID0gKHAxLCBwMiwgc3R5bGUpID0+IHtcbiAgICAgIGlmICghc3R5bGUud2lkdGggfHwgIXN0eWxlLmNvbG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChzdHlsZS5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQ7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueSk7XG4gICAgICBjdHgubGluZVRvKHAyLngsIHAyLnkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuXG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgaWYgKGdyaWQuZHJhd09uQ2hhcnRBcmVhKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS54MSwgeTogaXRlbS55MX0sXG4gICAgICAgICAgICB7eDogaXRlbS54MiwgeTogaXRlbS55Mn0sXG4gICAgICAgICAgICBpdGVtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChncmlkLmRyYXdUaWNrcykge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0udHgxLCB5OiBpdGVtLnR5MX0sXG4gICAgICAgICAgICB7eDogaXRlbS50eDIsIHk6IGl0ZW0udHkyfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29sb3I6IGl0ZW0udGlja0NvbG9yLFxuICAgICAgICAgICAgICB3aWR0aDogaXRlbS50aWNrV2lkdGgsXG4gICAgICAgICAgICAgIGJvcmRlckRhc2g6IGl0ZW0udGlja0JvcmRlckRhc2gsXG4gICAgICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IGl0ZW0udGlja0JvcmRlckRhc2hPZmZzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdCb3JkZXIoKSB7XG4gICAgY29uc3Qge2NoYXJ0LCBjdHgsIG9wdGlvbnM6IHtib3JkZXIsIGdyaWR9fSA9IHRoaXM7XG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGJvcmRlci5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBheGlzV2lkdGggPSBib3JkZXIuZGlzcGxheSA/IGJvcmRlck9wdHMud2lkdGggOiAwO1xuICAgIGlmICghYXhpc1dpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3RMaW5lV2lkdGggPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KDApKS5saW5lV2lkdGg7XG4gICAgY29uc3QgYm9yZGVyVmFsdWUgPSB0aGlzLl9ib3JkZXJWYWx1ZTtcbiAgICBsZXQgeDEsIHgyLCB5MSwgeTI7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgeDEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5sZWZ0LCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHgyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICB5MSA9IHkyID0gYm9yZGVyVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMudG9wLCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHkyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMuYm90dG9tLCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeDEgPSB4MiA9IGJvcmRlclZhbHVlO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJPcHRzLndpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlck9wdHMuY29sb3I7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdMYWJlbHMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG5cbiAgICBpZiAoIW9wdGlvblRpY2tzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcblxuICAgIGNvbnN0IGFyZWEgPSB0aGlzLl9jb21wdXRlTGFiZWxBcmVhKCk7XG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLmdldExhYmVsSXRlbXMoY2hhcnRBcmVhKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIGNvbnN0IHJlbmRlclRleHRPcHRpb25zID0gaXRlbS5vcHRpb25zO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSBpdGVtLmZvbnQ7XG4gICAgICBjb25zdCBsYWJlbCA9IGl0ZW0ubGFiZWw7XG4gICAgICBjb25zdCB5ID0gaXRlbS50ZXh0T2Zmc2V0O1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxhYmVsLCAwLCB5LCB0aWNrRm9udCwgcmVuZGVyVGV4dE9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChhcmVhKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9zaXRpb24sIHRpdGxlLCByZXZlcnNlfX0gPSB0aGlzO1xuXG4gICAgaWYgKCF0aXRsZS5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZm9udCA9IHRvRm9udCh0aXRsZS5mb250KTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlLnBhZGRpbmcpO1xuICAgIGNvbnN0IGFsaWduID0gdGl0bGUuYWxpZ247XG4gICAgbGV0IG9mZnNldCA9IGZvbnQubGluZUhlaWdodCAvIDI7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nIHx8IHBvc2l0aW9uID09PSAnY2VudGVyJyB8fCBpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLmJvdHRvbTtcbiAgICAgIGlmIChpc0FycmF5KHRpdGxlLnRleHQpKSB7XG4gICAgICAgIG9mZnNldCArPSBmb250LmxpbmVIZWlnaHQgKiAodGl0bGUudGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcudG9wO1xuICAgIH1cblxuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IHRpdGxlQXJncyh0aGlzLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbik7XG5cbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGUudGV4dCwgMCwgMCwgZm9udCwge1xuICAgICAgY29sb3I6IHRpdGxlLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG5cbiAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICB0aGlzLmRyYXdCb3JkZXIoKTtcbiAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2xheWVycygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHR6ID0gb3B0cy50aWNrcyAmJiBvcHRzLnRpY2tzLnogfHwgMDtcbiAgICBjb25zdCBneiA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuZ3JpZCAmJiBvcHRzLmdyaWQueiwgLTEpO1xuICAgIGNvbnN0IGJ6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ib3JkZXIgJiYgb3B0cy5ib3JkZXIueiwgMCk7XG5cbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8IHRoaXMuZHJhdyAhPT0gU2NhbGUucHJvdG90eXBlLmRyYXcpIHtcbiAgICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGRyYXcgaGFzIGJlZW4gb3ZlcnJpZGRlbiBieSBjdXN0b20gc2NhbGVcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiB0eixcbiAgICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICAgIHRoaXMuZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3tcbiAgICAgIHo6IGd6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICAgICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiBieixcbiAgICAgIGRyYXc6ICgpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogdHosXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1dO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdmlzaWJsZSBkYXRhc2V0IG1ldGFzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIHRoaXMgc2NhbGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSAtIGlmIHNwZWNpZmllZCwgYWxzbyBmaWx0ZXIgYnkgZGF0YXNldCB0eXBlXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKi9cbiAgZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkge1xuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5jaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgYXhpc0lEID0gdGhpcy5heGlzICsgJ0F4aXNJRCc7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgICBpZiAobWV0YVtheGlzSURdID09PSB0aGlzLmlkICYmICghdHlwZSB8fCBtZXRhLnR5cGUgPT09IHR5cGUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcmV0dXJuIHtvYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcbiBcdCAqL1xuICBfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpbmRleCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnMudGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICByZXR1cm4gdG9Gb250KG9wdHMuZm9udCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX21heERpZ2l0cygpIHtcbiAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkubGluZUhlaWdodDtcbiAgICByZXR1cm4gKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQpIC8gZm9udFNpemU7XG4gIH1cbn1cbiIsICJpbXBvcnQge21lcmdlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCBkZWZhdWx0cywge292ZXJyaWRlc30gZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e2lkOiBzdHJpbmcsIGRlZmF1bHRzOiBhbnksIG92ZXJyaWRlcz86IGFueSwgZGVmYXVsdFJvdXRlczogYW55fX0gSUNoYXJ0Q29tcG9uZW50XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHlwZWRSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIHNjb3BlLCBvdmVycmlkZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgICB0aGlzLml0ZW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIGlzRm9yVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKHRoaXMudHlwZS5wcm90b3R5cGUsIHR5cGUucHJvdG90eXBlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0lDaGFydENvbXBvbmVudH0gaXRlbVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc2NvcGUgd2hlcmUgaXRlbXMgZGVmYXVsdHMgd2VyZSByZWdpc3RlcmVkIHRvLlxuXHQgKi9cbiAgcmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGl0ZW0pO1xuICAgIGxldCBwYXJlbnRTY29wZTtcblxuICAgIGlmIChpc0lDaGFydENvbXBvbmVudChwcm90bykpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcGFyZW50IGlzIHJlZ2lzdGVyZWQgYW5kIG5vdGUgdGhlIHNjb3BlIHdoZXJlIGl0cyBkZWZhdWx0cyBhcmUuXG4gICAgICBwYXJlbnRTY29wZSA9IHRoaXMucmVnaXN0ZXIocHJvdG8pO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlICsgJy4nICsgaWQ7XG5cbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsYXNzIGRvZXMgbm90IGhhdmUgaWQ6ICcgKyBpdGVtKTtcbiAgICB9XG5cbiAgICBpZiAoaWQgaW4gaXRlbXMpIHtcbiAgICAgIC8vIGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cblxuICAgIGl0ZW1zW2lkXSA9IGl0ZW07XG4gICAgcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpO1xuICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICBkZWZhdWx0cy5vdmVycmlkZShpdGVtLmlkLCBpdGVtLm92ZXJyaWRlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjb3BlO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7b2JqZWN0P31cblx0ICovXG4gIGdldChpZCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zW2lkXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0lDaGFydENvbXBvbmVudH0gaXRlbVxuXHQgKi9cbiAgdW5yZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGU7XG5cbiAgICBpZiAoaWQgaW4gaXRlbXMpIHtcbiAgICAgIGRlbGV0ZSBpdGVtc1tpZF07XG4gICAgfVxuXG4gICAgaWYgKHNjb3BlICYmIGlkIGluIGRlZmF1bHRzW3Njb3BlXSkge1xuICAgICAgZGVsZXRlIGRlZmF1bHRzW3Njb3BlXVtpZF07XG4gICAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGVmYXVsdHMgYW5kIGtlZXAgZXhpc3RpbmcgZGVmYXVsdHNcbiAgY29uc3QgaXRlbURlZmF1bHRzID0gbWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW1xuICAgIHBhcmVudFNjb3BlID8gZGVmYXVsdHMuZ2V0KHBhcmVudFNjb3BlKSA6IHt9LFxuICAgIGRlZmF1bHRzLmdldChzY29wZSksXG4gICAgaXRlbS5kZWZhdWx0c1xuICBdKTtcblxuICBkZWZhdWx0cy5zZXQoc2NvcGUsIGl0ZW1EZWZhdWx0cyk7XG5cbiAgaWYgKGl0ZW0uZGVmYXVsdFJvdXRlcykge1xuICAgIHJvdXRlRGVmYXVsdHMoc2NvcGUsIGl0ZW0uZGVmYXVsdFJvdXRlcyk7XG4gIH1cblxuICBpZiAoaXRlbS5kZXNjcmlwdG9ycykge1xuICAgIGRlZmF1bHRzLmRlc2NyaWJlKHNjb3BlLCBpdGVtLmRlc2NyaXB0b3JzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByb3V0ZURlZmF1bHRzKHNjb3BlLCByb3V0ZXMpIHtcbiAgT2JqZWN0LmtleXMocm91dGVzKS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICBjb25zdCBwcm9wZXJ0eVBhcnRzID0gcHJvcGVydHkuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBzb3VyY2VOYW1lID0gcHJvcGVydHlQYXJ0cy5wb3AoKTtcbiAgICBjb25zdCBzb3VyY2VTY29wZSA9IFtzY29wZV0uY29uY2F0KHByb3BlcnR5UGFydHMpLmpvaW4oJy4nKTtcbiAgICBjb25zdCBwYXJ0cyA9IHJvdXRlc1twcm9wZXJ0eV0uc3BsaXQoJy4nKTtcbiAgICBjb25zdCB0YXJnZXROYW1lID0gcGFydHMucG9wKCk7XG4gICAgY29uc3QgdGFyZ2V0U2NvcGUgPSBwYXJ0cy5qb2luKCcuJyk7XG4gICAgZGVmYXVsdHMucm91dGUoc291cmNlU2NvcGUsIHNvdXJjZU5hbWUsIHRhcmdldFNjb3BlLCB0YXJnZXROYW1lKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSB7XG4gIHJldHVybiAnaWQnIGluIHByb3RvICYmICdkZWZhdWx0cycgaW4gcHJvdG87XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4vY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQgRWxlbWVudCBmcm9tICcuL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCBUeXBlZFJlZ2lzdHJ5IGZyb20gJy4vY29yZS50eXBlZFJlZ2lzdHJ5LmpzJztcbmltcG9ydCB7ZWFjaCwgY2FsbGJhY2sgYXMgY2FsbCwgX2NhcGl0YWxpemV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBQbGVhc2UgdXNlIHRoZSBtb2R1bGUncyBkZWZhdWx0IGV4cG9ydCB3aGljaCBwcm92aWRlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZVxuICogTm90ZTogY2xhc3MgaXMgZXhwb3J0ZWQgZm9yIHR5cGVkb2NcbiAqL1xuZXhwb3J0IGNsYXNzIFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb250cm9sbGVycyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KERhdGFzZXRDb250cm9sbGVyLCAnZGF0YXNldHMnLCB0cnVlKTtcbiAgICB0aGlzLmVsZW1lbnRzID0gbmV3IFR5cGVkUmVnaXN0cnkoRWxlbWVudCwgJ2VsZW1lbnRzJyk7XG4gICAgdGhpcy5wbHVnaW5zID0gbmV3IFR5cGVkUmVnaXN0cnkoT2JqZWN0LCAncGx1Z2lucycpO1xuICAgIHRoaXMuc2NhbGVzID0gbmV3IFR5cGVkUmVnaXN0cnkoU2NhbGUsICdzY2FsZXMnKTtcbiAgICAvLyBPcmRlciBpcyBpbXBvcnRhbnQsIFNjYWxlIGhhcyBFbGVtZW50IGluIHByb3RvdHlwZSBjaGFpbixcbiAgICAvLyBzbyBTY2FsZXMgbXVzdCBiZSBiZWZvcmUgRWxlbWVudHMuIFBsdWdpbnMgYXJlIGEgZmFsbGJhY2ssIHNvIG5vdCBsaXN0ZWQgaGVyZS5cbiAgICB0aGlzLl90eXBlZFJlZ2lzdHJpZXMgPSBbdGhpcy5jb250cm9sbGVycywgdGhpcy5zY2FsZXMsIHRoaXMuZWxlbWVudHNdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKi9cbiAgYWRkKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MpO1xuICB9XG5cbiAgcmVtb3ZlKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIERhdGFzZXRDb250cm9sbGVyfSBhcmdzXG5cdCAqL1xuICBhZGRDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgRWxlbWVudH0gYXJnc1xuXHQgKi9cbiAgYWRkRWxlbWVudHMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5lbGVtZW50cyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG5cdCAqL1xuICBhZGRQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIFNjYWxlfSBhcmdzXG5cdCAqL1xuICBhZGRTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7dHlwZW9mIERhdGFzZXRDb250cm9sbGVyfVxuXHQgKi9cbiAgZ2V0Q29udHJvbGxlcihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuY29udHJvbGxlcnMsICdjb250cm9sbGVyJyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHt0eXBlb2YgRWxlbWVudH1cblx0ICovXG4gIGdldEVsZW1lbnQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmVsZW1lbnRzLCAnZWxlbWVudCcpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fVxuXHQgKi9cbiAgZ2V0UGx1Z2luKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5wbHVnaW5zLCAncGx1Z2luJyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHt0eXBlb2YgU2NhbGV9XG5cdCAqL1xuICBnZXRTY2FsZShpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuc2NhbGVzLCAnc2NhbGUnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgRGF0YXNldENvbnRyb2xsZXJ9IGFyZ3Ncblx0ICovXG4gIHJlbW92ZUNvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIEVsZW1lbnR9IGFyZ3Ncblx0ICovXG4gIHJlbW92ZUVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5lbGVtZW50cyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG5cdCAqL1xuICByZW1vdmVQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgU2NhbGV9IGFyZ3Ncblx0ICovXG4gIHJlbW92ZVNjYWxlcyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2VhY2gobWV0aG9kLCBhcmdzLCB0eXBlZFJlZ2lzdHJ5KSB7XG4gICAgWy4uLmFyZ3NdLmZvckVhY2goYXJnID0+IHtcbiAgICAgIGNvbnN0IHJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGFyZyk7XG4gICAgICBpZiAodHlwZWRSZWdpc3RyeSB8fCByZWcuaXNGb3JUeXBlKGFyZykgfHwgKHJlZyA9PT0gdGhpcy5wbHVnaW5zICYmIGFyZy5pZCkpIHtcbiAgICAgICAgdGhpcy5fZXhlYyhtZXRob2QsIHJlZywgYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhbmRsZSBsb29wYWJsZSBhcmdzXG4gICAgICAgIC8vIFVzZSBjYXNlOlxuICAgICAgICAvLyAgaW1wb3J0ICogYXMgcGx1Z2lucyBmcm9tICcuL3BsdWdpbnMuanMnO1xuICAgICAgICAvLyAgQ2hhcnQucmVnaXN0ZXIocGx1Z2lucyk7XG4gICAgICAgIGVhY2goYXJnLCBpdGVtID0+IHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbWl4ZWQgdHlwZXMgaW4gdGhlIGxvb3BhYmxlLCBtYWtlIHN1cmUgdGhvc2UgYXJlXG4gICAgICAgICAgLy8gcmVnaXN0ZXJlZCBpbiBjb3JyZWN0IHJlZ2lzdHJ5XG4gICAgICAgICAgLy8gVXNlIGNhc2U6ICh0cmVlbWFwIGV4cG9ydGluZyBjb250cm9sbGVyLCBlbGVtZW50cyBldGMpXG4gICAgICAgICAgLy8gIGltcG9ydCAqIGFzIHRyZWVtYXAgZnJvbSAnY2hhcnRqcy1jaGFydC10cmVlbWFwLmpzJztcbiAgICAgICAgICAvLyAgQ2hhcnQucmVnaXN0ZXIodHJlZW1hcCk7XG5cbiAgICAgICAgICBjb25zdCBpdGVtUmVnID0gdHlwZWRSZWdpc3RyeSB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUoaXRlbSk7XG4gICAgICAgICAgdGhpcy5fZXhlYyhtZXRob2QsIGl0ZW1SZWcsIGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2V4ZWMobWV0aG9kLCByZWdpc3RyeSwgY29tcG9uZW50KSB7XG4gICAgY29uc3QgY2FtZWxNZXRob2QgPSBfY2FwaXRhbGl6ZShtZXRob2QpO1xuICAgIGNhbGwoY29tcG9uZW50WydiZWZvcmUnICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTsgLy8gYmVmb3JlUmVnaXN0ZXIgLyBiZWZvcmVVbnJlZ2lzdGVyXG4gICAgcmVnaXN0cnlbbWV0aG9kXShjb21wb25lbnQpO1xuICAgIGNhbGwoY29tcG9uZW50WydhZnRlcicgKyBjYW1lbE1ldGhvZF0sIFtdLCBjb21wb25lbnQpOyAvLyBhZnRlclJlZ2lzdGVyIC8gYWZ0ZXJVbnJlZ2lzdGVyXG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSZWdpc3RyeUZvclR5cGUodHlwZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdHlwZWRSZWdpc3RyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZWcgPSB0aGlzLl90eXBlZFJlZ2lzdHJpZXNbaV07XG4gICAgICBpZiAocmVnLmlzRm9yVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gcmVnO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwbHVnaW5zIGlzIHRoZSBmYWxsYmFjayByZWdpc3RyeVxuICAgIHJldHVybiB0aGlzLnBsdWdpbnM7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXQoaWQsIHR5cGVkUmVnaXN0cnksIHR5cGUpIHtcbiAgICBjb25zdCBpdGVtID0gdHlwZWRSZWdpc3RyeS5nZXQoaWQpO1xuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgaWQgKyAnXCIgaXMgbm90IGEgcmVnaXN0ZXJlZCAnICsgdHlwZSArICcuJyk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbn1cblxuLy8gc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgZGVmYXVsdCAvKiAjX19QVVJFX18gKi8gbmV3IFJlZ2lzdHJ5KCk7XG4iLCAiaW1wb3J0IHJlZ2lzdHJ5IGZyb20gJy4vY29yZS5yZWdpc3RyeS5qcyc7XG5pbXBvcnQge2NhbGxiYWNrIGFzIGNhbGxDYWxsYmFjaywgaXNOdWxsT3JVbmRlZiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vcGx1Z2lucy9wbHVnaW4udG9vbHRpcC5qcycpLmRlZmF1bHQgfSBUb29sdGlwXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZmlsdGVyQ2FsbGJhY2tcbiAqIEBwYXJhbSB7e3BsdWdpbjogb2JqZWN0LCBvcHRpb25zOiBvYmplY3R9fSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cbiAqIEBwYXJhbSB7YXJyYXl9IFthcnJheV1cbiAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc0FyZ11cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbHVnaW5TZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faW5pdCA9IFtdO1xuICB9XG5cbiAgLyoqXG5cdCAqIENhbGxzIGVuYWJsZWQgcGx1Z2lucyBmb3IgYGNoYXJ0YCBvbiB0aGUgc3BlY2lmaWVkIGhvb2sgYW5kIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG5cdCAqIFRoaXMgbWV0aG9kIGltbWVkaWF0ZWx5IHJldHVybnMgYXMgc29vbiBhcyBhIHBsdWdpbiBleHBsaWNpdGx5IHJldHVybnMgZmFsc2UuIFRoZVxuXHQgKiByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgdXNlZCwgZm9yIGluc3RhbmNlLCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgYWN0aW9uLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZSBmb3Igd2hpY2ggcGx1Z2lucyBzaG91bGQgYmUgY2FsbGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaG9vayAtIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gbWV0aG9kIHRvIGNhbGwgKGUuZy4gJ2JlZm9yZVVwZGF0ZScpLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW2FyZ3NdIC0gRXh0cmEgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBob29rIGNhbGwuXG4gICAqIEBwYXJhbSB7ZmlsdGVyQ2FsbGJhY2t9IFtmaWx0ZXJdIC0gRmlsdGVyaW5nIGZ1bmN0aW9uIGZvciBsaW1pdGluZyB3aGljaCBwbHVnaW5zIGFyZSBub3RpZmllZFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgYW55IG9mIHRoZSBwbHVnaW5zIHJldHVybiBmYWxzZSwgZWxzZSByZXR1cm5zIHRydWUuXG5cdCAqL1xuICBub3RpZnkoY2hhcnQsIGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIGlmIChob29rID09PSAnYmVmb3JlSW5pdCcpIHtcbiAgICAgIHRoaXMuX2luaXQgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgdHJ1ZSk7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICdpbnN0YWxsJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBmaWx0ZXIgPyB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCkuZmlsdGVyKGZpbHRlcikgOiB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCk7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncyk7XG5cbiAgICBpZiAoaG9vayA9PT0gJ2FmdGVyRGVzdHJveScpIHtcbiAgICAgIHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsICdzdG9wJyk7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICd1bmluc3RhbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpIHtcbiAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICBmb3IgKGNvbnN0IGRlc2NyaXB0b3Igb2YgZGVzY3JpcHRvcnMpIHtcbiAgICAgIGNvbnN0IHBsdWdpbiA9IGRlc2NyaXB0b3IucGx1Z2luO1xuICAgICAgY29uc3QgbWV0aG9kID0gcGx1Z2luW2hvb2tdO1xuICAgICAgY29uc3QgcGFyYW1zID0gW2NoYXJ0LCBhcmdzLCBkZXNjcmlwdG9yLm9wdGlvbnNdO1xuICAgICAgaWYgKGNhbGxDYWxsYmFjayhtZXRob2QsIHBhcmFtcywgcGx1Z2luKSA9PT0gZmFsc2UgJiYgYXJncy5jYW5jZWxhYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGludmFsaWRhdGUoKSB7XG4gICAgLy8gV2hlbiBwbHVnaW5zIGFyZSByZWdpc3RlcmVkLCB0aGVyZSBpcyB0aGUgcG9zc2liaWxpdHkgb2YgYSBkb3VibGVcbiAgICAvLyBpbnZhbGlkYXRlIHNpdHVhdGlvbi4gSW4gdGhpcyBjYXNlLCB3ZSBvbmx5IHdhbnQgdG8gaW52YWxpZGF0ZSBvbmNlLlxuICAgIC8vIElmIHdlIGludmFsaWRhdGUgbXVsdGlwbGUgdGltZXMsIHRoZSBgX29sZENhY2hlYCBpcyBsb3N0IGFuZCBhbGwgb2YgdGhlXG4gICAgLy8gcGx1Z2lucyBhcmUgcmVzdGFydGVkIHdpdGhvdXQgYmVpbmcgY29ycmVjdGx5IHN0b3BwZWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy84MTQ3XG4gICAgaWYgKCFpc051bGxPclVuZGVmKHRoaXMuX2NhY2hlKSkge1xuICAgICAgdGhpcy5fb2xkQ2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICAgIHRoaXMuX2NhY2hlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2Rlc2NyaXB0b3JzKGNoYXJ0KSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGU7XG4gICAgfVxuXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZSA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0KTtcblxuICAgIHRoaXMuX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCk7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH1cblxuICBfY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIGFsbCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNoYXJ0ICYmIGNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBvcHRpb25zID0gdmFsdWVPckRlZmF1bHQoY29uZmlnLm9wdGlvbnMgJiYgY29uZmlnLm9wdGlvbnMucGx1Z2lucywge30pO1xuICAgIGNvbnN0IHBsdWdpbnMgPSBhbGxQbHVnaW5zKGNvbmZpZyk7XG4gICAgLy8gb3B0aW9ucyA9PT0gZmFsc2UgPT4gYWxsIHBsdWdpbnMgYXJlIGRpc2FibGVkXG4gICAgcmV0dXJuIG9wdGlvbnMgPT09IGZhbHNlICYmICFhbGwgPyBbXSA6IGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBwbHVnaW5zLCBvcHRpb25zLCBhbGwpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfbm90aWZ5U3RhdGVDaGFuZ2VzKGNoYXJ0KSB7XG4gICAgY29uc3QgcHJldmlvdXNEZXNjcmlwdG9ycyA9IHRoaXMuX29sZENhY2hlIHx8IFtdO1xuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGU7XG4gICAgY29uc3QgZGlmZiA9IChhLCBiKSA9PiBhLmZpbHRlcih4ID0+ICFiLnNvbWUoeSA9PiB4LnBsdWdpbi5pZCA9PT0geS5wbHVnaW4uaWQpKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihwcmV2aW91c0Rlc2NyaXB0b3JzLCBkZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RvcCcpO1xuICAgIHRoaXMuX25vdGlmeShkaWZmKGRlc2NyaXB0b3JzLCBwcmV2aW91c0Rlc2NyaXB0b3JzKSwgY2hhcnQsICdzdGFydCcpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vY29yZS5jb25maWcuanMnKS5kZWZhdWx0fSBjb25maWdcbiAqL1xuZnVuY3Rpb24gYWxsUGx1Z2lucyhjb25maWcpIHtcbiAgY29uc3QgbG9jYWxJZHMgPSB7fTtcbiAgY29uc3QgcGx1Z2lucyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocmVnaXN0cnkucGx1Z2lucy5pdGVtcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHBsdWdpbnMucHVzaChyZWdpc3RyeS5nZXRQbHVnaW4oa2V5c1tpXSkpO1xuICB9XG5cbiAgY29uc3QgbG9jYWwgPSBjb25maWcucGx1Z2lucyB8fCBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBsdWdpbiA9IGxvY2FsW2ldO1xuXG4gICAgaWYgKHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICBsb2NhbElkc1twbHVnaW4uaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge3BsdWdpbnMsIGxvY2FsSWRzfTtcbn1cblxuZnVuY3Rpb24gZ2V0T3B0cyhvcHRpb25zLCBhbGwpIHtcbiAgaWYgKCFhbGwgJiYgb3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHtwbHVnaW5zLCBsb2NhbElkc30sIG9wdGlvbnMsIGFsbCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgY29udGV4dCA9IGNoYXJ0LmdldENvbnRleHQoKTtcblxuICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3Qgb3B0cyA9IGdldE9wdHMob3B0aW9uc1tpZF0sIGFsbCk7XG4gICAgaWYgKG9wdHMgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh7XG4gICAgICBwbHVnaW4sXG4gICAgICBvcHRpb25zOiBwbHVnaW5PcHRzKGNoYXJ0LmNvbmZpZywge3BsdWdpbiwgbG9jYWw6IGxvY2FsSWRzW2lkXX0sIG9wdHMsIGNvbnRleHQpXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwbHVnaW5PcHRzKGNvbmZpZywge3BsdWdpbiwgbG9jYWx9LCBvcHRzLCBjb250ZXh0KSB7XG4gIGNvbnN0IGtleXMgPSBjb25maWcucGx1Z2luU2NvcGVLZXlzKHBsdWdpbik7XG4gIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXMob3B0cywga2V5cyk7XG4gIGlmIChsb2NhbCAmJiBwbHVnaW4uZGVmYXVsdHMpIHtcbiAgICAvLyBtYWtlIHN1cmUgcGx1Z2luIGRlZmF1bHRzIGFyZSBpbiBzY29wZXMgZm9yIGxvY2FsIChub3QgcmVnaXN0ZXJlZCkgcGx1Z2luc1xuICAgIHNjb3Blcy5wdXNoKHBsdWdpbi5kZWZhdWx0cyk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIFsnJ10sIHtcbiAgICAvLyBUaGVzZSBhcmUganVzdCBkZWZhdWx0cyB0aGF0IHBsdWdpbnMgY2FuIG92ZXJyaWRlXG4gICAgc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBhbGxLZXlzOiB0cnVlXG4gIH0pO1xufVxuIiwgImltcG9ydCBkZWZhdWx0cywge292ZXJyaWRlcywgZGVzY3JpcHRvcnN9IGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge21lcmdlSWYsIHJlc29sdmVPYmplY3RLZXksIGlzQXJyYXksIGlzRnVuY3Rpb24sIHZhbHVlT3JEZWZhdWx0LCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtfYXR0YWNoQ29udGV4dCwgX2NyZWF0ZVJlc29sdmVyLCBfZGVzY3JpcHRvcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb25maWcuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5kZXhBeGlzKHR5cGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge307XG4gIGNvbnN0IGRhdGFzZXRPcHRpb25zID0gKG9wdGlvbnMuZGF0YXNldHMgfHwge30pW3R5cGVdIHx8IHt9O1xuICByZXR1cm4gZGF0YXNldE9wdGlvbnMuaW5kZXhBeGlzIHx8IG9wdGlvbnMuaW5kZXhBeGlzIHx8IGRhdGFzZXREZWZhdWx0cy5pbmRleEF4aXMgfHwgJ3gnO1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGlkLCBpbmRleEF4aXMpIHtcbiAgbGV0IGF4aXMgPSBpZDtcbiAgaWYgKGlkID09PSAnX2luZGV4XycpIHtcbiAgICBheGlzID0gaW5kZXhBeGlzO1xuICB9IGVsc2UgaWYgKGlkID09PSAnX3ZhbHVlXycpIHtcbiAgICBheGlzID0gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG4gIH1cbiAgcmV0dXJuIGF4aXM7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMoYXhpcywgaW5kZXhBeGlzKSB7XG4gIHJldHVybiBheGlzID09PSBpbmRleEF4aXMgPyAnX2luZGV4XycgOiAnX3ZhbHVlXyc7XG59XG5cbmZ1bmN0aW9uIGlkTWF0Y2hlc0F4aXMoaWQpIHtcbiAgaWYgKGlkID09PSAneCcgfHwgaWQgPT09ICd5JyB8fCBpZCA9PT0gJ3InKSB7XG4gICAgcmV0dXJuIGlkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF4aXNGcm9tUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICByZXR1cm4gJ3gnO1xuICB9XG4gIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgcmV0dXJuICd5JztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5lQXhpcyhpZCwgLi4uc2NhbGVPcHRpb25zKSB7XG4gIGlmIChpZE1hdGNoZXNBeGlzKGlkKSkge1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBmb3IgKGNvbnN0IG9wdHMgb2Ygc2NhbGVPcHRpb25zKSB7XG4gICAgY29uc3QgYXhpcyA9IG9wdHMuYXhpc1xuICAgICAgfHwgYXhpc0Zyb21Qb3NpdGlvbihvcHRzLnBvc2l0aW9uKVxuICAgICAgfHwgaWQubGVuZ3RoID4gMSAmJiBpZE1hdGNoZXNBeGlzKGlkWzBdLnRvTG93ZXJDYXNlKCkpO1xuICAgIGlmIChheGlzKSB7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGV0ZXJtaW5lIHR5cGUgb2YgJyR7aWR9JyBheGlzLiBQbGVhc2UgcHJvdmlkZSAnYXhpcycgb3IgJ3Bvc2l0aW9uJyBvcHRpb24uYCk7XG59XG5cbmZ1bmN0aW9uIGdldEF4aXNGcm9tRGF0YXNldChpZCwgYXhpcywgZGF0YXNldCkge1xuICBpZiAoZGF0YXNldFtheGlzICsgJ0F4aXNJRCddID09PSBpZCkge1xuICAgIHJldHVybiB7YXhpc307XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cmlldmVBeGlzRnJvbURhdGFzZXRzKGlkLCBjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5kYXRhICYmIGNvbmZpZy5kYXRhLmRhdGFzZXRzKSB7XG4gICAgY29uc3QgYm91bmREcyA9IGNvbmZpZy5kYXRhLmRhdGFzZXRzLmZpbHRlcigoZCkgPT4gZC54QXhpc0lEID09PSBpZCB8fCBkLnlBeGlzSUQgPT09IGlkKTtcbiAgICBpZiAoYm91bmREcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBnZXRBeGlzRnJvbURhdGFzZXQoaWQsICd4JywgYm91bmREc1swXSkgfHwgZ2V0QXhpc0Zyb21EYXRhc2V0KGlkLCAneScsIGJvdW5kRHNbMF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0RGVmYXVsdHMgPSBvdmVycmlkZXNbY29uZmlnLnR5cGVdIHx8IHtzY2FsZXM6IHt9fTtcbiAgY29uc3QgY29uZmlnU2NhbGVzID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG4gIGNvbnN0IGNoYXJ0SW5kZXhBeGlzID0gZ2V0SW5kZXhBeGlzKGNvbmZpZy50eXBlLCBvcHRpb25zKTtcbiAgY29uc3Qgc2NhbGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvLyBGaXJzdCBmaWd1cmUgb3V0IGZpcnN0IHNjYWxlIGlkJ3MgcGVyIGF4aXMuXG4gIE9iamVjdC5rZXlzKGNvbmZpZ1NjYWxlcykuZm9yRWFjaChpZCA9PiB7XG4gICAgY29uc3Qgc2NhbGVDb25mID0gY29uZmlnU2NhbGVzW2lkXTtcbiAgICBpZiAoIWlzT2JqZWN0KHNjYWxlQ29uZikpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGBJbnZhbGlkIHNjYWxlIGNvbmZpZ3VyYXRpb24gZm9yIHNjYWxlOiAke2lkfWApO1xuICAgIH1cbiAgICBpZiAoc2NhbGVDb25mLl9wcm94eSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihgSWdub3JpbmcgcmVzb2x2ZXIgcGFzc2VkIGFzIG9wdGlvbnMgZm9yIHNjYWxlOiAke2lkfWApO1xuICAgIH1cbiAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVDb25mLCByZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMoaWQsIGNvbmZpZyksIGRlZmF1bHRzLnNjYWxlc1tzY2FsZUNvbmYudHlwZV0pO1xuICAgIGNvbnN0IGRlZmF1bHRJZCA9IGdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMoYXhpcywgY2hhcnRJbmRleEF4aXMpO1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBjaGFydERlZmF1bHRzLnNjYWxlcyB8fCB7fTtcbiAgICBzY2FsZXNbaWRdID0gbWVyZ2VJZihPYmplY3QuY3JlYXRlKG51bGwpLCBbe2F4aXN9LCBzY2FsZUNvbmYsIGRlZmF1bHRTY2FsZU9wdGlvbnNbYXhpc10sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElkXV0pO1xuICB9KTtcblxuICAvLyBUaGVuIG1lcmdlIGRhdGFzZXQgZGVmYXVsdHMgdG8gc2NhbGUgY29uZmlnc1xuICBjb25maWcuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKGRhdGFzZXQgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgY29uZmlnLnR5cGU7XG4gICAgY29uc3QgaW5kZXhBeGlzID0gZGF0YXNldC5pbmRleEF4aXMgfHwgZ2V0SW5kZXhBeGlzKHR5cGUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRhdGFzZXREZWZhdWx0cyA9IG92ZXJyaWRlc1t0eXBlXSB8fCB7fTtcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gZGF0YXNldERlZmF1bHRzLnNjYWxlcyB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhkZWZhdWx0U2NhbGVPcHRpb25zKS5mb3JFYWNoKGRlZmF1bHRJRCA9PiB7XG4gICAgICBjb25zdCBheGlzID0gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChkZWZhdWx0SUQsIGluZGV4QXhpcyk7XG4gICAgICBjb25zdCBpZCA9IGRhdGFzZXRbYXhpcyArICdBeGlzSUQnXSB8fCBheGlzO1xuICAgICAgc2NhbGVzW2lkXSA9IHNjYWxlc1tpZF0gfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIG1lcmdlSWYoc2NhbGVzW2lkXSwgW3theGlzfSwgY29uZmlnU2NhbGVzW2lkXSwgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SURdXSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGFwcGx5IHNjYWxlIGRlZmF1bHRzLCBpZiBub3Qgb3ZlcnJpZGRlbiBieSBkYXRhc2V0IGRlZmF1bHRzXG4gIE9iamVjdC5rZXlzKHNjYWxlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGNvbnN0IHNjYWxlID0gc2NhbGVzW2tleV07XG4gICAgbWVyZ2VJZihzY2FsZSwgW2RlZmF1bHRzLnNjYWxlc1tzY2FsZS50eXBlXSwgZGVmYXVsdHMuc2NhbGVdKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNjYWxlcztcbn1cblxuZnVuY3Rpb24gaW5pdE9wdGlvbnMoY29uZmlnKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBjb25maWcub3B0aW9ucyB8fCAoY29uZmlnLm9wdGlvbnMgPSB7fSk7XG5cbiAgb3B0aW9ucy5wbHVnaW5zID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gIG9wdGlvbnMuc2NhbGVzID0gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YShkYXRhKSB7XG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuICBkYXRhLmRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cyB8fCBbXTtcbiAgZGF0YS5sYWJlbHMgPSBkYXRhLmxhYmVscyB8fCBbXTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGluaXRDb25maWcoY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgY29uZmlnLmRhdGEgPSBpbml0RGF0YShjb25maWcuZGF0YSk7XG5cbiAgaW5pdE9wdGlvbnMoY29uZmlnKTtcblxuICByZXR1cm4gY29uZmlnO1xufVxuXG5jb25zdCBrZXlDYWNoZSA9IG5ldyBNYXAoKTtcbmNvbnN0IGtleXNDYWNoZWQgPSBuZXcgU2V0KCk7XG5cbmZ1bmN0aW9uIGNhY2hlZEtleXMoY2FjaGVLZXksIGdlbmVyYXRlKSB7XG4gIGxldCBrZXlzID0ga2V5Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IGdlbmVyYXRlKCk7XG4gICAga2V5Q2FjaGUuc2V0KGNhY2hlS2V5LCBrZXlzKTtcbiAgICBrZXlzQ2FjaGVkLmFkZChrZXlzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuY29uc3QgYWRkSWZGb3VuZCA9IChzZXQsIG9iaiwga2V5KSA9PiB7XG4gIGNvbnN0IG9wdHMgPSByZXNvbHZlT2JqZWN0S2V5KG9iaiwga2V5KTtcbiAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHNldC5hZGQob3B0cyk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuX2NvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl9zY29wZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBnZXQgcGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbGF0Zm9ybTtcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcudHlwZTtcbiAgfVxuXG4gIHNldCB0eXBlKHR5cGUpIHtcbiAgICB0aGlzLl9jb25maWcudHlwZSA9IHR5cGU7XG4gIH1cblxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmRhdGE7XG4gIH1cblxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5fY29uZmlnLmRhdGEgPSBpbml0RGF0YShkYXRhKTtcbiAgfVxuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcub3B0aW9ucztcbiAgfVxuXG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBnZXQgcGx1Z2lucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsdWdpbnM7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5fY29uZmlnO1xuICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgIGluaXRPcHRpb25zKGNvbmZpZyk7XG4gIH1cblxuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlLmNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9uIHNjb3BlIGtleXMgZm9yIHJlc29sdmluZyBkYXRhc2V0IG9wdGlvbnMuXG4gICAqIFRoZXNlIGtleXMgZG8gbm90IGluY2x1ZGUgdGhlIGRhdGFzZXQgaXRzZWxmLCBiZWNhdXNlIGl0IGlzIG5vdCB1bmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YXNldFR5cGVcbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIGRhdGFzZXRTY29wZUtleXMoZGF0YXNldFR5cGUpIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhkYXRhc2V0VHlwZSxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgICcnXG4gICAgICBdXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9uIHNjb3BlIGtleXMgZm9yIHJlc29sdmluZyBkYXRhc2V0IGFuaW1hdGlvbiBvcHRpb25zLlxuICAgKiBUaGVzZSBrZXlzIGRvIG5vdCBpbmNsdWRlIHRoZSBkYXRhc2V0IGl0c2VsZiwgYmVjYXVzZSBpdCBpcyBub3QgdW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFzZXRUeXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2l0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdW119XG4gICAqL1xuICBkYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKGRhdGFzZXRUeXBlLCB0cmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb24uJHt0cmFuc2l0aW9ufWAsXG4gICAgICAoKSA9PiBbXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgICAgYHRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICBdLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZSB1c2VkIGZvciBsb29raW5nIHVwIHRoZSBgYW5pbWF0aW9uc2AgYW5kIGBhbmltYXRpb25gIGtleXNcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgICAgJydcbiAgICAgICAgXVxuICAgICAgXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9ucyBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgZWxlbWVudCBvcHRpb25zIHRoYXQgYmVsb25nXG4gICAqIHRvIGFuIGRhdGFzZXQuIFRoZXNlIGtleXMgZG8gbm90IGluY2x1ZGUgdGhlIGRhdGFzZXQgaXRzZWxmLCBiZWNhdXNlIGl0XG4gICAqIGlzIG5vdCB1bmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YXNldFR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRUeXBlXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdW119XG4gICAqL1xuICBkYXRhc2V0RWxlbWVudFNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgZWxlbWVudFR5cGUpIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0tJHtlbGVtZW50VHlwZX1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LmVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgYGVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb25zIHNjb3BlIGtleXMgZm9yIHJlc29sdmluZyBwbHVnaW4gb3B0aW9ucy5cbiAgICogQHBhcmFtIHt7aWQ6IHN0cmluZywgYWRkaXRpb25hbE9wdGlvblNjb3Blcz86IHN0cmluZ1tdfX0gcGx1Z2luXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdW119XG4gICAqL1xuICBwbHVnaW5TY29wZUtleXMocGx1Z2luKSB7XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZTtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHt0eXBlfS1wbHVnaW4tJHtpZH1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYHBsdWdpbnMuJHtpZH1gLFxuICAgICAgICAuLi5wbHVnaW4uYWRkaXRpb25hbE9wdGlvblNjb3BlcyB8fCBbXSxcbiAgICAgIF1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NhY2hlZFNjb3BlcyhtYWluU2NvcGUsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCBfc2NvcGVDYWNoZSA9IHRoaXMuX3Njb3BlQ2FjaGU7XG4gICAgbGV0IGNhY2hlID0gX3Njb3BlQ2FjaGUuZ2V0KG1haW5TY29wZSk7XG4gICAgaWYgKCFjYWNoZSB8fCByZXNldENhY2hlKSB7XG4gICAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgIF9zY29wZUNhY2hlLnNldChtYWluU2NvcGUsIGNhY2hlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIHRoZSBvYmplY3RzIGZyb20gb3B0aW9ucyBhbmQgZGVmYXVsdHMgZm9yIG9wdGlvbiB2YWx1ZSByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbWFpblNjb3BlIC0gVGhlIG1haW4gc2NvcGUgb2JqZWN0IGZvciBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nW11bXX0ga2V5TGlzdHMgLSBUaGUgYXJyYXlzIG9mIGtleXMgaW4gcmVzb2x1dGlvbiBvcmRlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNldENhY2hlXSAtIHJlc2V0IHRoZSBjYWNoZSBmb3IgdGhpcyBtYWluU2NvcGVcbiAgICovXG4gIGdldE9wdGlvblNjb3BlcyhtYWluU2NvcGUsIGtleUxpc3RzLCByZXNldENhY2hlKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIHR5cGV9ID0gdGhpcztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZFNjb3BlcyhtYWluU2NvcGUsIHJlc2V0Q2FjaGUpO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXlMaXN0cyk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG5cbiAgICBjb25zdCBzY29wZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBrZXlMaXN0cy5mb3JFYWNoKGtleXMgPT4ge1xuICAgICAgaWYgKG1haW5TY29wZSkge1xuICAgICAgICBzY29wZXMuYWRkKG1haW5TY29wZSk7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG1haW5TY29wZSwga2V5KSk7XG4gICAgICB9XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvcHRpb25zLCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSwga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBkZWZhdWx0cywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBkZXNjcmlwdG9ycywga2V5KSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBhcnJheSA9IEFycmF5LmZyb20oc2NvcGVzKTtcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICBhcnJheS5wdXNoKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIH1cbiAgICBpZiAoa2V5c0NhY2hlZC5oYXMoa2V5TGlzdHMpKSB7XG4gICAgICBjYWNoZS5zZXQoa2V5TGlzdHMsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbiBzY29wZXMgZm9yIHJlc29sdmluZyBjaGFydCBvcHRpb25zXG4gICAqIEByZXR1cm4ge29iamVjdFtdfVxuICAgKi9cbiAgY2hhcnRPcHRpb25TY29wZXMoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIHR5cGV9ID0gdGhpcztcblxuICAgIHJldHVybiBbXG4gICAgICBvcHRpb25zLFxuICAgICAgb3ZlcnJpZGVzW3R5cGVdIHx8IHt9LFxuICAgICAgZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge30sIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy84NTMxXG4gICAgICB7dHlwZX0sXG4gICAgICBkZWZhdWx0cyxcbiAgICAgIGRlc2NyaXB0b3JzXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdFtdfSBzY29wZXNcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gbmFtZXNcbiAgICogQHBhcmFtIHtmdW5jdGlvbnxvYmplY3R9IGNvbnRleHRcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3ByZWZpeGVzXVxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqL1xuICByZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHskc2hhcmVkOiB0cnVlfTtcbiAgICBjb25zdCB7cmVzb2x2ZXIsIHN1YlByZWZpeGVzfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIGxldCBvcHRpb25zID0gcmVzb2x2ZXI7XG4gICAgaWYgKG5lZWRDb250ZXh0KHJlc29sdmVyLCBuYW1lcykpIHtcbiAgICAgIHJlc3VsdC4kc2hhcmVkID0gZmFsc2U7XG4gICAgICBjb250ZXh0ID0gaXNGdW5jdGlvbihjb250ZXh0KSA/IGNvbnRleHQoKSA6IGNvbnRleHQ7XG4gICAgICAvLyBzdWJSZXNvbHZlciBpcyBwYXNzZWQgdG8gc2NyaXB0YWJsZSBvcHRpb25zLiBJdCBzaG91bGQgbm90IHJlc29sdmUgdG8gaG92ZXIgb3B0aW9ucy5cbiAgICAgIGNvbnN0IHN1YlJlc29sdmVyID0gdGhpcy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHN1YlByZWZpeGVzKTtcbiAgICAgIG9wdGlvbnMgPSBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgc3ViUmVzb2x2ZXIpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgICAgcmVzdWx0W3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdFtdfSBzY29wZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XVxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbcHJlZml4ZXNdXG4gICAqIEBwYXJhbSB7e3NjcmlwdGFibGU6IGJvb2xlYW4sIGluZGV4YWJsZTogYm9vbGVhbiwgYWxsS2V5cz86IGJvb2xlYW59fSBbZGVzY3JpcHRvckRlZmF1bHRzXVxuICAgKi9cbiAgY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10sIGRlc2NyaXB0b3JEZWZhdWx0cykge1xuICAgIGNvbnN0IHtyZXNvbHZlcn0gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICByZXR1cm4gaXNPYmplY3QoY29udGV4dClcbiAgICAgID8gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHVuZGVmaW5lZCwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICAgICAgOiByZXNvbHZlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZXNvbHZlcihyZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKSB7XG4gIGxldCBjYWNoZSA9IHJlc29sdmVyQ2FjaGUuZ2V0KHNjb3Blcyk7XG4gIGlmICghY2FjaGUpIHtcbiAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICByZXNvbHZlckNhY2hlLnNldChzY29wZXMsIGNhY2hlKTtcbiAgfVxuICBjb25zdCBjYWNoZUtleSA9IHByZWZpeGVzLmpvaW4oKTtcbiAgbGV0IGNhY2hlZCA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghY2FjaGVkKSB7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBfY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgY2FjaGVkID0ge1xuICAgICAgcmVzb2x2ZXIsXG4gICAgICBzdWJQcmVmaXhlczogcHJlZml4ZXMuZmlsdGVyKHAgPT4gIXAudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnaG92ZXInKSlcbiAgICB9O1xuICAgIGNhY2hlLnNldChjYWNoZUtleSwgY2FjaGVkKTtcbiAgfVxuICByZXR1cm4gY2FjaGVkO1xufVxuXG5jb25zdCBoYXNGdW5jdGlvbiA9IHZhbHVlID0+IGlzT2JqZWN0KHZhbHVlKVxuICAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkuc29tZSgoa2V5KSA9PiBpc0Z1bmN0aW9uKHZhbHVlW2tleV0pKTtcblxuZnVuY3Rpb24gbmVlZENvbnRleHQocHJveHksIG5hbWVzKSB7XG4gIGNvbnN0IHtpc1NjcmlwdGFibGUsIGlzSW5kZXhhYmxlfSA9IF9kZXNjcmlwdG9ycyhwcm94eSk7XG5cbiAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgY29uc3Qgc2NyaXB0YWJsZSA9IGlzU2NyaXB0YWJsZShwcm9wKTtcbiAgICBjb25zdCBpbmRleGFibGUgPSBpc0luZGV4YWJsZShwcm9wKTtcbiAgICBjb25zdCB2YWx1ZSA9IChpbmRleGFibGUgfHwgc2NyaXB0YWJsZSkgJiYgcHJveHlbcHJvcF07XG4gICAgaWYgKChzY3JpcHRhYmxlICYmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBoYXNGdW5jdGlvbih2YWx1ZSkpKVxuICAgICAgfHwgKGluZGV4YWJsZSAmJiBpc0FycmF5KHZhbHVlKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCAiaW1wb3J0IGFuaW1hdG9yIGZyb20gJy4vY29yZS5hbmltYXRvci5qcyc7XG5pbXBvcnQgZGVmYXVsdHMsIHtvdmVycmlkZXN9IGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24gZnJvbSAnLi9jb3JlLmludGVyYWN0aW9uLmpzJztcbmltcG9ydCBsYXlvdXRzIGZyb20gJy4vY29yZS5sYXlvdXRzLmpzJztcbmltcG9ydCB7X2RldGVjdFBsYXRmb3JtfSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5pbXBvcnQgUGx1Z2luU2VydmljZSBmcm9tICcuL2NvcmUucGx1Z2lucy5qcyc7XG5pbXBvcnQgcmVnaXN0cnkgZnJvbSAnLi9jb3JlLnJlZ2lzdHJ5LmpzJztcbmltcG9ydCBDb25maWcsIHtkZXRlcm1pbmVBeGlzLCBnZXRJbmRleEF4aXN9IGZyb20gJy4vY29yZS5jb25maWcuanMnO1xuaW1wb3J0IHtlYWNoLCBjYWxsYmFjayBhcyBjYWxsQ2FsbGJhY2ssIHVpZCwgdmFsdWVPckRlZmF1bHQsIF9lbGVtZW50c0VxdWFsLCBpc051bGxPclVuZGVmLCBzZXRzRXF1YWwsIGRlZmluZWQsIGlzRnVuY3Rpb24sIF9pc0NsaWNrRXZlbnR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Y2xlYXJDYW52YXMsIGNsaXBBcmVhLCBjcmVhdGVDb250ZXh0LCB1bmNsaXBBcmVhLCBfaXNQb2ludEluQXJlYSwgX2lzRG9tU3VwcG9ydGVkLCByZXRpbmFTY2FsZSwgZ2V0RGF0YXNldENsaXBBcmVhfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7dmVyc2lvbn0gZnJvbSAnLi4vLi4vcGFja2FnZS5qc29uJztcbmltcG9ydCB7ZGVib3VuY2V9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5Qb2ludCB9IFBvaW50XG4gKi9cblxuY29uc3QgS05PV05fUE9TSVRJT05TID0gWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnLCAnY2hhcnRBcmVhJ107XG5mdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbiwgYXhpcykge1xuICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCAoS05PV05fUE9TSVRJT05TLmluZGV4T2YocG9zaXRpb24pID09PSAtMSAmJiBheGlzID09PSAneCcpO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlMkxldmVsKGwxLCBsMikge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhW2wxXSA9PT0gYltsMV1cbiAgICAgID8gYVtsMl0gLSBiW2wyXVxuICAgICAgOiBhW2wxXSAtIGJbbDFdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbkFuaW1hdGlvbnNDb21wbGV0ZShjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuXG4gIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyUmVuZGVyJyk7XG4gIGNhbGxDYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Db21wbGV0ZSwgW2NvbnRleHRdLCBjaGFydCk7XG59XG5cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uUHJvZ3Jlc3MoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgY2FsbENhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cblxuLyoqXG4gKiBDaGFydC5qcyBjYW4gdGFrZSBhIHN0cmluZyBpZCBvZiBhIGNhbnZhcyBlbGVtZW50LCBhIDJkIGNvbnRleHQsIG9yIGEgY2FudmFzIGVsZW1lbnQgaXRzZWxmLlxuICogQXR0ZW1wdCB0byB1bndyYXAgdGhlIGl0ZW0gcGFzc2VkIGludG8gdGhlIGNoYXJ0IGNvbnN0cnVjdG9yIHNvIHRoYXQgaXQgaXMgYSBjYW52YXMgZWxlbWVudCAoaWYgcG9zc2libGUpLlxuICovXG5mdW5jdGlvbiBnZXRDYW52YXMoaXRlbSkge1xuICBpZiAoX2lzRG9tU3VwcG9ydGVkKCkgJiYgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaXRlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGl0ZW0pO1xuICB9IGVsc2UgaWYgKGl0ZW0gJiYgaXRlbS5sZW5ndGgpIHtcbiAgICAvLyBTdXBwb3J0IGZvciBhcnJheSBiYXNlZCBxdWVyaWVzIChzdWNoIGFzIGpRdWVyeSlcbiAgICBpdGVtID0gaXRlbVswXTtcbiAgfVxuXG4gIGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG4gICAgLy8gU3VwcG9ydCBmb3IgYW55IG9iamVjdCBhc3NvY2lhdGVkIHRvIGEgY2FudmFzIChpbmNsdWRpbmcgYSBjb250ZXh0MmQpXG4gICAgaXRlbSA9IGl0ZW0uY2FudmFzO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuXG5jb25zdCBpbnN0YW5jZXMgPSB7fTtcbmNvbnN0IGdldENoYXJ0ID0gKGtleSkgPT4ge1xuICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoa2V5KTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaW5zdGFuY2VzKS5maWx0ZXIoKGMpID0+IGMuY2FudmFzID09PSBjYW52YXMpLnBvcCgpO1xufTtcblxuZnVuY3Rpb24gbW92ZU51bWVyaWNLZXlzKG9iaiwgc3RhcnQsIG1vdmUpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBpbnRLZXkgPSAra2V5O1xuICAgIGlmIChpbnRLZXkgPj0gc3RhcnQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICBpZiAobW92ZSA+IDAgfHwgaW50S2V5ID4gc3RhcnQpIHtcbiAgICAgICAgb2JqW2ludEtleSArIG1vdmVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGFydEV2ZW50fSBlXG4gKiBAcGFyYW0ge0NoYXJ0RXZlbnR8bnVsbH0gbGFzdEV2ZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluQ2hhcnRBcmVhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzQ2xpY2tcbiAqIEByZXR1cm5zIHtDaGFydEV2ZW50fG51bGx9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUxhc3RFdmVudChlLCBsYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKSB7XG4gIGlmICghaW5DaGFydEFyZWEgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzQ2xpY2spIHtcbiAgICByZXR1cm4gbGFzdEV2ZW50O1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5jbGFzcyBDaGFydCB7XG5cbiAgc3RhdGljIGRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIHN0YXRpYyBpbnN0YW5jZXMgPSBpbnN0YW5jZXM7XG4gIHN0YXRpYyBvdmVycmlkZXMgPSBvdmVycmlkZXM7XG4gIHN0YXRpYyByZWdpc3RyeSA9IHJlZ2lzdHJ5O1xuICBzdGF0aWMgdmVyc2lvbiA9IHZlcnNpb247XG4gIHN0YXRpYyBnZXRDaGFydCA9IGdldENoYXJ0O1xuXG4gIHN0YXRpYyByZWdpc3RlciguLi5pdGVtcykge1xuICAgIHJlZ2lzdHJ5LmFkZCguLi5pdGVtcyk7XG4gICAgaW52YWxpZGF0ZVBsdWdpbnMoKTtcbiAgfVxuXG4gIHN0YXRpYyB1bnJlZ2lzdGVyKC4uLml0ZW1zKSB7XG4gICAgcmVnaXN0cnkucmVtb3ZlKC4uLml0ZW1zKTtcbiAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG4gIGNvbnN0cnVjdG9yKGl0ZW0sIHVzZXJDb25maWcpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZyA9IG5ldyBDb25maWcodXNlckNvbmZpZyk7XG4gICAgY29uc3QgaW5pdGlhbENhbnZhcyA9IGdldENhbnZhcyhpdGVtKTtcbiAgICBjb25zdCBleGlzdGluZ0NoYXJ0ID0gZ2V0Q2hhcnQoaW5pdGlhbENhbnZhcyk7XG4gICAgaWYgKGV4aXN0aW5nQ2hhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0NhbnZhcyBpcyBhbHJlYWR5IGluIHVzZS4gQ2hhcnQgd2l0aCBJRCBcXCcnICsgZXhpc3RpbmdDaGFydC5pZCArICdcXCcnICtcblx0XHRcdFx0JyBtdXN0IGJlIGRlc3Ryb3llZCBiZWZvcmUgdGhlIGNhbnZhcyB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmNhbnZhcy5pZCArICdcXCcgY2FuIGJlIHJldXNlZC4nXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcblxuICAgIHRoaXMucGxhdGZvcm0gPSBuZXcgKGNvbmZpZy5wbGF0Zm9ybSB8fCBfZGV0ZWN0UGxhdGZvcm0oaW5pdGlhbENhbnZhcykpKCk7XG4gICAgdGhpcy5wbGF0Zm9ybS51cGRhdGVDb25maWcoY29uZmlnKTtcblxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLnBsYXRmb3JtLmFjcXVpcmVDb250ZXh0KGluaXRpYWxDYW52YXMsIG9wdGlvbnMuYXNwZWN0UmF0aW8pO1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQgJiYgY29udGV4dC5jYW52YXM7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzICYmIGNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMgJiYgY2FudmFzLndpZHRoO1xuXG4gICAgdGhpcy5pZCA9IHVpZCgpO1xuICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gU3RvcmUgdGhlIHByZXZpb3VzbHkgdXNlZCBhc3BlY3QgcmF0aW8gdG8gZGV0ZXJtaW5lIGlmIGEgcmVzaXplXG4gICAgLy8gaXMgbmVlZGVkIGR1cmluZyB1cGRhdGVzLiBEbyB0aGlzIGFmdGVyIF9vcHRpb25zIGlzIHNldCBzaW5jZVxuICAgIC8vIGFzcGVjdFJhdGlvIHVzZXMgYSBnZXR0ZXJcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgdGhpcy5fbWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLl9zdGFja3MgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3hlcyA9IFtdO1xuICAgIHRoaXMuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFydEFyZWEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fYWN0aXZlID0gW107XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIC8qKiBAdHlwZSB7P3thdHRhY2g/OiBmdW5jdGlvbiwgZGV0YWNoPzogZnVuY3Rpb24sIHJlc2l6ZT86IGZ1bmN0aW9ufX0gKi9cbiAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gW107XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLl9wbHVnaW5zID0gbmV3IFBsdWdpblNlcnZpY2UoKTtcbiAgICB0aGlzLiRwcm94aWVzID0ge307XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlcyA9IHt9O1xuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kb1Jlc2l6ZSA9IGRlYm91bmNlKG1vZGUgPT4gdGhpcy51cGRhdGUobW9kZSksIG9wdGlvbnMucmVzaXplRGVsYXkgfHwgMCk7XG4gICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcblxuICAgIC8vIEFkZCB0aGUgY2hhcnQgaW5zdGFuY2UgdG8gdGhlIGdsb2JhbCBuYW1lc3BhY2VcbiAgICBpbnN0YW5jZXNbdGhpcy5pZF0gPSB0aGlzO1xuXG4gICAgaWYgKCFjb250ZXh0IHx8ICFjYW52YXMpIHtcbiAgICAgIC8vIFRoZSBnaXZlbiBpdGVtIGlzIG5vdCBhIGNvbXBhdGlibGUgY29udGV4dDJkIGVsZW1lbnQsIGxldCdzIHJldHVybiBiZWZvcmUgZmluYWxpemluZ1xuICAgICAgLy8gdGhlIGNoYXJ0IGluaXRpYWxpemF0aW9uIGJ1dCBhZnRlciBzZXR0aW5nIGJhc2ljIGNoYXJ0IC8gY29udHJvbGxlciBwcm9wZXJ0aWVzIHRoYXRcbiAgICAgIC8vIGNhbiBoZWxwIHRvIGZpZ3VyZSBvdXQgdGhhdCB0aGUgY2hhcnQgaXMgbm90IHZhbGlkIChlLmcgY2hhcnQuY2FudmFzICE9PSBudWxsKTtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFydDogY2FuJ3QgYWNxdWlyZSBjb250ZXh0IGZyb20gdGhlIGdpdmVuIGl0ZW1cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdjb21wbGV0ZScsIG9uQW5pbWF0aW9uc0NvbXBsZXRlKTtcbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ3Byb2dyZXNzJywgb25BbmltYXRpb25Qcm9ncmVzcyk7XG5cbiAgICB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGFzcGVjdFJhdGlvKCkge1xuICAgIGNvbnN0IHtvcHRpb25zOiB7YXNwZWN0UmF0aW8sIG1haW50YWluQXNwZWN0UmF0aW99LCB3aWR0aCwgaGVpZ2h0LCBfYXNwZWN0UmF0aW99ID0gdGhpcztcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYoYXNwZWN0UmF0aW8pKSB7XG4gICAgICAvLyBJZiBhc3BlY3RSYXRpbyBpcyBkZWZpbmVkIGluIG9wdGlvbnMsIHVzZSB0aGF0LlxuICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgIH1cblxuICAgIGlmIChtYWludGFpbkFzcGVjdFJhdGlvICYmIF9hc3BlY3RSYXRpbykge1xuICAgICAgLy8gSWYgbWFpbnRhaW5Bc3BlY3RSYXRpbyBpcyB0cnV0aGx5IGFuZCB3ZSBoYWQgcHJldmlvdXNseSBkZXRlcm1pbmVkIF9hc3BlY3RSYXRpbywgdXNlIHRoYXRcbiAgICAgIHJldHVybiBfYXNwZWN0UmF0aW87XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlXG4gICAgcmV0dXJuIGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogbnVsbDtcbiAgfVxuXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhO1xuICB9XG5cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuY29uZmlnLmRhdGEgPSBkYXRhO1xuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cblxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBnZXQgcmVnaXN0cnkoKSB7XG4gICAgcmV0dXJuIHJlZ2lzdHJ5O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICAvLyBCZWZvcmUgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVJbml0Jyk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldGluYVNjYWxlKHRoaXMsIHRoaXMub3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB9XG5cbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcblxuICAgIC8vIEFmdGVyIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJJbml0Jyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIGNsZWFyQ2FudmFzKHRoaXMuY2FudmFzLCB0aGlzLmN0eCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIGFuaW1hdG9yLnN0b3AodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogUmVzaXplIHRoZSBjaGFydCB0byBpdHMgY29udGFpbmVyIG9yIHRvIGV4cGxpY2l0IGRpbWVuc2lvbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XVxuXHQgKi9cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWFuaW1hdG9yLnJ1bm5pbmcodGhpcykpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IHt3aWR0aCwgaGVpZ2h0fTtcbiAgICB9XG4gIH1cblxuICBfcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gb3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIHRoaXMuYXNwZWN0UmF0aW87XG4gICAgY29uc3QgbmV3U2l6ZSA9IHRoaXMucGxhdGZvcm0uZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgbmV3UmF0aW8gPSBvcHRpb25zLmRldmljZVBpeGVsUmF0aW8gfHwgdGhpcy5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgY29uc3QgbW9kZSA9IHRoaXMud2lkdGggPyAncmVzaXplJyA6ICdhdHRhY2gnO1xuXG4gICAgdGhpcy53aWR0aCA9IG5ld1NpemUud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdTaXplLmhlaWdodDtcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgaWYgKCFyZXRpbmFTY2FsZSh0aGlzLCBuZXdSYXRpbywgdHJ1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2l6ZScsIHtzaXplOiBuZXdTaXplfSk7XG5cbiAgICBjYWxsQ2FsbGJhY2sob3B0aW9ucy5vblJlc2l6ZSwgW3RoaXMsIG5ld1NpemVdLCB0aGlzKTtcblxuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICBpZiAodGhpcy5fZG9SZXNpemUobW9kZSkpIHtcbiAgICAgICAgLy8gVGhlIHJlc2l6ZSB1cGRhdGUgaXMgZGVsYXllZCwgb25seSBkcmF3IHdpdGhvdXQgdXBkYXRpbmcuXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZW5zdXJlU2NhbGVzSGF2ZUlEcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlc09wdGlvbnMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcblxuICAgIGVhY2goc2NhbGVzT3B0aW9ucywgKGF4aXNPcHRpb25zLCBheGlzSUQpID0+IHtcbiAgICAgIGF4aXNPcHRpb25zLmlkID0gYXhpc0lEO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEJ1aWxkcyBhIG1hcCBvZiBzY2FsZSBJRCB0byBzY2FsZSBvYmplY3QgZm9yIGZ1dHVyZSBsb29rdXAuXG5cdCAqL1xuICBidWlsZE9yVXBkYXRlU2NhbGVzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVPcHRzID0gb3B0aW9ucy5zY2FsZXM7XG4gICAgY29uc3Qgc2NhbGVzID0gdGhpcy5zY2FsZXM7XG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5rZXlzKHNjYWxlcykucmVkdWNlKChvYmosIGlkKSA9PiB7XG4gICAgICBvYmpbaWRdID0gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sIHt9KTtcbiAgICBsZXQgaXRlbXMgPSBbXTtcblxuICAgIGlmIChzY2FsZU9wdHMpIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KFxuICAgICAgICBPYmplY3Qua2V5cyhzY2FsZU9wdHMpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSBzY2FsZU9wdHNbaWRdO1xuICAgICAgICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpO1xuICAgICAgICAgIGNvbnN0IGlzUmFkaWFsID0gYXhpcyA9PT0gJ3InO1xuICAgICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGF4aXMgPT09ICd4JztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3B0aW9uczogc2NhbGVPcHRpb25zLFxuICAgICAgICAgICAgZHBvc2l0aW9uOiBpc1JhZGlhbCA/ICdjaGFydEFyZWEnIDogaXNIb3Jpem9udGFsID8gJ2JvdHRvbScgOiAnbGVmdCcsXG4gICAgICAgICAgICBkdHlwZTogaXNSYWRpYWwgPyAncmFkaWFsTGluZWFyJyA6IGlzSG9yaXpvbnRhbCA/ICdjYXRlZ29yeScgOiAnbGluZWFyJ1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIGVhY2goaXRlbXMsIChpdGVtKSA9PiB7XG4gICAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSBpdGVtLm9wdGlvbnM7XG4gICAgICBjb25zdCBpZCA9IHNjYWxlT3B0aW9ucy5pZDtcbiAgICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpO1xuICAgICAgY29uc3Qgc2NhbGVUeXBlID0gdmFsdWVPckRlZmF1bHQoc2NhbGVPcHRpb25zLnR5cGUsIGl0ZW0uZHR5cGUpO1xuXG4gICAgICBpZiAoc2NhbGVPcHRpb25zLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb25Jc0hvcml6b250YWwoc2NhbGVPcHRpb25zLnBvc2l0aW9uLCBheGlzKSAhPT0gcG9zaXRpb25Jc0hvcml6b250YWwoaXRlbS5kcG9zaXRpb24pKSB7XG4gICAgICAgIHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9IGl0ZW0uZHBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVkW2lkXSA9IHRydWU7XG4gICAgICBsZXQgc2NhbGUgPSBudWxsO1xuICAgICAgaWYgKGlkIGluIHNjYWxlcyAmJiBzY2FsZXNbaWRdLnR5cGUgPT09IHNjYWxlVHlwZSkge1xuICAgICAgICBzY2FsZSA9IHNjYWxlc1tpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzY2FsZUNsYXNzID0gcmVnaXN0cnkuZ2V0U2NhbGUoc2NhbGVUeXBlKTtcbiAgICAgICAgc2NhbGUgPSBuZXcgc2NhbGVDbGFzcyh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgdHlwZTogc2NhbGVUeXBlLFxuICAgICAgICAgIGN0eDogdGhpcy5jdHgsXG4gICAgICAgICAgY2hhcnQ6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHNjYWxlc1tzY2FsZS5pZF0gPSBzY2FsZTtcbiAgICAgIH1cblxuICAgICAgc2NhbGUuaW5pdChzY2FsZU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIC8vIGNsZWFyIHVwIGRpc2NhcmRlZCBzY2FsZXNcbiAgICBlYWNoKHVwZGF0ZWQsIChoYXNVcGRhdGVkLCBpZCkgPT4ge1xuICAgICAgaWYgKCFoYXNVcGRhdGVkKSB7XG4gICAgICAgIGRlbGV0ZSBzY2FsZXNbaWRdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZWFjaChzY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5jb25maWd1cmUodGhpcywgc2NhbGUsIHNjYWxlLm9wdGlvbnMpO1xuICAgICAgbGF5b3V0cy5hZGRCb3godGhpcywgc2NhbGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlTWV0YXNldHMoKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBjb25zdCBudW1EYXRhID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBudW1NZXRhID0gbWV0YXNldHMubGVuZ3RoO1xuXG4gICAgbWV0YXNldHMuc29ydCgoYSwgYikgPT4gYS5pbmRleCAtIGIuaW5kZXgpO1xuICAgIGlmIChudW1NZXRhID4gbnVtRGF0YSkge1xuICAgICAgZm9yIChsZXQgaSA9IG51bURhdGE7IGkgPCBudW1NZXRhOyArK2kpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgfVxuICAgICAgbWV0YXNldHMuc3BsaWNlKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcbiAgICB9XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBtZXRhc2V0cy5zbGljZSgwKS5zb3J0KGNvbXBhcmUyTGV2ZWwoJ29yZGVyJywgJ2luZGV4JykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKSB7XG4gICAgY29uc3Qge19tZXRhc2V0czogbWV0YXNldHMsIGRhdGE6IHtkYXRhc2V0c319ID0gdGhpcztcbiAgICBpZiAobWV0YXNldHMubGVuZ3RoID4gZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3RhY2tzO1xuICAgIH1cbiAgICBtZXRhc2V0cy5mb3JFYWNoKChtZXRhLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGRhdGFzZXRzLmZpbHRlcih4ID0+IHggPT09IG1ldGEuX2RhdGFzZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCkge1xuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gW107XG4gICAgY29uc3QgZGF0YXNldHMgPSB0aGlzLmRhdGEuZGF0YXNldHM7XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICB0aGlzLl9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRzW2ldO1xuICAgICAgbGV0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCB0aGlzLmNvbmZpZy50eXBlO1xuXG4gICAgICBpZiAobWV0YS50eXBlICYmIG1ldGEudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgfVxuICAgICAgbWV0YS50eXBlID0gdHlwZTtcbiAgICAgIG1ldGEuaW5kZXhBeGlzID0gZGF0YXNldC5pbmRleEF4aXMgfHwgZ2V0SW5kZXhBeGlzKHR5cGUsIHRoaXMub3B0aW9ucyk7XG4gICAgICBtZXRhLm9yZGVyID0gZGF0YXNldC5vcmRlciB8fCAwO1xuICAgICAgbWV0YS5pbmRleCA9IGk7XG4gICAgICBtZXRhLmxhYmVsID0gJycgKyBkYXRhc2V0LmxhYmVsO1xuICAgICAgbWV0YS52aXNpYmxlID0gdGhpcy5pc0RhdGFzZXRWaXNpYmxlKGkpO1xuXG4gICAgICBpZiAobWV0YS5jb250cm9sbGVyKSB7XG4gICAgICAgIG1ldGEuY29udHJvbGxlci51cGRhdGVJbmRleChpKTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLmxpbmtTY2FsZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IENvbnRyb2xsZXJDbGFzcyA9IHJlZ2lzdHJ5LmdldENvbnRyb2xsZXIodHlwZSk7XG4gICAgICAgIGNvbnN0IHtkYXRhc2V0RWxlbWVudFR5cGUsIGRhdGFFbGVtZW50VHlwZX0gPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihDb250cm9sbGVyQ2xhc3MsIHtcbiAgICAgICAgICBkYXRhRWxlbWVudFR5cGU6IHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YUVsZW1lbnRUeXBlKSxcbiAgICAgICAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGRhdGFzZXRFbGVtZW50VHlwZSAmJiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFzZXRFbGVtZW50VHlwZSlcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyQ2xhc3ModGhpcywgaSk7XG4gICAgICAgIG5ld0NvbnRyb2xsZXJzLnB1c2gobWV0YS5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVNZXRhc2V0cygpO1xuICAgIHJldHVybiBuZXdDb250cm9sbGVycztcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXNldCB0aGUgZWxlbWVudHMgb2YgYWxsIGRhdGFzZXRzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzZXRFbGVtZW50cygpIHtcbiAgICBlYWNoKHRoaXMuZGF0YS5kYXRhc2V0cywgKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkgPT4ge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuXHQqIFJlc2V0cyB0aGUgY2hhcnQgYmFjayB0byBpdHMgc3RhdGUgYmVmb3JlIHRoZSBpbml0aWFsIGFuaW1hdGlvblxuXHQqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRzKCk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNldCcpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgIGNvbmZpZy51cGRhdGUoKTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFuaW1zRGlzYWJsZWQgPSB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSAhb3B0aW9ucy5hbmltYXRpb247XG5cbiAgICB0aGlzLl91cGRhdGVTY2FsZXMoKTtcbiAgICB0aGlzLl9jaGVja0V2ZW50QmluZGluZ3MoKTtcbiAgICB0aGlzLl91cGRhdGVIaWRkZW5JbmRpY2VzKCk7XG5cbiAgICAvLyBwbHVnaW5zIG9wdGlvbnMgcmVmZXJlbmNlcyBtaWdodCBoYXZlIGNoYW5nZSwgbGV0J3MgaW52YWxpZGF0ZSB0aGUgY2FjaGVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTExMSNpc3N1ZWNvbW1lbnQtMzU1OTM0MTY3XG4gICAgdGhpcy5fcGx1Z2lucy5pbnZhbGlkYXRlKCk7XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBkYXRhc2V0IGNvbnRyb2xsZXJzIGFyZSB1cGRhdGVkIGFuZCBuZXcgY29udHJvbGxlcnMgYXJlIHJlc2V0XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSB0aGlzLmJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpO1xuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFbGVtZW50c1VwZGF0ZScpO1xuXG4gICAgLy8gTWFrZSBzdXJlIGFsbCBkYXRhc2V0IGNvbnRyb2xsZXJzIGhhdmUgY29ycmVjdCBtZXRhIGRhdGEgY291bnRzXG4gICAgbGV0IG1pblBhZGRpbmcgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY29uc3Qge2NvbnRyb2xsZXJ9ID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGNvbnN0IHJlc2V0ID0gIWFuaW1zRGlzYWJsZWQgJiYgbmV3Q29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSA9PT0gLTE7XG4gICAgICAvLyBOZXcgY29udHJvbGxlcnMgd2lsbCBiZSByZXNldCBhZnRlciB0aGUgbGF5b3V0IHBhc3MsIHNvIHdlIG9ubHkgd2FudCB0byBtb2RpZnlcbiAgICAgIC8vIGVsZW1lbnRzIGFkZGVkIHRvIG5ldyBkYXRhc2V0c1xuICAgICAgY29udHJvbGxlci5idWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXQpO1xuICAgICAgbWluUGFkZGluZyA9IE1hdGgubWF4KCtjb250cm9sbGVyLmdldE1heE92ZXJmbG93KCksIG1pblBhZGRpbmcpO1xuICAgIH1cbiAgICBtaW5QYWRkaW5nID0gdGhpcy5fbWluUGFkZGluZyA9IG9wdGlvbnMubGF5b3V0LmF1dG9QYWRkaW5nID8gbWluUGFkZGluZyA6IDA7XG4gICAgdGhpcy5fdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpO1xuXG4gICAgLy8gT25seSByZXNldCB0aGUgY29udHJvbGxlcnMgaWYgd2UgaGF2ZSBhbmltYXRpb25zXG4gICAgaWYgKCFhbmltc0Rpc2FibGVkKSB7XG4gICAgICAvLyBDYW4gb25seSByZXNldCB0aGUgbmV3IGNvbnRyb2xsZXJzIGFmdGVyIHRoZSBzY2FsZXMgaGF2ZSBiZWVuIHVwZGF0ZWRcbiAgICAgIC8vIFJlc2V0IGlzIGRvbmUgdG8gZ2V0IHRoZSBzdGFydGluZyBwb2ludCBmb3IgdGhlIGluaXRpYWwgYW5pbWF0aW9uXG4gICAgICBlYWNoKG5ld0NvbnRyb2xsZXJzLCAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb250cm9sbGVyLnJlc2V0KCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVEYXRhc2V0cyhtb2RlKTtcblxuICAgIC8vIERvIHRoaXMgYmVmb3JlIHJlbmRlciBzbyB0aGF0IGFueSBwbHVnaW5zIHRoYXQgbmVlZCBmaW5hbCBzY2FsZSB1cGRhdGVzIGNhbiB1c2UgaXRcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyVXBkYXRlJywge21vZGV9KTtcblxuICAgIHRoaXMuX2xheWVycy5zb3J0KGNvbXBhcmUyTGV2ZWwoJ3onLCAnX2lkeCcpKTtcblxuICAgIC8vIFJlcGxheSBsYXN0IGV2ZW50IGZyb20gYmVmb3JlIHVwZGF0ZSwgb3Igc2V0IGhvdmVyIHN0eWxlcyBvbiBhY3RpdmUgZWxlbWVudHNcbiAgICBjb25zdCB7X2FjdGl2ZSwgX2xhc3RFdmVudH0gPSB0aGlzO1xuICAgIGlmIChfbGFzdEV2ZW50KSB7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIoX2xhc3RFdmVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChfYWN0aXZlLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoX2FjdGl2ZSwgX2FjdGl2ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZVNjYWxlcygpIHtcbiAgICBlYWNoKHRoaXMuc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMucmVtb3ZlQm94KHRoaXMsIHNjYWxlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZW5zdXJlU2NhbGVzSGF2ZUlEcygpO1xuICAgIHRoaXMuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tFdmVudEJpbmRpbmdzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZXhpc3RpbmdFdmVudHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuX2xpc3RlbmVycykpO1xuICAgIGNvbnN0IG5ld0V2ZW50cyA9IG5ldyBTZXQob3B0aW9ucy5ldmVudHMpO1xuXG4gICAgaWYgKCFzZXRzRXF1YWwoZXhpc3RpbmdFdmVudHMsIG5ld0V2ZW50cykgfHwgISF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzICE9PSBvcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIC8vIFRoZSBjb25maWd1cmVkIGV2ZW50cyBoYXZlIGNoYW5nZWQuIFJlYmluZC5cbiAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVIaWRkZW5JbmRpY2VzKCkge1xuICAgIGNvbnN0IHtfaGlkZGVuSW5kaWNlc30gPSB0aGlzO1xuICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IHttZXRob2QsIHN0YXJ0LCBjb3VudH0gb2YgY2hhbmdlcykge1xuICAgICAgY29uc3QgbW92ZSA9IG1ldGhvZCA9PT0gJ19yZW1vdmVFbGVtZW50cycgPyAtY291bnQgOiBjb3VudDtcbiAgICAgIG1vdmVOdW1lcmljS2V5cyhfaGlkZGVuSW5kaWNlcywgc3RhcnQsIG1vdmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHtcbiAgICBjb25zdCBfZGF0YUNoYW5nZXMgPSB0aGlzLl9kYXRhQ2hhbmdlcztcbiAgICBpZiAoIV9kYXRhQ2hhbmdlcyB8fCAhX2RhdGFDaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG4gICAgY29uc3QgZGF0YXNldENvdW50ID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBtYWtlU2V0ID0gKGlkeCkgPT4gbmV3IFNldChcbiAgICAgIF9kYXRhQ2hhbmdlc1xuICAgICAgICAuZmlsdGVyKGMgPT4gY1swXSA9PT0gaWR4KVxuICAgICAgICAubWFwKChjLCBpKSA9PiBpICsgJywnICsgYy5zcGxpY2UoMSkuam9pbignLCcpKVxuICAgICk7XG5cbiAgICBjb25zdCBjaGFuZ2VTZXQgPSBtYWtlU2V0KDApO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YXNldENvdW50OyBpKyspIHtcbiAgICAgIGlmICghc2V0c0VxdWFsKGNoYW5nZVNldCwgbWFrZVNldChpKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShjaGFuZ2VTZXQpXG4gICAgICAubWFwKGMgPT4gYy5zcGxpdCgnLCcpKVxuICAgICAgLm1hcChhID0+ICh7bWV0aG9kOiBhWzFdLCBzdGFydDogK2FbMl0sIGNvdW50OiArYVszXX0pKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBjaGFydCBsYXlvdXQgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZUxheW91dGBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyTGF5b3V0YC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVMYXlvdXQobWluUGFkZGluZykge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUxheW91dCcsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGF5b3V0cy51cGRhdGUodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIG1pblBhZGRpbmcpO1xuXG4gICAgY29uc3QgYXJlYSA9IHRoaXMuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG5vQXJlYSA9IGFyZWEud2lkdGggPD0gMCB8fCBhcmVhLmhlaWdodCA8PSAwO1xuXG4gICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgZWFjaCh0aGlzLmJveGVzLCAoYm94KSA9PiB7XG4gICAgICBpZiAobm9BcmVhICYmIGJveC5wb3NpdGlvbiA9PT0gJ2NoYXJ0QXJlYScpIHtcbiAgICAgICAgLy8gU2tpcCBkcmF3aW5nIGFuZCBjb25maWd1cmluZyBjaGFydEFyZWEgYm94ZXMgd2hlbiBjaGFydEFyZWEgaXMgemVybyBvciBuZWdhdGl2ZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbmZpZ3VyZSBpcyBjYWxsZWQgdHdpY2UsIG9uY2UgaW4gY29yZS5zY2FsZS51cGRhdGUgYW5kIG9uY2UgaGVyZS5cbiAgICAgIC8vIEhlcmUgdGhlIGJveGVzIGFyZSBmdWxseSB1cGRhdGVkIGFuZCBhdCB0aGVpciBmaW5hbCBwb3NpdGlvbnMuXG4gICAgICBpZiAoYm94LmNvbmZpZ3VyZSkge1xuICAgICAgICBib3guY29uZmlndXJlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXllcnMucHVzaCguLi5ib3guX2xheWVycygpKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgaXRlbS5faWR4ID0gaW5kZXg7XG4gICAgfSk7XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyTGF5b3V0Jyk7XG4gIH1cblxuICAvKipcblx0ICogVXBkYXRlcyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzVXBkYXRlYFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0c1VwZGF0ZWAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlRGF0YXNldHMobW9kZSkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzVXBkYXRlJywge21vZGUsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlci5jb25maWd1cmUoKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURhdGFzZXQoaSwgaXNGdW5jdGlvbihtb2RlKSA/IG1vZGUoe2RhdGFzZXRJbmRleDogaX0pIDogbW9kZSk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzVXBkYXRlJywge21vZGV9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGVzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRVcGRhdGVgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRVcGRhdGVgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZURhdGFzZXQoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gICAgY29uc3QgYXJncyA9IHttZXRhLCBpbmRleCwgbW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX07XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0VXBkYXRlJywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWV0YS5jb250cm9sbGVyLl91cGRhdGUobW9kZSk7XG5cbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldFVwZGF0ZScsIGFyZ3MpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVJlbmRlcicsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGFuaW1hdG9yLmhhcyh0aGlzKSkge1xuICAgICAgaWYgKHRoaXMuYXR0YWNoZWQgJiYgIWFuaW1hdG9yLnJ1bm5pbmcodGhpcykpIHtcbiAgICAgICAgYW5pbWF0b3Iuc3RhcnQodGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgb25BbmltYXRpb25zQ29tcGxldGUoe2NoYXJ0OiB0aGlzfSk7XG4gICAgfVxuICB9XG5cbiAgZHJhdygpIHtcbiAgICBsZXQgaTtcbiAgICBpZiAodGhpcy5fcmVzaXplQmVmb3JlRHJhdykge1xuICAgICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5fcmVzaXplQmVmb3JlRHJhdztcbiAgICAgIC8vIFVuc2V0IHBlbmRpbmcgcmVzaXplIHJlcXVlc3Qgbm93IHRvIGF2b2lkIHBvc3NpYmxlIHJlY3Vyc2lvbiB3aXRoaW4gX3Jlc2l6ZVxuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IG51bGw7XG4gICAgICB0aGlzLl9yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEJlY2F1c2Ugb2YgcGx1Z2luIGhvb2tzIChiZWZvcmUvYWZ0ZXJEYXRhc2V0c0RyYXcpLCBkYXRhc2V0cyBjYW4ndFxuICAgIC8vIGN1cnJlbnRseSBiZSBwYXJ0IG9mIGxheWVycy4gSW5zdGVhZCwgd2UgZHJhd1xuICAgIC8vIGxheWVycyA8PSAwIGJlZm9yZShkZWZhdWx0LCBiYWNrd2FyZCBjb21wYXQpLCBhbmQgdGhlIHJlc3QgYWZ0ZXJcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgZm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGggJiYgbGF5ZXJzW2ldLnogPD0gMDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZHJhd0RhdGFzZXRzKCk7XG5cbiAgICAvLyBSZXN0IG9mIGxheWVyc1xuICAgIGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRyYXcnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9zb3J0ZWRNZXRhc2V0cztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc2V0c1tpXTtcbiAgICAgIGlmICghZmlsdGVyVmlzaWJsZSB8fCBtZXRhLnZpc2libGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSB2aXNpYmxlIGRhdGFzZXQgbWV0YXMgaW4gZHJhd2luZyBvcmRlclxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0cnVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEcmF3cyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzRHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNEcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3RGF0YXNldHMoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGhpcy5fZHJhd0RhdGFzZXQobWV0YXNldHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c0RyYXcnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEcmF3cyBkYXRhc2V0IGF0IGluZGV4IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0RHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldERyYXdgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RyYXdEYXRhc2V0KG1ldGEpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgbWV0YSxcbiAgICAgIGluZGV4OiBtZXRhLmluZGV4LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH07XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IGNsaXAgPSBnZXREYXRhc2V0Q2xpcEFyZWEodGhpcywgbWV0YSk7XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0RHJhdycsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjbGlwKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIGNsaXApO1xuICAgIH1cblxuICAgIG1ldGEuY29udHJvbGxlci5kcmF3KCk7XG5cbiAgICBpZiAoY2xpcCkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cblxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0RHJhdycsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBwb2ludCBpcyBpbiB0aGUgY2hhcnQgYXJlYS5cbiAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBpbiByZWxhdGl2ZSBjb29yZGluYXRlcyAoc2VlLCBlLmcuLCBnZXRSZWxhdGl2ZVBvc2l0aW9uKVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzUG9pbnRJbkFyZWEocG9pbnQpIHtcbiAgICByZXR1cm4gX2lzUG9pbnRJbkFyZWEocG9pbnQsIHRoaXMuY2hhcnRBcmVhLCB0aGlzLl9taW5QYWRkaW5nKTtcbiAgfVxuXG4gIGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgbW9kZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG1ldGhvZCA9IEludGVyYWN0aW9uLm1vZGVzW21vZGVdO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbWV0aG9kKHRoaXMsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGxldCBtZXRhID0gbWV0YXNldHMuZmlsdGVyKHggPT4geCAmJiB4Ll9kYXRhc2V0ID09PSBkYXRhc2V0KS5wb3AoKTtcblxuICAgIGlmICghbWV0YSkge1xuICAgICAgbWV0YSA9IHtcbiAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGRhdGFzZXQ6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgIGhpZGRlbjogbnVsbCxcdFx0XHQvLyBTZWUgaXNEYXRhc2V0VmlzaWJsZSgpIGNvbW1lbnRcbiAgICAgICAgeEF4aXNJRDogbnVsbCxcbiAgICAgICAgeUF4aXNJRDogbnVsbCxcbiAgICAgICAgb3JkZXI6IGRhdGFzZXQgJiYgZGF0YXNldC5vcmRlciB8fCAwLFxuICAgICAgICBpbmRleDogZGF0YXNldEluZGV4LFxuICAgICAgICBfZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgX3BhcnNlZDogW10sXG4gICAgICAgIF9zb3J0ZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbWV0YXNldHMucHVzaChtZXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfVxuXG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwsIHtjaGFydDogdGhpcywgdHlwZTogJ2NoYXJ0J30pKTtcbiAgfVxuXG4gIGdldFZpc2libGVEYXRhc2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmxlbmd0aDtcbiAgfVxuXG4gIGlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmICghZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cbiAgICAvLyBtZXRhLmhpZGRlbiBpcyBhIHBlciBjaGFydCBkYXRhc2V0IGhpZGRlbiBmbGFnIG92ZXJyaWRlIHdpdGggMyBzdGF0ZXM6IGlmIHRydWUgb3IgZmFsc2UsXG4gICAgLy8gdGhlIGRhdGFzZXQuaGlkZGVuIHZhbHVlIGlzIGlnbm9yZWQsIGVsc2UgaWYgbnVsbCwgdGhlIGRhdGFzZXQgaGlkZGVuIHN0YXRlIGlzIHJldHVybmVkLlxuICAgIHJldHVybiB0eXBlb2YgbWV0YS5oaWRkZW4gPT09ICdib29sZWFuJyA/ICFtZXRhLmhpZGRlbiA6ICFkYXRhc2V0LmhpZGRlbjtcbiAgfVxuXG4gIHNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgbWV0YS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgfVxuXG4gIHRvZ2dsZURhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF0gPSAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cblxuICBnZXREYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHJldHVybiAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbW9kZSA9IHZpc2libGUgPyAnc2hvdycgOiAnaGlkZSc7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBhbmltcyA9IG1ldGEuY29udHJvbGxlci5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKTtcblxuICAgIGlmIChkZWZpbmVkKGRhdGFJbmRleCkpIHtcbiAgICAgIG1ldGEuZGF0YVtkYXRhSW5kZXhdLmhpZGRlbiA9ICF2aXNpYmxlO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpO1xuICAgICAgLy8gQW5pbWF0ZSB2aXNpYmxlIHN0YXRlLCBzbyBoaWRlIGFuaW1hdGlvbiBjYW4gYmUgc2Vlbi4gVGhpcyBjb3VsZCBiZSBoYW5kbGVkIGJldHRlciBpZiB1cGRhdGUgLyB1cGRhdGVEYXRhc2V0IHJldHVybmVkIGEgUHJvbWlzZS5cbiAgICAgIGFuaW1zLnVwZGF0ZShtZXRhLCB7dmlzaWJsZX0pO1xuICAgICAgdGhpcy51cGRhdGUoKGN0eCkgPT4gY3R4LmRhdGFzZXRJbmRleCA9PT0gZGF0YXNldEluZGV4ID8gbW9kZSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9XG5cbiAgaGlkZShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIGZhbHNlKTtcbiAgfVxuXG4gIHNob3coZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2Rlc3Ryb3lEYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAobWV0YSAmJiBtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgIG1ldGEuY29udHJvbGxlci5fZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgfVxuXG4gIF9zdG9wKCkge1xuICAgIGxldCBpLCBpbGVuO1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIGFuaW1hdG9yLnJlbW92ZSh0aGlzKTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURlc3Ryb3knKTtcbiAgICBjb25zdCB7Y2FudmFzLCBjdHh9ID0gdGhpcztcblxuICAgIHRoaXMuX3N0b3AoKTtcbiAgICB0aGlzLmNvbmZpZy5jbGVhckNhY2hlKCk7XG5cbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpO1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZWxlYXNlQ29udGV4dChjdHgpO1xuICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgIH1cblxuICAgIGRlbGV0ZSBpbnN0YW5jZXNbdGhpcy5pZF07XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGVzdHJveScpO1xuICB9XG5cbiAgdG9CYXNlNjRJbWFnZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTCguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLmJpbmRVc2VyRXZlbnRzKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLmJpbmRSZXNwb25zaXZlRXZlbnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYmluZFVzZXJFdmVudHMoKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcblxuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcblxuICAgIGNvbnN0IGxpc3RlbmVyID0gKGUsIHgsIHkpID0+IHtcbiAgICAgIGUub2Zmc2V0WCA9IHg7XG4gICAgICBlLm9mZnNldFkgPSB5O1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKGUpO1xuICAgIH07XG5cbiAgICBlYWNoKHRoaXMub3B0aW9ucy5ldmVudHMsICh0eXBlKSA9PiBfYWRkKHR5cGUsIGxpc3RlbmVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJpbmRSZXNwb25zaXZlRXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcblxuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBjb25zdCBfcmVtb3ZlID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBpZiAobGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIHBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW3R5cGVdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBsaXN0ZW5lciA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCBkZXRhY2hlZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItY29uc3RcbiAgICBjb25zdCBhdHRhY2hlZCA9ICgpID0+IHtcbiAgICAgIF9yZW1vdmUoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcblxuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICBfYWRkKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICBfYWRkKCdkZXRhY2gnLCBkZXRhY2hlZCk7XG4gICAgfTtcblxuICAgIGRldGFjaGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuXG4gICAgICBfcmVtb3ZlKCdyZXNpemUnLCBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFN0b3AgYW5pbWF0aW5nIGFuZCByZW1vdmUgbWV0YXNldHMsIHNvIHdoZW4gcmUtYXR0YWNoZWQsIHRoZSBhbmltYXRpb25zIHN0YXJ0IGZyb20gYmVnaW5uaW5nLlxuICAgICAgdGhpcy5fc3RvcCgpO1xuICAgICAgdGhpcy5fcmVzaXplKDAsIDApO1xuXG4gICAgICBfYWRkKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG4gICAgfTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0F0dGFjaGVkKHRoaXMuY2FudmFzKSkge1xuICAgICAgYXR0YWNoZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGV0YWNoZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIHVuYmluZEV2ZW50cygpIHtcbiAgICBlYWNoKHRoaXMuX2xpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXG4gICAgZWFjaCh0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHVwZGF0ZUhvdmVyU3R5bGUoaXRlbXMsIG1vZGUsIGVuYWJsZWQpIHtcbiAgICBjb25zdCBwcmVmaXggPSBlbmFibGVkID8gJ3NldCcgOiAncmVtb3ZlJztcbiAgICBsZXQgbWV0YSwgaXRlbSwgaSwgaWxlbjtcblxuICAgIGlmIChtb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW1zWzBdLmRhdGFzZXRJbmRleCk7XG4gICAgICBtZXRhLmNvbnRyb2xsZXJbJ18nICsgcHJlZml4ICsgJ0RhdGFzZXRIb3ZlclN0eWxlJ10oKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gaXRlbSAmJiB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW0uZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlcltwcmVmaXggKyAnSG92ZXJTdHlsZSddKGl0ZW0uZWxlbWVudCwgaXRlbS5kYXRhc2V0SW5kZXgsIGl0ZW0uaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgYWN0aXZlIChob3ZlcmVkKSBlbGVtZW50c1xuXHQgKiBAcmV0dXJucyBhcnJheVxuXHQgKi9cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZXQgYWN0aXZlIChob3ZlcmVkKSBlbGVtZW50c1xuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmVFbGVtZW50cyBOZXcgYWN0aXZlIGRhdGEgcG9pbnRzXG5cdCAqL1xuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cykge1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXRhc2V0IGZvdW5kIGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG5cbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHVzZSB0aGUgcHJldmlvdXMgbW91c2UgZXZlbnQgdG8gb3ZlcnJpZGUgdGhlIGFjdGl2ZSBlbGVtZW50cyBpbiB1cGRhdGUuXG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQ2FsbHMgZW5hYmxlZCBwbHVnaW5zIG9uIHRoZSBzcGVjaWZpZWQgaG9vayBhbmQgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICogVGhpcyBtZXRob2QgaW1tZWRpYXRlbHkgcmV0dXJucyBhcyBzb29uIGFzIGEgcGx1Z2luIGV4cGxpY2l0bHkgcmV0dXJucyBmYWxzZS4gVGhlXG5cdCAqIHJldHVybmVkIHZhbHVlIGNhbiBiZSB1c2VkLCBmb3IgaW5zdGFuY2UsIHRvIGludGVycnVwdCB0aGUgY3VycmVudCBhY3Rpb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnc10gLSBFeHRyYSBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGhvb2sgY2FsbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vY29yZS5wbHVnaW5zLmpzJykuZmlsdGVyQ2FsbGJhY2t9IFtmaWx0ZXJdIC0gRmlsdGVyaW5nIGZ1bmN0aW9uIGZvciBsaW1pdGluZyB3aGljaCBwbHVnaW5zIGFyZSBub3RpZmllZFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgYW55IG9mIHRoZSBwbHVnaW5zIHJldHVybiBmYWxzZSwgZWxzZSByZXR1cm5zIHRydWUuXG5cdCAqL1xuICBub3RpZnlQbHVnaW5zKGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLm5vdGlmeSh0aGlzLCBob29rLCBhcmdzLCBmaWx0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgcGx1Z2luIHdpdGggdGhlIHNwZWNpZmljIElEIGlzIHJlZ2lzdGVyZWQgYW5kIGVuYWJsZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBsdWdpbklkIC0gVGhlIElEIG9mIHRoZSBwbHVnaW4gb2Ygd2hpY2ggdG8gY2hlY2sgaWYgaXQgaXMgZW5hYmxlZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzUGx1Z2luRW5hYmxlZChwbHVnaW5JZCkge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLl9jYWNoZS5maWx0ZXIocCA9PiBwLnBsdWdpbi5pZCA9PT0gcGx1Z2luSWQpLmxlbmd0aCA9PT0gMTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5kYXRhc2V0SW5kZXggPT09IHkuZGF0YXNldEluZGV4ICYmIHguaW5kZXggPT09IHkuaW5kZXgpKTtcbiAgICBjb25zdCBkZWFjdGl2YXRlZCA9IGRpZmYobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBhY3RpdmF0ZWQgPSByZXBsYXkgPyBhY3RpdmUgOiBkaWZmKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG5cbiAgICBpZiAoZGVhY3RpdmF0ZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoZGVhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2YXRlZC5sZW5ndGggJiYgaG92ZXJPcHRpb25zLm1vZGUpIHtcbiAgICAgIHRoaXMudXBkYXRlSG92ZXJTdHlsZShhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ldmVudEhhbmRsZXIoZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgcmVwbGF5LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGluQ2hhcnRBcmVhOiB0aGlzLmlzUG9pbnRJbkFyZWEoZSlcbiAgICB9O1xuICAgIGNvbnN0IGV2ZW50RmlsdGVyID0gKHBsdWdpbikgPT4gKHBsdWdpbi5vcHRpb25zLmV2ZW50cyB8fCB0aGlzLm9wdGlvbnMuZXZlbnRzKS5pbmNsdWRlcyhlLm5hdGl2ZS50eXBlKTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLl9oYW5kbGVFdmVudChlLCByZXBsYXksIGFyZ3MuaW5DaGFydEFyZWEpO1xuXG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpO1xuXG4gICAgaWYgKGNoYW5nZWQgfHwgYXJncy5jaGFuZ2VkKSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgdGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXBsYXldIC0gdHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHJlcGxheWVkIGJ5IGB1cGRhdGVgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luQ2hhcnRBcmVhXSAtIHRydWUgaWYgdGhlIGV2ZW50IGlzIGluc2lkZSBjaGFydEFyZWFcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2hhcnQgbmVlZHMgdG8gcmUtcmVuZGVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IHtfYWN0aXZlOiBsYXN0QWN0aXZlID0gW10sIG9wdGlvbnN9ID0gdGhpcztcblxuICAgIC8vIElmIHRoZSBldmVudCBpcyByZXBsYXllZCBmcm9tIGB1cGRhdGVgLCB3ZSBzaG91bGQgZXZhbHVhdGUgd2l0aCB0aGUgZmluYWwgcG9zaXRpb25zLlxuICAgIC8vXG4gICAgLy8gVGhlIGByZXBsYXlgOlxuICAgIC8vIEl0J3MgdGhlIGxhc3QgZXZlbnQgKGV4Y2x1ZGluZyBjbGljaykgdGhhdCBoYXMgb2NjdXJyZWQgYmVmb3JlIGB1cGRhdGVgLlxuICAgIC8vIFNvIG1vdXNlIGhhcyBub3QgbW92ZWQuIEl0J3MgYWxzbyBvdmVyIHRoZSBjaGFydCwgYmVjYXVzZSB0aGVyZSBpcyBhIGByZXBsYXlgLlxuICAgIC8vXG4gICAgLy8gVGhlIHdoeTpcbiAgICAvLyBJZiBhbmltYXRpb25zIGFyZSBhY3RpdmUsIHRoZSBlbGVtZW50cyBoYXZlbid0IG1vdmVkIHlldCBjb21wYXJlZCB0byBzdGF0ZSBiZWZvcmUgdXBkYXRlLlxuICAgIC8vIEJ1dCBpZiB0aGV5IHdpbGwsIHdlIGFyZSBhY3RpdmF0aW5nIHRoZSBlbGVtZW50cyB0aGF0IHdvdWxkIGJlIGFjdGl2ZSwgaWYgdGhpcyBjaGVja1xuICAgIC8vIHdhcyBkb25lIGFmdGVyIHRoZSBhbmltYXRpb25zIGhhdmUgY29tcGxldGVkLiA9PiBcImZpbmFsIHBvc2l0aW9uc1wiLlxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFuaW1hdGlvbnMsIHRoZSBcImZpbmFsXCIgYW5kIFwiY3VycmVudFwiIHBvc2l0aW9ucyBhcmUgZXF1YWwuXG4gICAgLy8gVGhpcyBpcyBkb25lIHNvIHdlIGRvIG5vdCBoYXZlIHRvIGV2YWx1YXRlIHRoZSBhY3RpdmUgZWxlbWVudHMgZWFjaCBhbmltYXRpb24gZnJhbWVcbiAgICAvLyAtIGl0IHdvdWxkIGJlIGV4cGVuc2l2ZS5cbiAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gcmVwbGF5O1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBpc0NsaWNrID0gX2lzQ2xpY2tFdmVudChlKTtcbiAgICBjb25zdCBsYXN0RXZlbnQgPSBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgdGhpcy5fbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljayk7XG5cbiAgICBpZiAoaW5DaGFydEFyZWEpIHtcbiAgICAgIC8vIFNldCBfbGFzdEV2ZW50IHRvIG51bGwgd2hpbGUgd2UgYXJlIHByb2Nlc3NpbmcgdGhlIGV2ZW50IGhhbmRsZXJzLlxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyByZWN1cnNpb24gaWYgdGhlIGhhbmRsZXIgY2FsbHMgY2hhcnQudXBkYXRlKClcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG5cbiAgICAgIC8vIEludm9rZSBvbkhvdmVyIGhvb2tcbiAgICAgIGNhbGxDYWxsYmFjayhvcHRpb25zLm9uSG92ZXIsIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcblxuICAgICAgaWYgKGlzQ2xpY2spIHtcbiAgICAgICAgY2FsbENhbGxiYWNrKG9wdGlvbnMub25DbGljaywgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoY2hhbmdlZCB8fCByZXBsYXkpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KTtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBsYXN0RXZlbnQ7XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBUaGUgZXZlbnRcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQWN0aXZlRWxlbWVudFtdfSBsYXN0QWN0aXZlIC0gUHJldmlvdXNseSBhY3RpdmUgZWxlbWVudHNcbiAgICogQHBhcmFtIHtib29sZWFufSBpbkNoYXJ0QXJlYSAtIElzIHRoZSBldmVudCBpbnNpZGUgY2hhcnRBcmVhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlRmluYWxQb3NpdGlvbiAtIFNob3VsZCB0aGUgZXZhbHVhdGlvbiBiZSBkb25lIHdpdGggY3VycmVudCBvciBmaW5hbCAoYWZ0ZXIgYW5pbWF0aW9uKSBlbGVtZW50IHBvc2l0aW9uc1xuICAgKiBAcmV0dXJucyB7aW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkFjdGl2ZUVsZW1lbnRbXX0gLSBUaGUgYWN0aXZlIGVsZW1lbnRzXG4gICAqIEBwcmF2YXRlXG4gICAqL1xuICBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgaW5DaGFydEFyZWEsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xuICAgICAgLy8gTGV0IHVzZXIgY29udHJvbCB0aGUgYWN0aXZlIGVsZW1lbnRzIG91dHNpZGUgY2hhcnRBcmVhLiBFZy4gdXNpbmcgTGVnZW5kLlxuICAgICAgcmV0dXJuIGxhc3RBY3RpdmU7XG4gICAgfVxuXG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgaG92ZXJPcHRpb25zLm1vZGUsIGhvdmVyT3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbn1cblxuLy8gQHRzLWlnbm9yZVxuZnVuY3Rpb24gaW52YWxpZGF0ZVBsdWdpbnMoKSB7XG4gIHJldHVybiBlYWNoKENoYXJ0Lmluc3RhbmNlcywgKGNoYXJ0KSA9PiBjaGFydC5fcGx1Z2lucy5pbnZhbGlkYXRlKCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydDtcbiIsICJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge19hbmdsZUJldHdlZW4sIGdldEFuZ2xlRnJvbVBvaW50LCBUQVUsIEhBTEZfUEksIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7UEksIF9pc0JldHdlZW4sIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19yZWFkVmFsdWVUb1Byb3BzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQgdHlwZSB7QXJjT3B0aW9ucywgUG9pbnR9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuXG5mdW5jdGlvbiBjbGlwQXJjKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBlbGVtZW50OiBBcmNFbGVtZW50LCBlbmRBbmdsZTogbnVtYmVyKSB7XG4gIGNvbnN0IHtzdGFydEFuZ2xlLCBwaXhlbE1hcmdpbiwgeCwgeSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzfSA9IGVsZW1lbnQ7XG4gIGxldCBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gb3V0ZXJSYWRpdXM7XG5cbiAgLy8gRHJhdyBhbiBpbm5lciBib3JkZXIgYnkgY2xpcHBpbmcgdGhlIGFyYyBhbmQgZHJhd2luZyBhIGRvdWJsZS13aWR0aCBib3JkZXJcbiAgLy8gRW5sYXJnZSB0aGUgY2xpcHBpbmcgYXJjIGJ5IDAuMzMgcGl4ZWxzIHRvIGVsaW1pbmF0ZSBnbGl0Y2hlcyBiZXR3ZWVuIGJvcmRlcnNcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4pO1xuICBpZiAoaW5uZXJSYWRpdXMgPiBwaXhlbE1hcmdpbikge1xuICAgIGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBpbm5lclJhZGl1cztcbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5hcmMoeCwgeSwgcGl4ZWxNYXJnaW4sIGVuZEFuZ2xlICsgSEFMRl9QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICB9XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cblxuZnVuY3Rpb24gdG9SYWRpdXNDb3JuZXJzKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWydvdXRlclN0YXJ0JywgJ291dGVyRW5kJywgJ2lubmVyU3RhcnQnLCAnaW5uZXJFbmQnXSk7XG59XG5cbi8qKlxuICogUGFyc2UgYm9yZGVyIHJhZGl1cyBmcm9tIHRoZSBwcm92aWRlZCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzKGFyYzogQXJjRWxlbWVudCwgaW5uZXJSYWRpdXM6IG51bWJlciwgb3V0ZXJSYWRpdXM6IG51bWJlciwgYW5nbGVEZWx0YTogbnVtYmVyKSB7XG4gIGNvbnN0IG8gPSB0b1JhZGl1c0Nvcm5lcnMoYXJjLm9wdGlvbnMuYm9yZGVyUmFkaXVzKTtcbiAgY29uc3QgaGFsZlRoaWNrbmVzcyA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIDI7XG4gIGNvbnN0IGlubmVyTGltaXQgPSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBhbmdsZURlbHRhICogaW5uZXJSYWRpdXMgLyAyKTtcblxuICAvLyBPdXRlciBsaW1pdHMgYXJlIGNvbXBsaWNhdGVkLiBXZSB3YW50IHRvIGNvbXB1dGUgdGhlIGF2YWlsYWJsZSBhbmd1bGFyIGRpc3RhbmNlIGF0XG4gIC8vIGEgcmFkaXVzIG9mIG91dGVyUmFkaXVzIC0gYm9yZGVyUmFkaXVzIGJlY2F1c2UgZm9yIHNtYWxsIGFuZ3VsYXIgZGlzdGFuY2VzLCB0aGlzIHRlcm0gbGltaXRzLlxuICAvLyBXZSBjb21wdXRlIGF0IHIgPSBvdXRlclJhZGl1cyAtIGJvcmRlclJhZGl1cyBiZWNhdXNlIHRoaXMgY2lyY2xlIGRlZmluZXMgdGhlIGNlbnRlciBvZiB0aGUgYm9yZGVyIGNvcm5lcnMuXG4gIC8vXG4gIC8vIElmIHRoZSBib3JkZXJSYWRpdXMgaXMgbGFyZ2UsIHRoYXQgdmFsdWUgY2FuIGJlY29tZSBuZWdhdGl2ZS5cbiAgLy8gVGhpcyBjYXVzZXMgdGhlIG91dGVyIGJvcmRlcnMgdG8gbG9zZSB0aGVpciByYWRpdXMgZW50aXJlbHksIHdoaWNoIGlzIHJhdGhlciB1bmV4cGVjdGVkLiBUbyBzb2x2ZSB0aGF0LCBpZiBib3JkZXJSYWRpdXMgPiBvdXRlclJhZGl1c1xuICAvLyB3ZSBrbm93IHRoYXQgdGhlIHRoaWNrbmVzcyB0ZXJtIHdpbGwgZG9taW5hdGUgYW5kIGNvbXB1dGUgdGhlIGxpbWl0cyBhdCB0aGF0IHBvaW50XG4gIGNvbnN0IGNvbXB1dGVPdXRlckxpbWl0ID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IG91dGVyQXJjTGltaXQgPSAob3V0ZXJSYWRpdXMgLSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCB2YWwpKSAqIGFuZ2xlRGVsdGEgLyAyO1xuICAgIHJldHVybiBfbGltaXRWYWx1ZSh2YWwsIDAsIE1hdGgubWluKGhhbGZUaGlja25lc3MsIG91dGVyQXJjTGltaXQpKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG91dGVyU3RhcnQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJTdGFydCksXG4gICAgb3V0ZXJFbmQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJFbmQpLFxuICAgIGlubmVyU3RhcnQ6IF9saW1pdFZhbHVlKG8uaW5uZXJTdGFydCwgMCwgaW5uZXJMaW1pdCksXG4gICAgaW5uZXJFbmQ6IF9saW1pdFZhbHVlKG8uaW5uZXJFbmQsIDAsIGlubmVyTGltaXQpLFxuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnQgKHIsIPCdnIMpIHRvICh4LCB5KVxuICovXG5mdW5jdGlvbiByVGhldGFUb1hZKHI6IG51bWJlciwgdGhldGE6IG51bWJlciwgeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB4ICsgciAqIE1hdGguY29zKHRoZXRhKSxcbiAgICB5OiB5ICsgciAqIE1hdGguc2luKHRoZXRhKSxcbiAgfTtcbn1cblxuXG4vKipcbiAqIFBhdGggdGhlIGFyYywgcmVzcGVjdGluZyBib3JkZXIgcmFkaXVzIGJ5IHNlcGFyYXRpbmcgaW50byBsZWZ0IGFuZCByaWdodCBoYWx2ZXMuXG4gKlxuICogICBTdGFydCAgICAgIEVuZFxuICpcbiAqICAgIDEtLS0+YS0tLT4yICAgIE91dGVyXG4gKiAgIC8gICAgICAgICAgIFxcXG4gKiAgIDggICAgICAgICAgIDNcbiAqICAgfCAgICAgICAgICAgfFxuICogICB8ICAgICAgICAgICB8XG4gKiAgIDcgICAgICAgICAgIDRcbiAqICAgXFwgICAgICAgICAgIC9cbiAqICAgIDY8LS0tYjwtLS01ICAgIElubmVyXG4gKi9cbmZ1bmN0aW9uIHBhdGhBcmMoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBlbGVtZW50OiBBcmNFbGVtZW50LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgc3BhY2luZzogbnVtYmVyLFxuICBlbmQ6IG51bWJlcixcbiAgY2lyY3VsYXI6IGJvb2xlYW4sXG4pIHtcbiAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGU6IHN0YXJ0LCBwaXhlbE1hcmdpbiwgaW5uZXJSYWRpdXM6IGlubmVyUn0gPSBlbGVtZW50O1xuXG4gIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoZWxlbWVudC5vdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQgLSBwaXhlbE1hcmdpbiwgMCk7XG4gIGNvbnN0IGlubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiArIHNwYWNpbmcgKyBvZmZzZXQgKyBwaXhlbE1hcmdpbiA6IDA7XG5cbiAgbGV0IHNwYWNpbmdPZmZzZXQgPSAwO1xuICBjb25zdCBhbHBoYSA9IGVuZCAtIHN0YXJ0O1xuXG4gIGlmIChzcGFjaW5nKSB7XG4gICAgLy8gV2hlbiBzcGFjaW5nIGlzIHByZXNlbnQsIGl0IGlzIHRoZSBzYW1lIGZvciBhbGwgaXRlbXNcbiAgICAvLyBTbyB3ZSBhZGp1c3QgdGhlIHN0YXJ0IGFuZCBlbmQgYW5nbGUgb2YgdGhlIGFyYyBzdWNoIHRoYXRcbiAgICAvLyB0aGUgZGlzdGFuY2UgaXMgdGhlIHNhbWUgYXMgaXQgd291bGQgYmUgd2l0aG91dCB0aGUgc3BhY2luZ1xuICAgIGNvbnN0IG5vU3BhY2luZ0lubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IG5vU3BhY2luZ091dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgPiAwID8gb3V0ZXJSYWRpdXMgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBhdk5vZ1NwYWNpbmdSYWRpdXMgPSAobm9TcGFjaW5nSW5uZXJSYWRpdXMgKyBub1NwYWNpbmdPdXRlclJhZGl1cykgLyAyO1xuICAgIGNvbnN0IGFkanVzdGVkQW5nbGUgPSBhdk5vZ1NwYWNpbmdSYWRpdXMgIT09IDAgPyAoYWxwaGEgKiBhdk5vZ1NwYWNpbmdSYWRpdXMpIC8gKGF2Tm9nU3BhY2luZ1JhZGl1cyArIHNwYWNpbmcpIDogYWxwaGE7XG4gICAgc3BhY2luZ09mZnNldCA9IChhbHBoYSAtIGFkanVzdGVkQW5nbGUpIC8gMjtcbiAgfVxuXG4gIGNvbnN0IGJldGEgPSBNYXRoLm1heCgwLjAwMSwgYWxwaGEgKiBvdXRlclJhZGl1cyAtIG9mZnNldCAvIFBJKSAvIG91dGVyUmFkaXVzO1xuICBjb25zdCBhbmdsZU9mZnNldCA9IChhbHBoYSAtIGJldGEpIC8gMjtcbiAgY29uc3Qgc3RhcnRBbmdsZSA9IHN0YXJ0ICsgYW5nbGVPZmZzZXQgKyBzcGFjaW5nT2Zmc2V0O1xuICBjb25zdCBlbmRBbmdsZSA9IGVuZCAtIGFuZ2xlT2Zmc2V0IC0gc3BhY2luZ09mZnNldDtcbiAgY29uc3Qge291dGVyU3RhcnQsIG91dGVyRW5kLCBpbm5lclN0YXJ0LCBpbm5lckVuZH0gPSBwYXJzZUJvcmRlclJhZGl1cyhlbGVtZW50LCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG5cbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlclN0YXJ0O1xuICBjb25zdCBvdXRlckVuZEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlckVuZDtcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgb3V0ZXJTdGFydCAvIG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBvdXRlckVuZCAvIG91dGVyRW5kQWRqdXN0ZWRSYWRpdXM7XG5cbiAgY29uc3QgaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBpbm5lclN0YXJ0O1xuICBjb25zdCBpbm5lckVuZEFkanVzdGVkUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBpbm5lckVuZDtcbiAgY29uc3QgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgaW5uZXJTdGFydCAvIGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBpbm5lckVuZCAvIGlubmVyRW5kQWRqdXN0ZWRSYWRpdXM7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gIGlmIChjaXJjdWxhcikge1xuICAgIC8vIFRoZSBmaXJzdCBhcmMgc2VnbWVudHMgZnJvbSBwb2ludCAxIHRvIHBvaW50IGEgdG8gcG9pbnQgMlxuICAgIGNvbnN0IG91dGVyTWlkQWRqdXN0ZWRBbmdsZSA9IChvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSArIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgLyAyO1xuICAgIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCBvdXRlck1pZEFkanVzdGVkQW5nbGUpO1xuICAgIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIG91dGVyTWlkQWRqdXN0ZWRBbmdsZSwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDIgdG8gcG9pbnQgM1xuICAgIGlmIChvdXRlckVuZCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlckVuZCwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCBlbmRBbmdsZSArIEhBTEZfUEkpO1xuICAgIH1cblxuICAgIC8vIFRoZSBsaW5lIGZyb20gcG9pbnQgMyB0byBwb2ludCA0XG4gICAgY29uc3QgcDQgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGVuZEFuZ2xlLCB4LCB5KTtcbiAgICBjdHgubGluZVRvKHA0LngsIHA0LnkpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgNCB0byBwb2ludCA1XG4gICAgaWYgKGlubmVyRW5kID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyRW5kLCBlbmRBbmdsZSArIEhBTEZfUEksIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSArIE1hdGguUEkpO1xuICAgIH1cblxuICAgIC8vIFRoZSBpbm5lciBhcmMgZnJvbSBwb2ludCA1IHRvIHBvaW50IGIgdG8gcG9pbnQgNlxuICAgIGNvbnN0IGlubmVyTWlkQWRqdXN0ZWRBbmdsZSA9ICgoZW5kQW5nbGUgLSAoaW5uZXJFbmQgLyBpbm5lclJhZGl1cykpICsgKHN0YXJ0QW5nbGUgKyAoaW5uZXJTdGFydCAvIGlubmVyUmFkaXVzKSkpIC8gMjtcbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSAtIChpbm5lckVuZCAvIGlubmVyUmFkaXVzKSwgaW5uZXJNaWRBZGp1c3RlZEFuZ2xlLCB0cnVlKTtcbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBpbm5lck1pZEFkanVzdGVkQW5nbGUsIHN0YXJ0QW5nbGUgKyAoaW5uZXJTdGFydCAvIGlubmVyUmFkaXVzKSwgdHJ1ZSk7XG5cbiAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCA2IHRvIHBvaW50IDdcbiAgICBpZiAoaW5uZXJTdGFydCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cywgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJTdGFydCwgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGxpbmUgZnJvbSBwb2ludCA3IHRvIHBvaW50IDhcbiAgICBjb25zdCBwOCA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBzdGFydEFuZ2xlLCB4LCB5KTtcbiAgICBjdHgubGluZVRvKHA4LngsIHA4LnkpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgOCB0byBwb2ludCAxXG4gICAgaWYgKG91dGVyU3RhcnQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyU3RhcnQsIHN0YXJ0QW5nbGUgLSBIQUxGX1BJLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG5cbiAgICBjb25zdCBvdXRlclN0YXJ0WCA9IE1hdGguY29zKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICBjb25zdCBvdXRlclN0YXJ0WSA9IE1hdGguc2luKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeTtcbiAgICBjdHgubGluZVRvKG91dGVyU3RhcnRYLCBvdXRlclN0YXJ0WSk7XG5cbiAgICBjb25zdCBvdXRlckVuZFggPSBNYXRoLmNvcyhvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB4O1xuICAgIGNvbnN0IG91dGVyRW5kWSA9IE1hdGguc2luKG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgY3R4LmxpbmVUbyhvdXRlckVuZFgsIG91dGVyRW5kWSk7XG4gIH1cblxuICBjdHguY2xvc2VQYXRoKCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdBcmMoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBlbGVtZW50OiBBcmNFbGVtZW50LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgc3BhY2luZzogbnVtYmVyLFxuICBjaXJjdWxhcjogYm9vbGVhbixcbikge1xuICBjb25zdCB7ZnVsbENpcmNsZXMsIHN0YXJ0QW5nbGUsIGNpcmN1bWZlcmVuY2V9ID0gZWxlbWVudDtcbiAgbGV0IGVuZEFuZ2xlID0gZWxlbWVudC5lbmRBbmdsZTtcbiAgaWYgKGZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGlmICghaXNOYU4oY2lyY3VtZmVyZW5jZSkpIHtcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIChjaXJjdW1mZXJlbmNlICUgVEFVIHx8IFRBVSk7XG4gICAgfVxuICB9XG4gIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gIGN0eC5maWxsKCk7XG4gIHJldHVybiBlbmRBbmdsZTtcbn1cblxuZnVuY3Rpb24gZHJhd0JvcmRlcihcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGVsZW1lbnQ6IEFyY0VsZW1lbnQsXG4gIG9mZnNldDogbnVtYmVyLFxuICBzcGFjaW5nOiBudW1iZXIsXG4gIGNpcmN1bGFyOiBib29sZWFuLFxuKSB7XG4gIGNvbnN0IHtmdWxsQ2lyY2xlcywgc3RhcnRBbmdsZSwgY2lyY3VtZmVyZW5jZSwgb3B0aW9uc30gPSBlbGVtZW50O1xuICBjb25zdCB7Ym9yZGVyV2lkdGgsIGJvcmRlckpvaW5TdHlsZSwgYm9yZGVyRGFzaCwgYm9yZGVyRGFzaE9mZnNldH0gPSBvcHRpb25zO1xuICBjb25zdCBpbm5lciA9IG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcic7XG5cbiAgaWYgKCFib3JkZXJXaWR0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eC5zZXRMaW5lRGFzaChib3JkZXJEYXNoIHx8IFtdKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gYm9yZGVyRGFzaE9mZnNldDtcblxuICBpZiAoaW5uZXIpIHtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGggKiAyO1xuICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAncm91bmQnO1xuICB9IGVsc2Uge1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ2JldmVsJztcbiAgfVxuXG4gIGxldCBlbmRBbmdsZSA9IGVsZW1lbnQuZW5kQW5nbGU7XG4gIGlmIChmdWxsQ2lyY2xlcykge1xuICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIGlmICghaXNOYU4oY2lyY3VtZmVyZW5jZSkpIHtcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIChjaXJjdW1mZXJlbmNlICUgVEFVIHx8IFRBVSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlubmVyKSB7XG4gICAgY2xpcEFyYyhjdHgsIGVsZW1lbnQsIGVuZEFuZ2xlKTtcbiAgfVxuXG4gIGlmICghZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFyY1Byb3BzIGV4dGVuZHMgUG9pbnQge1xuICBzdGFydEFuZ2xlOiBudW1iZXI7XG4gIGVuZEFuZ2xlOiBudW1iZXI7XG4gIGlubmVyUmFkaXVzOiBudW1iZXI7XG4gIG91dGVyUmFkaXVzOiBudW1iZXI7XG4gIGNpcmN1bWZlcmVuY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJjRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ8QXJjUHJvcHMsIEFyY09wdGlvbnM+IHtcblxuICBzdGF0aWMgaWQgPSAnYXJjJztcblxuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgYm9yZGVyQWxpZ246ICdjZW50ZXInLFxuICAgIGJvcmRlckNvbG9yOiAnI2ZmZicsXG4gICAgYm9yZGVyRGFzaDogW10sXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgICBib3JkZXJKb2luU3R5bGU6IHVuZGVmaW5lZCxcbiAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgb2Zmc2V0OiAwLFxuICAgIHNwYWNpbmc6IDAsXG4gICAgYW5nbGU6IHVuZGVmaW5lZCxcbiAgICBjaXJjdWxhcjogdHJ1ZSxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InXG4gIH07XG5cbiAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCdcbiAgfTtcblxuICBjaXJjdW1mZXJlbmNlOiBudW1iZXI7XG4gIGVuZEFuZ2xlOiBudW1iZXI7XG4gIGZ1bGxDaXJjbGVzOiBudW1iZXI7XG4gIGlubmVyUmFkaXVzOiBudW1iZXI7XG4gIG91dGVyUmFkaXVzOiBudW1iZXI7XG4gIHBpeGVsTWFyZ2luOiBudW1iZXI7XG4gIHN0YXJ0QW5nbGU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2lyY3VtZmVyZW5jZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IDA7XG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IDA7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgaW5SYW5nZShjaGFydFg6IG51bWJlciwgY2hhcnRZOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pIHtcbiAgICBjb25zdCBwb2ludCA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge2FuZ2xlLCBkaXN0YW5jZX0gPSBnZXRBbmdsZUZyb21Qb2ludChwb2ludCwge3g6IGNoYXJ0WCwgeTogY2hhcnRZfSk7XG4gICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGNpcmN1bWZlcmVuY2V9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAnZW5kQW5nbGUnLFxuICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICdvdXRlclJhZGl1cycsXG4gICAgICAnY2lyY3VtZmVyZW5jZSdcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCByQWRqdXN0ID0gKHRoaXMub3B0aW9ucy5zcGFjaW5nICsgdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoKSAvIDI7XG4gICAgY29uc3QgX2NpcmN1bWZlcmVuY2UgPSB2YWx1ZU9yRGVmYXVsdChjaXJjdW1mZXJlbmNlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IG5vblplcm9CZXR3ZWVuID0gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpICYmIHN0YXJ0QW5nbGUgIT09IGVuZEFuZ2xlO1xuICAgIGNvbnN0IGJldHdlZW5BbmdsZXMgPSBfY2lyY3VtZmVyZW5jZSA+PSBUQVUgfHwgbm9uWmVyb0JldHdlZW47XG4gICAgY29uc3Qgd2l0aGluUmFkaXVzID0gX2lzQmV0d2VlbihkaXN0YW5jZSwgaW5uZXJSYWRpdXMgKyByQWRqdXN0LCBvdXRlclJhZGl1cyArIHJBZGp1c3QpO1xuXG4gICAgcmV0dXJuIChiZXR3ZWVuQW5nbGVzICYmIHdpdGhpblJhZGl1cyk7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKSB7XG4gICAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXN9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAneCcsXG4gICAgICAneScsXG4gICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAnZW5kQW5nbGUnLFxuICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICdvdXRlclJhZGl1cydcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7b2Zmc2V0LCBzcGFjaW5nfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBoYWxmQW5nbGUgPSAoc3RhcnRBbmdsZSArIGVuZEFuZ2xlKSAvIDI7XG4gICAgY29uc3QgaGFsZlJhZGl1cyA9IChpbm5lclJhZGl1cyArIG91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCkgLyAyO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcbiAgICB9O1xuICB9XG5cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzO1xuICAgIGNvbnN0IG9mZnNldCA9IChvcHRpb25zLm9mZnNldCB8fCAwKSAvIDQ7XG4gICAgY29uc3Qgc3BhY2luZyA9IChvcHRpb25zLnNwYWNpbmcgfHwgMCkgLyAyO1xuICAgIGNvbnN0IGNpcmN1bGFyID0gb3B0aW9ucy5jaXJjdWxhcjtcbiAgICB0aGlzLnBpeGVsTWFyZ2luID0gKG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcicpID8gMC4zMyA6IDA7XG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IGNpcmN1bWZlcmVuY2UgPiBUQVUgPyBNYXRoLmZsb29yKGNpcmN1bWZlcmVuY2UgLyBUQVUpIDogMDtcblxuICAgIGlmIChjaXJjdW1mZXJlbmNlID09PSAwIHx8IHRoaXMuaW5uZXJSYWRpdXMgPCAwIHx8IHRoaXMub3V0ZXJSYWRpdXMgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGNvbnN0IGhhbGZBbmdsZSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyB0aGlzLmVuZEFuZ2xlKSAvIDI7XG4gICAgY3R4LnRyYW5zbGF0ZShNYXRoLmNvcyhoYWxmQW5nbGUpICogb2Zmc2V0LCBNYXRoLnNpbihoYWxmQW5nbGUpICogb2Zmc2V0KTtcbiAgICBjb25zdCBmaXggPSAxIC0gTWF0aC5zaW4oTWF0aC5taW4oUEksIGNpcmN1bWZlcmVuY2UgfHwgMCkpO1xuICAgIGNvbnN0IHJhZGl1c09mZnNldCA9IG9mZnNldCAqIGZpeDtcblxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuXG4gICAgZHJhd0FyYyhjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpO1xuICAgIGRyYXdCb3JkZXIoY3R4LCB0aGlzLCByYWRpdXNPZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge19iZXppZXJJbnRlcnBvbGF0aW9uLCBfcG9pbnRJbkxpbmUsIF9zdGVwcGVkSW50ZXJwb2xhdGlvbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGVycG9sYXRpb24uanMnO1xuaW1wb3J0IHtfY29tcHV0ZVNlZ21lbnRzLCBfYm91bmRTZWdtZW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLnNlZ21lbnQuanMnO1xuaW1wb3J0IHtfc3RlcHBlZExpbmVUbywgX2JlemllckN1cnZlVG99IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmN1cnZlLmpzJztcbmltcG9ydCB7dmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzdHlsZSA9IG9wdGlvbnMpIHtcbiAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDYXBTdHlsZSwgb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSk7XG4gIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoLCBvcHRpb25zLmJvcmRlckRhc2gpKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaE9mZnNldCwgb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0KTtcbiAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVySm9pblN0eWxlLCBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSk7XG4gIGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNvbG9yLCBvcHRpb25zLmJvcmRlckNvbG9yKTtcbn1cblxuZnVuY3Rpb24gbGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCkge1xuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGluZU1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRMaW5lVG87XG4gIH1cblxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVyQ3VydmVUbztcbiAgfVxuXG4gIHJldHVybiBsaW5lVG87XG59XG5cbmZ1bmN0aW9uIHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zID0ge30pIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7c3RhcnQ6IHBhcmFtc1N0YXJ0ID0gMCwgZW5kOiBwYXJhbXNFbmQgPSBjb3VudCAtIDF9ID0gcGFyYW1zO1xuICBjb25zdCB7c3RhcnQ6IHNlZ21lbnRTdGFydCwgZW5kOiBzZWdtZW50RW5kfSA9IHNlZ21lbnQ7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocGFyYW1zU3RhcnQsIHNlZ21lbnRTdGFydCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHBhcmFtc0VuZCwgc2VnbWVudEVuZCk7XG4gIGNvbnN0IG91dHNpZGUgPSBwYXJhbXNTdGFydCA8IHNlZ21lbnRTdGFydCAmJiBwYXJhbXNFbmQgPCBzZWdtZW50U3RhcnQgfHwgcGFyYW1zU3RhcnQgPiBzZWdtZW50RW5kICYmIHBhcmFtc0VuZCA+IHNlZ21lbnRFbmQ7XG5cbiAgcmV0dXJuIHtcbiAgICBjb3VudCxcbiAgICBzdGFydCxcbiAgICBsb29wOiBzZWdtZW50Lmxvb3AsXG4gICAgaWxlbjogZW5kIDwgc3RhcnQgJiYgIW91dHNpZGUgPyBjb3VudCArIGVuZCAtIHN0YXJ0IDogZW5kIC0gc3RhcnRcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgcGF0aCBmcm9tIHBvaW50cywgZ3JvdXBpbmcgYnkgdHJ1bmNhdGVkIHgtY29vcmRpbmF0ZVxuICogUG9pbnRzIG5lZWQgdG8gYmUgaW4gb3JkZXIgYnkgeC1jb29yZGluYXRlIGZvciB0aGlzIHRvIHdvcmsgZWZmaWNpZW50bHlcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFBhdGgyRH0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubW92ZSAtIG1vdmUgdG8gc3RhcnRpbmcgcG9pbnQgKHZzIGxpbmUgdG8gaXQpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBlbmRpbmcgYXQgYHN0YXJ0YCArIGBjb3VudGAgaW5kZXhcbiAqL1xuZnVuY3Rpb24gcGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3Qge3BvaW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBsb29wLCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3QgbGluZU1ldGhvZCA9IGdldExpbmVNZXRob2Qob3B0aW9ucyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBpLCBwb2ludCwgcHJldjtcblxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGkgOiBpKSkgJSBjb3VudF07XG5cbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBza2lwcGVkIHBvaW50IGluc2lkZSBhIHNlZ21lbnQsIHNwYW5HYXBzIG11c3QgYmUgdHJ1ZVxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChtb3ZlKSB7XG4gICAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgbW92ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgfVxuXG4gICAgcHJldiA9IHBvaW50O1xuICB9XG5cbiAgaWYgKGxvb3ApIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gOiAwKSkgJSBjb3VudF07XG4gICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xuICB9XG5cbiAgcmV0dXJuICEhbG9vcDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgcGF0aCBmcm9tIHBvaW50cywgZ3JvdXBpbmcgYnkgdHJ1bmNhdGVkIHgtY29vcmRpbmF0ZVxuICogUG9pbnRzIG5lZWQgdG8gYmUgaW4gb3JkZXIgYnkgeC1jb29yZGluYXRlIGZvciB0aGlzIHRvIHdvcmsgZWZmaWNpZW50bHlcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFBhdGgyRH0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubW92ZSAtIG1vdmUgdG8gc3RhcnRpbmcgcG9pbnQgKHZzIGxpbmUgdG8gaXQpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBlbmRpbmcgYXQgYHN0YXJ0YCArIGBjb3VudGAgaW5kZXhcbiAqL1xuZnVuY3Rpb24gZmFzdFBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3Qge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCBwcmV2WCwgbWluWSwgbWF4WSwgbGFzdFk7XG5cbiAgY29uc3QgcG9pbnRJbmRleCA9IChpbmRleCkgPT4gKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaW5kZXggOiBpbmRleCkpICUgY291bnQ7XG4gIGNvbnN0IGRyYXdYID0gKCkgPT4ge1xuICAgIGlmIChtaW5ZICE9PSBtYXhZKSB7XG4gICAgICAvLyBEcmF3IGxpbmUgdG8gbWF4WSBhbmQgbWluWSwgdXNpbmcgdGhlIGF2ZXJhZ2UgeC1jb29yZGluYXRlXG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtaW5ZKTtcbiAgICAgIC8vIExpbmUgdG8geS12YWx1ZSBvZiBsYXN0IHBvaW50IGluIGdyb3VwLiBTbyB0aGUgbGluZSBjb250aW51ZXNcbiAgICAgIC8vIGZyb20gY29ycmVjdCBwb3NpdGlvbi4gTm90IHVzaW5nIG1vdmUsIHRvIGhhdmUgc29saWQgcGF0aC5cbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbGFzdFkpO1xuICAgIH1cbiAgfTtcblxuICBpZiAobW92ZSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoMCldO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoaSldO1xuXG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGEgc2tpcHBlZCBwb2ludCBpbnNpZGUgYSBzZWdtZW50LCBzcGFuR2FwcyBtdXN0IGJlIHRydWVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHggPSBwb2ludC54O1xuICAgIGNvbnN0IHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwOyAvLyB0cnVuY2F0ZWQgeC1jb29yZGluYXRlXG5cbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGBtaW5ZYCAvIGBtYXhZYCBhbmQgYGF2Z1hgIHdoaWxlIHdlIHN0YXkgd2l0aGluIHNhbWUgeC1wb3NpdGlvblxuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgIH1cbiAgICAgIC8vIEZvciBmaXJzdCBwb2ludCBpbiBncm91cCwgY291bnRYIGlzIGAwYCwgc28gYXZlcmFnZSB3aWxsIGJlIGB4YCAvIDEuXG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyB4KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3WCgpO1xuICAgICAgLy8gRHJhdyBsaW5lIHRvIG5leHQgeC1wb3NpdGlvbiwgdXNpbmcgdGhlIGZpcnN0IChvciBvbmx5KVxuICAgICAgLy8geS12YWx1ZSBpbiB0aGF0IGdyb3VwXG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuXG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgfVxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgeS12YWx1ZSBpbiBncm91cFxuICAgIGxhc3RZID0geTtcbiAgfVxuICBkcmF3WCgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmUgLSB0aGUgbGluZVxuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dldFNlZ21lbnRNZXRob2QobGluZSkge1xuICBjb25zdCBvcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBib3JkZXJEYXNoID0gb3B0cy5ib3JkZXJEYXNoICYmIG9wdHMuYm9yZGVyRGFzaC5sZW5ndGg7XG4gIGNvbnN0IHVzZUZhc3RQYXRoID0gIWxpbmUuX2RlY2ltYXRlZCAmJiAhbGluZS5fbG9vcCAmJiAhb3B0cy50ZW5zaW9uICYmIG9wdHMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSAhPT0gJ21vbm90b25lJyAmJiAhb3B0cy5zdGVwcGVkICYmICFib3JkZXJEYXNoO1xuICByZXR1cm4gdXNlRmFzdFBhdGggPyBmYXN0UGF0aFNlZ21lbnQgOiBwYXRoU2VnbWVudDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckludGVycG9sYXRpb247XG4gIH1cblxuICByZXR1cm4gX3BvaW50SW5MaW5lO1xufVxuXG5mdW5jdGlvbiBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGxldCBwYXRoID0gbGluZS5fcGF0aDtcbiAgaWYgKCFwYXRoKSB7XG4gICAgcGF0aCA9IGxpbmUuX3BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgaWYgKGxpbmUucGF0aChwYXRoLCBzdGFydCwgY291bnQpKSB7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuICBzZXRTdHlsZShjdHgsIGxpbmUub3B0aW9ucyk7XG4gIGN0eC5zdHJva2UocGF0aCk7XG59XG5cbmZ1bmN0aW9uIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKTtcblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHNlZ21lbnQuc3R5bGUpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoc2VnbWVudE1ldGhvZChjdHgsIGxpbmUsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5jb25zdCB1c2VQYXRoMkQgPSB0eXBlb2YgUGF0aDJEID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBkcmF3KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGlmICh1c2VQYXRoMkQgJiYgIWxpbmUub3B0aW9ucy5zZWdtZW50KSB7XG4gICAgc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH0gZWxzZSB7XG4gICAgc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcblxuICBzdGF0aWMgaWQgPSAnbGluZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgYm9yZGVyQ2FwU3R5bGU6ICdidXR0JyxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICAgIGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcbiAgICBib3JkZXJXaWR0aDogMyxcbiAgICBjYXBCZXppZXJQb2ludHM6IHRydWUsXG4gICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ2RlZmF1bHQnLFxuICAgIGZpbGw6IGZhbHNlLFxuICAgIHNwYW5HYXBzOiBmYWxzZSxcbiAgICBzdGVwcGVkOiBmYWxzZSxcbiAgICB0ZW5zaW9uOiAwLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICB9O1xuXG5cbiAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2ZpbGwnLFxuICB9O1xuXG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuYW5pbWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jaGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9sb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Z1bGxMb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NlZ21lbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RlY2ltYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhc2V0SW5kZXggPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ29udHJvbFBvaW50cyhjaGFydEFyZWEsIGluZGV4QXhpcykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSAmJiAhb3B0aW9ucy5zdGVwcGVkICYmICF0aGlzLl9wb2ludHNVcGRhdGVkKSB7XG4gICAgICBjb25zdCBsb29wID0gb3B0aW9ucy5zcGFuR2FwcyA/IHRoaXMuX2xvb3AgOiB0aGlzLl9mdWxsTG9vcDtcbiAgICAgIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHRoaXMuX3BvaW50cywgb3B0aW9ucywgY2hhcnRBcmVhLCBsb29wLCBpbmRleEF4aXMpO1xuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgc2V0IHBvaW50cyhwb2ludHMpIHtcbiAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XG4gICAgZGVsZXRlIHRoaXMuX3NlZ21lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9wYXRoO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGdldCBwb2ludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cztcbiAgfVxuXG4gIGdldCBzZWdtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudHMgfHwgKHRoaXMuX3NlZ21lbnRzID0gX2NvbXB1dGVTZWdtZW50cyh0aGlzLCB0aGlzLm9wdGlvbnMuc2VnbWVudCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEZpcnN0IG5vbi1za2lwcGVkIHBvaW50IG9uIHRoaXMgbGluZVxuXHQgKiBAcmV0dXJucyB7UG9pbnRFbGVtZW50fHVuZGVmaW5lZH1cblx0ICovXG4gIGZpcnN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoICYmIHBvaW50c1tzZWdtZW50c1swXS5zdGFydF07XG4gIH1cblxuICAvKipcblx0ICogTGFzdCBub24tc2tpcHBlZCBwb2ludCBvbiB0aGlzIGxpbmVcblx0ICogQHJldHVybnMge1BvaW50RWxlbWVudHx1bmRlZmluZWR9XG5cdCAqL1xuICBsYXN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBjb3VudCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gY291bnQgJiYgcG9pbnRzW3NlZ21lbnRzW2NvdW50IC0gMV0uZW5kXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBJbnRlcnBvbGF0ZSBhIHBvaW50IGluIHRoaXMgbGluZSBhdCB0aGUgc2FtZSB2YWx1ZSBvbiBgcHJvcGVydHlgIGFzXG5cdCAqIHRoZSByZWZlcmVuY2UgYHBvaW50YCBwcm92aWRlZFxuXHQgKiBAcGFyYW0ge1BvaW50RWxlbWVudH0gcG9pbnQgLSB0aGUgcmVmZXJlbmNlIHBvaW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eSB0byBtYXRjaCBvblxuXHQgKiBAcmV0dXJucyB7UG9pbnRFbGVtZW50fHVuZGVmaW5lZH1cblx0ICovXG4gIGludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0aGlzLCB7cHJvcGVydHksIHN0YXJ0OiB2YWx1ZSwgZW5kOiB2YWx1ZX0pO1xuXG4gICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBfaW50ZXJwb2xhdGUgPSBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50c1tpXTtcbiAgICAgIGNvbnN0IHAxID0gcG9pbnRzW3N0YXJ0XTtcbiAgICAgIGNvbnN0IHAyID0gcG9pbnRzW2VuZF07XG4gICAgICBpZiAocDEgPT09IHAyKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0ID0gTWF0aC5hYnMoKHZhbHVlIC0gcDFbcHJvcGVydHldKSAvIChwMltwcm9wZXJ0eV0gLSBwMVtwcm9wZXJ0eV0pKTtcbiAgICAgIGNvbnN0IGludGVycG9sYXRlZCA9IF9pbnRlcnBvbGF0ZShwMSwgcDIsIHQsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgICBpbnRlcnBvbGF0ZWRbcHJvcGVydHldID0gcG9pbnRbcHJvcGVydHldO1xuICAgICAgcmVzdWx0LnB1c2goaW50ZXJwb2xhdGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogQXBwZW5kIGEgc2VnbWVudCBvZiB0aGlzIGxpbmUgdG8gY3VycmVudCBwYXRoLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBzZWdtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gXHQgKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuXHQgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLm1vdmUgLSBtb3ZlIHRvIHN0YXJ0aW5nIHBvaW50ICh2cyBsaW5lIHRvIGl0KVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZW5kIC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgZW5kaW5nIGF0IGBzdGFydGAgKyBgY291bnRgIGluZGV4XG5cdCAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBzZWdtZW50IGlzIGEgZnVsbCBsb29wIChwYXRoIHNob3VsZCBiZSBjbG9zZWQpXG5cdCAqL1xuICBwYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICByZXR1cm4gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcblx0ICogQXBwZW5kIGFsbCBzZWdtZW50cyBvZiB0aGlzIGxpbmUgdG8gY3VycmVudCBwYXRoLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxQYXRoMkR9IGN0eFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2NvdW50XVxuXHQgKiBAcmV0dXJucyB7dW5kZWZpbmVkfGJvb2xlYW59IC0gdHJ1ZSBpZiBsaW5lIGlzIGEgZnVsbCBsb29wIChwYXRoIHNob3VsZCBiZSBjbG9zZWQpXG5cdCAqL1xuICBwYXRoKGN0eCwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICBsZXQgbG9vcCA9IHRoaXMuX2xvb3A7XG5cbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgY291bnQgPSBjb3VudCB8fCAodGhpcy5wb2ludHMubGVuZ3RoIC0gc3RhcnQpO1xuXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICBsb29wICY9IHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KTtcbiAgICB9XG4gICAgcmV0dXJuICEhbG9vcDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0QXJlYVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2NvdW50XVxuXHQgKi9cbiAgZHJhdyhjdHgsIGNoYXJ0QXJlYSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cyB8fCBbXTtcblxuICAgIGlmIChwb2ludHMubGVuZ3RoICYmIG9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGRyYXcoY3R4LCB0aGlzLCBzdGFydCwgY291bnQpO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFuaW1hdGVkKSB7XG4gICAgICAvLyBXaGVuIGxpbmUgaXMgYW5pbWF0ZWQsIHRoZSBjb250cm9sIHBvaW50cyBhbmQgcGF0aCBhcmUgbm90IGNhY2hlZC5cbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtkcmF3UG9pbnQsIF9pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB0eXBlIHtcbiAgQ2FydGVzaWFuUGFyc2VkRGF0YSxcbiAgQ2hhcnRBcmVhLFxuICBQb2ludCxcbiAgUG9pbnRIb3Zlck9wdGlvbnMsXG4gIFBvaW50T3B0aW9ucyxcbn0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBpblJhbmdlKGVsOiBQb2ludEVsZW1lbnQsIHBvczogbnVtYmVyLCBheGlzOiAneCcgfCAneScsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBlbC5vcHRpb25zO1xuICBjb25zdCB7W2F4aXNdOiB2YWx1ZX0gPSBlbC5nZXRQcm9wcyhbYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pO1xuXG4gIHJldHVybiAoTWF0aC5hYnMocG9zIC0gdmFsdWUpIDwgb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cyk7XG59XG5cbmV4cG9ydCB0eXBlIFBvaW50UHJvcHMgPSBQb2ludFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PFBvaW50UHJvcHMsIFBvaW50T3B0aW9ucyAmIFBvaW50SG92ZXJPcHRpb25zPiB7XG5cbiAgc3RhdGljIGlkID0gJ3BvaW50JztcblxuICBwYXJzZWQ6IENhcnRlc2lhblBhcnNlZERhdGE7XG4gIHNraXA/OiBib29sZWFuO1xuICBzdG9wPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBib3JkZXJXaWR0aDogMSxcbiAgICBoaXRSYWRpdXM6IDEsXG4gICAgaG92ZXJCb3JkZXJXaWR0aDogMSxcbiAgICBob3ZlclJhZGl1czogNCxcbiAgICBwb2ludFN0eWxlOiAnY2lyY2xlJyxcbiAgICByYWRpdXM6IDMsXG4gICAgcm90YXRpb246IDBcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFyc2VkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2tpcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0b3AgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgaW5SYW5nZShtb3VzZVg6IG51bWJlciwgbW91c2VZOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiAoKE1hdGgucG93KG1vdXNlWCAtIHgsIDIpICsgTWF0aC5wb3cobW91c2VZIC0geSwgMikpIDwgTWF0aC5wb3cob3B0aW9ucy5oaXRSYWRpdXMgKyBvcHRpb25zLnJhZGl1cywgMikpO1xuICB9XG5cbiAgaW5YUmFuZ2UobW91c2VYOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCAneCcsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgaW5ZUmFuZ2UobW91c2VZOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VZLCAneScsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX07XG4gIH1cblxuICBzaXplKG9wdGlvbnM/OiBQYXJ0aWFsPFBvaW50T3B0aW9ucyAmIFBvaW50SG92ZXJPcHRpb25zPikge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMDtcbiAgICByYWRpdXMgPSBNYXRoLm1heChyYWRpdXMsIHJhZGl1cyAmJiBvcHRpb25zLmhvdmVyUmFkaXVzIHx8IDApO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gcmFkaXVzICYmIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICByZXR1cm4gKHJhZGl1cyArIGJvcmRlcldpZHRoKSAqIDI7XG4gIH1cblxuICBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBhcmVhOiBDaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKHRoaXMuc2tpcCB8fCBvcHRpb25zLnJhZGl1cyA8IDAuMSB8fCAhX2lzUG9pbnRJbkFyZWEodGhpcywgYXJlYSwgdGhpcy5zaXplKG9wdGlvbnMpIC8gMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBkcmF3UG9pbnQoY3R4LCBvcHRpb25zLCB0aGlzLngsIHRoaXMueSk7XG4gIH1cblxuICBnZXRSYW5nZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgRmFsbGJhY2tzIHNob3VsZCBuZXZlciBiZSBoaXQgaW4gcHJhY3RpY2VcbiAgICByZXR1cm4gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cztcbiAgfVxufVxuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7aXNPYmplY3QsIF9pc0JldHdlZW4sIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7YWRkUm91bmRlZFJlY3RQYXRofSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7dG9UUkJMLCB0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbi8qKiBAdHlwZWRlZiB7eyB4OiBudW1iZXIsIHk6IG51bWJlciwgYmFzZTogbnVtYmVyLCBob3Jpem9udGFsOiBib29sZWFuLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9fSBCYXJQcm9wcyAqL1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGJvdW5kcyBvZiB0aGUgYmFyIHJlZ2FyZGxlc3Mgb2YgdGhlIG9yaWVudGF0aW9uXG4gKiBAcGFyYW0ge0JhckVsZW1lbnR9IGJhciB0aGUgYmFyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXVxuICogQHJldHVybiB7b2JqZWN0fSBib3VuZHMgb2YgdGhlIGJhclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCB7eCwgeSwgYmFzZSwgd2lkdGgsIGhlaWdodH0gPSAvKiogQHR5cGUge0JhclByb3BzfSAqLyAoYmFyLmdldFByb3BzKFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J10sIHVzZUZpbmFsUG9zaXRpb24pKTtcblxuICBsZXQgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBoYWxmO1xuXG4gIGlmIChiYXIuaG9yaXpvbnRhbCkge1xuICAgIGhhbGYgPSBoZWlnaHQgLyAyO1xuICAgIGxlZnQgPSBNYXRoLm1pbih4LCBiYXNlKTtcbiAgICByaWdodCA9IE1hdGgubWF4KHgsIGJhc2UpO1xuICAgIHRvcCA9IHkgLSBoYWxmO1xuICAgIGJvdHRvbSA9IHkgKyBoYWxmO1xuICB9IGVsc2Uge1xuICAgIGhhbGYgPSB3aWR0aCAvIDI7XG4gICAgbGVmdCA9IHggLSBoYWxmO1xuICAgIHJpZ2h0ID0geCArIGhhbGY7XG4gICAgdG9wID0gTWF0aC5taW4oeSwgYmFzZSk7XG4gICAgYm90dG9tID0gTWF0aC5tYXgoeSwgYmFzZSk7XG4gIH1cblxuICByZXR1cm4ge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX07XG59XG5cbmZ1bmN0aW9uIHNraXBPckxpbWl0KHNraXAsIHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gc2tpcCA/IDAgOiBfbGltaXRWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUJvcmRlcldpZHRoKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlcldpZHRoO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IG8gPSB0b1RSQkwodmFsdWUpO1xuXG4gIHJldHVybiB7XG4gICAgdDogc2tpcE9yTGltaXQoc2tpcC50b3AsIG8udG9wLCAwLCBtYXhIKSxcbiAgICByOiBza2lwT3JMaW1pdChza2lwLnJpZ2h0LCBvLnJpZ2h0LCAwLCBtYXhXKSxcbiAgICBiOiBza2lwT3JMaW1pdChza2lwLmJvdHRvbSwgby5ib3R0b20sIDAsIG1heEgpLFxuICAgIGw6IHNraXBPckxpbWl0KHNraXAubGVmdCwgby5sZWZ0LCAwLCBtYXhXKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3Qge2VuYWJsZUJvcmRlclJhZGl1c30gPSBiYXIuZ2V0UHJvcHMoWydlbmFibGVCb3JkZXJSYWRpdXMnXSk7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyUmFkaXVzO1xuICBjb25zdCBvID0gdG9UUkJMQ29ybmVycyh2YWx1ZSk7XG4gIGNvbnN0IG1heFIgPSBNYXRoLm1pbihtYXhXLCBtYXhIKTtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGFzc3VtZSB0aGUgdXNlciBrbm93cyB3aGF0IHRoZXkgYXJlIGRvaW5nXG4gIC8vIGFuZCBhcHBseSBhcyBkaXJlY3RlZC5cbiAgY29uc3QgZW5hYmxlQm9yZGVyID0gZW5hYmxlQm9yZGVyUmFkaXVzIHx8IGlzT2JqZWN0KHZhbHVlKTtcblxuICByZXR1cm4ge1xuICAgIHRvcExlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5sZWZ0LCBvLnRvcExlZnQsIDAsIG1heFIpLFxuICAgIHRvcFJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAucmlnaHQsIG8udG9wUmlnaHQsIDAsIG1heFIpLFxuICAgIGJvdHRvbUxlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5sZWZ0LCBvLmJvdHRvbUxlZnQsIDAsIG1heFIpLFxuICAgIGJvdHRvbVJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAucmlnaHQsIG8uYm90dG9tUmlnaHQsIDAsIG1heFIpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJvdW5kaW5nUmVjdHMoYmFyKSB7XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJhckJvdW5kcyhiYXIpO1xuICBjb25zdCB3aWR0aCA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xuICBjb25zdCBoZWlnaHQgPSBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcDtcbiAgY29uc3QgYm9yZGVyID0gcGFyc2VCb3JkZXJXaWR0aChiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIGNvbnN0IHJhZGl1cyA9IHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblxuICByZXR1cm4ge1xuICAgIG91dGVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCxcbiAgICAgIHk6IGJvdW5kcy50b3AsXG4gICAgICB3OiB3aWR0aCxcbiAgICAgIGg6IGhlaWdodCxcbiAgICAgIHJhZGl1c1xuICAgIH0sXG4gICAgaW5uZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0ICsgYm9yZGVyLmwsXG4gICAgICB5OiBib3VuZHMudG9wICsgYm9yZGVyLnQsXG4gICAgICB3OiB3aWR0aCAtIGJvcmRlci5sIC0gYm9yZGVyLnIsXG4gICAgICBoOiBoZWlnaHQgLSBib3JkZXIudCAtIGJvcmRlci5iLFxuICAgICAgcmFkaXVzOiB7XG4gICAgICAgIHRvcExlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BMZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5sKSksXG4gICAgICAgIHRvcFJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wUmlnaHQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLnIpKSxcbiAgICAgICAgYm90dG9tTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbUxlZnQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLmwpKSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21SaWdodCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIucikpLFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5SYW5nZShiYXIsIHgsIHksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qgc2tpcFggPSB4ID09PSBudWxsO1xuICBjb25zdCBza2lwWSA9IHkgPT09IG51bGw7XG4gIGNvbnN0IHNraXBCb3RoID0gc2tpcFggJiYgc2tpcFk7XG4gIGNvbnN0IGJvdW5kcyA9IGJhciAmJiAhc2tpcEJvdGggJiYgZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbik7XG5cbiAgcmV0dXJuIGJvdW5kc1xuXHRcdCYmIChza2lwWCB8fCBfaXNCZXR3ZWVuKHgsIGJvdW5kcy5sZWZ0LCBib3VuZHMucmlnaHQpKVxuXHRcdCYmIChza2lwWSB8fCBfaXNCZXR3ZWVuKHksIGJvdW5kcy50b3AsIGJvdW5kcy5ib3R0b20pKTtcbn1cblxuZnVuY3Rpb24gaGFzUmFkaXVzKHJhZGl1cykge1xuICByZXR1cm4gcmFkaXVzLnRvcExlZnQgfHwgcmFkaXVzLnRvcFJpZ2h0IHx8IHJhZGl1cy5ib3R0b21MZWZ0IHx8IHJhZGl1cy5ib3R0b21SaWdodDtcbn1cblxuLyoqXG4gKiBBZGQgYSBwYXRoIG9mIGEgcmVjdGFuZ2xlIHRvIHRoZSBjdXJyZW50IHN1Yi1wYXRoXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHRcbiAqIEBwYXJhbSB7Kn0gcmVjdCBCb3VuZGluZyByZWN0XG4gKi9cbmZ1bmN0aW9uIGFkZE5vcm1hbFJlY3RQYXRoKGN0eCwgcmVjdCkge1xuICBjdHgucmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53LCByZWN0LmgpO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVjdChyZWN0LCBhbW91bnQsIHJlZlJlY3QgPSB7fSkge1xuICBjb25zdCB4ID0gcmVjdC54ICE9PSByZWZSZWN0LnggPyAtYW1vdW50IDogMDtcbiAgY29uc3QgeSA9IHJlY3QueSAhPT0gcmVmUmVjdC55ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHcgPSAocmVjdC54ICsgcmVjdC53ICE9PSByZWZSZWN0LnggKyByZWZSZWN0LncgPyBhbW91bnQgOiAwKSAtIHg7XG4gIGNvbnN0IGggPSAocmVjdC55ICsgcmVjdC5oICE9PSByZWZSZWN0LnkgKyByZWZSZWN0LmggPyBhbW91bnQgOiAwKSAtIHk7XG4gIHJldHVybiB7XG4gICAgeDogcmVjdC54ICsgeCxcbiAgICB5OiByZWN0LnkgKyB5LFxuICAgIHc6IHJlY3QudyArIHcsXG4gICAgaDogcmVjdC5oICsgaCxcbiAgICByYWRpdXM6IHJlY3QucmFkaXVzXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcblxuICBzdGF0aWMgaWQgPSAnYmFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBib3JkZXJTa2lwcGVkOiAnc3RhcnQnLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIGJvcmRlclJhZGl1czogMCxcbiAgICBpbmZsYXRlQW1vdW50OiAnYXV0bycsXG4gICAgcG9pbnRTdHlsZTogdW5kZWZpbmVkXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhvcml6b250YWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYXNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbmZsYXRlQW1vdW50ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuXG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qge2luZmxhdGVBbW91bnQsIG9wdGlvbnM6IHtib3JkZXJDb2xvciwgYmFja2dyb3VuZENvbG9yfX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpbm5lciwgb3V0ZXJ9ID0gYm91bmRpbmdSZWN0cyh0aGlzKTtcbiAgICBjb25zdCBhZGRSZWN0UGF0aCA9IGhhc1JhZGl1cyhvdXRlci5yYWRpdXMpID8gYWRkUm91bmRlZFJlY3RQYXRoIDogYWRkTm9ybWFsUmVjdFBhdGg7XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgaWYgKG91dGVyLncgIT09IGlubmVyLncgfHwgb3V0ZXIuaCAhPT0gaW5uZXIuaCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChvdXRlciwgaW5mbGF0ZUFtb3VudCwgaW5uZXIpKTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCAtaW5mbGF0ZUFtb3VudCwgb3V0ZXIpKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsKCdldmVub2RkJyk7XG4gICAgfVxuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIGluZmxhdGVBbW91bnQpKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5maWxsKCk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbnVsbCwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBpbllSYW5nZShtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBudWxsLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5LCBiYXNlLCBob3Jpem9udGFsfSA9IC8qKiBAdHlwZSB7QmFyUHJvcHN9ICovICh0aGlzLmdldFByb3BzKFsneCcsICd5JywgJ2Jhc2UnLCAnaG9yaXpvbnRhbCddLCB1c2VGaW5hbFBvc2l0aW9uKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyAoeCArIGJhc2UpIC8gMiA6IHgsXG4gICAgICB5OiBob3Jpem9udGFsID8geSA6ICh5ICsgYmFzZSkgLyAyXG4gICAgfTtcbiAgfVxuXG4gIGdldFJhbmdlKGF4aXMpIHtcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gdGhpcy53aWR0aCAvIDIgOiB0aGlzLmhlaWdodCAvIDI7XG4gIH1cbn1cbiIsICJpbXBvcnQge0RvdWdobnV0Q29udHJvbGxlciwgUG9sYXJBcmVhQ29udHJvbGxlciwgZGVmYXVsdHN9IGZyb20gJy4uL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtDaGFydCwgQ2hhcnREYXRhc2V0fSBmcm9tICcuLi90eXBlcy5qcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sb3JzUGx1Z2luT3B0aW9ucyB7XG4gIGVuYWJsZWQ/OiBib29sZWFuO1xuICBmb3JjZU92ZXJyaWRlPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIENvbG9yc0Rlc2NyaXB0b3Ige1xuICBiYWNrZ3JvdW5kQ29sb3I/OiB1bmtub3duO1xuICBib3JkZXJDb2xvcj86IHVua25vd247XG59XG5cbmNvbnN0IEJPUkRFUl9DT0xPUlMgPSBbXG4gICdyZ2IoNTQsIDE2MiwgMjM1KScsIC8vIGJsdWVcbiAgJ3JnYigyNTUsIDk5LCAxMzIpJywgLy8gcmVkXG4gICdyZ2IoMjU1LCAxNTksIDY0KScsIC8vIG9yYW5nZVxuICAncmdiKDI1NSwgMjA1LCA4NiknLCAvLyB5ZWxsb3dcbiAgJ3JnYig3NSwgMTkyLCAxOTIpJywgLy8gZ3JlZW5cbiAgJ3JnYigxNTMsIDEwMiwgMjU1KScsIC8vIHB1cnBsZVxuICAncmdiKDIwMSwgMjAzLCAyMDcpJyAvLyBncmV5XG5dO1xuXG4vLyBCb3JkZXIgY29sb3JzIHdpdGggNTAlIHRyYW5zcGFyZW5jeVxuY29uc3QgQkFDS0dST1VORF9DT0xPUlMgPSAvKiAjX19QVVJFX18gKi8gQk9SREVSX0NPTE9SUy5tYXAoY29sb3IgPT4gY29sb3IucmVwbGFjZSgncmdiKCcsICdyZ2JhKCcpLnJlcGxhY2UoJyknLCAnLCAwLjUpJykpO1xuXG5mdW5jdGlvbiBnZXRCb3JkZXJDb2xvcihpOiBudW1iZXIpIHtcbiAgcmV0dXJuIEJPUkRFUl9DT0xPUlNbaSAlIEJPUkRFUl9DT0xPUlMubGVuZ3RoXTtcbn1cblxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZENvbG9yKGk6IG51bWJlcikge1xuICByZXR1cm4gQkFDS0dST1VORF9DT0xPUlNbaSAlIEJBQ0tHUk9VTkRfQ09MT1JTLmxlbmd0aF07XG59XG5cbmZ1bmN0aW9uIGNvbG9yaXplRGVmYXVsdERhdGFzZXQoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBpOiBudW1iZXIpIHtcbiAgZGF0YXNldC5ib3JkZXJDb2xvciA9IGdldEJvcmRlckNvbG9yKGkpO1xuICBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA9IGdldEJhY2tncm91bmRDb2xvcihpKTtcblxuICByZXR1cm4gKytpO1xufVxuXG5mdW5jdGlvbiBjb2xvcml6ZURvdWdobnV0RGF0YXNldChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGk6IG51bWJlcikge1xuICBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA9IGRhdGFzZXQuZGF0YS5tYXAoKCkgPT4gZ2V0Qm9yZGVyQ29sb3IoaSsrKSk7XG5cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yaXplUG9sYXJBcmVhRGF0YXNldChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGk6IG51bWJlcikge1xuICBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA9IGRhdGFzZXQuZGF0YS5tYXAoKCkgPT4gZ2V0QmFja2dyb3VuZENvbG9yKGkrKykpO1xuXG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBnZXRDb2xvcml6ZXIoY2hhcnQ6IENoYXJ0KSB7XG4gIGxldCBpID0gMDtcblxuICByZXR1cm4gKGRhdGFzZXQ6IENoYXJ0RGF0YXNldCwgZGF0YXNldEluZGV4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBEb3VnaG51dENvbnRyb2xsZXIpIHtcbiAgICAgIGkgPSBjb2xvcml6ZURvdWdobnV0RGF0YXNldChkYXRhc2V0LCBpKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBQb2xhckFyZWFDb250cm9sbGVyKSB7XG4gICAgICBpID0gY29sb3JpemVQb2xhckFyZWFEYXRhc2V0KGRhdGFzZXQsIGkpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlcikge1xuICAgICAgaSA9IGNvbG9yaXplRGVmYXVsdERhdGFzZXQoZGF0YXNldCwgaSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb250YWluc0NvbG9yc0RlZmluaXRpb25zKFxuICBkZXNjcmlwdG9yczogQ29sb3JzRGVzY3JpcHRvcltdIHwgUmVjb3JkPHN0cmluZywgQ29sb3JzRGVzY3JpcHRvcj5cbikge1xuICBsZXQgazogbnVtYmVyIHwgc3RyaW5nO1xuXG4gIGZvciAoayBpbiBkZXNjcmlwdG9ycykge1xuICAgIGlmIChkZXNjcmlwdG9yc1trXS5ib3JkZXJDb2xvciB8fCBkZXNjcmlwdG9yc1trXS5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNDb2xvcnNEZWZpbml0aW9uKFxuICBkZXNjcmlwdG9yOiBDb2xvcnNEZXNjcmlwdG9yXG4pIHtcbiAgcmV0dXJuIGRlc2NyaXB0b3IgJiYgKGRlc2NyaXB0b3IuYm9yZGVyQ29sb3IgfHwgZGVzY3JpcHRvci5iYWNrZ3JvdW5kQ29sb3IpO1xufVxuXG5mdW5jdGlvbiBjb250YWluc0RlZmF1bHRDb2xvcnNEZWZlbml0aW9ucygpIHtcbiAgcmV0dXJuIGRlZmF1bHRzLmJvcmRlckNvbG9yICE9PSAncmdiYSgwLDAsMCwwLjEpJyB8fCBkZWZhdWx0cy5iYWNrZ3JvdW5kQ29sb3IgIT09ICdyZ2JhKDAsMCwwLDAuMSknO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnY29sb3JzJyxcblxuICBkZWZhdWx0czoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZm9yY2VPdmVycmlkZTogZmFsc2VcbiAgfSBhcyBDb2xvcnNQbHVnaW5PcHRpb25zLFxuXG4gIGJlZm9yZUxheW91dChjaGFydDogQ2hhcnQsIF9hcmdzLCBvcHRpb25zOiBDb2xvcnNQbHVnaW5PcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7ZGF0YXNldHN9LFxuICAgICAgb3B0aW9uczogY2hhcnRPcHRpb25zXG4gICAgfSA9IGNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCB7ZWxlbWVudHN9ID0gY2hhcnRPcHRpb25zO1xuXG4gICAgY29uc3QgY29udGFpbnNDb2xvckRlZmVuaXRpb24gPSAoXG4gICAgICBjb250YWluc0NvbG9yc0RlZmluaXRpb25zKGRhdGFzZXRzKSB8fFxuICAgICAgY29udGFpbnNDb2xvcnNEZWZpbml0aW9uKGNoYXJ0T3B0aW9ucykgfHxcbiAgICAgIChlbGVtZW50cyAmJiBjb250YWluc0NvbG9yc0RlZmluaXRpb25zKGVsZW1lbnRzKSkgfHxcbiAgICAgIGNvbnRhaW5zRGVmYXVsdENvbG9yc0RlZmVuaXRpb25zKCkpO1xuXG4gICAgaWYgKCFvcHRpb25zLmZvcmNlT3ZlcnJpZGUgJiYgY29udGFpbnNDb2xvckRlZmVuaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb2xvcml6ZXIgPSBnZXRDb2xvcml6ZXIoY2hhcnQpO1xuXG4gICAgZGF0YXNldHMuZm9yRWFjaChjb2xvcml6ZXIpO1xuICB9XG59O1xuIiwgImltcG9ydCB7X2xpbWl0VmFsdWUsIF9sb29rdXBCeUtleSwgaXNOdWxsT3JVbmRlZiwgcmVzb2x2ZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpIHtcbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBMYXJnZXN0IFRyaWFuZ2xlIFRocmVlIEJ1Y2tldHMgYWxnb3JpdGhtLlxuICAgKlxuICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBieSBTdmVpbm4gU3RlaW5hcnNzb25cbiAgICogaW4gaHR0cHM6Ly9naXRodWIuY29tL3N2ZWlubi1zdGVpbmFyc3Nvbi9mbG90LWRvd25zYW1wbGUvYmxvYi9tYXN0ZXIvanF1ZXJ5LmZsb3QuZG93bnNhbXBsZS5qc1xuICAgKlxuICAgKiBUaGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gaXMgTUlUIGxpY2Vuc2VkLlxuICAgKi9cbiAgY29uc3Qgc2FtcGxlcyA9IG9wdGlvbnMuc2FtcGxlcyB8fCBhdmFpbGFibGVXaWR0aDtcbiAgLy8gVGhlcmUgYXJlIGxlc3MgcG9pbnRzIHRoYW4gdGhlIHRocmVzaG9sZCwgcmV0dXJuaW5nIHRoZSB3aG9sZSBhcnJheVxuICBpZiAoc2FtcGxlcyA+PSBjb3VudCkge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKHN0YXJ0LCBzdGFydCArIGNvdW50KTtcbiAgfVxuXG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuXG4gIGNvbnN0IGJ1Y2tldFdpZHRoID0gKGNvdW50IC0gMikgLyAoc2FtcGxlcyAtIDIpO1xuICBsZXQgc2FtcGxlZEluZGV4ID0gMDtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcbiAgLy8gU3RhcnRpbmcgZnJvbSBvZmZzZXRcbiAgbGV0IGEgPSBzdGFydDtcbiAgbGV0IGksIG1heEFyZWFQb2ludCwgbWF4QXJlYSwgYXJlYSwgbmV4dEE7XG5cbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbYV07XG5cbiAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMgLSAyOyBpKyspIHtcbiAgICBsZXQgYXZnWCA9IDA7XG4gICAgbGV0IGF2Z1kgPSAwO1xuICAgIGxldCBqO1xuXG4gICAgLy8gQWRkaW5nIG9mZnNldFxuICAgIGNvbnN0IGF2Z1JhbmdlU3RhcnQgPSBNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VFbmQgPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMikgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUxlbmd0aCA9IGF2Z1JhbmdlRW5kIC0gYXZnUmFuZ2VTdGFydDtcblxuICAgIGZvciAoaiA9IGF2Z1JhbmdlU3RhcnQ7IGogPCBhdmdSYW5nZUVuZDsgaisrKSB7XG4gICAgICBhdmdYICs9IGRhdGFbal0ueDtcbiAgICAgIGF2Z1kgKz0gZGF0YVtqXS55O1xuICAgIH1cblxuICAgIGF2Z1ggLz0gYXZnUmFuZ2VMZW5ndGg7XG4gICAgYXZnWSAvPSBhdmdSYW5nZUxlbmd0aDtcblxuICAgIC8vIEFkZGluZyBvZmZzZXRcbiAgICBjb25zdCByYW5nZU9mZnMgPSBNYXRoLmZsb29yKGkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgcmFuZ2VUbyA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IHt4OiBwb2ludEF4LCB5OiBwb2ludEF5fSA9IGRhdGFbYV07XG5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBjaGFuZ2VkIGZyb20gdGhlIG9yaWdpbmFsIGFsZ29yaXRobSB3aGljaCBpbml0aWFsaXplcyB0aGVzZVxuICAgIC8vIHZhbHVlcyB0byAxLiBUaGUgcmVhc29uIGZvciB0aGlzIGNoYW5nZSBpcyB0aGF0IGlmIHRoZSBhcmVhIGlzIHNtYWxsLCBuZXh0QVxuICAgIC8vIHdvdWxkIG5ldmVyIGJlIHNldCBhbmQgdGh1cyBhIGNyYXNoIHdvdWxkIG9jY3VyIGluIHRoZSBuZXh0IGxvb3AgYXMgYGFgIHdvdWxkIGJlY29tZVxuICAgIC8vIGB1bmRlZmluZWRgLiBTaW5jZSB0aGUgYXJlYSBpcyBhbHdheXMgcG9zaXRpdmUsIGJ1dCBjb3VsZCBiZSAwIGluIHRoZSBjYXNlIG9mIGEgZmxhdCB0cmFjZSxcbiAgICAvLyBpbml0aWFsaXppbmcgd2l0aCBhIG5lZ2F0aXZlIG51bWJlciBpcyB0aGUgY29ycmVjdCBzb2x1dGlvbi5cbiAgICBtYXhBcmVhID0gYXJlYSA9IC0xO1xuXG4gICAgZm9yIChqID0gcmFuZ2VPZmZzOyBqIDwgcmFuZ2VUbzsgaisrKSB7XG4gICAgICBhcmVhID0gMC41ICogTWF0aC5hYnMoXG4gICAgICAgIChwb2ludEF4IC0gYXZnWCkgKiAoZGF0YVtqXS55IC0gcG9pbnRBeSkgLVxuICAgICAgICAocG9pbnRBeCAtIGRhdGFbal0ueCkgKiAoYXZnWSAtIHBvaW50QXkpXG4gICAgICApO1xuXG4gICAgICBpZiAoYXJlYSA+IG1heEFyZWEpIHtcbiAgICAgICAgbWF4QXJlYSA9IGFyZWE7XG4gICAgICAgIG1heEFyZWFQb2ludCA9IGRhdGFbal07XG4gICAgICAgIG5leHRBID0gajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gbWF4QXJlYVBvaW50O1xuICAgIGEgPSBuZXh0QTtcbiAgfVxuXG4gIC8vIEluY2x1ZGUgdGhlIGxhc3QgcG9pbnRcbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbZW5kSW5kZXhdO1xuXG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5cbmZ1bmN0aW9uIG1pbk1heERlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCkge1xuICBsZXQgYXZnWCA9IDA7XG4gIGxldCBjb3VudFggPSAwO1xuICBsZXQgaSwgcG9pbnQsIHgsIHksIHByZXZYLCBtaW5JbmRleCwgbWF4SW5kZXgsIHN0YXJ0SW5kZXgsIG1pblksIG1heFk7XG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuXG4gIGNvbnN0IHhNaW4gPSBkYXRhW3N0YXJ0XS54O1xuICBjb25zdCB4TWF4ID0gZGF0YVtlbmRJbmRleF0ueDtcbiAgY29uc3QgZHggPSB4TWF4IC0geE1pbjtcblxuICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICB4ID0gKHBvaW50LnggLSB4TWluKSAvIGR4ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG5cbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGBtaW5ZYCAvIGBtYXhZYCBhbmQgYGF2Z1hgIHdoaWxlIHdlIHN0YXkgd2l0aGluIHNhbWUgeC1wb3NpdGlvblxuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgICBtaW5JbmRleCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgICBtYXhJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICAvLyBGb3IgZmlyc3QgcG9pbnQgaW4gZ3JvdXAsIGNvdW50WCBpcyBgMGAsIHNvIGF2ZXJhZ2Ugd2lsbCBiZSBgeGAgLyAxLlxuICAgICAgLy8gVXNlIHBvaW50LnggaGVyZSBiZWNhdXNlIHdlJ3JlIGNvbXB1dGluZyB0aGUgYXZlcmFnZSBkYXRhIGB4YCB2YWx1ZVxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgcG9pbnQueCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHVzaCB1cCB0byA0IHBvaW50cywgMyBmb3IgdGhlIGxhc3QgaW50ZXJ2YWwgYW5kIHRoZSBmaXJzdCBwb2ludCBmb3IgdGhpcyBpbnRlcnZhbFxuICAgICAgY29uc3QgbGFzdEluZGV4ID0gaSAtIDE7XG5cbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihtaW5JbmRleCkgJiYgIWlzTnVsbE9yVW5kZWYobWF4SW5kZXgpKSB7XG4gICAgICAgIC8vIFRoZSBpbnRlcnZhbCBpcyBkZWZpbmVkIGJ5IDQgcG9pbnRzOiBzdGFydCwgbWluLCBtYXgsIGVuZC5cbiAgICAgICAgLy8gVGhlIHN0YXJ0aW5nIHBvaW50IGlzIGFscmVhZHkgY29uc2lkZXJlZCBhdCB0aGlzIHBvaW50LCBzbyB3ZSBuZWVkIHRvIGRldGVybWluZSB3aGljaFxuICAgICAgICAvLyBvZiB0aGUgb3RoZXIgcG9pbnRzIHRvIGFkZC4gV2UgbmVlZCB0byBzb3J0IHRoZXNlIHBvaW50cyB0byBlbnN1cmUgdGhlIGRlY2ltYXRlZCBkYXRhXG4gICAgICAgIC8vIGlzIHN0aWxsIHNvcnRlZCBhbmQgdGhlbiBlbnN1cmUgdGhlcmUgYXJlIG5vIGR1cGxpY2F0ZXMuXG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MSA9IE1hdGgubWluKG1pbkluZGV4LCBtYXhJbmRleCk7XG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MiA9IE1hdGgubWF4KG1pbkluZGV4LCBtYXhJbmRleCk7XG5cbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MSAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDEgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgxXSxcbiAgICAgICAgICAgIHg6IGF2Z1gsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MiAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDIgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgyXSxcbiAgICAgICAgICAgIHg6IGF2Z1hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBsYXN0SW5kZXggPT09IHN0YXJ0SW5kZXggd2lsbCBvY2N1ciB3aGVuIGEgcmFuZ2UgaGFzIG9ubHkgMSBwb2ludCB3aGljaCBjb3VsZFxuICAgICAgLy8gaGFwcGVuIHdpdGggdmVyeSB1bmV2ZW4gZGF0YVxuICAgICAgaWYgKGkgPiAwICYmIGxhc3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xuICAgICAgICAvLyBMYXN0IHBvaW50IGluIHRoZSBwcmV2aW91cyBpbnRlcnZhbFxuICAgICAgICBkZWNpbWF0ZWQucHVzaChkYXRhW2xhc3RJbmRleF0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGFydCBvZiB0aGUgbmV3IGludGVydmFsXG4gICAgICBkZWNpbWF0ZWQucHVzaChwb2ludCk7XG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgICBtaW5JbmRleCA9IG1heEluZGV4ID0gc3RhcnRJbmRleCA9IGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cblxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpIHtcbiAgaWYgKGRhdGFzZXQuX2RlY2ltYXRlZCkge1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0Ll9kYXRhO1xuICAgIGRlbGV0ZSBkYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RhdGE7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGRhdGEsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KSB7XG4gIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCkgPT4ge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIHBvaW50cykge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcblxuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQ7XG5cbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcblxuICBpZiAobWluRGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1pbikubG8sIDAsIHBvaW50Q291bnQgLSAxKTtcbiAgfVxuICBpZiAobWF4RGVmaW5lZCkge1xuICAgIGNvdW50ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1heCkuaGkgKyAxLCBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgfSBlbHNlIHtcbiAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2RlY2ltYXRpb24nLFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxnb3JpdGhtOiAnbWluLW1heCcsXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gIH0sXG5cbiAgYmVmb3JlRWxlbWVudHNVcGRhdGU6IChjaGFydCwgYXJncywgb3B0aW9ucykgPT4ge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICAvLyBUaGUgZGVjaW1hdGlvbiBwbHVnaW4gbWF5IGhhdmUgYmVlbiBwcmV2aW91c2x5IGVuYWJsZWQuIE5lZWQgdG8gcmVtb3ZlIG9sZCBgZGF0YXNldC5fZGF0YWAgaGFuZGxlcnNcbiAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXNzdW1lIHRoZSBlbnRpcmUgY2hhcnQgaXMgYXZhaWxhYmxlIHRvIHNob3cgYSBmZXcgbW9yZSBwb2ludHMgdGhhbiBuZWVkZWRcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IGNoYXJ0LndpZHRoO1xuXG4gICAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtfZGF0YSwgaW5kZXhBeGlzfSA9IGRhdGFzZXQ7XG4gICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBfZGF0YSB8fCBkYXRhc2V0LmRhdGE7XG5cbiAgICAgIGlmIChyZXNvbHZlKFtpbmRleEF4aXMsIGNoYXJ0Lm9wdGlvbnMuaW5kZXhBeGlzXSkgPT09ICd5Jykge1xuICAgICAgICAvLyBEZWNpbWF0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBsaW5lcyB0aGF0IGhhdmUgYW4gWCBpbmRleEF4aXNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW1ldGEuY29udHJvbGxlci5zdXBwb3J0c0RlY2ltYXRpb24pIHtcbiAgICAgICAgLy8gT25seSBsaW5lIGRhdGFzZXRzIGFyZSBzdXBwb3J0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB4QXhpcyA9IGNoYXJ0LnNjYWxlc1ttZXRhLnhBeGlzSURdO1xuICAgICAgaWYgKHhBeGlzLnR5cGUgIT09ICdsaW5lYXInICYmIHhBeGlzLnR5cGUgIT09ICd0aW1lJykge1xuICAgICAgICAvLyBPbmx5IGxpbmVhciBpbnRlcnBvbGF0aW9uIGlzIHN1cHBvcnRlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFydC5vcHRpb25zLnBhcnNpbmcpIHtcbiAgICAgICAgLy8gUGx1Z2luIG9ubHkgc3VwcG9ydHMgZGF0YSB0aGF0IGRvZXMgbm90IG5lZWQgcGFyc2luZ1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIGRhdGEpO1xuICAgICAgY29uc3QgdGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQgfHwgNCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKGNvdW50IDw9IHRocmVzaG9sZCkge1xuICAgICAgICAvLyBObyBkZWNpbWF0aW9uIGlzIHJlcXVpcmVkIHVudGlsIHdlIGFyZSBhYm92ZSB0aGlzIHRocmVzaG9sZFxuICAgICAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYoX2RhdGEpKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgd2UgYXJlIHNlZWluZyB0aGlzIGRhdGFzZXRcbiAgICAgICAgLy8gV2Ugb3ZlcnJpZGUgdGhlICdkYXRhJyBwcm9wZXJ0eSB3aXRoIGEgc2V0dGVyIHRoYXQgc3RvcmVzIHRoZVxuICAgICAgICAvLyByYXcgZGF0YSBpbiBfZGF0YSwgYnV0IHJlYWRzIHRoZSBkZWNpbWF0ZWQgZGF0YSBmcm9tIF9kZWNpbWF0ZWRcbiAgICAgICAgZGF0YXNldC5fZGF0YSA9IGRhdGE7XG4gICAgICAgIGRlbGV0ZSBkYXRhc2V0LmRhdGE7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhc2V0LCAnZGF0YScsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY2ltYXRlZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gUG9pbnQgdGhlIGNoYXJ0IHRvIHRoZSBkZWNpbWF0ZWQgZGF0YVxuICAgICAgbGV0IGRlY2ltYXRlZDtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgJ2x0dGInOlxuICAgICAgICBkZWNpbWF0ZWQgPSBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaW4tbWF4JzpcbiAgICAgICAgZGVjaW1hdGVkID0gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlY2ltYXRpb24gYWxnb3JpdGhtICcke29wdGlvbnMuYWxnb3JpdGhtfSdgKTtcbiAgICAgIH1cblxuICAgICAgZGF0YXNldC5fZGVjaW1hdGVkID0gZGVjaW1hdGVkO1xuICAgIH0pO1xuICB9LFxuXG4gIGRlc3Ryb3koY2hhcnQpIHtcbiAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xuICB9XG59O1xuIiwgImltcG9ydCB7X2JvdW5kU2VnbWVudCwgX2JvdW5kU2VnbWVudHMsIF9ub3JtYWxpemVBbmdsZX0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB0cG9pbnRzID0gdGFyZ2V0LnBvaW50cztcbiAgY29uc3QgcGFydHMgPSBbXTtcblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBsZXQge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKTtcblxuICAgIGNvbnN0IGJvdW5kcyA9IF9nZXRCb3VuZHMocHJvcGVydHksIHBvaW50c1tzdGFydF0sIHBvaW50c1tlbmRdLCBzZWdtZW50Lmxvb3ApO1xuXG4gICAgaWYgKCF0YXJnZXQuc2VnbWVudHMpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYm91bmRhcnkgbm90IHN1cHBvcnRpbmcgYHNlZ21lbnRzYCAoc2ltcGxlQXJjKVxuICAgICAgLy8gQm91bmRzIGFyZSBwcm92aWRlZCBhcyBgdGFyZ2V0YCBmb3IgcGFydGlhbCBjaXJjbGUsIG9yIHVuZGVmaW5lZCBmb3IgZnVsbCBjaXJjbGVcbiAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICBzb3VyY2U6IHNlZ21lbnQsXG4gICAgICAgIHRhcmdldDogYm91bmRzLFxuICAgICAgICBzdGFydDogcG9pbnRzW3N0YXJ0XSxcbiAgICAgICAgZW5kOiBwb2ludHNbZW5kXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBHZXQgYWxsIHNlZ21lbnRzIGZyb20gYHRhcmdldGAgdGhhdCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBvZiBjdXJyZW50IHNlZ21lbnQgb2YgYGxpbmVgXG4gICAgY29uc3QgdGFyZ2V0U2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0YXJnZXQsIGJvdW5kcyk7XG5cbiAgICBmb3IgKGNvbnN0IHRndCBvZiB0YXJnZXRTZWdtZW50cykge1xuICAgICAgY29uc3Qgc3ViQm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgdHBvaW50c1t0Z3Quc3RhcnRdLCB0cG9pbnRzW3RndC5lbmRdLCB0Z3QubG9vcCk7XG4gICAgICBjb25zdCBmaWxsU291cmNlcyA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBzdWJCb3VuZHMpO1xuXG4gICAgICBmb3IgKGNvbnN0IGZpbGxTb3VyY2Ugb2YgZmlsbFNvdXJjZXMpIHtcbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgc291cmNlOiBmaWxsU291cmNlLFxuICAgICAgICAgIHRhcmdldDogdGd0LFxuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ3N0YXJ0JywgTWF0aC5tYXgpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnZW5kJywgTWF0aC5taW4pXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2dldEJvdW5kcyhwcm9wZXJ0eSwgZmlyc3QsIGxhc3QsIGxvb3ApIHtcbiAgaWYgKGxvb3ApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHN0YXJ0ID0gZmlyc3RbcHJvcGVydHldO1xuICBsZXQgZW5kID0gbGFzdFtwcm9wZXJ0eV07XG5cbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgc3RhcnQgPSBfbm9ybWFsaXplQW5nbGUoc3RhcnQpO1xuICAgIGVuZCA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICB9XG4gIHJldHVybiB7cHJvcGVydHksIHN0YXJ0LCBlbmR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3BvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSkge1xuICBjb25zdCB7eCA9IG51bGwsIHkgPSBudWxsfSA9IGJvdW5kYXJ5IHx8IHt9O1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBsaW5lLnNlZ21lbnRzLmZvckVhY2goKHtzdGFydCwgZW5kfSkgPT4ge1xuICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBsaW5lUG9pbnRzKTtcbiAgICBjb25zdCBmaXJzdCA9IGxpbmVQb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3QgPSBsaW5lUG9pbnRzW2VuZF07XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBmaXJzdC54LCB5fSk7XG4gICAgICBwb2ludHMucHVzaCh7eDogbGFzdC54LCB5fSk7XG4gICAgfSBlbHNlIGlmICh4ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogZmlyc3QueX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGxhc3QueX0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwb2ludHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKSB7XG4gIGZvciAoO2VuZCA+IHN0YXJ0OyBlbmQtLSkge1xuICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2VuZF07XG4gICAgaWYgKCFpc05hTihwb2ludC54KSAmJiAhaXNOYU4ocG9pbnQueSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5kO1xufVxuXG5mdW5jdGlvbiBfZ2V0RWRnZShhLCBiLCBwcm9wLCBmbikge1xuICBpZiAoYSAmJiBiKSB7XG4gICAgcmV0dXJuIGZuKGFbcHJvcF0sIGJbcHJvcF0pO1xuICB9XG4gIHJldHVybiBhID8gYVtwcm9wXSA6IGIgPyBiW3Byb3BdIDogMDtcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuaW1wb3J0IHtMaW5lRWxlbWVudH0gZnJvbSAnLi4vLi4vZWxlbWVudHMvaW5kZXguanMnO1xuaW1wb3J0IHtpc0FycmF5fSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X3BvaW50c0Zyb21TZWdtZW50c30gZnJvbSAnLi9maWxsZXIuc2VnbWVudC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXSB8IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IH19IGJvdW5kYXJ5XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcmV0dXJuIHtMaW5lRWxlbWVudD99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGxldCBwb2ludHMgPSBbXTtcbiAgbGV0IF9sb29wID0gZmFsc2U7XG5cbiAgaWYgKGlzQXJyYXkoYm91bmRhcnkpKSB7XG4gICAgX2xvb3AgPSB0cnVlO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwb2ludHMgPSBib3VuZGFyeTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHMubGVuZ3RoID8gbmV3IExpbmVFbGVtZW50KHtcbiAgICBwb2ludHMsXG4gICAgb3B0aW9uczoge3RlbnNpb246IDB9LFxuICAgIF9sb29wLFxuICAgIF9mdWxsTG9vcDogX2xvb3BcbiAgfSkgOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHtcbiAgcmV0dXJuIHNvdXJjZSAmJiBzb3VyY2UuZmlsbCAhPT0gZmFsc2U7XG59XG4iLCAiaW1wb3J0IHtpc09iamVjdCwgaXNGaW5pdGUsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi8uLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcycpLmRlZmF1bHQgfSBMaW5lRWxlbWVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzL2luZGV4LmpzJykuRmlsbFRhcmdldCB9IEZpbGxUYXJnZXRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcy9pbmRleC5qcycpLkNvbXBsZXhGaWxsVGFyZ2V0IH0gQ29tcGxleEZpbGxUYXJnZXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaW5kZXgsIHByb3BhZ2F0ZSkge1xuICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgbGV0IGZpbGwgPSBzb3VyY2UuZmlsbDtcbiAgY29uc3QgdmlzaXRlZCA9IFtpbmRleF07XG4gIGxldCB0YXJnZXQ7XG5cbiAgaWYgKCFwcm9wYWdhdGUpIHtcbiAgICByZXR1cm4gZmlsbDtcbiAgfVxuXG4gIHdoaWxlIChmaWxsICE9PSBmYWxzZSAmJiB2aXNpdGVkLmluZGV4T2YoZmlsbCkgPT09IC0xKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShmaWxsKSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gc291cmNlc1tmaWxsXTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQudmlzaWJsZSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuXG4gICAgdmlzaXRlZC5wdXNoKGZpbGwpO1xuICAgIGZpbGwgPSB0YXJnZXQuZmlsbDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICovXG5leHBvcnQgZnVuY3Rpb24gX2RlY29kZUZpbGwobGluZSwgaW5kZXgsIGNvdW50KSB7XG4gIC8qKiBAdHlwZSB7c3RyaW5nIHwge3ZhbHVlOiBudW1iZXJ9fSAqL1xuICBjb25zdCBmaWxsID0gcGFyc2VGaWxsT3B0aW9uKGxpbmUpO1xuXG4gIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHJldHVybiBpc05hTihmaWxsLnZhbHVlKSA/IGZhbHNlIDogZmlsbDtcbiAgfVxuXG4gIGxldCB0YXJnZXQgPSBwYXJzZUZsb2F0KGZpbGwpO1xuXG4gIGlmIChpc0Zpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGRlY29kZVRhcmdldEluZGV4KGZpbGxbMF0sIGluZGV4LCB0YXJnZXQsIGNvdW50KTtcbiAgfVxuXG4gIHJldHVybiBbJ29yaWdpbicsICdzdGFydCcsICdlbmQnLCAnc3RhY2snLCAnc2hhcGUnXS5pbmRleE9mKGZpbGwpID49IDAgJiYgZmlsbDtcbn1cblxuZnVuY3Rpb24gZGVjb2RlVGFyZ2V0SW5kZXgoZmlyc3RDaCwgaW5kZXgsIHRhcmdldCwgY291bnQpIHtcbiAgaWYgKGZpcnN0Q2ggPT09ICctJyB8fCBmaXJzdENoID09PSAnKycpIHtcbiAgICB0YXJnZXQgPSBpbmRleCArIHRhcmdldDtcbiAgfVxuXG4gIGlmICh0YXJnZXQgPT09IGluZGV4IHx8IHRhcmdldCA8IDAgfHwgdGFyZ2V0ID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZpbGxUYXJnZXQgfCBDb21wbGV4RmlsbFRhcmdldH0gZmlsbFxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEByZXR1cm5zIHtudW1iZXIgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFRhcmdldFBpeGVsKGZpbGwsIHNjYWxlKSB7XG4gIGxldCBwaXhlbCA9IG51bGw7XG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5ib3R0b207XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLnRvcDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwaXhlbCA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZmlsbC52YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgfVxuICByZXR1cm4gcGl4ZWw7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGaWxsVGFyZ2V0IHwgQ29tcGxleEZpbGxUYXJnZXR9IGZpbGxcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRWYWx1ZVxuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRUYXJnZXRWYWx1ZShmaWxsLCBzY2FsZSwgc3RhcnRWYWx1ZSkge1xuICBsZXQgdmFsdWU7XG5cbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICB2YWx1ZSA9IHN0YXJ0VmFsdWU7XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICB2YWx1ZSA9IHNjYWxlLm9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1pbiA6IHNjYWxlLm1heDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB2YWx1ZSA9IGZpbGwudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBzY2FsZS5nZXRCYXNlVmFsdWUoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICovXG5mdW5jdGlvbiBwYXJzZUZpbGxPcHRpb24obGluZSkge1xuICBjb25zdCBvcHRpb25zID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gb3B0aW9ucy5maWxsO1xuICBsZXQgZmlsbCA9IHZhbHVlT3JEZWZhdWx0KGZpbGxPcHRpb24gJiYgZmlsbE9wdGlvbi50YXJnZXQsIGZpbGxPcHRpb24pO1xuXG4gIGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcbiAgICBmaWxsID0gISFvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgfVxuXG4gIGlmIChmaWxsID09PSBmYWxzZSB8fCBmaWxsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09IHRydWUpIHtcbiAgICByZXR1cm4gJ29yaWdpbic7XG4gIH1cbiAgcmV0dXJuIGZpbGw7XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICovXG5cbmltcG9ydCB7TGluZUVsZW1lbnR9IGZyb20gJy4uLy4uL2VsZW1lbnRzL2luZGV4LmpzJztcbmltcG9ydCB7X2lzQmV0d2Vlbn0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19jcmVhdGVCb3VuZGFyeUxpbmV9IGZyb20gJy4vZmlsbGVyLmhlbHBlci5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHt7IGNoYXJ0OiBDaGFydDsgc2NhbGU6IFNjYWxlOyBpbmRleDogbnVtYmVyOyBsaW5lOiBMaW5lRWxlbWVudDsgfX0gc291cmNlXG4gKiBAcmV0dXJuIHtMaW5lRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9idWlsZFN0YWNrTGluZShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlLCBpbmRleCwgbGluZX0gPSBzb3VyY2U7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IHNvdXJjZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBsaW5lc0JlbG93ID0gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpO1xuICBsaW5lc0JlbG93LnB1c2goX2NyZWF0ZUJvdW5kYXJ5TGluZSh7eDogbnVsbCwgeTogc2NhbGUuYm90dG9tfSwgbGluZSkpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgZm9yIChsZXQgaiA9IHNlZ21lbnQuc3RhcnQ7IGogPD0gc2VnbWVudC5lbmQ7IGorKykge1xuICAgICAgYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludHNbal0sIGxpbmVzQmVsb3cpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IExpbmVFbGVtZW50KHtwb2ludHMsIG9wdGlvbnM6IHt9fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7TGluZUVsZW1lbnRbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpIHtcbiAgY29uc3QgYmVsb3cgPSBbXTtcbiAgY29uc3QgbWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygnbGluZScpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgaWYgKG1ldGEuaW5kZXggPT09IGluZGV4KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFtZXRhLmhpZGRlbikge1xuICAgICAgYmVsb3cudW5zaGlmdChtZXRhLmRhdGFzZXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmVsb3c7XG59XG5cbi8qKlxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudH0gc291cmNlUG9pbnRcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnRbXX0gbGluZXNCZWxvd1xuICovXG5mdW5jdGlvbiBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50LCBsaW5lc0JlbG93KSB7XG4gIGNvbnN0IHBvc3Rwb25lZCA9IFtdO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmVzQmVsb3cubGVuZ3RoOyBqKyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNCZWxvd1tqXTtcbiAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHBvaW50fSA9IGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgJ3gnKTtcblxuICAgIGlmICghcG9pbnQgfHwgKGZpcnN0ICYmIGxhc3QpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICAvLyBGaXJzdCBwb2ludCBvZiBhbiBzZWdtZW50IC0+IG5lZWQgdG8gYWRkIGFub3RoZXIgcG9pbnQgYmVmb3JlIHRoaXMsXG4gICAgICAvLyBmcm9tIG5leHQgbGluZSBiZWxvdy5cbiAgICAgIHBvc3Rwb25lZC51bnNoaWZ0KHBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIC8vIEluIHRoZSBtaWRkbGUgb2YgYW4gc2VnbWVudCwgbm8gbmVlZCB0byBhZGQgbW9yZSBwb2ludHMuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwb2ludHMucHVzaCguLi5wb3N0cG9uZWQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50fSBzb3VyY2VQb2ludFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7e3BvaW50PzogUG9pbnRFbGVtZW50LCBmaXJzdD86IGJvb2xlYW4sIGxhc3Q/OiBib29sZWFufX1cbiAqL1xuZnVuY3Rpb24gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBwb2ludCA9IGxpbmUuaW50ZXJwb2xhdGUoc291cmNlUG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKCFwb2ludCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IHBvaW50VmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBsZXQgZmlyc3QgPSBmYWxzZTtcbiAgbGV0IGxhc3QgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBjb25zdCBmaXJzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LnN0YXJ0XVtwcm9wZXJ0eV07XG4gICAgY29uc3QgbGFzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LmVuZF1bcHJvcGVydHldO1xuICAgIGlmIChfaXNCZXR3ZWVuKHBvaW50VmFsdWUsIGZpcnN0VmFsdWUsIGxhc3RWYWx1ZSkpIHtcbiAgICAgIGZpcnN0ID0gcG9pbnRWYWx1ZSA9PT0gZmlyc3RWYWx1ZTtcbiAgICAgIGxhc3QgPSBwb2ludFZhbHVlID09PSBsYXN0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtmaXJzdCwgbGFzdCwgcG9pbnR9O1xufVxuIiwgImltcG9ydCB7VEFVfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLy8gVE9ETzogdXNlIGVsZW1lbnRzLkFyY0VsZW1lbnQgaW5zdGVhZFxuZXhwb3J0IGNsYXNzIHNpbXBsZUFyYyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLnggPSBvcHRzLng7XG4gICAgdGhpcy55ID0gb3B0cy55O1xuICAgIHRoaXMucmFkaXVzID0gb3B0cy5yYWRpdXM7XG4gIH1cblxuICBwYXRoU2VnbWVudChjdHgsIGJvdW5kcywgb3B0cykge1xuICAgIGNvbnN0IHt4LCB5LCByYWRpdXN9ID0gdGhpcztcbiAgICBib3VuZHMgPSBib3VuZHMgfHwge3N0YXJ0OiAwLCBlbmQ6IFRBVX07XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIGJvdW5kcy5lbmQsIGJvdW5kcy5zdGFydCwgdHJ1ZSk7XG4gICAgcmV0dXJuICFvcHRzLmJvdW5kcztcbiAgfVxuXG4gIGludGVycG9sYXRlKHBvaW50KSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGNvbnN0IGFuZ2xlID0gcG9pbnQuYW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG59XG4iLCAiaW1wb3J0IHtpc0Zpbml0ZX0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19jcmVhdGVCb3VuZGFyeUxpbmV9IGZyb20gJy4vZmlsbGVyLmhlbHBlci5qcyc7XG5pbXBvcnQge19nZXRUYXJnZXRQaXhlbCwgX2dldFRhcmdldFZhbHVlfSBmcm9tICcuL2ZpbGxlci5vcHRpb25zLmpzJztcbmltcG9ydCB7X2J1aWxkU3RhY2tMaW5lfSBmcm9tICcuL2ZpbGxlci50YXJnZXQuc3RhY2suanMnO1xuaW1wb3J0IHtzaW1wbGVBcmN9IGZyb20gJy4vc2ltcGxlQXJjLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0VGFyZ2V0KHNvdXJjZSkge1xuICBjb25zdCB7Y2hhcnQsIGZpbGwsIGxpbmV9ID0gc291cmNlO1xuXG4gIGlmIChpc0Zpbml0ZShmaWxsKSkge1xuICAgIHJldHVybiBnZXRMaW5lQnlJbmRleChjaGFydCwgZmlsbCk7XG4gIH1cblxuICBpZiAoZmlsbCA9PT0gJ3N0YWNrJykge1xuICAgIHJldHVybiBfYnVpbGRTdGFja0xpbmUoc291cmNlKTtcbiAgfVxuXG4gIGlmIChmaWxsID09PSAnc2hhcGUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBib3VuZGFyeSA9IGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpO1xuXG4gIGlmIChib3VuZGFyeSBpbnN0YW5jZW9mIHNpbXBsZUFyYykge1xuICAgIHJldHVybiBib3VuZGFyeTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmZ1bmN0aW9uIGdldExpbmVCeUluZGV4KGNoYXJ0LCBpbmRleCkge1xuICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICBjb25zdCB2aXNpYmxlID0gbWV0YSAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KTtcbiAgcmV0dXJuIHZpc2libGUgPyBtZXRhLmRhdGFzZXQgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHNjYWxlID0gc291cmNlLnNjYWxlIHx8IHt9O1xuXG4gIGlmIChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUpIHtcbiAgICByZXR1cm4gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKTtcbiAgfVxuICByZXR1cm4gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSk7XG59XG5cblxuZnVuY3Rpb24gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUgPSB7fSwgZmlsbH0gPSBzb3VyY2U7XG4gIGNvbnN0IHBpeGVsID0gX2dldFRhcmdldFBpeGVsKGZpbGwsIHNjYWxlKTtcblxuICBpZiAoaXNGaW5pdGUocGl4ZWwpKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyBwaXhlbCA6IG51bGwsXG4gICAgICB5OiBob3Jpem9udGFsID8gbnVsbCA6IHBpeGVsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlLCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3Qgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnM7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLmdldExhYmVscygpLmxlbmd0aDtcbiAgY29uc3Qgc3RhcnQgPSBvcHRpb25zLnJldmVyc2UgPyBzY2FsZS5tYXggOiBzY2FsZS5taW47XG4gIGNvbnN0IHZhbHVlID0gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydCk7XG4gIGNvbnN0IHRhcmdldCA9IFtdO1xuXG4gIGlmIChvcHRpb25zLmdyaWQuY2lyY3VsYXIpIHtcbiAgICBjb25zdCBjZW50ZXIgPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoMCwgc3RhcnQpO1xuICAgIHJldHVybiBuZXcgc2ltcGxlQXJjKHtcbiAgICAgIHg6IGNlbnRlci54LFxuICAgICAgeTogY2VudGVyLnksXG4gICAgICByYWRpdXM6IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKVxuICAgIH0pO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHRhcmdldC5wdXNoKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbiIsICJpbXBvcnQge2NsaXBBcmVhLCB1bmNsaXBBcmVhLCBnZXREYXRhc2V0Q2xpcEFyZWF9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfZmluZFNlZ21lbnRFbmQsIF9nZXRCb3VuZHMsIF9zZWdtZW50c30gZnJvbSAnLi9maWxsZXIuc2VnbWVudC5qcyc7XG5pbXBvcnQge19nZXRUYXJnZXR9IGZyb20gJy4vZmlsbGVyLnRhcmdldC5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfZHJhd2ZpbGwoY3R4LCBzb3VyY2UsIGFyZWEpIHtcbiAgY29uc3QgdGFyZ2V0ID0gX2dldFRhcmdldChzb3VyY2UpO1xuICBjb25zdCB7Y2hhcnQsIGluZGV4LCBsaW5lLCBzY2FsZSwgYXhpc30gPSBzb3VyY2U7XG4gIGNvbnN0IGxpbmVPcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gbGluZU9wdHMuZmlsbDtcbiAgY29uc3QgY29sb3IgPSBsaW5lT3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gIGNvbnN0IHthYm92ZSA9IGNvbG9yLCBiZWxvdyA9IGNvbG9yfSA9IGZpbGxPcHRpb24gfHwge307XG4gIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gIGNvbnN0IGNsaXAgPSBnZXREYXRhc2V0Q2xpcEFyZWEoY2hhcnQsIG1ldGEpO1xuICBpZiAodGFyZ2V0ICYmIGxpbmUucG9pbnRzLmxlbmd0aCkge1xuICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgZG9GaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZSwgYXhpcywgY2xpcH0pO1xuICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZSwgY2xpcH0gPSBjZmc7XG4gIGNvbnN0IHByb3BlcnR5ID0gbGluZS5fbG9vcCA/ICdhbmdsZScgOiBjZmcuYXhpcztcblxuICBjdHguc2F2ZSgpO1xuXG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnICYmIGJlbG93ICE9PSBhYm92ZSkge1xuICAgIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgYXJlYS50b3ApO1xuICAgIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYWJvdmUsIHNjYWxlLCBwcm9wZXJ0eSwgY2xpcH0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEuYm90dG9tKTtcbiAgfVxuICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGJlbG93LCBzY2FsZSwgcHJvcGVydHksIGNsaXB9KTtcblxuICBjdHgucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGNsaXBZKSB7XG4gIGNvbnN0IHtzZWdtZW50cywgcG9pbnRzfSA9IHRhcmdldDtcbiAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgbGV0IGxpbmVMb29wID0gZmFsc2U7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBwb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IHBvaW50c1tfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKV07XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBjbGlwWSk7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICB9XG4gICAgbGluZUxvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHttb3ZlOiBsaW5lTG9vcH0pO1xuICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGxhc3RQb2ludC54LCBjbGlwWSk7XG4gICAgfVxuICB9XG5cbiAgY3R4LmxpbmVUbyh0YXJnZXQuZmlyc3QoKS54LCBjbGlwWSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cblxuZnVuY3Rpb24gZmlsbChjdHgsIGNmZykge1xuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSwgY29sb3IsIHNjYWxlLCBjbGlwfSA9IGNmZztcbiAgY29uc3Qgc2VnbWVudHMgPSBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgZm9yIChjb25zdCB7c291cmNlOiBzcmMsIHRhcmdldDogdGd0LCBzdGFydCwgZW5kfSBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdHlsZToge2JhY2tncm91bmRDb2xvciA9IGNvbG9yfSA9IHt9fSA9IHNyYztcbiAgICBjb25zdCBub3RTaGFwZSA9IHRhcmdldCAhPT0gdHJ1ZTtcblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcblxuICAgIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgY2xpcCwgbm90U2hhcGUgJiYgX2dldEJvdW5kcyhwcm9wZXJ0eSwgc3RhcnQsIGVuZCkpO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgY29uc3QgbGluZUxvb3AgPSAhIWxpbmUucGF0aFNlZ21lbnQoY3R4LCBzcmMpO1xuXG4gICAgbGV0IGxvb3A7XG4gICAgaWYgKG5vdFNoYXBlKSB7XG4gICAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBlbmQsIHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFyZ2V0TG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgdGd0LCB7bW92ZTogbGluZUxvb3AsIHJldmVyc2U6IHRydWV9KTtcbiAgICAgIGxvb3AgPSBsaW5lTG9vcCAmJiB0YXJnZXRMb29wO1xuICAgICAgaWYgKCFsb29wKSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgc3RhcnQsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwobG9vcCA/ICdldmVub2RkJyA6ICdub256ZXJvJyk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgY2xpcCwgYm91bmRzKSB7XG4gIGNvbnN0IGNoYXJ0QXJlYSA9IHNjYWxlLmNoYXJ0LmNoYXJ0QXJlYTtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydCwgZW5kfSA9IGJvdW5kcyB8fCB7fTtcblxuICBpZiAocHJvcGVydHkgPT09ICd4JyB8fCBwcm9wZXJ0eSA9PT0gJ3knKSB7XG4gICAgbGV0IGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbTtcblxuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ3gnKSB7XG4gICAgICBsZWZ0ID0gc3RhcnQ7XG4gICAgICB0b3AgPSBjaGFydEFyZWEudG9wO1xuICAgICAgcmlnaHQgPSBlbmQ7XG4gICAgICBib3R0b20gPSBjaGFydEFyZWEuYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB0b3AgPSBzdGFydDtcbiAgICAgIHJpZ2h0ID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgICAgYm90dG9tID0gZW5kO1xuICAgIH1cblxuICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgIGlmIChjbGlwKSB7XG4gICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgY2xpcC5sZWZ0KTtcbiAgICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIGNsaXAucmlnaHQpO1xuICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBjbGlwLnRvcCk7XG4gICAgICBib3R0b20gPSBNYXRoLm1pbihib3R0b20sIGNsaXAuYm90dG9tKTtcbiAgICB9XG5cbiAgICBjdHgucmVjdChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcbiAgICBjdHguY2xpcCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgcG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGludGVycG9sYXRlZFBvaW50ID0gdGFyZ2V0LmludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmIChpbnRlcnBvbGF0ZWRQb2ludCkge1xuICAgIGN0eC5saW5lVG8oaW50ZXJwb2xhdGVkUG9pbnQueCwgaW50ZXJwb2xhdGVkUG9pbnQueSk7XG4gIH1cbn1cblxuIiwgIi8qKlxuICogUGx1Z2luIGJhc2VkIG9uIGRpc2N1c3Npb24gZnJvbSB0aGUgZm9sbG93aW5nIENoYXJ0LmpzIGlzc3VlczpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzIzODAjaXNzdWVjb21tZW50LTI3OTk2MTU2OVxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjQ0MCNpc3N1ZWNvbW1lbnQtMjU2NDYxODk3XG4gKi9cblxuaW1wb3J0IExpbmVFbGVtZW50IGZyb20gJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcyc7XG5pbXBvcnQge19kcmF3ZmlsbH0gZnJvbSAnLi9maWxsZXIuZHJhd2luZy5qcyc7XG5pbXBvcnQge19zaG91bGRBcHBseUZpbGx9IGZyb20gJy4vZmlsbGVyLmhlbHBlci5qcyc7XG5pbXBvcnQge19kZWNvZGVGaWxsLCBfcmVzb2x2ZVRhcmdldH0gZnJvbSAnLi9maWxsZXIub3B0aW9ucy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdmaWxsZXInLFxuXG4gIGFmdGVyRGF0YXNldHNVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY291bnQgPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoO1xuICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICBsZXQgbWV0YSwgaSwgbGluZSwgc291cmNlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgICBzb3VyY2UgPSBudWxsO1xuXG4gICAgICBpZiAobGluZSAmJiBsaW5lLm9wdGlvbnMgJiYgbGluZSBpbnN0YW5jZW9mIExpbmVFbGVtZW50KSB7XG4gICAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgICB2aXNpYmxlOiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIGZpbGw6IF9kZWNvZGVGaWxsKGxpbmUsIGksIGNvdW50KSxcbiAgICAgICAgICBjaGFydCxcbiAgICAgICAgICBheGlzOiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5pbmRleEF4aXMsXG4gICAgICAgICAgc2NhbGU6IG1ldGEudlNjYWxlLFxuICAgICAgICAgIGxpbmUsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcbiAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgaWYgKCFzb3VyY2UgfHwgc291cmNlLmZpbGwgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UuZmlsbCA9IF9yZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGksIG9wdGlvbnMucHJvcGFnYXRlKTtcbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkcmF3ID0gb3B0aW9ucy5kcmF3VGltZSA9PT0gJ2JlZm9yZURyYXcnO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZS5saW5lLnVwZGF0ZUNvbnRyb2xQb2ludHMoYXJlYSwgc291cmNlLmF4aXMpO1xuICAgICAgaWYgKGRyYXcgJiYgc291cmNlLmZpbGwpIHtcbiAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRGF0YXNldHNEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldHNEcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcblxuICAgICAgaWYgKF9zaG91bGRBcHBseUZpbGwoc291cmNlKSkge1xuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZURhdGFzZXREcmF3KGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc291cmNlID0gYXJncy5tZXRhLiRmaWxsZXI7XG5cbiAgICBpZiAoIV9zaG91bGRBcHBseUZpbGwoc291cmNlKSB8fCBvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldERyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgIGRyYXdUaW1lOiAnYmVmb3JlRGF0YXNldERyYXcnXG4gIH1cbn07XG4iLCAiaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2NvcmUvY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuLi9jb3JlL2NvcmUubGF5b3V0cy5qcyc7XG5pbXBvcnQge2FkZFJvdW5kZWRSZWN0UGF0aCwgZHJhd1BvaW50TGVnZW5kLCByZW5kZXJUZXh0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7XG4gIF9pc0JldHdlZW4sXG4gIGNhbGxiYWNrIGFzIGNhbGwsXG4gIGNsaXBBcmVhLFxuICBnZXRSdGxBZGFwdGVyLFxuICBvdmVycmlkZVRleHREaXJlY3Rpb24sXG4gIHJlc3RvcmVUZXh0RGlyZWN0aW9uLFxuICB0b0ZvbnQsXG4gIHRvUGFkZGluZyxcbiAgdW5jbGlwQXJlYSxcbiAgdmFsdWVPckRlZmF1bHQsXG59IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfYWxpZ25TdGFydEVuZCwgX3RleHRYLCBfdG9MZWZ0UmlnaHRDZW50ZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHt0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqL1xuXG5jb25zdCBnZXRCb3hTaXplID0gKGxhYmVsT3B0cywgZm9udFNpemUpID0+IHtcbiAgbGV0IHtib3hIZWlnaHQgPSBmb250U2l6ZSwgYm94V2lkdGggPSBmb250U2l6ZX0gPSBsYWJlbE9wdHM7XG5cbiAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgYm94SGVpZ2h0ID0gTWF0aC5taW4oYm94SGVpZ2h0LCBmb250U2l6ZSk7XG4gICAgYm94V2lkdGggPSBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoIHx8IE1hdGgubWluKGJveFdpZHRoLCBmb250U2l6ZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJveFdpZHRoLFxuICAgIGJveEhlaWdodCxcbiAgICBpdGVtSGVpZ2h0OiBNYXRoLm1heChmb250U2l6ZSwgYm94SGVpZ2h0KVxuICB9O1xufTtcblxuY29uc3QgaXRlbXNFcXVhbCA9IChhLCBiKSA9PiBhICE9PSBudWxsICYmIGIgIT09IG51bGwgJiYgYS5kYXRhc2V0SW5kZXggPT09IGIuZGF0YXNldEluZGV4ICYmIGEuaW5kZXggPT09IGIuaW5kZXg7XG5cbmV4cG9ydCBjbGFzcyBMZWdlbmQgZXh0ZW5kcyBFbGVtZW50IHtcblxuICAvKipcblx0ICogQHBhcmFtIHt7IGN0eDogYW55OyBvcHRpb25zOiBhbnk7IGNoYXJ0OiBhbnk7IH19IGNvbmZpZ1xuXHQgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2FkZGVkID0gZmFsc2U7XG5cbiAgICAvLyBDb250YWlucyBoaXQgYm94ZXMgZm9yIGVhY2ggZGF0YXNldCAoaW4gZGF0YXNldCBvcmRlcilcbiAgICB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG5cbiAgICAvKipcbiBcdFx0ICogQHByaXZhdGVcbiBcdFx0ICovXG4gICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBudWxsO1xuXG4gICAgLy8gQXJlIHdlIGluIGRvdWdobnV0IG1vZGUgd2hpY2ggaGFzIGEgZGlmZmVyZW50IGRhdGEgdHlwZVxuICAgIHRoaXMuZG91Z2hudXRNb2RlID0gZmFsc2U7XG5cbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sdW1uU2l6ZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5saW5lV2lkdGhzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zO1xuXG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5idWlsZExhYmVscygpO1xuICAgIHRoaXMuZml0KCk7XG4gIH1cblxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IHRoaXMuX21hcmdpbnMubGVmdDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgdGhpcy50b3AgPSB0aGlzLl9tYXJnaW5zLnRvcDtcbiAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgYnVpbGRMYWJlbHMoKSB7XG4gICAgY29uc3QgbGFiZWxPcHRzID0gdGhpcy5vcHRpb25zLmxhYmVscyB8fCB7fTtcbiAgICBsZXQgbGVnZW5kSXRlbXMgPSBjYWxsKGxhYmVsT3B0cy5nZW5lcmF0ZUxhYmVscywgW3RoaXMuY2hhcnRdLCB0aGlzKSB8fCBbXTtcblxuICAgIGlmIChsYWJlbE9wdHMuZmlsdGVyKSB7XG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gbGFiZWxPcHRzLmZpbHRlcihpdGVtLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAobGFiZWxPcHRzLnNvcnQpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuc29ydCgoYSwgYikgPT4gbGFiZWxPcHRzLnNvcnQoYSwgYiwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBsZWdlbmRJdGVtcy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5sZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zO1xuICB9XG5cbiAgZml0KCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjdHh9ID0gdGhpcztcblxuICAgIC8vIFRoZSBsZWdlbmQgbWF5IG5vdCBiZSBkaXNwbGF5ZWQgZm9yIGEgdmFyaWV0eSBvZiByZWFzb25zIGluY2x1ZGluZ1xuICAgIC8vIHRoZSBmYWN0IHRoYXQgdGhlIGRlZmF1bHRzIGdvdCBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyBXaGVuIHRoZSBsZWdlbmQgaXMgbm90IGRpc3BsYXllZCwgdGhlcmUgYXJlIG5vIGd1YXJhbnRlZXMgdGhhdCB0aGUgb3B0aW9uc1xuICAgIC8vIGFyZSBjb3JyZWN0bHkgZm9ybWF0dGVkIHNvIHdlIG5lZWQgdG8gYmFpbCBvdXQgYXMgZWFybHkgYXMgcG9zc2libGUuXG4gICAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxPcHRzID0gb3B0aW9ucy5sYWJlbHM7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2JveFdpZHRoLCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB3aWR0aCA9IHRoaXMubWF4V2lkdGg7IC8vIGZpbGwgYWxsIHRoZSB3aWR0aFxuICAgICAgaGVpZ2h0ID0gdGhpcy5fZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSB0aGlzLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuICAgICAgd2lkdGggPSB0aGlzLl9maXRDb2xzKHRpdGxlSGVpZ2h0LCBsYWJlbEZvbnQsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH1cblxuICAgIHRoaXMud2lkdGggPSBNYXRoLm1pbih3aWR0aCwgb3B0aW9ucy5tYXhXaWR0aCB8fCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWluKGhlaWdodCwgb3B0aW9ucy5tYXhIZWlnaHQgfHwgdGhpcy5tYXhIZWlnaHQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4V2lkdGgsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICAvLyBXaWR0aCBvZiBlYWNoIGxpbmUgb2YgbGVnZW5kIGJveGVzLiBMYWJlbHMgd3JhcCBvbnRvIG11bHRpcGxlIGxpbmVzIHdoZW4gdGhlcmUgYXJlIHRvbyBtYW55IHRvIGZpdCBvbiBvbmVcbiAgICBjb25zdCBsaW5lV2lkdGhzID0gdGhpcy5saW5lV2lkdGhzID0gWzBdO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICBsZXQgdG90YWxIZWlnaHQgPSB0aXRsZUhlaWdodDtcblxuICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgbGV0IHJvdyA9IC0xO1xuICAgIGxldCB0b3AgPSAtbGluZUhlaWdodDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcblxuICAgICAgaWYgKGkgPT09IDAgfHwgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgaXRlbVdpZHRoICsgMiAqIHBhZGRpbmcgPiBtYXhXaWR0aCkge1xuICAgICAgICB0b3RhbEhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gKGkgPiAwID8gMCA6IDEpXSA9IDA7XG4gICAgICAgIHRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICByb3crKztcbiAgICAgIH1cblxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdDogMCwgdG9wLCByb3csIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG5cbiAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArPSBpdGVtV2lkdGggKyBwYWRkaW5nO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRvdGFsSGVpZ2h0O1xuICB9XG5cbiAgX2ZpdENvbHModGl0bGVIZWlnaHQsIGxhYmVsRm9udCwgYm94V2lkdGgsIF9pdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4SGVpZ2h0LCBvcHRpb25zOiB7bGFiZWxzOiB7cGFkZGluZ319fSA9IHRoaXM7XG4gICAgY29uc3QgaGl0Ym94ZXMgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgY29uc3QgY29sdW1uU2l6ZXMgPSB0aGlzLmNvbHVtblNpemVzID0gW107XG4gICAgY29uc3QgaGVpZ2h0TGltaXQgPSBtYXhIZWlnaHQgLSB0aXRsZUhlaWdodDtcblxuICAgIGxldCB0b3RhbFdpZHRoID0gcGFkZGluZztcbiAgICBsZXQgY3VycmVudENvbFdpZHRoID0gMDtcbiAgICBsZXQgY3VycmVudENvbEhlaWdodCA9IDA7XG5cbiAgICBsZXQgbGVmdCA9IDA7XG4gICAgbGV0IGNvbCA9IDA7XG5cbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IHtpdGVtV2lkdGgsIGl0ZW1IZWlnaHR9ID0gY2FsY3VsYXRlSXRlbVNpemUoYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4LCBsZWdlbmRJdGVtLCBfaXRlbUhlaWdodCk7XG5cbiAgICAgIC8vIElmIHRvbyB0YWxsLCBnbyB0byBuZXcgY29sdW1uXG4gICAgICBpZiAoaSA+IDAgJiYgY3VycmVudENvbEhlaWdodCArIGl0ZW1IZWlnaHQgKyAyICogcGFkZGluZyA+IGhlaWdodExpbWl0KSB7XG4gICAgICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7IC8vIHByZXZpb3VzIGNvbHVtbiBzaXplXG4gICAgICAgIGxlZnQgKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sKys7XG4gICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBTdG9yZSB0aGUgaGl0Ym94IHdpZHRoIGFuZCBoZWlnaHQgaGVyZS4gRmluYWwgcG9zaXRpb24gd2lsbCBiZSB1cGRhdGVkIGluIGBkcmF3YFxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdCwgdG9wOiBjdXJyZW50Q29sSGVpZ2h0LCBjb2wsIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG5cbiAgICAgIC8vIEdldCBtYXggd2lkdGhcbiAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IE1hdGgubWF4KGN1cnJlbnRDb2xXaWR0aCwgaXRlbVdpZHRoKTtcbiAgICAgIGN1cnJlbnRDb2xIZWlnaHQgKz0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgfSk7XG5cbiAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aDtcbiAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTsgLy8gcHJldmlvdXMgY29sdW1uIHNpemVcblxuICAgIHJldHVybiB0b3RhbFdpZHRoO1xuICB9XG5cbiAgYWRqdXN0SGl0Qm94ZXMoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGNvbnN0IHtsZWdlbmRIaXRCb3hlczogaGl0Ym94ZXMsIG9wdGlvbnM6IHthbGlnbiwgbGFiZWxzOiB7cGFkZGluZ30sIHJ0bH19ID0gdGhpcztcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKHJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgbGV0IHJvdyA9IDA7XG4gICAgICBsZXQgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKHJvdyAhPT0gaGl0Ym94LnJvdykge1xuICAgICAgICAgIHJvdyA9IGhpdGJveC5yb3c7XG4gICAgICAgICAgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgKz0gdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngobGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIGxlZnQgKz0gaGl0Ym94LndpZHRoICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNvbCA9IDA7XG4gICAgICBsZXQgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKGhpdGJveC5jb2wgIT09IGNvbCkge1xuICAgICAgICAgIGNvbCA9IGhpdGJveC5jb2w7XG4gICAgICAgICAgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgPSB0b3A7XG4gICAgICAgIGhpdGJveC5sZWZ0ICs9IHRoaXMubGVmdCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngoaGl0Ym94LmxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICB0b3AgKz0gaGl0Ym94LmhlaWdodCArIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjbGlwQXJlYShjdHgsIHRoaXMpO1xuXG4gICAgICB0aGlzLl9kcmF3KCk7XG5cbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3KCkge1xuICAgIGNvbnN0IHtvcHRpb25zOiBvcHRzLCBjb2x1bW5TaXplcywgbGluZVdpZHRocywgY3R4fSA9IHRoaXM7XG4gICAgY29uc3Qge2FsaWduLCBsYWJlbHM6IGxhYmVsT3B0c30gPSBvcHRzO1xuICAgIGNvbnN0IGRlZmF1bHRDb2xvciA9IGRlZmF1bHRzLmNvbG9yO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCB7cGFkZGluZ30gPSBsYWJlbE9wdHM7XG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSBmb250U2l6ZSAvIDI7XG4gICAgbGV0IGN1cnNvcjtcblxuICAgIHRoaXMuZHJhd1RpdGxlKCk7XG5cbiAgICAvLyBDYW52YXMgc2V0dXBcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbignbGVmdCcpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHgubGluZVdpZHRoID0gMC41O1xuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcblxuICAgIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0LCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cbiAgICAvLyBjdXJyZW50IHBvc2l0aW9uXG4gICAgY29uc3QgZHJhd0xlZ2VuZEJveCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcbiAgICAgIGlmIChpc05hTihib3hXaWR0aCkgfHwgYm94V2lkdGggPD0gMCB8fCBpc05hTihib3hIZWlnaHQpIHx8IGJveEhlaWdodCA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIGN0eCBmb3IgdGhlIGJveFxuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgY29uc3QgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lV2lkdGgsIDEpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuICAgICAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVDYXAsICdidXR0Jyk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoT2Zmc2V0LCAwKTtcbiAgICAgIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUpvaW4sICdtaXRlcicpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uc3Ryb2tlU3R5bGUsIGRlZmF1bHRDb2xvcik7XG5cbiAgICAgIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoLCBbXSkpO1xuXG4gICAgICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgICAgLy8gUmVjYWxjdWxhdGUgeCBhbmQgeSBmb3IgZHJhd1BvaW50KCkgYmVjYXVzZSBpdHMgZXhwZWN0aW5nXG4gICAgICAgIC8vIHggYW5kIHkgdG8gYmUgY2VudGVyIG9mIGZpZ3VyZSAoaW5zdGVhZCBvZiB0b3AgbGVmdClcbiAgICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgICAgcmFkaXVzOiBib3hIZWlnaHQgKiBNYXRoLlNRUlQyIC8gMixcbiAgICAgICAgICBwb2ludFN0eWxlOiBsZWdlbmRJdGVtLnBvaW50U3R5bGUsXG4gICAgICAgICAgcm90YXRpb246IGxlZ2VuZEl0ZW0ucm90YXRpb24sXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IGxpbmVXaWR0aFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLnhQbHVzKHgsIGJveFdpZHRoIC8gMik7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSB5ICsgaGFsZkZvbnRTaXplO1xuXG4gICAgICAgIC8vIERyYXcgcG9pbnRTdHlsZSBhcyBsZWdlbmQgc3ltYm9sXG4gICAgICAgIGRyYXdQb2ludExlZ2VuZChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZLCBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoICYmIGJveFdpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERyYXcgYm94IGFzIGxlZ2VuZCBzeW1ib2xcbiAgICAgICAgLy8gQWRqdXN0IHBvc2l0aW9uIHdoZW4gYm94SGVpZ2h0IDwgZm9udFNpemUgKHdhbnQgaXQgY2VudGVyZWQpXG4gICAgICAgIGNvbnN0IHlCb3hUb3AgPSB5ICsgTWF0aC5tYXgoKGZvbnRTaXplIC0gYm94SGVpZ2h0KSAvIDIsIDApO1xuICAgICAgICBjb25zdCB4Qm94TGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHgsIGJveFdpZHRoKTtcbiAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsZWdlbmRJdGVtLmJvcmRlclJhZGl1cyk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgICAgeDogeEJveExlZnQsXG4gICAgICAgICAgICB5OiB5Qm94VG9wLFxuICAgICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgucmVjdCh4Qm94TGVmdCwgeUJveFRvcCwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZiAobGluZVdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxlZ2VuZEl0ZW0udGV4dCwgeCwgeSArIChpdGVtSGVpZ2h0IC8gMiksIGxhYmVsRm9udCwge1xuICAgICAgICBzdHJpa2V0aHJvdWdoOiBsZWdlbmRJdGVtLmhpZGRlbixcbiAgICAgICAgdGV4dEFsaWduOiBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduKVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEhvcml6b250YWxcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbMF0pLFxuICAgICAgICB5OiB0aGlzLnRvcCArIHBhZGRpbmcgKyB0aXRsZUhlaWdodCxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiB0aGlzLmxlZnQgKyBwYWRkaW5nLFxuICAgICAgICB5OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbMF0uaGVpZ2h0KSxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBvdmVycmlkZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG5cbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvcjsgLy8gZm9yIHN0cmlrZXRocm91Z2ggZWZmZWN0XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGVnZW5kSXRlbS5mb250Q29sb3I7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxuXG4gICAgICBjb25zdCB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24gfHwgKGxlZ2VuZEl0ZW0udGV4dEFsaWduID0gbGFiZWxPcHRzLnRleHRBbGlnbikpO1xuICAgICAgY29uc3Qgd2lkdGggPSBib3hXaWR0aCArIGhhbGZGb250U2l6ZSArIHRleHRXaWR0aDtcbiAgICAgIGxldCB4ID0gY3Vyc29yLng7XG4gICAgICBsZXQgeSA9IGN1cnNvci55O1xuXG4gICAgICBydGxIZWxwZXIuc2V0V2lkdGgodGhpcy53aWR0aCk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGkgPiAwICYmIHggKyB3aWR0aCArIHBhZGRpbmcgPiB0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgeSA9IGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgY3Vyc29yLmxpbmUrKztcbiAgICAgICAgICB4ID0gY3Vyc29yLnggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpID4gMCAmJiB5ICsgbGluZUhlaWdodCA+IHRoaXMuYm90dG9tKSB7XG4gICAgICAgIHggPSBjdXJzb3IueCA9IHggKyBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0ud2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICB5ID0gY3Vyc29yLnkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlYWxYID0gcnRsSGVscGVyLngoeCk7XG5cbiAgICAgIGRyYXdMZWdlbmRCb3gocmVhbFgsIHksIGxlZ2VuZEl0ZW0pO1xuXG4gICAgICB4ID0gX3RleHRYKHRleHRBbGlnbiwgeCArIGJveFdpZHRoICsgaGFsZkZvbnRTaXplLCBpc0hvcml6b250YWwgPyB4ICsgd2lkdGggOiB0aGlzLnJpZ2h0LCBvcHRzLnJ0bCk7XG5cbiAgICAgIC8vIEZpbGwgdGhlIGFjdHVhbCBsYWJlbFxuICAgICAgZmlsbFRleHQocnRsSGVscGVyLngoeCksIHksIGxlZ2VuZEl0ZW0pO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGN1cnNvci54ICs9IHdpZHRoICsgcGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxlZ2VuZEl0ZW0udGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgZm9udExpbmVIZWlnaHQgPSBsYWJlbEZvbnQubGluZUhlaWdodDtcbiAgICAgICAgY3Vyc29yLnkgKz0gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkgKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IG9wdHMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuXG4gICAgaWYgKCF0aXRsZU9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aXRsZU9wdHMucG9zaXRpb247XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gdGl0bGVGb250LnNpemUgLyAyO1xuICAgIGNvbnN0IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplID0gdGl0bGVQYWRkaW5nLnRvcCArIGhhbGZGb250U2l6ZTtcbiAgICBsZXQgeTtcblxuICAgIC8vIFRoZXNlIGRlZmF1bHRzIGFyZSB1c2VkIHdoZW4gdGhlIGxlZ2VuZCBpcyB2ZXJ0aWNhbC5cbiAgICAvLyBXaGVuIGhvcml6b250YWwsIHRoZXkgYXJlIGNvbXB1dGVkIGJlbG93LlxuICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0O1xuICAgIGxldCBtYXhXaWR0aCA9IHRoaXMud2lkdGg7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgLy8gTW92ZSBsZWZ0IC8gcmlnaHQgc28gdGhhdCB0aGUgdGl0bGUgaXMgYWJvdmUgdGhlIGxlZ2VuZCBsaW5lc1xuICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCguLi50aGlzLmxpbmVXaWR0aHMpO1xuICAgICAgeSA9IHRoaXMudG9wICsgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemU7XG4gICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgbGVmdCwgdGhpcy5yaWdodCAtIG1heFdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92ZSBkb3duIHNvIHRoYXQgdGhlIHRpdGxlIGlzIGFib3ZlIHRoZSBsZWdlbmQgc3RhY2sgaW4gZXZlcnkgYWxpZ25tZW50XG4gICAgICBjb25zdCBtYXhIZWlnaHQgPSB0aGlzLmNvbHVtblNpemVzLnJlZHVjZSgoYWNjLCBzaXplKSA9PiBNYXRoLm1heChhY2MsIHNpemUuaGVpZ2h0KSwgMCk7XG4gICAgICB5ID0gdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgKyBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCB0aGlzLnRvcCwgdGhpcy5ib3R0b20gLSBtYXhIZWlnaHQgLSBvcHRzLmxhYmVscy5wYWRkaW5nIC0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCkpO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlIGtub3cgdGhlIGxlZnQgZWRnZSBvZiB0aGUgaW5uZXIgbGVnZW5kIGJveCwgY29tcHV0ZSB0aGUgY29ycmVjdFxuICAgIC8vIFggY29vcmRpbmF0ZSBmcm9tIHRoZSB0aXRsZSBhbGlnbm1lbnRcbiAgICBjb25zdCB4ID0gX2FsaWduU3RhcnRFbmQocG9zaXRpb24sIGxlZnQsIGxlZnQgKyBtYXhXaWR0aCk7XG5cbiAgICAvLyBDYW52YXMgc2V0dXBcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihfdG9MZWZ0UmlnaHRDZW50ZXIocG9zaXRpb24pKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuXG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlT3B0cy50ZXh0LCB4LCB5LCB0aXRsZUZvbnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZVRpdGxlSGVpZ2h0KCkge1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IHRoaXMub3B0aW9ucy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG4gICAgcmV0dXJuIHRpdGxlT3B0cy5kaXNwbGF5ID8gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVBhZGRpbmcuaGVpZ2h0IDogMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExlZ2VuZEl0ZW1BdCh4LCB5KSB7XG4gICAgbGV0IGksIGhpdEJveCwgbGg7XG5cbiAgICBpZiAoX2lzQmV0d2Vlbih4LCB0aGlzLmxlZnQsIHRoaXMucmlnaHQpXG4gICAgICAmJiBfaXNCZXR3ZWVuKHksIHRoaXMudG9wLCB0aGlzLmJvdHRvbSkpIHtcbiAgICAgIC8vIFNlZSBpZiB3ZSBhcmUgdG91Y2hpbmcgb25lIG9mIHRoZSBkYXRhc2V0IGJveGVzXG4gICAgICBsaCA9IHRoaXMubGVnZW5kSGl0Qm94ZXM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaGl0Qm94ID0gbGhbaV07XG5cbiAgICAgICAgaWYgKF9pc0JldHdlZW4oeCwgaGl0Qm94LmxlZnQsIGhpdEJveC5sZWZ0ICsgaGl0Qm94LndpZHRoKVxuICAgICAgICAgICYmIF9pc0JldHdlZW4oeSwgaGl0Qm94LnRvcCwgaGl0Qm94LnRvcCArIGhpdEJveC5oZWlnaHQpKSB7XG4gICAgICAgICAgLy8gVG91Y2hpbmcgYW4gZWxlbWVudFxuICAgICAgICAgIHJldHVybiB0aGlzLmxlZ2VuZEl0ZW1zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcblx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICovXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghaXNMaXN0ZW5lZChlLnR5cGUsIG9wdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hhcnQgZXZlbnQgYWxyZWFkeSBoYXMgcmVsYXRpdmUgcG9zaXRpb24gaW4gaXRcbiAgICBjb25zdCBob3ZlcmVkSXRlbSA9IHRoaXMuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XG5cbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyB8fCBlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5faG92ZXJlZEl0ZW07XG4gICAgICBjb25zdCBzYW1lSXRlbSA9IGl0ZW1zRXF1YWwocHJldmlvdXMsIGhvdmVyZWRJdGVtKTtcbiAgICAgIGlmIChwcmV2aW91cyAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbChvcHRzLm9uTGVhdmUsIFtlLCBwcmV2aW91cywgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IGhvdmVyZWRJdGVtO1xuXG4gICAgICBpZiAoaG92ZXJlZEl0ZW0gJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgIGNhbGwob3B0cy5vbkhvdmVyLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtKSB7XG4gICAgICBjYWxsKG9wdHMub25DbGljaywgW2UsIGhvdmVyZWRJdGVtLCB0aGlzXSwgdGhpcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUl0ZW1TaXplKGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCwgbGVnZW5kSXRlbSwgX2l0ZW1IZWlnaHQpIHtcbiAgY29uc3QgaXRlbVdpZHRoID0gY2FsY3VsYXRlSXRlbVdpZHRoKGxlZ2VuZEl0ZW0sIGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCk7XG4gIGNvbnN0IGl0ZW1IZWlnaHQgPSBjYWxjdWxhdGVJdGVtSGVpZ2h0KF9pdGVtSGVpZ2h0LCBsZWdlbmRJdGVtLCBsYWJlbEZvbnQubGluZUhlaWdodCk7XG4gIHJldHVybiB7aXRlbVdpZHRoLCBpdGVtSGVpZ2h0fTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSXRlbVdpZHRoKGxlZ2VuZEl0ZW0sIGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCkge1xuICBsZXQgbGVnZW5kSXRlbVRleHQgPSBsZWdlbmRJdGVtLnRleHQ7XG4gIGlmIChsZWdlbmRJdGVtVGV4dCAmJiB0eXBlb2YgbGVnZW5kSXRlbVRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgbGVnZW5kSXRlbVRleHQgPSBsZWdlbmRJdGVtVGV4dC5yZWR1Y2UoKGEsIGIpID0+IGEubGVuZ3RoID4gYi5sZW5ndGggPyBhIDogYik7XG4gIH1cbiAgcmV0dXJuIGJveFdpZHRoICsgKGxhYmVsRm9udC5zaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbVRleHQpLndpZHRoO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJdGVtSGVpZ2h0KF9pdGVtSGVpZ2h0LCBsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkge1xuICBsZXQgaXRlbUhlaWdodCA9IF9pdGVtSGVpZ2h0O1xuICBpZiAodHlwZW9mIGxlZ2VuZEl0ZW0udGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICBpdGVtSGVpZ2h0ID0gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCk7XG4gIH1cbiAgcmV0dXJuIGl0ZW1IZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobGVnZW5kSXRlbSwgZm9udExpbmVIZWlnaHQpIHtcbiAgY29uc3QgbGFiZWxIZWlnaHQgPSBsZWdlbmRJdGVtLnRleHQgPyBsZWdlbmRJdGVtLnRleHQubGVuZ3RoIDogMDtcbiAgcmV0dXJuIGZvbnRMaW5lSGVpZ2h0ICogbGFiZWxIZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGlzTGlzdGVuZWQodHlwZSwgb3B0cykge1xuICBpZiAoKHR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IHR5cGUgPT09ICdtb3VzZW91dCcpICYmIChvcHRzLm9uSG92ZXIgfHwgb3B0cy5vbkxlYXZlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChvcHRzLm9uQ2xpY2sgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ21vdXNldXAnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2xlZ2VuZCcsXG5cbiAgLyoqXG5cdCAqIEZvciB0ZXN0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2VsZW1lbnQ6IExlZ2VuZCxcblxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQgPSBuZXcgTGVnZW5kKHtjdHg6IGNoYXJ0LmN0eCwgb3B0aW9ucywgY2hhcnR9KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcbiAgfSxcblxuICBzdG9wKGNoYXJ0KSB7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIGNoYXJ0LmxlZ2VuZCk7XG4gICAgZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcbiAgfSxcblxuICAvLyBEdXJpbmcgdGhlIGJlZm9yZVVwZGF0ZSBzdGVwLCB0aGUgbGF5b3V0IGNvbmZpZ3VyYXRpb24gbmVlZHMgdG8gcnVuXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGlmIHRoZSBsZWdlbmQgcG9zaXRpb24gY2hhbmdlcyAodmlhIGFuIG9wdGlvbiB1cGRhdGUpXG4gIC8vIHRoZSBsYXlvdXQgc3lzdGVtIHJlc3BlY3RzIHRoZSBjaGFuZ2UuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNzUyN1xuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxlZ2VuZC5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICAvLyBUaGUgbGFiZWxzIG5lZWQgdG8gYmUgYnVpbHQgYWZ0ZXIgZGF0YXNldHMgYXJlIHVwZGF0ZWQgdG8gZW5zdXJlIHRoYXQgY29sb3JzXG4gIC8vIGFuZCBvdGhlciBzdHlsaW5nIGFyZSBjb3JyZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzY5NjhcbiAgYWZ0ZXJVcGRhdGUoY2hhcnQpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGVnZW5kLmJ1aWxkTGFiZWxzKCk7XG4gICAgbGVnZW5kLmFkanVzdEhpdEJveGVzKCk7XG4gIH0sXG5cblxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKCFhcmdzLnJlcGxheSkge1xuICAgICAgY2hhcnQubGVnZW5kLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQpO1xuICAgIH1cbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICB3ZWlnaHQ6IDEwMDAsXG5cbiAgICAvLyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBoYW5kbGVcbiAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgY29uc3QgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcbiAgICAgIGNvbnN0IGNpID0gbGVnZW5kLmNoYXJ0O1xuICAgICAgaWYgKGNpLmlzRGF0YXNldFZpc2libGUoaW5kZXgpKSB7XG4gICAgICAgIGNpLmhpZGUoaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaS5zaG93KGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25Ib3ZlcjogbnVsbCxcbiAgICBvbkxlYXZlOiBudWxsLFxuXG4gICAgbGFiZWxzOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBib3hXaWR0aDogNDAsXG4gICAgICBwYWRkaW5nOiAxMCxcbiAgICAgIC8vIEdlbmVyYXRlcyBsYWJlbHMgc2hvd24gaW4gdGhlIGxlZ2VuZFxuICAgICAgLy8gVmFsaWQgcHJvcGVydGllcyB0byByZXR1cm46XG4gICAgICAvLyB0ZXh0IDogdGV4dCB0byBkaXNwbGF5XG4gICAgICAvLyBmaWxsU3R5bGUgOiBmaWxsIG9mIGNvbG91cmVkIGJveFxuICAgICAgLy8gc3Ryb2tlU3R5bGU6IHN0cm9rZSBvZiBjb2xvdXJlZCBib3hcbiAgICAgIC8vIGhpZGRlbiA6IGlmIHRoaXMgbGVnZW5kIGl0ZW0gcmVmZXJzIHRvIGEgaGlkZGVuIGl0ZW1cbiAgICAgIC8vIGxpbmVDYXAgOiBjYXAgc3R5bGUgZm9yIGxpbmVcbiAgICAgIC8vIGxpbmVEYXNoXG4gICAgICAvLyBsaW5lRGFzaE9mZnNldCA6XG4gICAgICAvLyBsaW5lSm9pbiA6XG4gICAgICAvLyBsaW5lV2lkdGggOlxuICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgY29uc3QgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuICAgICAgICBjb25zdCB7bGFiZWxzOiB7dXNlUG9pbnRTdHlsZSwgcG9pbnRTdHlsZSwgdGV4dEFsaWduLCBjb2xvciwgdXNlQm9yZGVyUmFkaXVzLCBib3JkZXJSYWRpdXN9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuXG4gICAgICAgIHJldHVybiBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKCkubWFwKChtZXRhKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodXNlUG9pbnRTdHlsZSA/IDAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdG9QYWRkaW5nKHN0eWxlLmJvcmRlcldpZHRoKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBkYXRhc2V0c1ttZXRhLmluZGV4XS5sYWJlbCxcbiAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGhpZGRlbjogIW1ldGEudmlzaWJsZSxcbiAgICAgICAgICAgIGxpbmVDYXA6IHN0eWxlLmJvcmRlckNhcFN0eWxlLFxuICAgICAgICAgICAgbGluZURhc2g6IHN0eWxlLmJvcmRlckRhc2gsXG4gICAgICAgICAgICBsaW5lRGFzaE9mZnNldDogc3R5bGUuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgICAgIGxpbmVKb2luOiBzdHlsZS5ib3JkZXJKb2luU3R5bGUsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IChib3JkZXJXaWR0aC53aWR0aCArIGJvcmRlcldpZHRoLmhlaWdodCkgLyA0LFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSB8fCBzdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICAgICAgcm90YXRpb246IHN0eWxlLnJvdGF0aW9uLFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24gfHwgc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiB1c2VCb3JkZXJSYWRpdXMgJiYgKGJvcmRlclJhZGl1cyB8fCBzdHlsZS5ib3JkZXJSYWRpdXMpLFxuXG4gICAgICAgICAgICAvLyBCZWxvdyBpcyBleHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBkYXRhc2V0c1xuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRpdGxlOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICAgIHRleHQ6ICcnLFxuICAgIH1cbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgICBsYWJlbHM6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIVsnZ2VuZXJhdGVMYWJlbHMnLCAnZmlsdGVyJywgJ3NvcnQnXS5pbmNsdWRlcyhuYW1lKSxcbiAgICB9XG4gIH0sXG59O1xuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCBsYXlvdXRzIGZyb20gJy4uL2NvcmUvY29yZS5sYXlvdXRzLmpzJztcbmltcG9ydCB7UEksIGlzQXJyYXksIHRvUGFkZGluZywgdG9Gb250fSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X3RvTGVmdFJpZ2h0Q2VudGVyLCBfYWxpZ25TdGFydEVuZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge3JlbmRlclRleHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuXG5leHBvcnQgY2xhc3MgVGl0bGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgLyoqXG5cdCAqIEBwYXJhbSB7eyBjdHg6IGFueTsgb3B0aW9uczogYW55OyBjaGFydDogYW55OyB9fSBjb25maWdcblx0ICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLl9wYWRkaW5nID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgdGhpcy5sZWZ0ID0gMDtcbiAgICB0aGlzLnRvcCA9IDA7XG5cbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5yaWdodCA9IHRoaXMuYm90dG9tID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCA9IG1heFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3R0b20gPSBtYXhIZWlnaHQ7XG5cbiAgICBjb25zdCBsaW5lQ291bnQgPSBpc0FycmF5KG9wdHMudGV4dCkgPyBvcHRzLnRleHQubGVuZ3RoIDogMTtcbiAgICB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKG9wdHMucGFkZGluZyk7XG4gICAgY29uc3QgdGV4dFNpemUgPSBsaW5lQ291bnQgKiB0b0ZvbnQob3B0cy5mb250KS5saW5lSGVpZ2h0ICsgdGhpcy5fcGFkZGluZy5oZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0ZXh0U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHRleHRTaXplO1xuICAgIH1cbiAgfVxuXG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgcmV0dXJuIHBvcyA9PT0gJ3RvcCcgfHwgcG9zID09PSAnYm90dG9tJztcbiAgfVxuXG4gIF9kcmF3QXJncyhvZmZzZXQpIHtcbiAgICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgYWxpZ24gPSBvcHRpb25zLmFsaWduO1xuICAgIGxldCByb3RhdGlvbiA9IDA7XG4gICAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuICAgICAgdGl0bGVZID0gdG9wICsgb2Zmc2V0O1xuICAgICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgdGl0bGVYID0gbGVmdCArIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIC0wLjU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZVggPSByaWdodCAtIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRvcCwgYm90dG9tKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIDAuNTtcbiAgICAgIH1cbiAgICAgIG1heFdpZHRoID0gYm90dG9tIC0gdG9wO1xuICAgIH1cbiAgICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKCFvcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBmb250T3B0cyA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBmb250T3B0cy5saW5lSGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldCA9IGxpbmVIZWlnaHQgLyAyICsgdGhpcy5fcGFkZGluZy50b3A7XG4gICAgY29uc3Qge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259ID0gdGhpcy5fZHJhd0FyZ3Mob2Zmc2V0KTtcblxuICAgIHJlbmRlclRleHQoY3R4LCBvcHRzLnRleHQsIDAsIDAsIGZvbnRPcHRzLCB7XG4gICAgICBjb2xvcjogb3B0cy5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IF90b0xlZnRSaWdodENlbnRlcihvcHRzLmFsaWduKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUaXRsZShjaGFydCwgdGl0bGVPcHRzKSB7XG4gIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICBjdHg6IGNoYXJ0LmN0eCxcbiAgICBvcHRpb25zOiB0aXRsZU9wdHMsXG4gICAgY2hhcnRcbiAgfSk7XG5cbiAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCB0aXRsZU9wdHMpO1xuICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICBjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICd0aXRsZScsXG5cbiAgLyoqXG5cdCAqIEZvciB0ZXN0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2VsZW1lbnQ6IFRpdGxlLFxuXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNyZWF0ZVRpdGxlKGNoYXJ0LCBvcHRpb25zKTtcbiAgfSxcblxuICBzdG9wKGNoYXJ0KSB7XG4gICAgY29uc3QgdGl0bGVCbG9jayA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIHRpdGxlQmxvY2spO1xuICAgIGRlbGV0ZSBjaGFydC50aXRsZUJsb2NrO1xuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDEwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDIwMDAgICAgICAgICAvLyBieSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZWdlbmQgKDEwMDApIHRvIGJlIGFib3ZlXG4gIH0sXG5cbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG5cbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfSxcbn07XG4iLCAiaW1wb3J0IHtUaXRsZX0gZnJvbSAnLi9wbHVnaW4udGl0bGUuanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi4vY29yZS9jb3JlLmxheW91dHMuanMnO1xuXG5jb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnc3VidGl0bGUnLFxuXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICAgIGN0eDogY2hhcnQuY3R4LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNoYXJ0XG4gICAgfSk7XG5cbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gICAgbWFwLnNldChjaGFydCwgdGl0bGUpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgbWFwLmdldChjaGFydCkpO1xuICAgIG1hcC5kZWxldGUoY2hhcnQpO1xuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG1hcC5nZXQoY2hhcnQpO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMTUwMCAgICAgICAgIC8vIGJ5IGRlZmF1bHQgZ3JlYXRlciB0aGFuIGxlZ2VuZCAoMTAwMCkgYW5kIHNtYWxsZXIgdGhhbiB0aXRsZSAoMjAwMClcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcbiIsICJpbXBvcnQgQW5pbWF0aW9ucyBmcm9tICcuLi9jb3JlL2NvcmUuYW5pbWF0aW9ucy5qcyc7XG5pbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge2FkZFJvdW5kZWRSZWN0UGF0aH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge2VhY2gsIG5vb3AsIGlzTnVsbE9yVW5kZWYsIGlzQXJyYXksIF9lbGVtZW50c0VxdWFsLCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0ZvbnQsIHRvUGFkZGluZywgdG9UUkJMQ29ybmVyc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtnZXRSdGxBZGFwdGVyLCBvdmVycmlkZVRleHREaXJlY3Rpb24sIHJlc3RvcmVUZXh0RGlyZWN0aW9ufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMucnRsLmpzJztcbmltcG9ydCB7ZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCBkcmF3UG9pbnR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9wbGF0Zm9ybS9wbGF0Zm9ybS5iYXNlLmpzJykuQ2hhcnQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkFjdGl2ZUVsZW1lbnQgfSBBY3RpdmVFbGVtZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmludGVyYWN0aW9uLmpzJykuSW50ZXJhY3Rpb25JdGVtIH0gSW50ZXJhY3Rpb25JdGVtXG4gKi9cblxuY29uc3QgcG9zaXRpb25lcnMgPSB7XG4gIC8qKlxuXHQgKiBBdmVyYWdlIG1vZGUgcGxhY2VzIHRoZSB0b29sdGlwIGF0IHRoZSBhdmVyYWdlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50cyBzaG93blxuXHQgKi9cbiAgYXZlcmFnZShpdGVtcykge1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGksIGxlbjtcbiAgICBsZXQgeFNldCA9IG5ldyBTZXQoKTtcbiAgICBsZXQgeSA9IDA7XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgICAgeFNldC5hZGQocG9zLngpO1xuICAgICAgICB5ICs9IHBvcy55O1xuICAgICAgICArK2NvdW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIHZpc2libGUgaXRlbXMgd2hlcmUgZm91bmQsIHJldHVybiBmYWxzZSBzbyB3ZSBkb24ndCBoYXZlIHRvIGRpdmlkZSBieSAwIHdoaWNoIHJlZHVjZXMgaW4gTmFOXG4gICAgaWYgKGNvdW50ID09PSAwIHx8IHhTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHhBdmVyYWdlID0gWy4uLnhTZXRdLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8geFNldC5zaXplO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHhBdmVyYWdlLFxuICAgICAgeTogeSAvIGNvdW50XG4gICAgfTtcbiAgfSxcblxuICAvKipcblx0ICogR2V0cyB0aGUgdG9vbHRpcCBwb3NpdGlvbiBuZWFyZXN0IG9mIHRoZSBpdGVtIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdCAqL1xuICBuZWFyZXN0KGl0ZW1zLCBldmVudFBvc2l0aW9uKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgeCA9IGV2ZW50UG9zaXRpb24ueDtcbiAgICBsZXQgeSA9IGV2ZW50UG9zaXRpb24ueTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IGksIGxlbiwgbmVhcmVzdEVsZW1lbnQ7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gZWwuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgICAgY29uc3QgZCA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhldmVudFBvc2l0aW9uLCBjZW50ZXIpO1xuXG4gICAgICAgIGlmIChkIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGQ7XG4gICAgICAgICAgbmVhcmVzdEVsZW1lbnQgPSBlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWFyZXN0RWxlbWVudCkge1xuICAgICAgY29uc3QgdHAgPSBuZWFyZXN0RWxlbWVudC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgIHggPSB0cC54O1xuICAgICAgeSA9IHRwLnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxufTtcblxuLy8gSGVscGVyIHRvIHB1c2ggb3IgY29uY2F0IGJhc2VkIG9uIGlmIHRoZSAybmQgcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9yIG5vdFxuZnVuY3Rpb24gcHVzaE9yQ29uY2F0KGJhc2UsIHRvUHVzaCkge1xuICBpZiAodG9QdXNoKSB7XG4gICAgaWYgKGlzQXJyYXkodG9QdXNoKSkge1xuICAgICAgLy8gYmFzZSA9IGJhc2UuY29uY2F0KHRvUHVzaCk7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlLnB1c2godG9QdXNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIHN0cmluZ3Mgc3BsaXQgYnkgbmV3bGluZVxuICogQHBhcmFtIHsqfSBzdHIgLSBUaGUgdmFsdWUgdG8gc3BsaXQgYnkgbmV3bGluZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3RyaW5nW119IHZhbHVlIGlmIG5ld2xpbmUgcHJlc2VudCAtIFJldHVybmVkIGZyb20gU3RyaW5nIHNwbGl0KCkgbWV0aG9kXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcbiAgaWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnXFxuJyk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuXG4vKipcbiAqIFByaXZhdGUgaGVscGVyIHRvIGNyZWF0ZSBhIHRvb2x0aXAgaXRlbSBtb2RlbFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnRcbiAqIEBwYXJhbSB7QWN0aXZlRWxlbWVudH0gaXRlbSAtIHtlbGVtZW50LCBpbmRleCwgZGF0YXNldEluZGV4fSB0byBjcmVhdGUgdGhlIHRvb2x0aXAgaXRlbSBmb3JcbiAqIEByZXR1cm4gbmV3IHRvb2x0aXAgaXRlbVxuICovXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwSXRlbShjaGFydCwgaXRlbSkge1xuICBjb25zdCB7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0gPSBpdGVtO1xuICBjb25zdCBjb250cm9sbGVyID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICBjb25zdCB7bGFiZWwsIHZhbHVlfSA9IGNvbnRyb2xsZXIuZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCk7XG5cbiAgcmV0dXJuIHtcbiAgICBjaGFydCxcbiAgICBsYWJlbCxcbiAgICBwYXJzZWQ6IGNvbnRyb2xsZXIuZ2V0UGFyc2VkKGluZGV4KSxcbiAgICByYXc6IGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSxcbiAgICBmb3JtYXR0ZWRWYWx1ZTogdmFsdWUsXG4gICAgZGF0YXNldDogY29udHJvbGxlci5nZXREYXRhc2V0KCksXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBkYXRhc2V0SW5kZXgsXG4gICAgZWxlbWVudFxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgdG9vbHRpcFxuICovXG5mdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBvcHRpb25zKSB7XG4gIGNvbnN0IGN0eCA9IHRvb2x0aXAuY2hhcnQuY3R4O1xuICBjb25zdCB7Ym9keSwgZm9vdGVyLCB0aXRsZX0gPSB0b29sdGlwO1xuICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodH0gPSBvcHRpb25zO1xuICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgY29uc3QgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuICBjb25zdCB0aXRsZUxpbmVDb3VudCA9IHRpdGxlLmxlbmd0aDtcbiAgY29uc3QgZm9vdGVyTGluZUNvdW50ID0gZm9vdGVyLmxlbmd0aDtcbiAgY29uc3QgYm9keUxpbmVJdGVtQ291bnQgPSBib2R5Lmxlbmd0aDtcblxuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIGxldCBoZWlnaHQgPSBwYWRkaW5nLmhlaWdodDtcbiAgbGV0IHdpZHRoID0gMDtcblxuICAvLyBDb3VudCBvZiBhbGwgbGluZXMgaW4gdGhlIGJvZHlcbiAgbGV0IGNvbWJpbmVkQm9keUxlbmd0aCA9IGJvZHkucmVkdWNlKChjb3VudCwgYm9keUl0ZW0pID0+IGNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aCwgMCk7XG4gIGNvbWJpbmVkQm9keUxlbmd0aCArPSB0b29sdGlwLmJlZm9yZUJvZHkubGVuZ3RoICsgdG9vbHRpcC5hZnRlckJvZHkubGVuZ3RoO1xuXG4gIGlmICh0aXRsZUxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCAqIHRpdGxlRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrICh0aXRsZUxpbmVDb3VudCAtIDEpICogb3B0aW9ucy50aXRsZVNwYWNpbmdcblx0XHRcdCsgb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbTtcbiAgfVxuICBpZiAoY29tYmluZWRCb2R5TGVuZ3RoKSB7XG4gICAgLy8gQm9keSBsaW5lcyBtYXkgaW5jbHVkZSBzb21lIGV4dHJhIGhlaWdodCBkZXBlbmRpbmcgb24gYm94SGVpZ2h0XG4gICAgY29uc3QgYm9keUxpbmVIZWlnaHQgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyBNYXRoLm1heChib3hIZWlnaHQsIGJvZHlGb250LmxpbmVIZWlnaHQpIDogYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBoZWlnaHQgKz0gYm9keUxpbmVJdGVtQ291bnQgKiBib2R5TGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gYm9keUxpbmVJdGVtQ291bnQpICogYm9keUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBvcHRpb25zLmJvZHlTcGFjaW5nO1xuICB9XG4gIGlmIChmb290ZXJMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3Bcblx0XHRcdCsgZm9vdGVyTGluZUNvdW50ICogZm9vdGVyRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgfVxuXG4gIC8vIFRpdGxlIHdpZHRoXG4gIGxldCB3aWR0aFBhZGRpbmcgPSAwO1xuICBjb25zdCBtYXhMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcbiAgfTtcblxuICBjdHguc2F2ZSgpO1xuXG4gIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuXG4gIC8vIEJvZHkgd2lkdGhcbiAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5iZWZvcmVCb2R5LmNvbmNhdCh0b29sdGlwLmFmdGVyQm9keSksIG1heExpbmVXaWR0aCk7XG5cbiAgLy8gQm9keSBsaW5lcyBtYXkgaW5jbHVkZSBzb21lIGV4dHJhIHdpZHRoIGR1ZSB0byB0aGUgY29sb3IgYm94XG4gIHdpZHRoUGFkZGluZyA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IChib3hXaWR0aCArIDIgKyBvcHRpb25zLmJveFBhZGRpbmcpIDogMDtcbiAgZWFjaChib2R5LCAoYm9keUl0ZW0pID0+IHtcbiAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgbWF4TGluZVdpZHRoKTtcbiAgICBlYWNoKGJvZHlJdGVtLmxpbmVzLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XG4gIH0pO1xuXG4gIC8vIFJlc2V0IGJhY2sgdG8gMFxuICB3aWR0aFBhZGRpbmcgPSAwO1xuXG4gIC8vIEZvb3RlciB3aWR0aFxuICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAuZm9vdGVyLCBtYXhMaW5lV2lkdGgpO1xuXG4gIGN0eC5yZXN0b3JlKCk7XG5cbiAgLy8gQWRkIHBhZGRpbmdcbiAgd2lkdGggKz0gcGFkZGluZy53aWR0aDtcblxuICByZXR1cm4ge3dpZHRoLCBoZWlnaHR9O1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpIHtcbiAgY29uc3Qge3ksIGhlaWdodH0gPSBzaXplO1xuXG4gIGlmICh5IDwgaGVpZ2h0IC8gMikge1xuICAgIHJldHVybiAndG9wJztcbiAgfSBlbHNlIGlmICh5ID4gKGNoYXJ0LmhlaWdodCAtIGhlaWdodCAvIDIpKSB7XG4gICAgcmV0dXJuICdib3R0b20nO1xuICB9XG4gIHJldHVybiAnY2VudGVyJztcbn1cblxuZnVuY3Rpb24gZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCBjYXJldCA9IG9wdGlvbnMuY2FyZXRTaXplICsgb3B0aW9ucy5jYXJldFBhZGRpbmc7XG4gIGlmICh4QWxpZ24gPT09ICdsZWZ0JyAmJiB4ICsgd2lkdGggKyBjYXJldCA+IGNoYXJ0LndpZHRoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoeEFsaWduID09PSAncmlnaHQnICYmIHggLSB3aWR0aCAtIGNhcmV0IDwgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCB7d2lkdGg6IGNoYXJ0V2lkdGgsIGNoYXJ0QXJlYToge2xlZnQsIHJpZ2h0fX0gPSBjaGFydDtcbiAgbGV0IHhBbGlnbiA9ICdjZW50ZXInO1xuXG4gIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeEFsaWduID0geCA8PSAobGVmdCArIHJpZ2h0KSAvIDIgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9IGVsc2UgaWYgKHggPD0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ2xlZnQnO1xuICB9IGVsc2UgaWYgKHggPj0gY2hhcnRXaWR0aCAtIHdpZHRoIC8gMikge1xuICAgIHhBbGlnbiA9ICdyaWdodCc7XG4gIH1cblxuICBpZiAoZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSkge1xuICAgIHhBbGlnbiA9ICdjZW50ZXInO1xuICB9XG5cbiAgcmV0dXJuIHhBbGlnbjtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBhbGlnbm1lbnQgb2YgYSB0b29sdGlwIGdpdmVuIHRoZSBzaXplXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudChjaGFydCwgb3B0aW9ucywgc2l6ZSkge1xuICBjb25zdCB5QWxpZ24gPSBzaXplLnlBbGlnbiB8fCBvcHRpb25zLnlBbGlnbiB8fCBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpO1xuXG4gIHJldHVybiB7XG4gICAgeEFsaWduOiBzaXplLnhBbGlnbiB8fCBvcHRpb25zLnhBbGlnbiB8fCBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbiksXG4gICAgeUFsaWduXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFsaWduWChzaXplLCB4QWxpZ24pIHtcbiAgbGV0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3aWR0aDtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAod2lkdGggLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge3ksIGhlaWdodH0gPSBzaXplO1xuICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgIHkgKz0gcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgIHkgLT0gaGVpZ2h0ICsgcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSB7XG4gICAgeSAtPSAoaGVpZ2h0IC8gMik7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGdldCB0aGUgbG9jYXRpb24gYSB0b29sdGlwIG5lZWRzIHRvIGJlIHBsYWNlZCBhdCBnaXZlbiB0aGUgaW5pdGlhbCBwb3NpdGlvbiAodmlhIHRoZSB2bSkgYW5kIHRoZSBzaXplIGFuZCBhbGlnbm1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHNpemUsIGFsaWdubWVudCwgY2hhcnQpIHtcbiAgY29uc3Qge2NhcmV0U2l6ZSwgY2FyZXRQYWRkaW5nLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IGFsaWdubWVudDtcbiAgY29uc3QgcGFkZGluZ0FuZFNpemUgPSBjYXJldFNpemUgKyBjYXJldFBhZGRpbmc7XG4gIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhjb3JuZXJSYWRpdXMpO1xuXG4gIGxldCB4ID0gYWxpZ25YKHNpemUsIHhBbGlnbik7XG4gIGNvbnN0IHkgPSBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSk7XG5cbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHggKz0gcGFkZGluZ0FuZFNpemU7XG4gICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHggLT0gcGFkZGluZ0FuZFNpemU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgeCAtPSBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIGNhcmV0U2l6ZTtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4ICs9IE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgKyBjYXJldFNpemU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IF9saW1pdFZhbHVlKHgsIDAsIGNoYXJ0LndpZHRoIC0gc2l6ZS53aWR0aCksXG4gICAgeTogX2xpbWl0VmFsdWUoeSwgMCwgY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEFsaWduZWRYKHRvb2x0aXAsIGFsaWduLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcblxuICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInXG4gICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC8gMlxuICAgIDogYWxpZ24gPT09ICdyaWdodCdcbiAgICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAtIHBhZGRpbmcucmlnaHRcbiAgICAgIDogdG9vbHRpcC54ICsgcGFkZGluZy5sZWZ0O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBidWlsZCBiZWZvcmUgYW5kIGFmdGVyIGJvZHkgbGluZXNcbiAqL1xuZnVuY3Rpb24gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHB1c2hPckNvbmNhdChbXSwgc3BsaXROZXdsaW5lcyhjYWxsYmFjaykpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwQ29udGV4dChwYXJlbnQsIHRvb2x0aXAsIHRvb2x0aXBJdGVtcykge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICB0b29sdGlwLFxuICAgIHRvb2x0aXBJdGVtcyxcbiAgICB0eXBlOiAndG9vbHRpcCdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCkge1xuICBjb25zdCBvdmVycmlkZSA9IGNvbnRleHQgJiYgY29udGV4dC5kYXRhc2V0ICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwLmNhbGxiYWNrcztcbiAgcmV0dXJuIG92ZXJyaWRlID8gY2FsbGJhY2tzLm92ZXJyaWRlKG92ZXJyaWRlKSA6IGNhbGxiYWNrcztcbn1cblxuY29uc3QgZGVmYXVsdENhbGxiYWNrcyA9IHtcbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGJlZm9yZVRpdGxlOiBub29wLFxuICB0aXRsZSh0b29sdGlwSXRlbXMpIHtcbiAgICBpZiAodG9vbHRpcEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XG4gICAgICBjb25zdCBsYWJlbHMgPSBpdGVtLmNoYXJ0LmRhdGEubGFiZWxzO1xuICAgICAgY29uc3QgbGFiZWxDb3VudCA9IGxhYmVscyA/IGxhYmVscy5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICByZXR1cm4gaXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLmxhYmVsKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmxhYmVsO1xuICAgICAgfSBlbHNlIGlmIChsYWJlbENvdW50ID4gMCAmJiBpdGVtLmRhdGFJbmRleCA8IGxhYmVsQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsc1tpdGVtLmRhdGFJbmRleF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9LFxuICBhZnRlclRpdGxlOiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuICBiZWZvcmVCb2R5OiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG4gIGJlZm9yZUxhYmVsOiBub29wLFxuICBsYWJlbCh0b29sdGlwSXRlbSkge1xuICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICByZXR1cm4gdG9vbHRpcEl0ZW0ubGFiZWwgKyAnOiAnICsgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWUgfHwgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgfVxuXG4gICAgbGV0IGxhYmVsID0gdG9vbHRpcEl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcblxuICAgIGlmIChsYWJlbCkge1xuICAgICAgbGFiZWwgKz0gJzogJztcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICBsYWJlbCArPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsO1xuICB9LFxuICBsYWJlbENvbG9yKHRvb2x0aXBJdGVtKSB7XG4gICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICB9O1xuICB9LFxuICBsYWJlbFRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJvZHlDb2xvcjtcbiAgfSxcbiAgbGFiZWxQb2ludFN0eWxlKHRvb2x0aXBJdGVtKSB7XG4gICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG4gICAgICByb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcbiAgICB9O1xuICB9LFxuICBhZnRlckxhYmVsOiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuICBhZnRlckJvZHk6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGJlZm9yZUZvb3Rlcjogbm9vcCxcbiAgZm9vdGVyOiBub29wLFxuICBhZnRlckZvb3Rlcjogbm9vcFxufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgZnJvbSBvYmplY3Qgd2l0aCBjb250ZXh0IGFuZCBhcmd1bWVudHMuXG4gKiBJZiBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgLCB0aGVuIHdpbGwgYmUgaW52b2tlZCBkZWZhdWx0IGNhbGxiYWNrLlxuICogQHBhcmFtIHtSZWNvcmQ8a2V5b2YgdHlwZW9mIGRlZmF1bHRDYWxsYmFja3MsIEZ1bmN0aW9uPn0gY2FsbGJhY2tzXG4gKiBAcGFyYW0ge2tleW9mIHR5cGVvZiBkZWZhdWx0Q2FsbGJhY2tzfSBuYW1lXG4gKiBAcGFyYW0geyp9IGN0eFxuICogQHBhcmFtIHsqfSBhcmdcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgbmFtZSwgY3R4LCBhcmcpIHtcbiAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2tzW25hbWVdLmNhbGwoY3R4LCBhcmcpO1xuXG4gIGlmICh0eXBlb2YgcmVzdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBkZWZhdWx0Q2FsbGJhY2tzW25hbWVdLmNhbGwoY3R4LCBhcmcpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBFbGVtZW50IHtcblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzXG4gICAqL1xuICBzdGF0aWMgcG9zaXRpb25lcnMgPSBwb3NpdGlvbmVycztcblxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcGFjaXR5ID0gMDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSBbXTtcbiAgICB0aGlzLiRhbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aXRsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJlZm9yZUJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9vdGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueEFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueUFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WSA9IHVuZGVmaW5lZDtcbiAgICAvLyBUT0RPOiBWNCwgbWFrZSB0aGlzIHByaXZhdGUsIHJlbmFtZSB0byBgX2xhYmVsU3R5bGVzYCwgYW5kIGNvbWJpbmUgd2l0aCBgbGFiZWxQb2ludFN0eWxlc2BcbiAgICAvLyBhbmQgYGxhYmVsVGV4dENvbG9yc2AgdG8gY3JlYXRlIGEgc2luZ2xlIHZhcmlhYmxlXG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpbml0aWFsaXplKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVBbmltYXRpb25zKCkge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX2NhY2hlZEFuaW1hdGlvbnM7XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zLmVuYWJsZWQgJiYgY2hhcnQub3B0aW9ucy5hbmltYXRpb24gJiYgb3B0aW9ucy5hbmltYXRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyh0aGlzLmNoYXJ0LCBvcHRzKTtcbiAgICBpZiAob3B0cy5fY2FjaGVhYmxlKSB7XG4gICAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVRvb2x0aXBDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLCB0aGlzLl90b29sdGlwSXRlbXMpKTtcbiAgfVxuXG4gIGdldFRpdGxlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBiZWZvcmVUaXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2JlZm9yZVRpdGxlJywgdGhpcywgY29udGV4dCk7XG4gICAgY29uc3QgdGl0bGUgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICd0aXRsZScsIHRoaXMsIGNvbnRleHQpO1xuICAgIGNvbnN0IGFmdGVyVGl0bGUgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdhZnRlclRpdGxlJywgdGhpcywgY29udGV4dCk7XG5cbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVUaXRsZSkpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKHRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJUaXRsZSkpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoXG4gICAgICBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhvcHRpb25zLmNhbGxiYWNrcywgJ2JlZm9yZUJvZHknLCB0aGlzLCB0b29sdGlwSXRlbXMpXG4gICAgKTtcbiAgfVxuXG4gIGdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlJdGVtcyA9IFtdO1xuXG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBib2R5SXRlbSA9IHtcbiAgICAgICAgYmVmb3JlOiBbXSxcbiAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICBhZnRlcjogW11cbiAgICAgIH07XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmJlZm9yZSwgc3BsaXROZXdsaW5lcyhpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdiZWZvcmVMYWJlbCcsIHRoaXMsIGNvbnRleHQpKSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmFmdGVyLCBzcGxpdE5ld2xpbmVzKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2FmdGVyTGFiZWwnLCB0aGlzLCBjb250ZXh0KSkpO1xuXG4gICAgICBib2R5SXRlbXMucHVzaChib2R5SXRlbSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYm9keUl0ZW1zO1xuICB9XG5cbiAgZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhcbiAgICAgIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKG9wdGlvbnMuY2FsbGJhY2tzLCAnYWZ0ZXJCb2R5JywgdGhpcywgdG9vbHRpcEl0ZW1zKVxuICAgICk7XG4gIH1cblxuICAvLyBHZXQgdGhlIGZvb3RlciBhbmQgYmVmb3JlRm9vdGVyIGFuZCBhZnRlckZvb3RlciBsaW5lc1xuICBnZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgYmVmb3JlRm9vdGVyID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYmVmb3JlRm9vdGVyJywgdGhpcywgdG9vbHRpcEl0ZW1zKTtcbiAgICBjb25zdCBmb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdmb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuICAgIGNvbnN0IGFmdGVyRm9vdGVyID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYWZ0ZXJGb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuXG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlRm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoZm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJGb290ZXIpKTtcblxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICBjb25zdCBsYWJlbENvbG9ycyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZXMgPSBbXTtcbiAgICBjb25zdCBsYWJlbFRleHRDb2xvcnMgPSBbXTtcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG4gICAgbGV0IGksIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdG9vbHRpcEl0ZW1zLnB1c2goY3JlYXRlVG9vbHRpcEl0ZW0odGhpcy5jaGFydCwgYWN0aXZlW2ldKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBmaWx0ZXIgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcbiAgICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5maWx0ZXIoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gb3B0aW9ucy5maWx0ZXIoZWxlbWVudCwgaW5kZXgsIGFycmF5LCBkYXRhKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBzb3J0aW5nIGZ1bmN0aW9uLCB1c2UgaXQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIGl0ZW1zXG4gICAgaWYgKG9wdGlvbnMuaXRlbVNvcnQpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KChhLCBiKSA9PiBvcHRpb25zLml0ZW1Tb3J0KGEsIGIsIGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgY29sb3JzIGZvciBib3hlc1xuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3Mob3B0aW9ucy5jYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgbGFiZWxDb2xvcnMucHVzaChpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdsYWJlbENvbG9yJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxQb2ludFN0eWxlcy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsUG9pbnRTdHlsZScsIHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIGxhYmVsVGV4dENvbG9ycy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsVGV4dENvbG9yJywgdGhpcywgY29udGV4dCkpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IGxhYmVsUG9pbnRTdHlsZXM7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSBsYWJlbFRleHRDb2xvcnM7XG4gICAgdGhpcy5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xuICAgIHJldHVybiB0b29sdGlwSXRlbXM7XG4gIH1cblxuICB1cGRhdGUoY2hhbmdlZCwgcmVwbGF5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgbGV0IHByb3BlcnRpZXM7XG4gICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuXG4gICAgaWYgKCFhY3RpdmUubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5vcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRoaXMuX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLnRpdGxlID0gdGhpcy5nZXRUaXRsZSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5iZWZvcmVCb2R5ID0gdGhpcy5nZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJvZHkgPSB0aGlzLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdGhpcy5nZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZm9vdGVyID0gdGhpcy5nZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcblxuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCBzaXplKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudCh0aGlzLmNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgYmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCB0aGlzLmNoYXJ0KTtcblxuICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuXG4gICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICB4OiBiYWNrZ3JvdW5kUG9pbnQueCxcbiAgICAgICAgeTogYmFja2dyb3VuZFBvaW50LnksXG4gICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgICAgICBjYXJldFg6IHBvc2l0aW9uLngsXG4gICAgICAgIGNhcmV0WTogcG9zaXRpb24ueVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXM7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlZCAmJiBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICBvcHRpb25zLmV4dGVybmFsLmNhbGwodGhpcywge2NoYXJ0OiB0aGlzLmNoYXJ0LCB0b29sdGlwOiB0aGlzLCByZXBsYXl9KTtcbiAgICB9XG4gIH1cblxuICBkcmF3Q2FyZXQodG9vbHRpcFBvaW50LCBjdHgsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucyk7XG5cbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcbiAgfVxuXG4gIGdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge2NhcmV0U2l6ZSwgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG4gICAgY29uc3Qge3g6IHB0WCwgeTogcHRZfSA9IHRvb2x0aXBQb2ludDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzaXplO1xuICAgIGxldCB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xuXG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHkyID0gcHRZICsgKGhlaWdodCAvIDIpO1xuXG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDEgPSBwdFg7XG4gICAgICAgIHgyID0geDEgLSBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gTGVmdCBkcmF3cyBib3R0b20gLT4gdG9wLCB0aGlzIHkxIGlzIG9uIHRoZSBib3R0b21cbiAgICAgICAgeTEgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgxID0gcHRYICsgd2lkdGg7XG4gICAgICAgIHgyID0geDEgKyBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gUmlnaHQgZHJhd3MgdG9wIC0+IGJvdHRvbSwgdGh1cyB5MSBpcyBvbiB0aGUgdG9wXG4gICAgICAgIHkxID0geTIgLSBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgKyBjYXJldFNpemU7XG4gICAgICB9XG5cbiAgICAgIHgzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MiA9IHB0WCArIE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgKGNhcmV0U2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4MiA9IHB0WCArIHdpZHRoIC0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0gdGhpcy5jYXJldFg7XG4gICAgICB9XG5cbiAgICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgIHkxID0gcHRZO1xuICAgICAgICB5MiA9IHkxIC0gY2FyZXRTaXplO1xuXG4gICAgICAgIC8vIFRvcCBkcmF3cyBsZWZ0IC0+IHJpZ2h0LCB0aHVzIHgxIGlzIG9uIHRoZSBsZWZ0XG4gICAgICAgIHgxID0geDIgLSBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgKyBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5MSA9IHB0WSArIGhlaWdodDtcbiAgICAgICAgeTIgPSB5MSArIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBCb3R0b20gZHJhd3MgcmlnaHQgLT4gbGVmdCwgdGh1cyB4MSBpcyBvbiB0aGUgcmlnaHRcbiAgICAgICAgeDEgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH1cbiAgICAgIHkzID0geTE7XG4gICAgfVxuICAgIHJldHVybiB7eDEsIHgyLCB4MywgeTEsIHkyLCB5M307XG4gIH1cblxuICBkcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy50aXRsZTtcbiAgICBjb25zdCBsZW5ndGggPSB0aXRsZS5sZW5ndGg7XG4gICAgbGV0IHRpdGxlRm9udCwgdGl0bGVTcGFjaW5nLCBpO1xuXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcblxuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMudGl0bGVBbGlnbiwgb3B0aW9ucyk7XG5cbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMudGl0bGVBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICAgIHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gICAgICB0aXRsZVNwYWNpbmcgPSBvcHRpb25zLnRpdGxlU3BhY2luZztcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMudGl0bGVDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0aXRsZVtpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyB0aXRsZUZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICBwdC55ICs9IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVTcGFjaW5nOyAvLyBMaW5lIEhlaWdodCBhbmQgc3BhY2luZ1xuXG4gICAgICAgIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgcHQueSArPSBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nOyAvLyBJZiBMYXN0LCBhZGQgbWFyZ2luLCByZW1vdmUgc3BhY2luZ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxhYmVsQ29sb3IgPSB0aGlzLmxhYmVsQ29sb3JzW2ldO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZSA9IHRoaXMubGFiZWxQb2ludFN0eWxlc1tpXTtcbiAgICBjb25zdCB7Ym94SGVpZ2h0LCBib3hXaWR0aH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGNvbnN0IGNvbG9yWCA9IGdldEFsaWduZWRYKHRoaXMsICdsZWZ0Jywgb3B0aW9ucyk7XG4gICAgY29uc3QgcnRsQ29sb3JYID0gcnRsSGVscGVyLngoY29sb3JYKTtcbiAgICBjb25zdCB5T2ZmU2V0ID0gYm94SGVpZ2h0IDwgYm9keUZvbnQubGluZUhlaWdodCA/IChib2R5Rm9udC5saW5lSGVpZ2h0IC0gYm94SGVpZ2h0KSAvIDIgOiAwO1xuICAgIGNvbnN0IGNvbG9yWSA9IHB0LnkgKyB5T2ZmU2V0O1xuXG4gICAgaWYgKG9wdGlvbnMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgIHJhZGl1czogTWF0aC5taW4oYm94V2lkdGgsIGJveEhlaWdodCkgLyAyLCAvLyBmaXQgdGhlIGNpcmNsZSBpbiB0aGUgYm94XG4gICAgICAgIHBvaW50U3R5bGU6IGxhYmVsUG9pbnRTdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICByb3RhdGlvbjogbGFiZWxQb2ludFN0eWxlLnJvdGF0aW9uLFxuICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgfTtcbiAgICAgIC8vIFJlY2FsY3VsYXRlIHggYW5kIHkgZm9yIGRyYXdQb2ludCgpIGJlY2F1c2UgaXRzIGV4cGVjdGluZ1xuICAgICAgLy8geCBhbmQgeSB0byBiZSBjZW50ZXIgb2YgZmlndXJlIChpbnN0ZWFkIG9mIHRvcCBsZWZ0KVxuICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGgpICsgYm94V2lkdGggLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IGNvbG9yWSArIGJveEhlaWdodCAvIDI7XG5cbiAgICAgIC8vIEZpbGwgdGhlIHBvaW50IHdpdGggd2hpdGUgc28gdGhhdCBjb2xvdXJzIG1lcmdlIG5pY2VseSBpZiB0aGUgb3BhY2l0eSBpcyA8IDFcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuXG4gICAgICAvLyBEcmF3IHRoZSBwb2ludFxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvci5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQm9yZGVyXG4gICAgICBjdHgubGluZVdpZHRoID0gaXNPYmplY3QobGFiZWxDb2xvci5ib3JkZXJXaWR0aCkgPyBNYXRoLm1heCguLi5PYmplY3QudmFsdWVzKGxhYmVsQ29sb3IuYm9yZGVyV2lkdGgpKSA6IChsYWJlbENvbG9yLmJvcmRlcldpZHRoIHx8IDEpOyAvLyBUT0RPLCB2NCByZW1vdmUgZmFsbGJhY2tcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3IuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2gobGFiZWxDb2xvci5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxhYmVsQ29sb3IuYm9yZGVyRGFzaE9mZnNldCB8fCAwO1xuXG4gICAgICAvLyBGaWxsIGEgd2hpdGUgcmVjdCBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxuICAgICAgY29uc3Qgb3V0ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCk7XG4gICAgICBjb25zdCBpbm5lclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueFBsdXMocnRsQ29sb3JYLCAxKSwgYm94V2lkdGggLSAyKTtcbiAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGFiZWxDb2xvci5ib3JkZXJSYWRpdXMpO1xuXG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IG91dGVyWCxcbiAgICAgICAgICB5OiBjb2xvclksXG4gICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIC8vIElubmVyIHNxdWFyZVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IGlubmVyWCxcbiAgICAgICAgICB5OiBjb2xvclkgKyAxLFxuICAgICAgICAgIHc6IGJveFdpZHRoIC0gMixcbiAgICAgICAgICBoOiBib3hIZWlnaHQgLSAyLFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vcm1hbCByZWN0XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgY3R4LmZpbGxSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICAvLyBJbm5lciBzcXVhcmVcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3IuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoaW5uZXJYLCBjb2xvclkgKyAxLCBib3hXaWR0aCAtIDIsIGJveEhlaWdodCAtIDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlc3RvcmUgZmlsbFN0eWxlXG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW2ldO1xuICB9XG5cbiAgZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtib2R5fSA9IHRoaXM7XG4gICAgY29uc3Qge2JvZHlTcGFjaW5nLCBib2R5QWxpZ24sIGRpc3BsYXlDb2xvcnMsIGJveEhlaWdodCwgYm94V2lkdGgsIGJveFBhZGRpbmd9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBsZXQgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGxldCB4TGluZVBhZGRpbmcgPSAwO1xuXG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcblxuICAgIGNvbnN0IGZpbGxMaW5lT2ZUZXh0ID0gZnVuY3Rpb24obGluZSkge1xuICAgICAgY3R4LmZpbGxUZXh0KGxpbmUsIHJ0bEhlbHBlci54KHB0LnggKyB4TGluZVBhZGRpbmcpLCBwdC55ICsgYm9keUxpbmVIZWlnaHQgLyAyKTtcbiAgICAgIHB0LnkgKz0gYm9keUxpbmVIZWlnaHQgKyBib2R5U3BhY2luZztcbiAgICB9O1xuXG4gICAgY29uc3QgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gPSBydGxIZWxwZXIudGV4dEFsaWduKGJvZHlBbGlnbik7XG4gICAgbGV0IGJvZHlJdGVtLCB0ZXh0Q29sb3IsIGxpbmVzLCBpLCBqLCBpbGVuLCBqbGVuO1xuXG4gICAgY3R4LnRleHRBbGlnbiA9IGJvZHlBbGlnbjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG5cbiAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24sIG9wdGlvbnMpO1xuXG4gICAgLy8gQmVmb3JlIGJvZHkgbGluZXNcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5ib2R5Q29sb3I7XG4gICAgZWFjaCh0aGlzLmJlZm9yZUJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcblxuICAgIHhMaW5lUGFkZGluZyA9IGRpc3BsYXlDb2xvcnMgJiYgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gIT09ICdyaWdodCdcbiAgICAgID8gYm9keUFsaWduID09PSAnY2VudGVyJyA/IChib3hXaWR0aCAvIDIgKyBib3hQYWRkaW5nKSA6IChib3hXaWR0aCArIDIgKyBib3hQYWRkaW5nKVxuICAgICAgOiAwO1xuXG4gICAgLy8gRHJhdyBib2R5IGxpbmVzIG5vd1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBib2R5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgYm9keUl0ZW0gPSBib2R5W2ldO1xuICAgICAgdGV4dENvbG9yID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG4gICAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xuXG4gICAgICBsaW5lcyA9IGJvZHlJdGVtLmxpbmVzO1xuICAgICAgLy8gRHJhdyBMZWdlbmQtbGlrZSBib3hlcyBpZiBuZWVkZWRcbiAgICAgIGlmIChkaXNwbGF5Q29sb3JzICYmIGxpbmVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKTtcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBNYXRoLm1heChib2R5Rm9udC5saW5lSGVpZ2h0LCBib3hIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGluZXMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgIGZpbGxMaW5lT2ZUZXh0KGxpbmVzW2pdKTtcbiAgICAgICAgLy8gUmVzZXQgZm9yIGFueSBsaW5lcyB0aGF0IGRvbid0IGluY2x1ZGUgY29sb3Jib3hcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBlYWNoKGJvZHlJdGVtLmFmdGVyLCBmaWxsTGluZU9mVGV4dCk7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgYmFjayB0byAwIGZvciBhZnRlciBib2R5XG4gICAgeExpbmVQYWRkaW5nID0gMDtcbiAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG5cbiAgICAvLyBBZnRlciBib2R5IGxpbmVzXG4gICAgZWFjaCh0aGlzLmFmdGVyQm9keSwgZmlsbExpbmVPZlRleHQpO1xuICAgIHB0LnkgLT0gYm9keVNwYWNpbmc7IC8vIFJlbW92ZSBsYXN0IGJvZHkgc3BhY2luZ1xuICB9XG5cbiAgZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZm9vdGVyID0gdGhpcy5mb290ZXI7XG4gICAgY29uc3QgbGVuZ3RoID0gZm9vdGVyLmxlbmd0aDtcbiAgICBsZXQgZm9vdGVyRm9udCwgaTtcblxuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG5cbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLmZvb3RlckFsaWduLCBvcHRpb25zKTtcbiAgICAgIHB0LnkgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3A7XG5cbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMuZm9vdGVyQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgICBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZvb3RlckNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSBmb290ZXJGb250LnN0cmluZztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChmb290ZXJbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgZm9vdGVyRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gZm9vdGVyRm9udC5saW5lSGVpZ2h0ICsgb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge3gsIHl9ID0gcHQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdG9vbHRpcFNpemU7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKG9wdGlvbnMuY29ybmVyUmFkaXVzKTtcblxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHRvcExlZnQsIHkpO1xuICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gdG9wUmlnaHQsIHkpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgdG9wUmlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIGJvdHRvbVJpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIGJvdHRvbVJpZ2h0LCB5ICsgaGVpZ2h0KTtcbiAgICBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyBib3R0b21MZWZ0LCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gYm90dG9tTGVmdCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgdG9wTGVmdCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHRvcExlZnQsIHkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgIGN0eC5maWxsKCk7XG5cbiAgICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogVXBkYXRlIHgveSBhbmltYXRpb24gdGFyZ2V0cyB3aGVuIF9hY3RpdmUgZWxlbWVudHMgYXJlIGFuaW1hdGluZyB0b29cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucykge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbVggPSBhbmltcyAmJiBhbmltcy54O1xuICAgIGNvbnN0IGFuaW1ZID0gYW5pbXMgJiYgYW5pbXMueTtcbiAgICBpZiAoYW5pbVggfHwgYW5pbVkpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCB0aGlzLl9hY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHRoaXMuX3NpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgcG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIGNoYXJ0KTtcbiAgICAgIGlmIChhbmltWC5fdG8gIT09IHBvaW50LnggfHwgYW5pbVkuX3RvICE9PSBwb2ludC55KSB7XG4gICAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuICAgICAgICB0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgdGhpcy5jYXJldFggPSBwb3NpdGlvbi54O1xuICAgICAgICB0aGlzLmNhcmV0WSA9IHBvc2l0aW9uLnk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSB0b29sdGlwIHdpbGwgZHJhdyBhbnl0aGluZ1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdG9vbHRpcCB3aWxsIHJlbmRlclxuICAgKi9cbiAgX3dpbGxSZW5kZXIoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5vcGFjaXR5O1xuICB9XG5cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGxldCBvcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpO1xuXG4gICAgY29uc3QgdG9vbHRpcFNpemUgPSB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHB0ID0ge1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55XG4gICAgfTtcblxuICAgIC8vIElFMTEvRWRnZSBkb2VzIG5vdCBsaWtlIHZlcnkgc21hbGwgb3BhY2l0aWVzLCBzbyBzbmFwIHRvIDBcbiAgICBvcGFjaXR5ID0gTWF0aC5hYnMob3BhY2l0eSkgPCAxZS0zID8gMCA6IG9wYWNpdHk7XG5cbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG5cbiAgICAvLyBUcnV0aHkvZmFsc2V5IHZhbHVlIGZvciBlbXB0eSB0b29sdGlwXG4gICAgY29uc3QgaGFzVG9vbHRpcENvbnRlbnQgPSB0aGlzLnRpdGxlLmxlbmd0aCB8fCB0aGlzLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHRoaXMuYm9keS5sZW5ndGggfHwgdGhpcy5hZnRlckJvZHkubGVuZ3RoIHx8IHRoaXMuZm9vdGVyLmxlbmd0aDtcblxuICAgIGlmIChvcHRpb25zLmVuYWJsZWQgJiYgaGFzVG9vbHRpcENvbnRlbnQpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuXG4gICAgICAvLyBEcmF3IEJhY2tncm91bmRcbiAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuXG4gICAgICBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuXG4gICAgICBwdC55ICs9IHBhZGRpbmcudG9wO1xuXG4gICAgICAvLyBUaXRsZXNcbiAgICAgIHRoaXMuZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBCb2R5XG4gICAgICB0aGlzLmRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBGb290ZXJcbiAgICAgIHRoaXMuZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKTtcblxuICAgICAgcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgYWN0aXZlIGVsZW1lbnRzIGluIHRoZSB0b29sdGlwXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgYWN0aXZlIGluIHRoZSB0b29sdGlwXG5cdCAqL1xuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldCBhY3RpdmUgZWxlbWVudHMgaW4gdGhlIHRvb2x0aXBcblx0ICogQHBhcmFtIHthcnJheX0gYWN0aXZlRWxlbWVudHMgQXJyYXkgb2YgYWN0aXZlIGRhdGFzZXRJbmRleC9pbmRleCBwYWlycy5cblx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50UG9zaXRpb24gU3ludGhldGljIGV2ZW50IHBvc2l0aW9uIHVzZWQgaW4gcG9zaXRpb25pbmdcblx0ICovXG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblxuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgYSBkYXRhc2V0IGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZXZlbnRQb3NpdGlvbik7XG5cbiAgICBpZiAoY2hhbmdlZCB8fCBwb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSBldmVudFBvc2l0aW9uO1xuICAgICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXBsYXldIC0gVGhpcyBpcyBhIHJlcGxheWVkIGV2ZW50IChmcm9tIHVwZGF0ZSlcblx0ICogQHBhcmFtIHtib29sZWFufSBbaW5DaGFydEFyZWFdIC0gVGhlIGV2ZW50IGlzIGluc2lkZSBjaGFydEFyZWFcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRvb2x0aXAgY2hhbmdlZFxuXHQgKi9cbiAgaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSA9IHRydWUpIHtcbiAgICBpZiAocmVwbGF5ICYmIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSBmYWxzZTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKTtcblxuICAgIC8vIFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGl0ZW1zIHNob3duLCBidXQgdGhlIHRvb2x0aXAgcG9zaXRpb24gaXMgbmVhcmVzdCBtb2RlXG4gICAgLy8gYW4gdXBkYXRlIG1heSBuZWVkIHRvIGJlIG1hZGUgYmVjYXVzZSBvdXIgcG9zaXRpb24gbWF5IGhhdmUgY2hhbmdlZCBldmVuIHRob3VnaFxuICAgIC8vIHRoZSBpdGVtcyBhcmUgdGhlIHNhbWUgYXMgYmVmb3JlLlxuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpO1xuXG4gICAgLy8gUmVtZW1iZXIgTGFzdCBBY3RpdmVzXG4gICAgY29uc3QgY2hhbmdlZCA9IHJlcGxheSB8fCAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKSB8fCBwb3NpdGlvbkNoYW5nZWQ7XG5cbiAgICAvLyBPbmx5IGhhbmRsZSB0YXJnZXQgZXZlbnQgb24gdG9vbHRpcCBjaGFuZ2VcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuXG4gICAgICBpZiAob3B0aW9ucy5lbmFibGVkIHx8IG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBlLngsXG4gICAgICAgICAgeTogZS55XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51cGRhdGUodHJ1ZSwgcmVwbGF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBIZWxwZXIgZm9yIGRldGVybWluaW5nIHRoZSBhY3RpdmUgZWxlbWVudHMgZm9yIGV2ZW50XG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbkl0ZW1bXX0gbGFzdEFjdGl2ZSAtIFByZXZpb3VzbHkgYWN0aXZlIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcGxheV0gLSBUaGlzIGlzIGEgcmVwbGF5ZWQgZXZlbnQgKGZyb20gdXBkYXRlKVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbkNoYXJ0QXJlYV0gLSBUaGUgZXZlbnQgaXMgaW5zaWRlIGNoYXJ0QXJlYVxuXHQgKiBAcmV0dXJucyB7SW50ZXJhY3Rpb25JdGVtW119IC0gQWN0aXZlIGVsZW1lbnRzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xuICAgICAgLy8gTGV0IHVzZXIgY29udHJvbCB0aGUgYWN0aXZlIGVsZW1lbnRzIG91dHNpZGUgY2hhcnRBcmVhLiBFZy4gdXNpbmcgTGVnZW5kLlxuICAgICAgLy8gQnV0IG1ha2Ugc3VyZSB0aGF0IGFjdGl2ZSBlbGVtZW50cyBhcmUgc3RpbGwgdmFsaWQuXG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZS5maWx0ZXIoaSA9PlxuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbaS5kYXRhc2V0SW5kZXhdICYmXG4gICAgICAgIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaS5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGkuaW5kZXgpICE9PSB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIHRvb2x0aXBzXG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG9wdGlvbnMubW9kZSwgb3B0aW9ucywgcmVwbGF5KTtcblxuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGFjdGl2ZS5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGl2ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgdGhlIGFjdGl2ZSBlbGVtZW50cyArIGV2ZW50IGNvbWJpbmF0aW9uIGNoYW5nZXMgdGhlXG5cdCAqIHRvb2x0aXAgcG9zaXRpb25cblx0ICogQHBhcmFtIHthcnJheX0gYWN0aXZlIC0gQWN0aXZlIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIEV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBwb3NpdGlvbiBjaGFuZ2Vcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBvc2l0aW9uIGhhcyBjaGFuZ2VkXG5cdCAqL1xuICBfcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSkge1xuICAgIGNvbnN0IHtjYXJldFgsIGNhcmV0WSwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIGUpO1xuICAgIHJldHVybiBwb3NpdGlvbiAhPT0gZmFsc2UgJiYgKGNhcmV0WCAhPT0gcG9zaXRpb24ueCB8fCBjYXJldFkgIT09IHBvc2l0aW9uLnkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICd0b29sdGlwJyxcbiAgX2VsZW1lbnQ6IFRvb2x0aXAsXG4gIHBvc2l0aW9uZXJzLFxuXG4gIGFmdGVySW5pdChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgY2hhcnQudG9vbHRpcCA9IG5ldyBUb29sdGlwKHtjaGFydCwgb3B0aW9uc30pO1xuICAgIH1cbiAgfSxcblxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVzZXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgYWZ0ZXJEcmF3KGNoYXJ0KSB7XG4gICAgY29uc3QgdG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXA7XG5cbiAgICBpZiAodG9vbHRpcCAmJiB0b29sdGlwLl93aWxsUmVuZGVyKCkpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgIHRvb2x0aXBcbiAgICAgIH07XG5cbiAgICAgIGlmIChjaGFydC5ub3RpZnlQbHVnaW5zKCdiZWZvcmVUb29sdGlwRHJhdycsIHsuLi5hcmdzLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdG9vbHRpcC5kcmF3KGNoYXJ0LmN0eCk7XG5cbiAgICAgIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyVG9vbHRpcERyYXcnLCBhcmdzKTtcbiAgICB9XG4gIH0sXG5cbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICAvLyBJZiB0aGUgZXZlbnQgaXMgcmVwbGF5ZWQgZnJvbSBgdXBkYXRlYCwgd2Ugc2hvdWxkIGV2YWx1YXRlIHdpdGggdGhlIGZpbmFsIHBvc2l0aW9ucy5cbiAgICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSBhcmdzLnJlcGxheTtcbiAgICAgIGlmIChjaGFydC50b29sdGlwLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQsIHVzZUZpbmFsUG9zaXRpb24sIGFyZ3MuaW5DaGFydEFyZWEpKSB7XG4gICAgICAgIC8vIG5vdGlmeSBjaGFydCBhYm91dCB0aGUgY2hhbmdlLCBzbyBpdCB3aWxsIHJlbmRlclxuICAgICAgICBhcmdzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZXh0ZXJuYWw6IG51bGwsXG4gICAgcG9zaXRpb246ICdhdmVyYWdlJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgIHRpdGxlQ29sb3I6ICcjZmZmJyxcbiAgICB0aXRsZUZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgdGl0bGVTcGFjaW5nOiAyLFxuICAgIHRpdGxlTWFyZ2luQm90dG9tOiA2LFxuICAgIHRpdGxlQWxpZ246ICdsZWZ0JyxcbiAgICBib2R5Q29sb3I6ICcjZmZmJyxcbiAgICBib2R5U3BhY2luZzogMixcbiAgICBib2R5Rm9udDoge1xuICAgIH0sXG4gICAgYm9keUFsaWduOiAnbGVmdCcsXG4gICAgZm9vdGVyQ29sb3I6ICcjZmZmJyxcbiAgICBmb290ZXJTcGFjaW5nOiAyLFxuICAgIGZvb3Rlck1hcmdpblRvcDogNixcbiAgICBmb290ZXJGb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZvb3RlckFsaWduOiAnbGVmdCcsXG4gICAgcGFkZGluZzogNixcbiAgICBjYXJldFBhZGRpbmc6IDIsXG4gICAgY2FyZXRTaXplOiA1LFxuICAgIGNvcm5lclJhZGl1czogNixcbiAgICBib3hIZWlnaHQ6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICBib3hXaWR0aDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIG11bHRpS2V5QmFja2dyb3VuZDogJyNmZmYnLFxuICAgIGRpc3BsYXlDb2xvcnM6IHRydWUsXG4gICAgYm94UGFkZGluZzogMCxcbiAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAnY2FyZXRYJywgJ2NhcmV0WSddLFxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgfVxuICAgIH0sXG4gICAgY2FsbGJhY2tzOiBkZWZhdWx0Q2FsbGJhY2tzXG4gIH0sXG5cbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGJvZHlGb250OiAnZm9udCcsXG4gICAgZm9vdGVyRm9udDogJ2ZvbnQnLFxuICAgIHRpdGxlRm9udDogJ2ZvbnQnXG4gIH0sXG5cbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgIT09ICdpdGVtU29ydCcgJiYgbmFtZSAhPT0gJ2V4dGVybmFsJyxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBfZmFsbGJhY2s6IGZhbHNlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBfZmFsbGJhY2s6ICdhbmltYXRpb24nXG4gICAgfVxuICB9LFxuXG4gIC8vIFJlc29sdmUgYWRkaXRpb25hbGx5IGZyb20gYGludGVyYWN0aW9uYCBvcHRpb25zIGFuZCBkZWZhdWx0cy5cbiAgYWRkaXRpb25hbE9wdGlvblNjb3BlczogWydpbnRlcmFjdGlvbiddXG59O1xuIiwgImltcG9ydCBTY2FsZSBmcm9tICcuLi9jb3JlL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmLCB2YWx1ZU9yRGVmYXVsdCwgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5jb25zdCBhZGRJZlN0cmluZyA9IChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSA9PiB7XG4gIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgIGluZGV4ID0gbGFiZWxzLnB1c2gocmF3KSAtIDE7XG4gICAgYWRkZWRMYWJlbHMudW5zaGlmdCh7aW5kZXgsIGxhYmVsOiByYXd9KTtcbiAgfSBlbHNlIGlmIChpc05hTihyYXcpKSB7XG4gICAgaW5kZXggPSBudWxsO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn07XG5cbmZ1bmN0aW9uIGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpIHtcbiAgY29uc3QgZmlyc3QgPSBsYWJlbHMuaW5kZXhPZihyYXcpO1xuICBpZiAoZmlyc3QgPT09IC0xKSB7XG4gICAgcmV0dXJuIGFkZElmU3RyaW5nKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpO1xuICB9XG4gIGNvbnN0IGxhc3QgPSBsYWJlbHMubGFzdEluZGV4T2YocmF3KTtcbiAgcmV0dXJuIGZpcnN0ICE9PSBsYXN0ID8gaW5kZXggOiBmaXJzdDtcbn1cblxuY29uc3QgdmFsaWRJbmRleCA9IChpbmRleCwgbWF4KSA9PiBpbmRleCA9PT0gbnVsbCA/IG51bGwgOiBfbGltaXRWYWx1ZShNYXRoLnJvdW5kKGluZGV4KSwgMCwgbWF4KTtcblxuZnVuY3Rpb24gX2dldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcblxuICBpZiAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8IGxhYmVscy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbGFiZWxzW3ZhbHVlXTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhdGVnb3J5U2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG5cbiAgc3RhdGljIGlkID0gJ2NhdGVnb3J5JztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICB0aWNrczoge1xuICAgICAgY2FsbGJhY2s6IF9nZXRMYWJlbEZvclZhbHVlXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gIH1cblxuICBpbml0KHNjYWxlT3B0aW9ucykge1xuICAgIGNvbnN0IGFkZGVkID0gdGhpcy5fYWRkZWRMYWJlbHM7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICAgIGZvciAoY29uc3Qge2luZGV4LCBsYWJlbH0gb2YgYWRkZWQpIHtcbiAgICAgICAgaWYgKGxhYmVsc1tpbmRleF0gPT09IGxhYmVsKSB7XG4gICAgICAgICAgbGFiZWxzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gICAgfVxuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRpb25zKTtcbiAgfVxuXG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBpbmRleCA9IGlzRmluaXRlKGluZGV4KSAmJiBsYWJlbHNbaW5kZXhdID09PSByYXcgPyBpbmRleFxuICAgICAgOiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgdmFsdWVPckRlZmF1bHQoaW5kZXgsIHJhdyksIHRoaXMuX2FkZGVkTGFiZWxzKTtcbiAgICByZXR1cm4gdmFsaWRJbmRleChpbmRleCwgbGFiZWxzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IHRoaXMuZ2V0TGFiZWxzKCkubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vcHRpb25zLm9mZnNldDtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGxldCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuXG4gICAgLy8gSWYgd2UgYXJlIHZpZXdpbmcgc29tZSBzdWJzZXQgb2YgbGFiZWxzLCBzbGljZSB0aGUgb3JpZ2luYWwgYXJyYXlcbiAgICBsYWJlbHMgPSAobWluID09PSAwICYmIG1heCA9PT0gbGFiZWxzLmxlbmd0aCAtIDEpID8gbGFiZWxzIDogbGFiZWxzLnNsaWNlKG1pbiwgbWF4ICsgMSk7XG5cbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gTWF0aC5tYXgobGFiZWxzLmxlbmd0aCAtIChvZmZzZXQgPyAwIDogMSksIDEpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLm1pbiAtIChvZmZzZXQgPyAwLjUgOiAwKTtcblxuICAgIGZvciAobGV0IHZhbHVlID0gbWluOyB2YWx1ZSA8PSBtYXg7IHZhbHVlKyspIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlfSk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gX2dldExhYmVsRm9yVmFsdWUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29uZmlndXJlKCkge1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuXG4gICAgaWYgKCF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdmVydGljYWwgY2F0ZWdvcnkgc2NhbGUgcmV2ZXJzZSBpcyBpbnZlcnRlZC5cbiAgICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSAhdGhpcy5fcmV2ZXJzZVBpeGVscztcbiAgICB9XG4gIH1cblxuICAvLyBVc2VkIHRvIGdldCBkYXRhIHZhbHVlIGxvY2F0aW9ucy4gVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIC8vIE11c3Qgb3ZlcnJpZGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBiZWNhdXNlIGl0IGNhbGxzIGdldFBpeGVsRm9yVmFsdWVcbiAgLy8gYW5kIGNhdGVnb3J5IHNjYWxlIGNhbiBoYXZlIGR1cGxpY2F0ZSB2YWx1ZXNcbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3R0b207XG4gIH1cbn1cbiIsICJpbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7YWxtb3N0RXF1YWxzLCBhbG1vc3RXaG9sZSwgbmljZU51bSwgX2RlY2ltYWxQbGFjZXMsIF9zZXRNaW5BbmRNYXhCeUtleSwgc2lnbiwgdG9SYWRpYW5zfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgbGluZWFyIHRpY2tzIGZvciBhbiBheGlzXG4gKiAxLiBJZiBnZW5lcmF0aW9uT3B0aW9ucy5taW4sIGdlbmVyYXRpb25PcHRpb25zLm1heCwgYW5kIGdlbmVyYXRpb25PcHRpb25zLnN0ZXAgYXJlIGRlZmluZWQ6XG4gKiAgICBpZiAobWF4IC0gbWluKSAvIHN0ZXAgaXMgYW4gaW50ZWdlciwgdGlja3MgYXJlIGdlbmVyYXRlZCBhcyBbbWluLCBtaW4gKyBzdGVwLCAuLi4sIG1heF1cbiAqICAgIE5vdGUgdGhhdCB0aGUgZ2VuZXJhdGlvbk9wdGlvbnMubWF4Q291bnQgc2V0dGluZyBpcyByZXNwZWN0ZWQgaW4gdGhpcyBzY2VuYXJpb1xuICpcbiAqIDIuIElmIGdlbmVyYXRpb25PcHRpb25zLm1pbiwgZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCBhbmQgZ2VuZXJhdGlvbk9wdGlvbnMuY291bnQgaXMgZGVmaW5lZFxuICogICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gY291bnRcbiAqICAgIFRpY2tzIGFyZSBnZW5lcmF0ZWQgYXMgW21pbiwgbWluICsgc3BhY2luZywgLi4uLCBtYXhdXG4gKlxuICogMy4gSWYgZ2VuZXJhdGlvbk9wdGlvbnMuY291bnQgaXMgZGVmaW5lZFxuICogICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBjb3VudFxuICpcbiAqIDQuIENvbXB1dGUgb3B0aW1hbCBzcGFjaW5nIG9mIHRpY2tzIHVzaW5nIG5pY2VOdW0gYWxnb3JpdGhtXG4gKlxuICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXG4gKiBAcGFyYW0gZGF0YVJhbmdlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxuICogQHJldHVybnMge29iamVjdFtdfSBhcnJheSBvZiB0aWNrIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIC8vIFRvIGdldCBhIFwibmljZVwiIHZhbHVlIGZvciB0aGUgdGljayBzcGFjaW5nLCB3ZSB3aWxsIHVzZSB0aGUgYXBwcm9wcmlhdGVseSBuYW1lZFxuICAvLyBcIm5pY2UgbnVtYmVyXCIgYWxnb3JpdGhtLiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODUwNjg4MS9uaWNlLWxhYmVsLWFsZ29yaXRobS1mb3ItY2hhcnRzLXdpdGgtbWluaW11bS10aWNrc1xuICAvLyBmb3IgZGV0YWlscy5cblxuICBjb25zdCBNSU5fU1BBQ0lORyA9IDFlLTE0O1xuICBjb25zdCB7Ym91bmRzLCBzdGVwLCBtaW4sIG1heCwgcHJlY2lzaW9uLCBjb3VudCwgbWF4VGlja3MsIG1heERpZ2l0cywgaW5jbHVkZUJvdW5kc30gPSBnZW5lcmF0aW9uT3B0aW9ucztcbiAgY29uc3QgdW5pdCA9IHN0ZXAgfHwgMTtcbiAgY29uc3QgbWF4U3BhY2VzID0gbWF4VGlja3MgLSAxO1xuICBjb25zdCB7bWluOiBybWluLCBtYXg6IHJtYXh9ID0gZGF0YVJhbmdlO1xuICBjb25zdCBtaW5EZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWluKTtcbiAgY29uc3QgbWF4RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1heCk7XG4gIGNvbnN0IGNvdW50RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKGNvdW50KTtcbiAgY29uc3QgbWluU3BhY2luZyA9IChybWF4IC0gcm1pbikgLyAobWF4RGlnaXRzICsgMSk7XG4gIGxldCBzcGFjaW5nID0gbmljZU51bSgocm1heCAtIHJtaW4pIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICBsZXQgZmFjdG9yLCBuaWNlTWluLCBuaWNlTWF4LCBudW1TcGFjZXM7XG5cbiAgLy8gQmV5b25kIE1JTl9TUEFDSU5HIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgYmVpbmcgdG8gbG9zZSBwcmVjaXNpb25cbiAgLy8gc3VjaCB0aGF0IHdlIGNhbid0IGRvIHRoZSBtYXRoIG5lY2Vzc2FyeSB0byBnZW5lcmF0ZSB0aWNrc1xuICBpZiAoc3BhY2luZyA8IE1JTl9TUEFDSU5HICYmICFtaW5EZWZpbmVkICYmICFtYXhEZWZpbmVkKSB7XG4gICAgcmV0dXJuIFt7dmFsdWU6IHJtaW59LCB7dmFsdWU6IHJtYXh9XTtcbiAgfVxuXG4gIG51bVNwYWNlcyA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgLSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKTtcbiAgaWYgKG51bVNwYWNlcyA+IG1heFNwYWNlcykge1xuICAgIC8vIElmIHRoZSBjYWxjdWxhdGVkIG51bSBvZiBzcGFjZXMgZXhjZWVkcyBtYXhOdW1TcGFjZXMsIHJlY2FsY3VsYXRlIGl0XG4gICAgc3BhY2luZyA9IG5pY2VOdW0obnVtU3BhY2VzICogc3BhY2luZyAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgfVxuXG4gIGlmICghaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pKSB7XG4gICAgLy8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIGEgcHJlY2lzaW9uLCByb3VuZCB0byB0aGF0IG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICAgIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIH1cblxuICBpZiAoYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgbmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgICBuaWNlTWF4ID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gIH0gZWxzZSB7XG4gICAgbmljZU1pbiA9IHJtaW47XG4gICAgbmljZU1heCA9IHJtYXg7XG4gIH1cblxuICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkICYmIHN0ZXAgJiYgYWxtb3N0V2hvbGUoKG1heCAtIG1pbikgLyBzdGVwLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAvLyBDYXNlIDE6IElmIG1pbiwgbWF4IGFuZCBzdGVwU2l6ZSBhcmUgc2V0IGFuZCB0aGV5IG1ha2UgYW4gZXZlbmx5IHNwYWNlZCBzY2FsZSB1c2UgaXQuXG4gICAgLy8gc3BhY2luZyA9IHN0ZXA7XG4gICAgLy8gbnVtU3BhY2VzID0gKG1heCAtIG1pbikgLyBzcGFjaW5nO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSByb3VuZCBoZXJlIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhbG1vc3RXaG9sZSB0cmFuc2xhdGVkIGFuIEZQIGVycm9yXG4gICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChNYXRoLm1pbigobWF4IC0gbWluKSAvIHNwYWNpbmcsIG1heFRpY2tzKSk7XG4gICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gbnVtU3BhY2VzO1xuICAgIG5pY2VNaW4gPSBtaW47XG4gICAgbmljZU1heCA9IG1heDtcbiAgfSBlbHNlIGlmIChjb3VudERlZmluZWQpIHtcbiAgICAvLyBDYXNlcyAyICYgMywgd2UgaGF2ZSBhIGNvdW50IHNwZWNpZmllZC4gSGFuZGxlIG9wdGlvbmFsIHVzZXIgZGVmaW5lZCBlZGdlcyB0byB0aGUgcmFuZ2UuXG4gICAgLy8gU29tZXRpbWVzIHRoZXNlIGFyZSBuby1vcHMsIGJ1dCBpdCBtYWtlcyB0aGUgY29kZSBhIGxvdCBjbGVhcmVyXG4gICAgLy8gYW5kIHdoZW4gYSB1c2VyIGRlZmluZWQgcmFuZ2UgaXMgc3BlY2lmaWVkLCB3ZSB3YW50IHRoZSBjb3JyZWN0IHRpY2tzXG4gICAgbmljZU1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiBuaWNlTWluO1xuICAgIG5pY2VNYXggPSBtYXhEZWZpbmVkID8gbWF4IDogbmljZU1heDtcbiAgICBudW1TcGFjZXMgPSBjb3VudCAtIDE7XG4gICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBudW1TcGFjZXM7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FzZSA0XG4gICAgbnVtU3BhY2VzID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIHNwYWNpbmc7XG5cbiAgICAvLyBJZiB2ZXJ5IGNsb3NlIHRvIG91ciByb3VuZGVkIHZhbHVlLCB1c2UgaXQuXG4gICAgaWYgKGFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoZSBzcGFjaW5nIHdpbGwgaGF2ZSBjaGFuZ2VkIGluIGNhc2VzIDEsIDIsIGFuZCAzIHNvIHRoZSBmYWN0b3IgY2Fubm90IGJlIGNvbXB1dGVkXG4gIC8vIHVudGlsIHRoaXMgcG9pbnRcbiAgY29uc3QgZGVjaW1hbFBsYWNlcyA9IE1hdGgubWF4KFxuICAgIF9kZWNpbWFsUGxhY2VzKHNwYWNpbmcpLFxuICAgIF9kZWNpbWFsUGxhY2VzKG5pY2VNaW4pXG4gICk7XG4gIGZhY3RvciA9IE1hdGgucG93KDEwLCBpc051bGxPclVuZGVmKHByZWNpc2lvbikgPyBkZWNpbWFsUGxhY2VzIDogcHJlY2lzaW9uKTtcbiAgbmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIG5pY2VNYXggPSBNYXRoLnJvdW5kKG5pY2VNYXggKiBmYWN0b3IpIC8gZmFjdG9yO1xuXG4gIGxldCBqID0gMDtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBpZiAoaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWluICE9PSBtaW4pIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtaW59KTtcblxuICAgICAgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgICAgaisrOyAvLyBTa2lwIG5pY2VNaW5cbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBuZXh0IG5pY2UgdGljayBpcyBjbG9zZSB0byBtaW4sIHNraXAgaXRcbiAgICAgIGlmIChhbG1vc3RFcXVhbHMoTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3IsIG1pbiwgcmVsYXRpdmVMYWJlbFNpemUobWluLCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgIGorKztcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG51bVNwYWNlczsgKytqKSB7XG4gICAgY29uc3QgdGlja1ZhbHVlID0gTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3I7XG4gICAgaWYgKG1heERlZmluZWQgJiYgdGlja1ZhbHVlID4gbWF4KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IHRpY2tWYWx1ZX0pO1xuICB9XG5cbiAgaWYgKG1heERlZmluZWQgJiYgaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWF4ICE9PSBtYXgpIHtcbiAgICAvLyBJZiB0aGUgcHJldmlvdXMgdGljayBpcyB0b28gY2xvc2UgdG8gbWF4LCByZXBsYWNlIGl0IHdpdGggbWF4LCBlbHNlIGFkZCBtYXhcbiAgICBpZiAodGlja3MubGVuZ3RoICYmIGFsbW9zdEVxdWFscyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSwgbWF4LCByZWxhdGl2ZUxhYmVsU2l6ZShtYXgsIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlID0gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWF4fSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFtYXhEZWZpbmVkIHx8IG5pY2VNYXggPT09IG1heCkge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBuaWNlTWF4fSk7XG4gIH1cblxuICByZXR1cm4gdGlja3M7XG59XG5cbmZ1bmN0aW9uIHJlbGF0aXZlTGFiZWxTaXplKHZhbHVlLCBtaW5TcGFjaW5nLCB7aG9yaXpvbnRhbCwgbWluUm90YXRpb259KSB7XG4gIGNvbnN0IHJhZCA9IHRvUmFkaWFucyhtaW5Sb3RhdGlvbik7XG4gIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihyYWQpIDogTWF0aC5jb3MocmFkKSkgfHwgMC4wMDE7XG4gIGNvbnN0IGxlbmd0aCA9IDAuNzUgKiBtaW5TcGFjaW5nICogKCcnICsgdmFsdWUpLmxlbmd0aDtcbiAgcmV0dXJuIE1hdGgubWluKG1pblNwYWNpbmcgLyByYXRpbywgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZWFyU2NhbGVCYXNlIGV4dGVuZHMgU2NhbGUge1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fZW5kVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cblxuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2YgcmF3ID09PSAnbnVtYmVyJyB8fCByYXcgaW5zdGFuY2VvZiBOdW1iZXIpICYmICFpc0Zpbml0ZSgrcmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuICtyYXc7XG4gIH1cblxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVyb30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzO1xuXG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcblxuICAgIGlmIChiZWdpbkF0WmVybykge1xuICAgICAgY29uc3QgbWluU2lnbiA9IHNpZ24obWluKTtcbiAgICAgIGNvbnN0IG1heFNpZ24gPSBzaWduKG1heCk7XG5cbiAgICAgIGlmIChtaW5TaWduIDwgMCAmJiBtYXhTaWduIDwgMCkge1xuICAgICAgICBzZXRNYXgoMCk7XG4gICAgICB9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG4gICAgICAgIHNldE1pbigwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGxldCBvZmZzZXQgPSBtYXggPT09IDAgPyAxIDogTWF0aC5hYnMobWF4ICogMC4wNSk7XG5cbiAgICAgIHNldE1heChtYXggKyBvZmZzZXQpO1xuXG4gICAgICBpZiAoIWJlZ2luQXRaZXJvKSB7XG4gICAgICAgIHNldE1pbihtaW4gLSBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIGdldFRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHttYXhUaWNrc0xpbWl0LCBzdGVwU2l6ZX0gPSB0aWNrT3B0cztcbiAgICBsZXQgbWF4VGlja3M7XG5cbiAgICBpZiAoc3RlcFNpemUpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5jZWlsKHRoaXMubWF4IC8gc3RlcFNpemUpIC0gTWF0aC5mbG9vcih0aGlzLm1pbiAvIHN0ZXBTaXplKSArIDE7XG4gICAgICBpZiAobWF4VGlja3MgPiAxMDAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihgc2NhbGVzLiR7dGhpcy5pZH0udGlja3Muc3RlcFNpemU6ICR7c3RlcFNpemV9IHdvdWxkIHJlc3VsdCBnZW5lcmF0aW5nIHVwIHRvICR7bWF4VGlja3N9IHRpY2tzLiBMaW1pdGluZyB0byAxMDAwLmApO1xuICAgICAgICBtYXhUaWNrcyA9IDEwMDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFRpY2tzID0gdGhpcy5jb21wdXRlVGlja0xpbWl0KCk7XG4gICAgICBtYXhUaWNrc0xpbWl0ID0gbWF4VGlja3NMaW1pdCB8fCAxMTtcbiAgICB9XG5cbiAgICBpZiAobWF4VGlja3NMaW1pdCkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heFRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfVxuXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cbiAgICAvLyBGaWd1cmUgb3V0IHdoYXQgdGhlIG1heCBudW1iZXIgb2YgdGlja3Mgd2UgY2FuIHN1cHBvcnQgaXQgaXMgYmFzZWQgb24gdGhlIHNpemUgb2ZcbiAgICAvLyB0aGUgYXhpcyBhcmVhLiBGb3Igbm93LCB3ZSBzYXkgdGhhdCB0aGUgbWluaW11bSB0aWNrIHNwYWNpbmcgaW4gcGl4ZWxzIG11c3QgYmUgNDBcbiAgICAvLyBXZSBhbHNvIGxpbWl0IHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyB0byAxMSB3aGljaCBnaXZlcyBhIG5pY2UgMTAgc3F1YXJlcyBvblxuICAgIC8vIHRoZSBncmFwaC4gTWFrZSBzdXJlIHdlIGFsd2F5cyBoYXZlIGF0IGxlYXN0IDIgdGlja3NcbiAgICBsZXQgbWF4VGlja3MgPSB0aGlzLmdldFRpY2tMaW1pdCgpO1xuICAgIG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuXG4gICAgY29uc3QgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XG4gICAgICBtYXhUaWNrcyxcbiAgICAgIGJvdW5kczogb3B0cy5ib3VuZHMsXG4gICAgICBtaW46IG9wdHMubWluLFxuICAgICAgbWF4OiBvcHRzLm1heCxcbiAgICAgIHByZWNpc2lvbjogdGlja09wdHMucHJlY2lzaW9uLFxuICAgICAgc3RlcDogdGlja09wdHMuc3RlcFNpemUsXG4gICAgICBjb3VudDogdGlja09wdHMuY291bnQsXG4gICAgICBtYXhEaWdpdHM6IHRoaXMuX21heERpZ2l0cygpLFxuICAgICAgaG9yaXpvbnRhbDogdGhpcy5pc0hvcml6b250YWwoKSxcbiAgICAgIG1pblJvdGF0aW9uOiB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwLFxuICAgICAgaW5jbHVkZUJvdW5kczogdGlja09wdHMuaW5jbHVkZUJvdW5kcyAhPT0gZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGRhdGFSYW5nZSA9IHRoaXMuX3JhbmdlIHx8IHRoaXM7XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKG51bWVyaWNHZW5lcmF0b3JPcHRpb25zLCBkYXRhUmFuZ2UpO1xuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyxcbiAgICAvLyBzaW5jZSB3ZSBwcm9iYWJseSBoYXZlIGV4cGFuZGVkIHRoZSByYW5nZSBvZiB0aGUgc2NhbGVcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuXG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cblxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGxldCBzdGFydCA9IHRoaXMubWluO1xuICAgIGxldCBlbmQgPSB0aGlzLm1heDtcblxuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSAoZW5kIC0gc3RhcnQpIC8gTWF0aC5tYXgodGlja3MubGVuZ3RoIC0gMSwgMSkgLyAyO1xuICAgICAgc3RhcnQgLT0gb2Zmc2V0O1xuICAgICAgZW5kICs9IG9mZnNldDtcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHN0YXJ0O1xuICAgIHRoaXMuX2VuZFZhbHVlID0gZW5kO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBlbmQgLSBzdGFydDtcbiAgfVxuXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxufVxuIiwgImltcG9ydCB7aXNGaW5pdGV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCBMaW5lYXJTY2FsZUJhc2UgZnJvbSAnLi9zY2FsZS5saW5lYXJiYXNlLmpzJztcbmltcG9ydCBUaWNrcyBmcm9tICcuLi9jb3JlL2NvcmUudGlja3MuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnN9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG5cbiAgc3RhdGljIGlkID0gJ2xpbmVhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgdGlja3M6IHtcbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgICB9XG4gIH07XG5cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcblxuICAgIHRoaXMubWluID0gaXNGaW5pdGUobWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc0Zpbml0ZShtYXgpID8gbWF4IDogMTtcblxuICAgIC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSBtaW4sIG1heCwgYmVnaW5BdFplcm9cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyBiYXNlZCBvbiB0aGUgc2NhbGUgZGltZW5zaW9uXG5cdCAqIEBwcm90ZWN0ZWRcbiBcdCAqL1xuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhvcml6b250YWwgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0b1JhZGlhbnModGhpcy5vcHRpb25zLnRpY2tzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4obWluUm90YXRpb24pIDogTWF0aC5jb3MobWluUm90YXRpb24pKSB8fCAwLjAwMTtcbiAgICBjb25zdCB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCk7XG4gICAgcmV0dXJuIE1hdGguY2VpbChsZW5ndGggLyBNYXRoLm1pbig0MCwgdGlja0ZvbnQubGluZUhlaWdodCAvIHJhdGlvKSk7XG4gIH1cblxuICAvLyBVdGlsc1xuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2U7XG4gIH1cbn1cbiIsICJpbXBvcnQge2Zpbml0ZU9yRGVmYXVsdCwgaXNGaW5pdGV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5pbXBvcnQge19zZXRNaW5BbmRNYXhCeUtleSwgbG9nMTB9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCBTY2FsZSBmcm9tICcuLi9jb3JlL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IExpbmVhclNjYWxlQmFzZSBmcm9tICcuL3NjYWxlLmxpbmVhcmJhc2UuanMnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL2NvcmUvY29yZS50aWNrcy5qcyc7XG5cbmNvbnN0IGxvZzEwRmxvb3IgPSB2ID0+IE1hdGguZmxvb3IobG9nMTAodikpO1xuY29uc3QgY2hhbmdlRXhwb25lbnQgPSAodiwgbSkgPT4gTWF0aC5wb3coMTAsIGxvZzEwRmxvb3IodikgKyBtKTtcblxuZnVuY3Rpb24gaXNNYWpvcih0aWNrVmFsKSB7XG4gIGNvbnN0IHJlbWFpbiA9IHRpY2tWYWwgLyAoTWF0aC5wb3coMTAsIGxvZzEwRmxvb3IodGlja1ZhbCkpKTtcbiAgcmV0dXJuIHJlbWFpbiA9PT0gMTtcbn1cblxuZnVuY3Rpb24gc3RlcHMobWluLCBtYXgsIHJhbmdlRXhwKSB7XG4gIGNvbnN0IHJhbmdlU3RlcCA9IE1hdGgucG93KDEwLCByYW5nZUV4cCk7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5mbG9vcihtaW4gLyByYW5nZVN0ZXApO1xuICBjb25zdCBlbmQgPSBNYXRoLmNlaWwobWF4IC8gcmFuZ2VTdGVwKTtcbiAgcmV0dXJuIGVuZCAtIHN0YXJ0O1xufVxuXG5mdW5jdGlvbiBzdGFydEV4cChtaW4sIG1heCkge1xuICBjb25zdCByYW5nZSA9IG1heCAtIG1pbjtcbiAgbGV0IHJhbmdlRXhwID0gbG9nMTBGbG9vcihyYW5nZSk7XG4gIHdoaWxlIChzdGVwcyhtaW4sIG1heCwgcmFuZ2VFeHApID4gMTApIHtcbiAgICByYW5nZUV4cCsrO1xuICB9XG4gIHdoaWxlIChzdGVwcyhtaW4sIG1heCwgcmFuZ2VFeHApIDwgMTApIHtcbiAgICByYW5nZUV4cC0tO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihyYW5nZUV4cCwgbG9nMTBGbG9vcihtaW4pKTtcbn1cblxuXG4vKipcbiAqIEdlbmVyYXRlIGEgc2V0IG9mIGxvZ2FyaXRobWljIHRpY2tzXG4gKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGlja3NcbiAqIEBwYXJhbSBkYXRhUmFuZ2UgdGhlIHJhbmdlIG9mIHRoZSBkYXRhXG4gKiBAcmV0dXJucyB7b2JqZWN0W119IGFycmF5IG9mIHRpY2sgb2JqZWN0c1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCB7bWluLCBtYXh9KSB7XG4gIG1pbiA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5taW4sIG1pbik7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGNvbnN0IG1pbkV4cCA9IGxvZzEwRmxvb3IobWluKTtcbiAgbGV0IGV4cCA9IHN0YXJ0RXhwKG1pbiwgbWF4KTtcbiAgbGV0IHByZWNpc2lvbiA9IGV4cCA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMoZXhwKSkgOiAxO1xuICBjb25zdCBzdGVwU2l6ZSA9IE1hdGgucG93KDEwLCBleHApO1xuICBjb25zdCBiYXNlID0gbWluRXhwID4gZXhwID8gTWF0aC5wb3coMTAsIG1pbkV4cCkgOiAwO1xuICBjb25zdCBzdGFydCA9IE1hdGgucm91bmQoKG1pbiAtIGJhc2UpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5mbG9vcigobWluIC0gYmFzZSkgLyBzdGVwU2l6ZSAvIDEwKSAqIHN0ZXBTaXplICogMTA7XG4gIGxldCBzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IoKHN0YXJ0IC0gb2Zmc2V0KSAvIE1hdGgucG93KDEwLCBleHApKTtcbiAgbGV0IHZhbHVlID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1pbiwgTWF0aC5yb3VuZCgoYmFzZSArIG9mZnNldCArIHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbik7XG4gIHdoaWxlICh2YWx1ZSA8IG1heCkge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlLCBtYWpvcjogaXNNYWpvcih2YWx1ZSksIHNpZ25pZmljYW5kfSk7XG4gICAgaWYgKHNpZ25pZmljYW5kID49IDEwKSB7XG4gICAgICBzaWduaWZpY2FuZCA9IHNpZ25pZmljYW5kIDwgMTUgPyAxNSA6IDIwO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaWduaWZpY2FuZCsrO1xuICAgIH1cbiAgICBpZiAoc2lnbmlmaWNhbmQgPj0gMjApIHtcbiAgICAgIGV4cCsrO1xuICAgICAgc2lnbmlmaWNhbmQgPSAyO1xuICAgICAgcHJlY2lzaW9uID0gZXhwID49IDAgPyAxIDogcHJlY2lzaW9uO1xuICAgIH1cbiAgICB2YWx1ZSA9IE1hdGgucm91bmQoKGJhc2UgKyBvZmZzZXQgKyBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIH1cbiAgY29uc3QgbGFzdFRpY2sgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCB2YWx1ZSk7XG4gIHRpY2tzLnB1c2goe3ZhbHVlOiBsYXN0VGljaywgbWFqb3I6IGlzTWFqb3IobGFzdFRpY2spLCBzaWduaWZpY2FuZH0pO1xuXG4gIHJldHVybiB0aWNrcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9nYXJpdGhtaWNTY2FsZSBleHRlbmRzIFNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAnbG9nYXJpdGhtaWMnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIHRpY2tzOiB7XG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pYyxcbiAgICAgIG1ham9yOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG5cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGNvbnN0IHZhbHVlID0gTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5wYXJzZS5hcHBseSh0aGlzLCBbcmF3LCBpbmRleF0pO1xuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpICYmIHZhbHVlID4gMCA/IHZhbHVlIDogbnVsbDtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuXG4gICAgdGhpcy5taW4gPSBpc0Zpbml0ZShtaW4pID8gTWF0aC5tYXgoMCwgbWluKSA6IG51bGw7XG4gICAgdGhpcy5tYXggPSBpc0Zpbml0ZShtYXgpID8gTWF0aC5tYXgoMCwgbWF4KSA6IG51bGw7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmJlZ2luQXRaZXJvKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBpZiBkYXRhIGhhcyBgMGAgaW4gaXQgb3IgYGJlZ2luQXRaZXJvYCBpcyB0cnVlLCBtaW4gKG5vbiB6ZXJvKSB2YWx1ZSBpcyBhdCBib3R0b21cbiAgICAvLyBvZiBzY2FsZSwgYW5kIGl0IGRvZXMgbm90IGVxdWFsIHN1Z2dlc3RlZE1pbiwgbG93ZXIgdGhlIG1pbiBib3VuZCBieSBvbmUgZXhwLlxuICAgIGlmICh0aGlzLl96ZXJvICYmIHRoaXMubWluICE9PSB0aGlzLl9zdWdnZXN0ZWRNaW4gJiYgIWlzRmluaXRlKHRoaXMuX3VzZXJNaW4pKSB7XG4gICAgICB0aGlzLm1pbiA9IG1pbiA9PT0gY2hhbmdlRXhwb25lbnQodGhpcy5taW4sIDApID8gY2hhbmdlRXhwb25lbnQodGhpcy5taW4sIC0xKSA6IGNoYW5nZUV4cG9uZW50KHRoaXMubWluLCAwKTtcbiAgICB9XG5cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuXG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IG1pbiA9IHRoaXMubWluO1xuICAgIGxldCBtYXggPSB0aGlzLm1heDtcblxuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG5cbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGlmIChtaW4gPD0gMCkgeyAvLyBpbmNsdWRlcyBudWxsXG4gICAgICAgIHNldE1pbigxKTtcbiAgICAgICAgc2V0TWF4KDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE1pbihjaGFuZ2VFeHBvbmVudChtaW4sIC0xKSk7XG4gICAgICAgIHNldE1heChjaGFuZ2VFeHBvbmVudChtYXgsICsxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaW4gPD0gMCkge1xuICAgICAgc2V0TWluKGNoYW5nZUV4cG9uZW50KG1heCwgLTEpKTtcbiAgICB9XG4gICAgaWYgKG1heCA8PSAwKSB7XG5cbiAgICAgIHNldE1heChjaGFuZ2VFeHBvbmVudChtaW4sICsxKSk7XG4gICAgfVxuXG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cblxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBjb25zdCBnZW5lcmF0aW9uT3B0aW9ucyA9IHtcbiAgICAgIG1pbjogdGhpcy5fdXNlck1pbixcbiAgICAgIG1heDogdGhpcy5fdXNlck1heFxuICAgIH07XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCB0aGlzKTtcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBtYXggYW5kIG1pbiBnaXZlbiB0aGUgdGljayB2YWx1ZXMsXG4gICAgLy8gc2luY2Ugd2UgcHJvYmFibHkgaGF2ZSBleHBhbmRlZCB0aGUgcmFuZ2Ugb2YgdGhlIHNjYWxlXG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcblxuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWF4O1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgPyAnMCdcbiAgICAgIDogZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLm1pbjtcblxuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IGxvZzEwKHN0YXJ0KTtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gbG9nMTAodGhpcy5tYXgpIC0gbG9nMTAoc3RhcnQpO1xuICB9XG5cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMubWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwodmFsdWUgPT09IHRoaXMubWluXG4gICAgICA/IDBcbiAgICAgIDogKGxvZzEwKHZhbHVlKSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cblxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKTtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXJ0VmFsdWUgKyBkZWNpbWFsICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7X2xvbmdlc3RUZXh0LCBhZGRSb3VuZGVkUmVjdFBhdGgsIHJlbmRlclRleHQsIF9pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7SEFMRl9QSSwgVEFVLCB0b0RlZ3JlZXMsIHRvUmFkaWFucywgX25vcm1hbGl6ZUFuZ2xlLCBQSX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IExpbmVhclNjYWxlQmFzZSBmcm9tICcuL3NjYWxlLmxpbmVhcmJhc2UuanMnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL2NvcmUvY29yZS50aWNrcy5qcyc7XG5pbXBvcnQge3ZhbHVlT3JEZWZhdWx0LCBpc0FycmF5LCBpc0Zpbml0ZSwgY2FsbGJhY2sgYXMgY2FsbENhbGxiYWNrLCBpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIHRvRm9udCwgdG9QYWRkaW5nLCB0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbmZ1bmN0aW9uIGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuICBpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZyk7XG4gICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZvbnQgJiYgdGlja09wdHMuZm9udC5zaXplLCBkZWZhdWx0cy5mb250LnNpemUpICsgcGFkZGluZy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIG1lYXN1cmVMYWJlbFNpemUoY3R4LCBmb250LCBsYWJlbCkge1xuICBsYWJlbCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwgOiBbbGFiZWxdO1xuICByZXR1cm4ge1xuICAgIHc6IF9sb25nZXN0VGV4dChjdHgsIGZvbnQuc3RyaW5nLCBsYWJlbCksXG4gICAgaDogbGFiZWwubGVuZ3RoICogZm9udC5saW5lSGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9zLCBzaXplLCBtaW4sIG1heCkge1xuICBpZiAoYW5nbGUgPT09IG1pbiB8fCBhbmdsZSA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSAoc2l6ZSAvIDIpLFxuICAgICAgZW5kOiBwb3MgKyAoc2l6ZSAvIDIpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChhbmdsZSA8IG1pbiB8fCBhbmdsZSA+IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gc2l6ZSxcbiAgICAgIGVuZDogcG9zXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHBvcyxcbiAgICBlbmQ6IHBvcyArIHNpemVcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZml0IGEgcmFkaWFsIGxpbmVhciBzY2FsZSB3aXRoIHBvaW50IGxhYmVsc1xuICovXG5mdW5jdGlvbiBmaXRXaXRoUG9pbnRMYWJlbHMoc2NhbGUpIHtcblxuICAvLyBSaWdodCwgdGhpcyBpcyByZWFsbHkgY29uZnVzaW5nIGFuZCB0aGVyZSBpcyBhIGxvdCBvZiBtYXRocyBnb2luZyBvbiBoZXJlXG4gIC8vIFRoZSBnaXN0IG9mIHRoZSBwcm9ibGVtIGlzIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL25ubmljay82OTZjYzljNTVmNGIwYmViOGZlOVxuICAvL1xuICAvLyBSZWFjdGlvbjogaHR0cHM6Ly9kbC5kcm9wYm94dXNlcmNvbnRlbnQuY29tL3UvMzQ2MDEzNjMvdG9vbXVjaHNjaWVuY2UuZ2lmXG4gIC8vXG4gIC8vIFNvbHV0aW9uOlxuICAvL1xuICAvLyBXZSBhc3N1bWUgdGhlIHJhZGl1cyBvZiB0aGUgcG9seWdvbiBpcyBoYWxmIHRoZSBzaXplIG9mIHRoZSBjYW52YXMgYXQgZmlyc3RcbiAgLy8gYXQgZWFjaCBpbmRleCB3ZSBjaGVjayBpZiB0aGUgdGV4dCBvdmVybGFwcy5cbiAgLy9cbiAgLy8gV2hlcmUgaXQgZG9lcywgd2Ugc3RvcmUgdGhhdCBhbmdsZSBhbmQgdGhhdCBpbmRleC5cbiAgLy9cbiAgLy8gQWZ0ZXIgZmluZGluZyB0aGUgbGFyZ2VzdCBpbmRleCBhbmQgYW5nbGUgd2UgY2FsY3VsYXRlIGhvdyBtdWNoIHdlIG5lZWQgdG8gcmVtb3ZlXG4gIC8vIGZyb20gdGhlIHNoYXBlIHJhZGl1cyB0byBtb3ZlIHRoZSBwb2ludCBpbndhcmRzIGJ5IHRoYXQgeC5cbiAgLy9cbiAgLy8gV2UgYXZlcmFnZSB0aGUgbGVmdCBhbmQgcmlnaHQgZGlzdGFuY2VzIHRvIGdldCB0aGUgbWF4aW11bSBzaGFwZSByYWRpdXMgdGhhdCBjYW4gZml0IGluIHRoZSBib3hcbiAgLy8gYWxvbmcgd2l0aCBsYWJlbHMuXG4gIC8vXG4gIC8vIE9uY2Ugd2UgaGF2ZSB0aGF0LCB3ZSBjYW4gZmluZCB0aGUgY2VudHJlIHBvaW50IGZvciB0aGUgY2hhcnQsIGJ5IHRha2luZyB0aGUgeCB0ZXh0IHByb3RydXNpb25cbiAgLy8gb24gZWFjaCBzaWRlLCByZW1vdmluZyB0aGF0IGZyb20gdGhlIHNpemUsIGhhbHZpbmcgaXQgYW5kIGFkZGluZyB0aGUgbGVmdCB4IHByb3RydXNpb24gd2lkdGguXG4gIC8vXG4gIC8vIFRoaXMgd2lsbCBtZWFuIHdlIGhhdmUgYSBzaGFwZSBmaXR0ZWQgdG8gdGhlIGNhbnZhcywgYXMgbGFyZ2UgYXMgaXQgY2FuIGJlIHdpdGggdGhlIGxhYmVsc1xuICAvLyBhbmQgcG9zaXRpb24gaXQgaW4gdGhlIG1vc3Qgc3BhY2UgZWZmaWNpZW50IG1hbm5lclxuICAvL1xuICAvLyBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My95ZWFoc2NpZW5jZS5naWZcblxuICAvLyBHZXQgbWF4aW11bSByYWRpdXMgb2YgdGhlIHBvbHlnb24uIEVpdGhlciBoYWxmIHRoZSBoZWlnaHQgKG1pbnVzIHRoZSB0ZXh0IHdpZHRoKSBvciBoYWxmIHRoZSB3aWR0aC5cbiAgLy8gVXNlIHRoaXMgdG8gY2FsY3VsYXRlIHRoZSBvZmZzZXQgKyBjaGFuZ2UuIC0gTWFrZSBzdXJlIEwvUiBwcm90cnVzaW9uIGlzIGF0IGxlYXN0IDAgdG8gc3RvcCBpc3N1ZXMgd2l0aCBjZW50cmUgcG9pbnRzXG4gIGNvbnN0IG9yaWcgPSB7XG4gICAgbDogc2NhbGUubGVmdCArIHNjYWxlLl9wYWRkaW5nLmxlZnQsXG4gICAgcjogc2NhbGUucmlnaHQgLSBzY2FsZS5fcGFkZGluZy5yaWdodCxcbiAgICB0OiBzY2FsZS50b3AgKyBzY2FsZS5fcGFkZGluZy50b3AsXG4gICAgYjogc2NhbGUuYm90dG9tIC0gc2NhbGUuX3BhZGRpbmcuYm90dG9tXG4gIH07XG4gIGNvbnN0IGxpbWl0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWcpO1xuICBjb25zdCBsYWJlbFNpemVzID0gW107XG4gIGNvbnN0IHBhZGRpbmcgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IHBvaW50TGFiZWxPcHRzID0gc2NhbGUub3B0aW9ucy5wb2ludExhYmVscztcbiAgY29uc3QgYWRkaXRpb25hbEFuZ2xlID0gcG9pbnRMYWJlbE9wdHMuY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgY29uc3Qgb3B0cyA9IHBvaW50TGFiZWxPcHRzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIHBhZGRpbmdbaV0gPSBvcHRzLnBhZGRpbmc7XG4gICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgc2NhbGUuZHJhd2luZ0FyZWEgKyBwYWRkaW5nW2ldLCBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShzY2FsZS5jdHgsIHBsRm9udCwgc2NhbGUuX3BvaW50TGFiZWxzW2ldKTtcbiAgICBsYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG5cbiAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSBfbm9ybWFsaXplQW5nbGUoc2NhbGUuZ2V0SW5kZXhBbmdsZShpKSArIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhhbmdsZVJhZGlhbnMpKTtcbiAgICBjb25zdCBoTGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLngsIHRleHRTaXplLncsIDAsIDE4MCk7XG4gICAgY29uc3QgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcbiAgICB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZVJhZGlhbnMsIGhMaW1pdHMsIHZMaW1pdHMpO1xuICB9XG5cbiAgc2NhbGUuc2V0Q2VudGVyUG9pbnQoXG4gICAgb3JpZy5sIC0gbGltaXRzLmwsXG4gICAgbGltaXRzLnIgLSBvcmlnLnIsXG4gICAgb3JpZy50IC0gbGltaXRzLnQsXG4gICAgbGltaXRzLmIgLSBvcmlnLmJcbiAgKTtcblxuICAvLyBOb3cgdGhhdCB0ZXh0IHNpemUgaXMgZGV0ZXJtaW5lZCwgY29tcHV0ZSB0aGUgZnVsbCBwb3NpdGlvbnNcbiAgc2NhbGUuX3BvaW50TGFiZWxJdGVtcyA9IGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGUsIGhMaW1pdHMsIHZMaW1pdHMpIHtcbiAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4oYW5nbGUpKTtcbiAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpKTtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmIChoTGltaXRzLnN0YXJ0IDwgb3JpZy5sKSB7XG4gICAgeCA9IChvcmlnLmwgLSBoTGltaXRzLnN0YXJ0KSAvIHNpbjtcbiAgICBsaW1pdHMubCA9IE1hdGgubWluKGxpbWl0cy5sLCBvcmlnLmwgLSB4KTtcbiAgfSBlbHNlIGlmIChoTGltaXRzLmVuZCA+IG9yaWcucikge1xuICAgIHggPSAoaExpbWl0cy5lbmQgLSBvcmlnLnIpIC8gc2luO1xuICAgIGxpbWl0cy5yID0gTWF0aC5tYXgobGltaXRzLnIsIG9yaWcuciArIHgpO1xuICB9XG4gIGlmICh2TGltaXRzLnN0YXJ0IDwgb3JpZy50KSB7XG4gICAgeSA9IChvcmlnLnQgLSB2TGltaXRzLnN0YXJ0KSAvIGNvcztcbiAgICBsaW1pdHMudCA9IE1hdGgubWluKGxpbWl0cy50LCBvcmlnLnQgLSB5KTtcbiAgfSBlbHNlIGlmICh2TGltaXRzLmVuZCA+IG9yaWcuYikge1xuICAgIHkgPSAodkxpbWl0cy5lbmQgLSBvcmlnLmIpIC8gY29zO1xuICAgIGxpbWl0cy5iID0gTWF0aC5tYXgobGltaXRzLmIsIG9yaWcuYiArIHkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxJdGVtKHNjYWxlLCBpbmRleCwgaXRlbU9wdHMpIHtcbiAgY29uc3Qgb3V0ZXJEaXN0YW5jZSA9IHNjYWxlLmRyYXdpbmdBcmVhO1xuICBjb25zdCB7ZXh0cmEsIGFkZGl0aW9uYWxBbmdsZSwgcGFkZGluZywgc2l6ZX0gPSBpdGVtT3B0cztcbiAgY29uc3QgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgb3V0ZXJEaXN0YW5jZSArIGV4dHJhICsgcGFkZGluZywgYWRkaXRpb25hbEFuZ2xlKTtcbiAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhfbm9ybWFsaXplQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLmFuZ2xlICsgSEFMRl9QSSkpKTtcbiAgY29uc3QgeSA9IHlGb3JBbmdsZShwb2ludExhYmVsUG9zaXRpb24ueSwgc2l6ZS5oLCBhbmdsZSk7XG4gIGNvbnN0IHRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcbiAgY29uc3QgbGVmdCA9IGxlZnRGb3JUZXh0QWxpZ24ocG9pbnRMYWJlbFBvc2l0aW9uLngsIHNpemUudywgdGV4dEFsaWduKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBpZiB0byBkcmF3IG9yIG92ZXJsYXBwZWRcbiAgICB2aXNpYmxlOiB0cnVlLFxuXG4gICAgLy8gVGV4dCBwb3NpdGlvblxuICAgIHg6IHBvaW50TGFiZWxQb3NpdGlvbi54LFxuICAgIHksXG5cbiAgICAvLyBUZXh0IHJlbmRlcmluZyBkYXRhXG4gICAgdGV4dEFsaWduLFxuXG4gICAgLy8gQm91bmRpbmcgYm94XG4gICAgbGVmdCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IGxlZnQgKyBzaXplLncsXG4gICAgYm90dG9tOiB5ICsgc2l6ZS5oXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzTm90T3ZlcmxhcHBlZChpdGVtLCBhcmVhKSB7XG4gIGlmICghYXJlYSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gaXRlbTtcbiAgY29uc3QgYXBleGVzSW5BcmVhID0gX2lzUG9pbnRJbkFyZWEoe3g6IGxlZnQsIHk6IHRvcH0sIGFyZWEpIHx8IF9pc1BvaW50SW5BcmVhKHt4OiBsZWZ0LCB5OiBib3R0b219LCBhcmVhKSB8fFxuICAgIF9pc1BvaW50SW5BcmVhKHt4OiByaWdodCwgeTogdG9wfSwgYXJlYSkgfHwgX2lzUG9pbnRJbkFyZWEoe3g6IHJpZ2h0LCB5OiBib3R0b219LCBhcmVhKTtcbiAgcmV0dXJuICFhcGV4ZXNJbkFyZWE7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICBjb25zdCBvcHRzID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3Qge2NlbnRlclBvaW50TGFiZWxzLCBkaXNwbGF5fSA9IG9wdHMucG9pbnRMYWJlbHM7XG4gIGNvbnN0IGl0ZW1PcHRzID0ge1xuICAgIGV4dHJhOiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykgLyAyLFxuICAgIGFkZGl0aW9uYWxBbmdsZTogY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwXG4gIH07XG4gIGxldCBhcmVhO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgaXRlbU9wdHMucGFkZGluZyA9IHBhZGRpbmdbaV07XG4gICAgaXRlbU9wdHMuc2l6ZSA9IGxhYmVsU2l6ZXNbaV07XG5cbiAgICBjb25zdCBpdGVtID0gY3JlYXRlUG9pbnRMYWJlbEl0ZW0oc2NhbGUsIGksIGl0ZW1PcHRzKTtcbiAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgIGlmIChkaXNwbGF5ID09PSAnYXV0bycpIHtcbiAgICAgIGl0ZW0udmlzaWJsZSA9IGlzTm90T3ZlcmxhcHBlZChpdGVtLCBhcmVhKTtcbiAgICAgIGlmIChpdGVtLnZpc2libGUpIHtcbiAgICAgICAgYXJlYSA9IGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtcztcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSAwIHx8IGFuZ2xlID09PSAxODApIHtcbiAgICByZXR1cm4gJ2NlbnRlcic7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPCAxODApIHtcbiAgICByZXR1cm4gJ2xlZnQnO1xuICB9XG5cbiAgcmV0dXJuICdyaWdodCc7XG59XG5cbmZ1bmN0aW9uIGxlZnRGb3JUZXh0QWxpZ24oeCwgdywgYWxpZ24pIHtcbiAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3O1xuICB9IGVsc2UgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHcgLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24geUZvckFuZ2xlKHksIGgsIGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gOTAgfHwgYW5nbGUgPT09IDI3MCkge1xuICAgIHkgLT0gKGggLyAyKTtcbiAgfSBlbHNlIGlmIChhbmdsZSA+IDI3MCB8fCBhbmdsZSA8IDkwKSB7XG4gICAgeSAtPSBoO1xuICB9XG4gIHJldHVybiB5O1xufVxuXG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbEJveChjdHgsIG9wdHMsIGl0ZW0pIHtcbiAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBpdGVtO1xuICBjb25zdCB7YmFja2Ryb3BDb2xvcn0gPSBvcHRzO1xuXG4gIGlmICghaXNOdWxsT3JVbmRlZihiYWNrZHJvcENvbG9yKSkge1xuICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMob3B0cy5ib3JkZXJSYWRpdXMpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZHJvcENvbG9yO1xuXG4gICAgY29uc3QgYmFja2Ryb3BMZWZ0ID0gbGVmdCAtIHBhZGRpbmcubGVmdDtcbiAgICBjb25zdCBiYWNrZHJvcFRvcCA9IHRvcCAtIHBhZGRpbmcudG9wO1xuICAgIGNvbnN0IGJhY2tkcm9wV2lkdGggPSByaWdodCAtIGxlZnQgKyBwYWRkaW5nLndpZHRoO1xuICAgIGNvbnN0IGJhY2tkcm9wSGVpZ2h0ID0gYm90dG9tIC0gdG9wICsgcGFkZGluZy5oZWlnaHQ7XG5cbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICB4OiBiYWNrZHJvcExlZnQsXG4gICAgICAgIHk6IGJhY2tkcm9wVG9wLFxuICAgICAgICB3OiBiYWNrZHJvcFdpZHRoLFxuICAgICAgICBoOiBiYWNrZHJvcEhlaWdodCxcbiAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICB9KTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5maWxsUmVjdChiYWNrZHJvcExlZnQsIGJhY2tkcm9wVG9wLCBiYWNrZHJvcFdpZHRoLCBiYWNrZHJvcEhlaWdodCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9pbnRMYWJlbHN9fSA9IHNjYWxlO1xuXG4gIGZvciAobGV0IGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBpdGVtID0gc2NhbGUuX3BvaW50TGFiZWxJdGVtc1tpXTtcbiAgICBpZiAoIWl0ZW0udmlzaWJsZSkge1xuICAgICAgLy8gb3ZlcmxhcHBpbmdcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBvcHRzQXRJbmRleCA9IHBvaW50TGFiZWxzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIGRyYXdQb2ludExhYmVsQm94KGN0eCwgb3B0c0F0SW5kZXgsIGl0ZW0pO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICBjb25zdCB7eCwgeSwgdGV4dEFsaWdufSA9IGl0ZW07XG5cbiAgICByZW5kZXJUZXh0KFxuICAgICAgY3R4LFxuICAgICAgc2NhbGUuX3BvaW50TGFiZWxzW2ldLFxuICAgICAgeCxcbiAgICAgIHkgKyAocGxGb250LmxpbmVIZWlnaHQgLyAyKSxcbiAgICAgIHBsRm9udCxcbiAgICAgIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgfVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eH0gPSBzY2FsZTtcbiAgaWYgKGNpcmN1bGFyKSB7XG4gICAgLy8gRHJhdyBjaXJjdWxhciBhcmNzIGJldHdlZW4gdGhlIHBvaW50c1xuICAgIGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBUQVUpO1xuICB9IGVsc2Uge1xuICAgIC8vIERyYXcgc3RyYWlnaHQgbGluZXMgY29ubmVjdGluZyBlYWNoIGluZGV4XG4gICAgbGV0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKDAsIHJhZGl1cyk7XG4gICAgY3R4Lm1vdmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgcmFkaXVzKTtcbiAgICAgIGN0eC5saW5lVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGxhYmVsQ291bnQsIGJvcmRlck9wdHMpIHtcbiAgY29uc3QgY3R4ID0gc2NhbGUuY3R4O1xuICBjb25zdCBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcblxuICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBncmlkTGluZU9wdHM7XG5cbiAgaWYgKCghY2lyY3VsYXIgJiYgIWxhYmVsQ291bnQpIHx8ICFjb2xvciB8fCAhbGluZVdpZHRoIHx8IHJhZGl1cyA8IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguc2F2ZSgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgY3R4LnNldExpbmVEYXNoKGJvcmRlck9wdHMuZGFzaCB8fCBbXSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGJvcmRlck9wdHMuZGFzaE9mZnNldDtcblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguc3Ryb2tlKCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHBhcmVudCwgaW5kZXgsIGxhYmVsKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGxhYmVsLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICdwb2ludExhYmVsJ1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaWFsTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuXG4gIHN0YXRpYyBpZCA9ICdyYWRpYWxMaW5lYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRpc3BsYXk6IHRydWUsXG5cbiAgICAvLyBCb29sZWFuIC0gV2hldGhlciB0byBhbmltYXRlIHNjYWxpbmcgdGhlIGNoYXJ0IGZyb20gdGhlIGNlbnRyZVxuICAgIGFuaW1hdGU6IHRydWUsXG4gICAgcG9zaXRpb246ICdjaGFydEFyZWEnLFxuXG4gICAgYW5nbGVMaW5lczoge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgIGJvcmRlckRhc2g6IFtdLFxuICAgICAgYm9yZGVyRGFzaE9mZnNldDogMC4wXG4gICAgfSxcblxuICAgIGdyaWQ6IHtcbiAgICAgIGNpcmN1bGFyOiBmYWxzZVxuICAgIH0sXG5cbiAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgLy8gbGFiZWwgc2V0dGluZ3NcbiAgICB0aWNrczoge1xuICAgICAgLy8gQm9vbGVhbiAtIFNob3cgYSBiYWNrZHJvcCB0byB0aGUgc2NhbGUgbGFiZWxcbiAgICAgIHNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxuXG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gICAgfSxcblxuICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICBiYWNrZHJvcENvbG9yOiB1bmRlZmluZWQsXG5cbiAgICAgIC8vIE51bWJlciAtIFRoZSBiYWNrZHJvcCBwYWRkaW5nIGFib3ZlICYgYmVsb3cgdGhlIGxhYmVsIGluIHBpeGVsc1xuICAgICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuXG4gICAgICAvLyBCb29sZWFuIC0gaWYgdHJ1ZSwgc2hvdyBwb2ludCBsYWJlbHNcbiAgICAgIGRpc3BsYXk6IHRydWUsXG5cbiAgICAgIC8vIE51bWJlciAtIFBvaW50IGxhYmVsIGZvbnQgc2l6ZSBpbiBwaXhlbHNcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgc2l6ZTogMTBcbiAgICAgIH0sXG5cbiAgICAgIC8vIEZ1bmN0aW9uIC0gVXNlZCB0byBjb252ZXJ0IHBvaW50IGxhYmVsc1xuICAgICAgY2FsbGJhY2sobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgfSxcblxuICAgICAgLy8gTnVtYmVyIC0gQWRkaXRpb25sIHBhZGRpbmcgYmV0d2VlbiBzY2FsZSBhbmQgcG9pbnRMYWJlbFxuICAgICAgcGFkZGluZzogNSxcblxuICAgICAgLy8gQm9vbGVhbiAtIGlmIHRydWUsIGNlbnRlciBwb2ludCBsYWJlbHMgdG8gc2xpY2VzIGluIHBvbGFyIGNoYXJ0XG4gICAgICBjZW50ZXJQb2ludExhYmVsczogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgJ2FuZ2xlTGluZXMuY29sb3InOiAnYm9yZGVyQ29sb3InLFxuICAgICdwb2ludExhYmVscy5jb2xvcic6ICdjb2xvcicsXG4gICAgJ3RpY2tzLmNvbG9yJzogJ2NvbG9yJ1xuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBhbmdsZUxpbmVzOiB7XG4gICAgICBfZmFsbGJhY2s6ICdncmlkJ1xuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy54Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMueUNlbnRlciA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSBbXTtcbiAgICB0aGlzLl9wb2ludExhYmVsSXRlbXMgPSBbXTtcbiAgfVxuXG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgLy8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSAvIDIpO1xuICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aCAtIHBhZGRpbmcud2lkdGg7XG4gICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBwYWRkaW5nLmhlaWdodDtcbiAgICB0aGlzLnhDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMubGVmdCArIHcgLyAyICsgcGFkZGluZy5sZWZ0KTtcbiAgICB0aGlzLnlDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMudG9wICsgaCAvIDIgKyBwYWRkaW5nLnRvcCk7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IE1hdGguZmxvb3IoTWF0aC5taW4odywgaCkgLyAyKTtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KGZhbHNlKTtcblxuICAgIHRoaXMubWluID0gaXNGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc0Zpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogMDtcblxuICAgIC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSBtaW4sIG1heCwgYmVnaW5BdFplcm9cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyBiYXNlZCBvbiB0aGUgc2NhbGUgZGltZW5zaW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xuICB9XG5cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5nZW5lcmF0ZVRpY2tMYWJlbHMuY2FsbCh0aGlzLCB0aWNrcyk7XG5cbiAgICAvLyBQb2ludCBsYWJlbHNcbiAgICB0aGlzLl9wb2ludExhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKClcbiAgICAgIC5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGNhbGxDYWxsYmFjayh0aGlzLm9wdGlvbnMucG9pbnRMYWJlbHMuY2FsbGJhY2ssIFt2YWx1ZSwgaW5kZXhdLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsIHx8IGxhYmVsID09PSAwID8gbGFiZWwgOiAnJztcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKCh2LCBpKSA9PiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpKTtcbiAgfVxuXG4gIGZpdCgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKG9wdHMuZGlzcGxheSAmJiBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGZpdFdpdGhQb2ludExhYmVscyh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDZW50ZXJQb2ludCgwLCAwLCAwLCAwKTtcbiAgICB9XG4gIH1cblxuICBzZXRDZW50ZXJQb2ludChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xuICAgIHRoaXMueENlbnRlciArPSBNYXRoLmZsb29yKChsZWZ0TW92ZW1lbnQgLSByaWdodE1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMueUNlbnRlciArPSBNYXRoLmZsb29yKCh0b3BNb3ZlbWVudCAtIGJvdHRvbU1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgLT0gTWF0aC5taW4odGhpcy5kcmF3aW5nQXJlYSAvIDIsIE1hdGgubWF4KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSk7XG4gIH1cblxuICBnZXRJbmRleEFuZ2xlKGluZGV4KSB7XG4gICAgY29uc3QgYW5nbGVNdWx0aXBsaWVyID0gVEFVIC8gKHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCB8fCAxKTtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcblxuICAgIHJldHVybiBfbm9ybWFsaXplQW5nbGUoaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyB0b1JhZGlhbnMoc3RhcnRBbmdsZSkpO1xuICB9XG5cbiAgZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgLy8gVGFrZSBpbnRvIGFjY291bnQgaGFsZiBmb250IHNpemUgKyB0aGUgeVBhZGRpbmcgb2YgdGhlIHRvcCB2YWx1ZVxuICAgIGNvbnN0IHNjYWxpbmdGYWN0b3IgPSB0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgcmV0dXJuICh0aGlzLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG4gICAgfVxuICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1pbikgKiBzY2FsaW5nRmFjdG9yO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIoZGlzdGFuY2UpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihkaXN0YW5jZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgY29uc3Qgc2NhbGVkRGlzdGFuY2UgPSBkaXN0YW5jZSAvICh0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJldmVyc2UgPyB0aGlzLm1heCAtIHNjYWxlZERpc3RhbmNlIDogdGhpcy5taW4gKyBzY2FsZWREaXN0YW5jZTtcbiAgfVxuXG4gIGdldFBvaW50TGFiZWxDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgcG9pbnRMYWJlbHMgPSB0aGlzLl9wb2ludExhYmVscyB8fCBbXTtcblxuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgcG9pbnRMYWJlbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwb2ludExhYmVsID0gcG9pbnRMYWJlbHNbaW5kZXhdO1xuICAgICAgcmV0dXJuIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgcG9pbnRMYWJlbCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyLCBhZGRpdGlvbmFsQW5nbGUgPSAwKSB7XG4gICAgY29uc3QgYW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoaW5kZXgpIC0gSEFMRl9QSSArIGFkZGl0aW9uYWxBbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy54Q2VudGVyLFxuICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy55Q2VudGVyLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG5cbiAgZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcbiAgfVxuXG4gIGdldEJhc2VQb3NpdGlvbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCB8fCAwLCB0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuXG4gIGdldFBvaW50TGFiZWxQb3NpdGlvbihpbmRleCkge1xuICAgIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gdGhpcy5fcG9pbnRMYWJlbEl0ZW1zW2luZGV4XTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2JhY2tncm91bmRDb2xvciwgZ3JpZDoge2NpcmN1bGFyfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcGF0aFJhZGl1c0xpbmUodGhpcywgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLl9lbmRWYWx1ZSksIGNpcmN1bGFyLCB0aGlzLl9wb2ludExhYmVscy5sZW5ndGgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3R3JpZCgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHthbmdsZUxpbmVzLCBncmlkLCBib3JkZXJ9ID0gb3B0cztcbiAgICBjb25zdCBsYWJlbENvdW50ID0gdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuXG4gICAgbGV0IGksIG9mZnNldCwgcG9zaXRpb247XG5cbiAgICBpZiAob3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBkcmF3UG9pbnRMYWJlbHModGhpcywgbGFiZWxDb3VudCk7XG4gICAgfVxuXG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggIT09IDAgfHwgKGluZGV4ID09PSAwICYmIHRoaXMubWluIDwgMCkpIHtcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRpY2sudmFsdWUpO1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoaW5kZXgpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4Qm9yZGVyID0gYm9yZGVyLnNldENvbnRleHQoY29udGV4dCk7XG5cbiAgICAgICAgICBkcmF3UmFkaXVzTGluZSh0aGlzLCBvcHRzQXRJbmRleCwgb2Zmc2V0LCBsYWJlbENvdW50LCBvcHRzQXRJbmRleEJvcmRlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhbmdsZUxpbmVzLmRpc3BsYXkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGZvciAoaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGFuZ2xlTGluZXMuc2V0Q29udGV4dCh0aGlzLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICAgICAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gb3B0c0F0SW5kZXg7XG5cbiAgICAgICAgaWYgKCFsaW5lV2lkdGggfHwgIWNvbG9yKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcblxuICAgICAgICBjdHguc2V0TGluZURhc2gob3B0c0F0SW5kZXguYm9yZGVyRGFzaCk7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2hPZmZzZXQ7XG5cbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnJldmVyc2UgPyB0aGlzLm1pbiA6IHRoaXMubWF4KTtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50UG9zaXRpb24oaSwgb2Zmc2V0KTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3Qm9yZGVyKCkge31cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0xhYmVscygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuICAgIGlmICghdGlja09wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG4gICAgbGV0IG9mZnNldCwgd2lkdGg7XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUodGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgIGN0eC5yb3RhdGUoc3RhcnRBbmdsZSk7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgIGlmICgoaW5kZXggPT09IDAgJiYgdGhpcy5taW4gPj0gMCkgJiYgIW9wdHMucmV2ZXJzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gdGlja09wdHMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLnRpY2tzW2luZGV4XS52YWx1ZSk7XG5cbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcbiAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGljay5sYWJlbCkud2lkdGg7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yO1xuXG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgIC13aWR0aCAvIDIgLSBwYWRkaW5nLmxlZnQsXG4gICAgICAgICAgLW9mZnNldCAtIHRpY2tGb250LnNpemUgLyAyIC0gcGFkZGluZy50b3AsXG4gICAgICAgICAgd2lkdGggKyBwYWRkaW5nLndpZHRoLFxuICAgICAgICAgIHRpY2tGb250LnNpemUgKyBwYWRkaW5nLmhlaWdodFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZW5kZXJUZXh0KGN0eCwgdGljay5sYWJlbCwgMCwgLW9mZnNldCwgdGlja0ZvbnQsIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICBzdHJva2VDb2xvcjogb3B0c0F0SW5kZXgudGV4dFN0cm9rZUNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdUaXRsZSgpIHt9XG59XG4iLCAiaW1wb3J0IGFkYXB0ZXJzIGZyb20gJy4uL2NvcmUvY29yZS5hZGFwdGVycy5qcyc7XG5pbXBvcnQge2NhbGxiYWNrIGFzIGNhbGwsIGlzRmluaXRlLCBpc051bGxPclVuZGVmLCBtZXJnZUlmLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnMsIGlzTnVtYmVyLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQge19hcnJheVVuaXF1ZSwgX2ZpbHRlckJldHdlZW4sIF9sb29rdXB9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmFkYXB0ZXJzLmpzJykuVGltZVVuaXQgfSBVbml0XG4gKiBAdHlwZWRlZiB7e2NvbW1vbjogYm9vbGVhbiwgc2l6ZTogbnVtYmVyLCBzdGVwcz86IG51bWJlcn19IEludGVydmFsXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmFkYXB0ZXJzLmpzJykuRGF0ZUFkYXB0ZXIgfSBEYXRlQWRhcHRlclxuICovXG5cbi8qKlxuICogQHR5cGUge09iamVjdDxVbml0LCBJbnRlcnZhbD59XG4gKi9cbmNvbnN0IElOVEVSVkFMUyA9IHtcbiAgbWlsbGlzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEsIHN0ZXBzOiAxMDAwfSxcbiAgc2Vjb25kOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAxMDAwLCBzdGVwczogNjB9LFxuICBtaW51dGU6IHtjb21tb246IHRydWUsIHNpemU6IDYwMDAwLCBzdGVwczogNjB9LFxuICBob3VyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzNjAwMDAwLCBzdGVwczogMjR9LFxuICBkYXk6IHtjb21tb246IHRydWUsIHNpemU6IDg2NDAwMDAwLCBzdGVwczogMzB9LFxuICB3ZWVrOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNjA0ODAwMDAwLCBzdGVwczogNH0sXG4gIG1vbnRoOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAyLjYyOGU5LCBzdGVwczogMTJ9LFxuICBxdWFydGVyOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNy44ODRlOSwgc3RlcHM6IDR9LFxuICB5ZWFyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzLjE1NGUxMH1cbn07XG5cbi8qKlxuICogQHR5cGUge1VuaXRbXX1cbiAqL1xuY29uc3QgVU5JVFMgPSAvKiogQHR5cGUgVW5pdFtdICovIC8qICNfX1BVUkVfXyAqLyAoT2JqZWN0LmtleXMoSU5URVJWQUxTKSk7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKi9cbmZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7Kn0gaW5wdXRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc2NhbGUsIGlucHV0KSB7XG4gIGlmIChpc051bGxPclVuZGVmKGlucHV0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCB7cGFyc2VyLCByb3VuZCwgaXNvV2Vla2RheX0gPSBzY2FsZS5fcGFyc2VPcHRzO1xuICBsZXQgdmFsdWUgPSBpbnB1dDtcblxuICBpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE9ubHkgcGFyc2UgaWYgaXQncyBub3QgYSB0aW1lc3RhbXAgYWxyZWFkeVxuICBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdHlwZW9mIHBhcnNlciA9PT0gJ3N0cmluZydcbiAgICAgID8gYWRhcHRlci5wYXJzZSh2YWx1ZSwgcGFyc2VyKVxuICAgICAgOiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHJvdW5kKSB7XG4gICAgdmFsdWUgPSByb3VuZCA9PT0gJ3dlZWsnICYmIChpc051bWJlcihpc29XZWVrZGF5KSB8fCBpc29XZWVrZGF5ID09PSB0cnVlKVxuICAgICAgPyBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsICdpc29XZWVrJywgaXNvV2Vla2RheSlcbiAgICAgIDogYWRhcHRlci5zdGFydE9mKHZhbHVlLCByb3VuZCk7XG4gIH1cblxuICByZXR1cm4gK3ZhbHVlO1xufVxuXG4vKipcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCByZXN1bHRzIGluIGFuIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhdXRvLWdlbmVyYXRlZCB0aWNrc1xuICogQHBhcmFtIHtVbml0fSBtaW5Vbml0XG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKiBAcGFyYW0ge251bWJlcn0gY2FwYWNpdHlcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcbiAgY29uc3QgaWxlbiA9IFVOSVRTLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IElOVEVSVkFMU1tVTklUU1tpXV07XG4gICAgY29uc3QgZmFjdG9yID0gaW50ZXJ2YWwuc3RlcHMgPyBpbnRlcnZhbC5zdGVwcyA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4gICAgaWYgKGludGVydmFsLmNvbW1vbiAmJiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoZmFjdG9yICogaW50ZXJ2YWwuc2l6ZSkpIDw9IGNhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcbn1cblxuLyoqXG4gKiBGaWd1cmVzIG91dCB3aGF0IHVuaXQgdG8gZm9ybWF0IGEgc2V0IG9mIHRpY2tzIHdpdGhcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IG51bVRpY2tzXG4gKiBAcGFyYW0ge1VuaXR9IG1pblVuaXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge1VuaXR9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHNjYWxlLCBudW1UaWNrcywgbWluVW5pdCwgbWluLCBtYXgpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmxlbmd0aCAtIDE7IGkgPj0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaS0tKSB7XG4gICAgY29uc3QgdW5pdCA9IFVOSVRTW2ldO1xuICAgIGlmIChJTlRFUlZBTFNbdW5pdF0uY29tbW9uICYmIHNjYWxlLl9hZGFwdGVyLmRpZmYobWF4LCBtaW4sIHVuaXQpID49IG51bVRpY2tzIC0gMSkge1xuICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XG59XG5cbi8qKlxuICogQHBhcmFtIHtVbml0fSB1bml0XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZU1ham9yVW5pdCh1bml0KSB7XG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKHVuaXQpICsgMSwgaWxlbiA9IFVOSVRTLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGlmIChJTlRFUlZBTFNbVU5JVFNbaV1dLmNvbW1vbikge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSB0aWNrc1xuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcbiAqIEBwYXJhbSB7bnVtYmVyW119IFt0aW1lc3RhbXBzXSAtIGlmIGRlZmluZWQsIHNuYXAgdG8gdGhlc2UgdGltZXN0YW1wc1xuICovXG5mdW5jdGlvbiBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKSB7XG4gIGlmICghdGltZXN0YW1wcykge1xuICAgIHRpY2tzW3RpbWVdID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgIGNvbnN0IHtsbywgaGl9ID0gX2xvb2t1cCh0aW1lc3RhbXBzLCB0aW1lKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2xvXSA+PSB0aW1lID8gdGltZXN0YW1wc1tsb10gOiB0aW1lc3RhbXBzW2hpXTtcbiAgICB0aWNrc1t0aW1lc3RhbXBdID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtvYmplY3RbXX0gdGlja3NcbiAqIEBwYXJhbSB7b2JqZWN0fSBtYXBcbiAqIEBwYXJhbSB7VW5pdH0gbWFqb3JVbml0XG4gKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KSB7XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3QgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKHRpY2tzWzBdLnZhbHVlLCBtYWpvclVuaXQpO1xuICBjb25zdCBsYXN0ID0gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWU7XG4gIGxldCBtYWpvciwgaW5kZXg7XG5cbiAgZm9yIChtYWpvciA9IGZpcnN0OyBtYWpvciA8PSBsYXN0OyBtYWpvciA9ICthZGFwdGVyLmFkZChtYWpvciwgMSwgbWFqb3JVbml0KSkge1xuICAgIGluZGV4ID0gbWFwW21ham9yXTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGlja3NbaW5kZXhdLm1ham9yID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJbXX0gdmFsdWVzXG4gKiBAcGFyYW0ge1VuaXR8dW5kZWZpbmVkfSBbbWFqb3JVbml0XVxuICogQHJldHVybiB7b2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIC8qKiBAdHlwZSB7T2JqZWN0PG51bWJlcixvYmplY3Q+fSAqL1xuICBjb25zdCBtYXAgPSB7fTtcbiAgY29uc3QgaWxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGxldCBpLCB2YWx1ZTtcblxuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgbWFwW3ZhbHVlXSA9IGk7XG5cbiAgICB0aWNrcy5wdXNoKHtcbiAgICAgIHZhbHVlLFxuICAgICAgbWFqb3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvLyBXZSBzZXQgdGhlIG1ham9yIHRpY2tzIHNlcGFyYXRlbHkgZnJvbSB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIGNhbGxpbmcgc3RhcnRPZiBmb3IgZXZlcnkgdGlja1xuICAvLyBpcyBleHBlbnNpdmUgd2hlbiB0aGVyZSBpcyBhIGxhcmdlIG51bWJlciBvZiB0aWNrc1xuICByZXR1cm4gKGlsZW4gPT09IDAgfHwgIW1ham9yVW5pdCkgPyB0aWNrcyA6IHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVTY2FsZSBleHRlbmRzIFNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAndGltZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogU2NhbGUgYm91bmRhcnkgc3RyYXRlZ3kgKGJ5cGFzc2VkIGJ5IG1pbi9tYXggdGltZSBvcHRpb25zKVxuICAgICAqIC0gYGRhdGFgOiBtYWtlIHN1cmUgZGF0YSBhcmUgZnVsbHkgdmlzaWJsZSwgdGlja3Mgb3V0c2lkZSBhcmUgcmVtb3ZlZFxuICAgICAqIC0gYHRpY2tzYDogbWFrZSBzdXJlIHRpY2tzIGFyZSBmdWxseSB2aXNpYmxlLCBkYXRhIG91dHNpZGUgYXJlIHRydW5jYXRlZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTU2XG4gICAgICogQHNpbmNlIDIuNy4wXG4gICAgICovXG4gICAgYm91bmRzOiAnZGF0YScsXG5cbiAgICBhZGFwdGVyczoge30sXG4gICAgdGltZToge1xuICAgICAgcGFyc2VyOiBmYWxzZSwgLy8gZmFsc2UgPT0gYSBwYXR0ZXJuIHN0cmluZyBmcm9tIG9yIGEgY3VzdG9tIGNhbGxiYWNrIHRoYXQgY29udmVydHMgaXRzIGFyZ3VtZW50IHRvIGEgdGltZXN0YW1wXG4gICAgICB1bml0OiBmYWxzZSwgLy8gZmFsc2UgPT0gYXV0b21hdGljIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cbiAgICAgIHJvdW5kOiBmYWxzZSwgLy8gbm9uZSwgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxuICAgICAgaXNvV2Vla2RheTogZmFsc2UsIC8vIG92ZXJyaWRlIHdlZWsgc3RhcnQgZGF5XG4gICAgICBtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxuICAgICAgZGlzcGxheUZvcm1hdHM6IHt9XG4gICAgfSxcbiAgICB0aWNrczoge1xuICAgICAgLyoqXG4gICAgICAgKiBUaWNrcyBnZW5lcmF0aW9uIGlucHV0IHZhbHVlczpcbiAgICAgICAqIC0gJ2F1dG8nOiBnZW5lcmF0ZXMgXCJvcHRpbWFsXCIgdGlja3MgYmFzZWQgb24gc2NhbGUgc2l6ZSBhbmQgdGltZSBvcHRpb25zLlxuICAgICAgICogLSAnZGF0YSc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIGRhdGEgKGluY2x1ZGluZyBsYWJlbHMgZnJvbSBkYXRhIHt0fHh8eX0gb2JqZWN0cykuXG4gICAgICAgKiAtICdsYWJlbHMnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSB1c2VyIGdpdmVuIGBkYXRhLmxhYmVsc2AgdmFsdWVzIE9OTFkuXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xuICAgICAgICogQHNpbmNlIDIuNy4wXG4gICAgICAgKi9cbiAgICAgIHNvdXJjZTogJ2F1dG8nLFxuXG4gICAgICBjYWxsYmFjazogZmFsc2UsXG5cbiAgICAgIG1ham9yOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcblx0ICovXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgLyoqIEB0eXBlIHt7ZGF0YTogbnVtYmVyW10sIGxhYmVsczogbnVtYmVyW10sIGFsbDogbnVtYmVyW119fSAqL1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG5cbiAgICAvKiogQHR5cGUge1VuaXR9ICovXG4gICAgdGhpcy5fdW5pdCA9ICdkYXknO1xuICAgIC8qKiBAdHlwZSB7VW5pdD19ICovXG4gICAgdGhpcy5fbWFqb3JVbml0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29mZnNldHMgPSB7fTtcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaW5pdChzY2FsZU9wdHMsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHRpbWUgPSBzY2FsZU9wdHMudGltZSB8fCAoc2NhbGVPcHRzLnRpbWUgPSB7fSk7XG4gICAgLyoqIEB0eXBlIHtEYXRlQWRhcHRlcn0gKi9cbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlciA9IG5ldyBhZGFwdGVycy5fZGF0ZShzY2FsZU9wdHMuYWRhcHRlcnMuZGF0ZSk7XG5cbiAgICBhZGFwdGVyLmluaXQob3B0cyk7XG5cbiAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBiZWZvcmUgaW50cm9kdWNpbmcgYWRhcHRlciwgYGRpc3BsYXlGb3JtYXRzYCB3YXNcbiAgICAvLyBzdXBwb3NlZCB0byBjb250YWluICphbGwqIHVuaXQvc3RyaW5nIHBhaXJzIGJ1dCB0aGlzIGNhbid0IGJlIHJlc29sdmVkXG4gICAgLy8gd2hlbiBsb2FkaW5nIHRoZSBzY2FsZSAoYWRhcHRlcnMgYXJlIGxvYWRlZCBhZnRlcndhcmQpLCBzbyBsZXQncyBwb3B1bGF0ZVxuICAgIC8vIG1pc3NpbmcgZm9ybWF0cyBvbiB1cGRhdGVcbiAgICBtZXJnZUlmKHRpbWUuZGlzcGxheUZvcm1hdHMsIGFkYXB0ZXIuZm9ybWF0cygpKTtcblxuICAgIHRoaXMuX3BhcnNlT3B0cyA9IHtcbiAgICAgIHBhcnNlcjogdGltZS5wYXJzZXIsXG4gICAgICByb3VuZDogdGltZS5yb3VuZCxcbiAgICAgIGlzb1dlZWtkYXk6IHRpbWUuaXNvV2Vla2RheVxuICAgIH07XG5cbiAgICBzdXBlci5pbml0KHNjYWxlT3B0cyk7XG5cbiAgICB0aGlzLl9ub3JtYWxpemVkID0gb3B0cy5ub3JtYWxpemVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Kn0gcmF3XG5cdCAqIEBwYXJhbSB7bnVtYmVyP30gW2luZGV4XVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAocmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2UodGhpcywgcmF3KTtcbiAgfVxuXG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICBzdXBlci5iZWZvcmVMYXlvdXQoKTtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHVuaXQgPSBvcHRpb25zLnRpbWUudW5pdCB8fCAnZGF5JztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcblxuICAgIC8qKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBib3VuZHNcblx0XHQgKi9cbiAgICBmdW5jdGlvbiBfYXBwbHlCb3VuZHMoYm91bmRzKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5taW4pKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgYm91bmRzLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5tYXgpKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgYm91bmRzLm1heCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSB1c2VyIHByb3ZpZGVkIGBtaW5gIGFuZCBgbWF4YCBsYWJlbHMgLyBkYXRhIGJvdW5kcyBjYW4gYmUgaWdub3JlZFxuICAgIGlmICghbWluRGVmaW5lZCB8fCAhbWF4RGVmaW5lZCkge1xuICAgICAgLy8gTGFiZWxzIGFyZSBhbHdheXMgY29uc2lkZXJlZCwgd2hlbiB1c2VyIGRpZCBub3QgZm9yY2UgYm91bmRzXG4gICAgICBfYXBwbHlCb3VuZHModGhpcy5fZ2V0TGFiZWxCb3VuZHMoKSk7XG5cbiAgICAgIC8vIElmIGBib3VuZHNgIGlzIGAndGlja3MnYCBhbmQgYHRpY2tzLnNvdXJjZWAgaXMgYCdsYWJlbHMnYCxcbiAgICAgIC8vIGRhdGEgYm91bmRzIGFyZSBpZ25vcmVkIChhbmQgZG9uJ3QgbmVlZCB0byBiZSBkZXRlcm1pbmVkKVxuICAgICAgaWYgKG9wdGlvbnMuYm91bmRzICE9PSAndGlja3MnIHx8IG9wdGlvbnMudGlja3Muc291cmNlICE9PSAnbGFiZWxzJykge1xuICAgICAgICBfYXBwbHlCb3VuZHModGhpcy5nZXRNaW5NYXgoZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtaW4gPSBpc0Zpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KTtcbiAgICBtYXggPSBpc0Zpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogK2FkYXB0ZXIuZW5kT2YoRGF0ZS5ub3coKSwgdW5pdCkgKyAxO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgbWF4IGlzIHN0cmljdGx5IGhpZ2hlciB0aGFuIG1pbiAocmVxdWlyZWQgYnkgdGhlIHRpbWVzZXJpZXMgbG9va3VwIHRhYmxlKVxuICAgIHRoaXMubWluID0gTWF0aC5taW4obWluLCBtYXggLSAxKTtcbiAgICB0aGlzLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbEJvdW5kcygpIHtcbiAgICBjb25zdCBhcnIgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGxldCBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICAgIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgICBtaW4gPSBhcnJbMF07XG4gICAgICBtYXggPSBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2xhYmVscycgPyB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpIDogdGhpcy5fZ2VuZXJhdGUoKTtcblxuICAgIGlmIChvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgdGhpcy5taW4gPSB0aGlzLl91c2VyTWluIHx8IHRpbWVzdGFtcHNbMF07XG4gICAgICB0aGlzLm1heCA9IHRoaXMuX3VzZXJNYXggfHwgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuXG4gICAgY29uc3QgdGlja3MgPSBfZmlsdGVyQmV0d2Vlbih0aW1lc3RhbXBzLCBtaW4sIG1heCk7XG5cbiAgICAvLyBQUklWQVRFXG4gICAgLy8gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcgcmVsaWVzIG9uIHRoZSBudW1iZXIgb2YgdGlja3Mgc28gd2UgZG9uJ3QgdXNlIGl0IHdoZW5cbiAgICAvLyBhdXRvU2tpcCBpcyBlbmFibGVkIGJlY2F1c2Ugd2UgZG9uJ3QgeWV0IGtub3cgd2hhdCB0aGUgZmluYWwgbnVtYmVyIG9mIHRpY2tzIHdpbGwgYmVcbiAgICB0aGlzLl91bml0ID0gdGltZU9wdHMudW5pdCB8fCAodGlja09wdHMuYXV0b1NraXBcbiAgICAgID8gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSlcbiAgICAgIDogZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcodGhpcywgdGlja3MubGVuZ3RoLCB0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgpKTtcbiAgICB0aGlzLl9tYWpvclVuaXQgPSAhdGlja09wdHMubWFqb3IuZW5hYmxlZCB8fCB0aGlzLl91bml0ID09PSAneWVhcicgPyB1bmRlZmluZWRcbiAgICAgIDogZGV0ZXJtaW5lTWFqb3JVbml0KHRoaXMuX3VuaXQpO1xuICAgIHRoaXMuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG5cbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgdGlja3MsIHRoaXMuX21ham9yVW5pdCk7XG4gIH1cblxuICBhZnRlckF1dG9Ta2lwKCkge1xuICAgIC8vIE9mZnNldHMgZm9yIGJhciBjaGFydHMgbmVlZCB0byBiZSBoYW5kbGVkIHdpdGggdGhlIGF1dG8gc2tpcHBlZFxuICAgIC8vIHRpY2tzLiBPbmNlIHRpY2tzIGhhdmUgYmVlbiBza2lwcGVkLCB3ZSByZS1jb21wdXRlIHRoZSBvZmZzZXRzLlxuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0QWZ0ZXJBdXRvc2tpcCkge1xuICAgICAgdGhpcy5pbml0T2Zmc2V0cyh0aGlzLnRpY2tzLm1hcCh0aWNrID0+ICt0aWNrLnZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0cyBmcm9tIGVkZ2VzIGluIHRoZSBmb3JtIG9mIHtzdGFydCwgZW5kfVxuXHQgKiB3aGVyZSBlYWNoIHZhbHVlIGlzIGEgcmVsYXRpdmUgd2lkdGggdG8gdGhlIHNjYWxlIGFuZCByYW5nZXMgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBUaGV5IGFkZCBleHRyYSBtYXJnaW5zIG9uIHRoZSBib3RoIHNpZGVzIGJ5IHNjYWxpbmcgZG93biB0aGUgb3JpZ2luYWwgc2NhbGUuXG5cdCAqIE9mZnNldHMgYXJlIGFkZGVkIHdoZW4gdGhlIGBvZmZzZXRgIG9wdGlvbiBpcyB0cnVlLlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB0aW1lc3RhbXBzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGluaXRPZmZzZXRzKHRpbWVzdGFtcHMgPSBbXSkge1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IDA7XG4gICAgbGV0IGZpcnN0LCBsYXN0O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIGZpcnN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1swXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RhcnQgPSAxIC0gZmlyc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9ICh0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzFdKSAtIGZpcnN0KSAvIDI7XG4gICAgICB9XG4gICAgICBsYXN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbmQgPSBsYXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gKGxhc3QgLSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0pKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdGltZXN0YW1wcy5sZW5ndGggPCAzID8gMC41IDogMC4yNTtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKHN0YXJ0LCAwLCBsaW1pdCk7XG4gICAgZW5kID0gX2xpbWl0VmFsdWUoZW5kLCAwLCBsaW1pdCk7XG5cbiAgICB0aGlzLl9vZmZzZXRzID0ge3N0YXJ0LCBlbmQsIGZhY3RvcjogMSAvIChzdGFydCArIDEgKyBlbmQpfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBtYXhpbXVtIG9mIGBjYXBhY2l0eWAgdGltZXN0YW1wcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCByb3VuZGVkIHRvIHRoZVxuXHQgKiBgbWlub3JgIHVuaXQgdXNpbmcgdGhlIGdpdmVuIHNjYWxlIHRpbWUgYG9wdGlvbnNgLlxuXHQgKiBJbXBvcnRhbnQ6IHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gdGlja3Mgb3V0c2lkZSB0aGUgbWluIGFuZCBtYXggcmFuZ2UsIGl0J3MgdGhlXG5cdCAqIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsaW5nIGNvZGUgdG8gY2xhbXAgdmFsdWVzIGlmIG5lZWRlZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgX2dlbmVyYXRlKCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IG1pbm9yID0gdGltZU9wdHMudW5pdCB8fCBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIG1pbiwgbWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpO1xuICAgIGNvbnN0IHN0ZXBTaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5zdGVwU2l6ZSwgMSk7XG4gICAgY29uc3Qgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XG4gICAgY29uc3QgaGFzV2Vla2RheSA9IGlzTnVtYmVyKHdlZWtkYXkpIHx8IHdlZWtkYXkgPT09IHRydWU7XG4gICAgY29uc3QgdGlja3MgPSB7fTtcbiAgICBsZXQgZmlyc3QgPSBtaW47XG4gICAgbGV0IHRpbWUsIGNvdW50O1xuXG4gICAgLy8gRm9yICd3ZWVrJyB1bml0LCBoYW5kbGUgdGhlIGZpcnN0IGRheSBvZiB3ZWVrIG9wdGlvblxuICAgIGlmIChoYXNXZWVrZGF5KSB7XG4gICAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsICdpc29XZWVrJywgd2Vla2RheSk7XG4gICAgfVxuXG4gICAgLy8gQWxpZ24gZmlyc3QgdGlja3Mgb24gdW5pdFxuICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgaGFzV2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuXG4gICAgLy8gUHJldmVudCBicm93c2VyIGZyb20gZnJlZXppbmcgaW4gY2FzZSB1c2VyIG9wdGlvbnMgcmVxdWVzdCBtaWxsaW9ucyBvZiBtaWxsaXNlY29uZHNcbiAgICBpZiAoYWRhcHRlci5kaWZmKG1heCwgbWluLCBtaW5vcikgPiAxMDAwMDAgKiBzdGVwU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1pbiArICcgYW5kICcgKyBtYXggKyAnIGFyZSB0b28gZmFyIGFwYXJ0IHdpdGggc3RlcFNpemUgb2YgJyArIHN0ZXBTaXplICsgJyAnICsgbWlub3IpO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBvcHRpb25zLnRpY2tzLnNvdXJjZSA9PT0gJ2RhdGEnICYmIHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBmb3IgKHRpbWUgPSBmaXJzdCwgY291bnQgPSAwOyB0aW1lIDwgbWF4OyB0aW1lID0gK2FkYXB0ZXIuYWRkKHRpbWUsIHN0ZXBTaXplLCBtaW5vciksIGNvdW50KyspIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cblxuICAgIGlmICh0aW1lID09PSBtYXggfHwgb3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgfHwgY291bnQgPT09IDEpIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGlja3MpLnNvcnQoc29ydGVyKS5tYXAoeCA9PiAreCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuXG4gICAgaWYgKHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpIHtcbiAgICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMuZGlzcGxheUZvcm1hdHMuZGF0ZXRpbWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGZvcm1hdFxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBmb3JtYXQodmFsdWUsIGZvcm1hdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCB1bml0ID0gdGhpcy5fdW5pdDtcbiAgICBjb25zdCBmbXQgPSBmb3JtYXQgfHwgZm9ybWF0c1t1bml0XTtcbiAgICByZXR1cm4gdGhpcy5fYWRhcHRlci5mb3JtYXQodmFsdWUsIGZtdCk7XG4gIH1cblxuICAvKipcblx0ICogRnVuY3Rpb24gdG8gZm9ybWF0IGFuIGluZGl2aWR1YWwgdGljayBtYXJrXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcGFyYW0ge29iamVjdFtdfSB0aWNrc1xuXHQgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IFtmb3JtYXRdXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF90aWNrRm9ybWF0RnVuY3Rpb24odGltZSwgaW5kZXgsIHRpY2tzLCBmb3JtYXQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IG9wdGlvbnMudGlja3MuY2FsbGJhY2s7XG5cbiAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gY2FsbChmb3JtYXR0ZXIsIFt0aW1lLCBpbmRleCwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IHVuaXQgPSB0aGlzLl91bml0O1xuICAgIGNvbnN0IG1ham9yVW5pdCA9IHRoaXMuX21ham9yVW5pdDtcbiAgICBjb25zdCBtaW5vckZvcm1hdCA9IHVuaXQgJiYgZm9ybWF0c1t1bml0XTtcbiAgICBjb25zdCBtYWpvckZvcm1hdCA9IG1ham9yVW5pdCAmJiBmb3JtYXRzW21ham9yVW5pdF07XG4gICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICBjb25zdCBtYWpvciA9IG1ham9yVW5pdCAmJiBtYWpvckZvcm1hdCAmJiB0aWNrICYmIHRpY2subWFqb3I7XG5cbiAgICByZXR1cm4gdGhpcy5fYWRhcHRlci5mb3JtYXQodGltZSwgZm9ybWF0IHx8IChtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdFtdfSB0aWNrc1xuXHQgKi9cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKHRpY2sudmFsdWUsIGksIHRpY2tzKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gTWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBNaWxsaXNlY29uZHMgc2luY2UgZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQylcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKG9mZnNldHMuc3RhcnQgKyBwb3MpICogb2Zmc2V0cy5mYWN0b3IpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gdGhpcy5taW4gKyBwb3MgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG5cdCAqIEByZXR1cm4ge3t3Om51bWJlciwgaDpudW1iZXJ9fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExhYmVsU2l6ZShsYWJlbCkge1xuICAgIGNvbnN0IHRpY2tzT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aWNrTGFiZWxXaWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgICBjb25zdCBhbmdsZSA9IHRvUmFkaWFucyh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGlja3NPcHRzLm1heFJvdGF0aW9uIDogdGlja3NPcHRzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCB0aWNrRm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLnNpemU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdzogKHRpY2tMYWJlbFdpZHRoICogY29zUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIHNpblJvdGF0aW9uKSxcbiAgICAgIGg6ICh0aWNrTGFiZWxXaWR0aCAqIHNpblJvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBjb3NSb3RhdGlvbilcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBleGFtcGxlVGltZVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxDYXBhY2l0eShleGFtcGxlVGltZSkge1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgY29uc3QgZGlzcGxheUZvcm1hdHMgPSB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cztcblxuICAgIC8vIHBpY2sgdGhlIGxvbmdlc3QgZm9ybWF0IChtaWxsaXNlY29uZHMpIGZvciBndWVzc3RpbWF0aW9uXG4gICAgY29uc3QgZm9ybWF0ID0gZGlzcGxheUZvcm1hdHNbdGltZU9wdHMudW5pdF0gfHwgZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XG4gICAgY29uc3QgZXhhbXBsZUxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIFtleGFtcGxlVGltZV0sIHRoaXMuX21ham9yVW5pdCksIGZvcm1hdCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xuICAgIC8vIHN1YnRyYWN0IDEgLSBpZiBvZmZzZXQgdGhlbiB0aGVyZSdzIG9uZSBsZXNzIGxhYmVsIHRoYW4gdGlja1xuICAgIC8vIGlmIG5vdCBvZmZzZXQgdGhlbiBvbmUgaGFsZiBsYWJlbCBwYWRkaW5nIGlzIGFkZGVkIHRvIGVhY2ggZW5kIGxlYXZpbmcgcm9vbSBmb3Igb25lIGxlc3MgbGFiZWxcbiAgICBjb25zdCBjYXBhY2l0eSA9IE1hdGguZmxvb3IodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggLyBzaXplLncgOiB0aGlzLmhlaWdodCAvIHNpemUuaCkgLSAxO1xuICAgIHJldHVybiBjYXBhY2l0eSA+IDAgPyBjYXBhY2l0eSA6IDE7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0RGF0YVRpbWVzdGFtcHMoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5kYXRhIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcblxuICAgIGlmICh0aGlzLl9ub3JtYWxpemVkICYmIG1ldGFzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gbWV0YXNbMF0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmNvbmNhdChtZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsVGltZXN0YW1wcygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUubGFiZWxzIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gocGFyc2UodGhpcywgbGFiZWxzW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5sYWJlbHMgPSB0aGlzLl9ub3JtYWxpemVkID8gdGltZXN0YW1wcyA6IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB2YWx1ZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgbm9ybWFsaXplKHZhbHVlcykge1xuICAgIC8vIEl0IHNlZW1zIHRvIGJlIHNvbWV3aGF0IGZhc3RlciB0byBkbyBzb3J0aW5nIGZpcnN0XG4gICAgcmV0dXJuIF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydChzb3J0ZXIpKTtcbiAgfVxufVxuIiwgImltcG9ydCBUaW1lU2NhbGUgZnJvbSAnLi9zY2FsZS50aW1lLmpzJztcbmltcG9ydCB7X2xvb2t1cEJ5S2V5fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5cbi8qKlxuICogTGluZWFybHkgaW50ZXJwb2xhdGVzIHRoZSBnaXZlbiBzb3VyY2UgYHZhbGAgdXNpbmcgdGhlIHRhYmxlLiBJZiB2YWx1ZSBpcyBvdXQgb2YgYm91bmRzLCB2YWx1ZXNcbiAqIGF0IGVkZ2VzIGFyZSB1c2VkIGZvciB0aGUgaW50ZXJwb2xhdGlvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0YWJsZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbFxuICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZV0gbG9va3VwIHRpbWUgYmFzZWQgb24gcG9zaXRpb24gaW5zdGVhZCBvZiB2aWNlIHZlcnNhXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlKHRhYmxlLCB2YWwsIHJldmVyc2UpIHtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZTb3VyY2UsIG5leHRTb3VyY2UsIHByZXZUYXJnZXQsIG5leHRUYXJnZXQ7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10ucG9zICYmIHZhbCA8PSB0YWJsZVtoaV0ucG9zKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICdwb3MnLCB2YWwpKTtcbiAgICB9XG4gICAgKHtwb3M6IHByZXZTb3VyY2UsIHRpbWU6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3BvczogbmV4dFNvdXJjZSwgdGltZTogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnRpbWUgJiYgdmFsIDw9IHRhYmxlW2hpXS50aW1lKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICd0aW1lJywgdmFsKSk7XG4gICAgfVxuICAgICh7dGltZTogcHJldlNvdXJjZSwgcG9zOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHt0aW1lOiBuZXh0U291cmNlLCBwb3M6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfVxuXG4gIGNvbnN0IHNwYW4gPSBuZXh0U291cmNlIC0gcHJldlNvdXJjZTtcbiAgcmV0dXJuIHNwYW4gPyBwcmV2VGFyZ2V0ICsgKG5leHRUYXJnZXQgLSBwcmV2VGFyZ2V0KSAqICh2YWwgLSBwcmV2U291cmNlKSAvIHNwYW4gOiBwcmV2VGFyZ2V0O1xufVxuXG5jbGFzcyBUaW1lU2VyaWVzU2NhbGUgZXh0ZW5kcyBUaW1lU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICd0aW1lc2VyaWVzJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IFRpbWVTY2FsZS5kZWZhdWx0cztcblxuICAvKipcblx0ICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIC8qKiBAdHlwZSB7b2JqZWN0W119ICovXG4gICAgdGhpcy5fdGFibGUgPSBbXTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9taW5Qb3MgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBpbml0T2Zmc2V0cygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCk7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLl90YWJsZSA9IHRoaXMuYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzKTtcbiAgICB0aGlzLl9taW5Qb3MgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5taW4pO1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5tYXgpIC0gdGhpcy5fbWluUG9zO1xuICAgIHN1cGVyLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2Yge3RpbWUsIHBvc30gb2JqZWN0cyB1c2VkIHRvIGludGVycG9sYXRlIGEgc3BlY2lmaWMgYHRpbWVgIG9yIHBvc2l0aW9uXG5cdCAqIChgcG9zYCkgb24gdGhlIHNjYWxlLCBieSBzZWFyY2hpbmcgZW50cmllcyBiZWZvcmUgYW5kIGFmdGVyIHRoZSByZXF1ZXN0ZWQgdmFsdWUuIGBwb3NgIGlzXG5cdCAqIGEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDE6IDAgYmVpbmcgdGhlIHN0YXJ0IG9mIHRoZSBzY2FsZSAobGVmdCBvciB0b3ApIGFuZCAxIHRoZSBvdGhlclxuXHQgKiBleHRyZW1pdHkgKGxlZnQgKyB3aWR0aCBvciB0b3AgKyBoZWlnaHQpLiBOb3RlIHRoYXQgaXQgd291bGQgYmUgbW9yZSBvcHRpbWl6ZWQgdG8gZGlyZWN0bHlcblx0ICogc3RvcmUgcHJlLWNvbXB1dGVkIHBpeGVscywgYnV0IHRoZSBzY2FsZSBkaW1lbnNpb25zIGFyZSBub3QgZ3VhcmFudGVlZCBhdCB0aGUgdGltZSB3ZSBuZWVkXG5cdCAqIHRvIGNyZWF0ZSB0aGUgbG9va3VwIHRhYmxlLiBUaGUgdGFibGUgQUxXQVlTIGNvbnRhaW5zIGF0IGxlYXN0IHR3byBpdGVtczogbWluIGFuZCBtYXguXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IHRpbWVzdGFtcHNcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcykge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3QgdGFibGUgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgcHJldiwgY3VyciwgbmV4dDtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY3VyciA9IHRpbWVzdGFtcHNbaV07XG4gICAgICBpZiAoY3VyciA+PSBtaW4gJiYgY3VyciA8PSBtYXgpIHtcbiAgICAgICAgaXRlbXMucHVzaChjdXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMikge1xuICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBsZXNzIHRoYXQgMiB0aW1lc3RhbXBzIGJldHdlZW4gbWluIGFuZCBtYXgsIHRoZSBzY2FsZSBpcyBkZWZpbmVkIGJ5IG1pbiBhbmQgbWF4XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7dGltZTogbWluLCBwb3M6IDB9LFxuICAgICAgICB7dGltZTogbWF4LCBwb3M6IDF9XG4gICAgICBdO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG5leHQgPSBpdGVtc1tpICsgMV07XG4gICAgICBwcmV2ID0gaXRlbXNbaSAtIDFdO1xuICAgICAgY3VyciA9IGl0ZW1zW2ldO1xuXG4gICAgICAvLyBvbmx5IGFkZCBwb2ludHMgdGhhdCBicmVha3MgdGhlIHNjYWxlIGxpbmVhcml0eVxuICAgICAgaWYgKE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XG4gICAgICAgIHRhYmxlLnB1c2goe3RpbWU6IGN1cnIsIHBvczogaSAvIChpbGVuIC0gMSl9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9XG5cbiAgLyoqXG4gICAgKiBHZW5lcmF0ZXMgYWxsIHRpbWVzdGFtcHMgZGVmaW5lZCBpbiB0aGUgZGF0YS5cbiAgICAqIEltcG9ydGFudDogdGhpcyBtZXRob2QgY2FuIHJldHVybiB0aWNrcyBvdXRzaWRlIHRoZSBtaW4gYW5kIG1heCByYW5nZSwgaXQncyB0aGVcbiAgICAqIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsaW5nIGNvZGUgdG8gY2xhbXAgdmFsdWVzIGlmIG5lZWRlZC5cbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqL1xuICBfZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSBzdXBlci5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGlmICghdGltZXN0YW1wcy5pbmNsdWRlcyhtaW4pIHx8ICF0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgdGltZXN0YW1wcy5zcGxpY2UoMCwgMCwgbWluKTtcbiAgICB9XG4gICAgaWYgKCF0aW1lc3RhbXBzLmluY2x1ZGVzKG1heCkgfHwgdGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRpbWVzdGFtcHMucHVzaChtYXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGltZXN0YW1wcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhbGwgdGltZXN0YW1wc1xuXHQgKiBAcmV0dXJuIHtudW1iZXJbXX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgfHwgW107XG5cbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGlmIChkYXRhLmxlbmd0aCAmJiBsYWJlbC5sZW5ndGgpIHtcbiAgICAgIC8vIElmIGNvbWJpbmluZyBsYWJlbHMgYW5kIGRhdGEgKGRhdGEgbWlnaHQgbm90IGNvbnRhaW4gYWxsIGxhYmVscyksXG4gICAgICAvLyB3ZSBuZWVkIHRvIHJlY2hlY2sgdW5pcXVlbmVzcyBhbmQgc29ydFxuICAgICAgdGltZXN0YW1wcyA9IHRoaXMubm9ybWFsaXplKGRhdGEuY29uY2F0KGxhYmVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVzdGFtcHMgPSBkYXRhLmxlbmd0aCA/IGRhdGEgOiBsYWJlbDtcbiAgICB9XG4gICAgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCA9IHRpbWVzdGFtcHM7XG5cbiAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBNaWxsaXNlY29uZHMgc2luY2UgZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQylcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgdmFsdWUpIC0gdGhpcy5fbWluUG9zKSAvIHRoaXMuX3RhYmxlUmFuZ2U7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIGRlY2ltYWwgKiB0aGlzLl90YWJsZVJhbmdlICsgdGhpcy5fbWluUG9zLCB0cnVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lU2VyaWVzU2NhbGU7XG4iLCAiZXhwb3J0ICogZnJvbSAnLi9jb250cm9sbGVycy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvcmUvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbGVtZW50cy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3BsYXRmb3JtL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vcGx1Z2lucy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3NjYWxlcy9pbmRleC5qcyc7XG5cbmltcG9ydCAqIGFzIGNvbnRyb2xsZXJzIGZyb20gJy4vY29udHJvbGxlcnMvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgZWxlbWVudHMgZnJvbSAnLi9lbGVtZW50cy9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBwbHVnaW5zIGZyb20gJy4vcGx1Z2lucy9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBzY2FsZXMgZnJvbSAnLi9zY2FsZXMvaW5kZXguanMnO1xuXG5leHBvcnQge1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbn07XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlcmFibGVzID0gW1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbl07XG4iLCAiaW1wb3J0IHtDaGFydCwgcmVnaXN0ZXJhYmxlc30gZnJvbSAnLi4vZGlzdC9jaGFydC5qcyc7XG5cbkNoYXJ0LnJlZ2lzdGVyKC4uLnJlZ2lzdGVyYWJsZXMpO1xuXG5leHBvcnQgKiBmcm9tICcuLi9kaXN0L2NoYXJ0LmpzJztcbmV4cG9ydCBkZWZhdWx0IENoYXJ0O1xuIiwgIi8qKiFcbiAqIFNvcnRhYmxlIDEuMTUuNlxuICogQGF1dGhvclx0UnViYVhhICAgPHRyYXNoQHJ1YmF4YS5vcmc+XG4gKiBAYXV0aG9yXHRvd2VubSAgICA8b3dlbjIzMzU1QGdtYWlsLmNvbT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkge1xuICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KTtcbiAgICB9XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjEuMTUuNlwiO1xuXG5mdW5jdGlvbiB1c2VyQWdlbnQocGF0dGVybikge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm5hdmlnYXRvcikge1xuICAgIHJldHVybiAhISAvKkBfX1BVUkVfXyovbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChwYXR0ZXJuKTtcbiAgfVxufVxudmFyIElFMTFPckxlc3MgPSB1c2VyQWdlbnQoLyg/OlRyaWRlbnQuKnJ2WyA6XT8xMVxcLnxtc2llfGllbW9iaWxlfFdpbmRvd3MgUGhvbmUpL2kpO1xudmFyIEVkZ2UgPSB1c2VyQWdlbnQoL0VkZ2UvaSk7XG52YXIgRmlyZUZveCA9IHVzZXJBZ2VudCgvZmlyZWZveC9pKTtcbnZhciBTYWZhcmkgPSB1c2VyQWdlbnQoL3NhZmFyaS9pKSAmJiAhdXNlckFnZW50KC9jaHJvbWUvaSkgJiYgIXVzZXJBZ2VudCgvYW5kcm9pZC9pKTtcbnZhciBJT1MgPSB1c2VyQWdlbnQoL2lQKGFkfG9kfGhvbmUpL2kpO1xudmFyIENocm9tZUZvckFuZHJvaWQgPSB1c2VyQWdlbnQoL2Nocm9tZS9pKSAmJiB1c2VyQWdlbnQoL2FuZHJvaWQvaSk7XG5cbnZhciBjYXB0dXJlTW9kZSA9IHtcbiAgY2FwdHVyZTogZmFsc2UsXG4gIHBhc3NpdmU6IGZhbHNlXG59O1xuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBmbikge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgIUlFMTFPckxlc3MgJiYgY2FwdHVyZU1vZGUpO1xufVxuZnVuY3Rpb24gb2ZmKGVsLCBldmVudCwgZm4pIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZm4sICFJRTExT3JMZXNzICYmIGNhcHR1cmVNb2RlKTtcbn1cbmZ1bmN0aW9uIG1hdGNoZXMoIC8qKkhUTUxFbGVtZW50Ki9lbCwgLyoqU3RyaW5nKi9zZWxlY3Rvcikge1xuICBpZiAoIXNlbGVjdG9yKSByZXR1cm47XG4gIHNlbGVjdG9yWzBdID09PSAnPicgJiYgKHNlbGVjdG9yID0gc2VsZWN0b3Iuc3Vic3RyaW5nKDEpKTtcbiAgaWYgKGVsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChlbC5tYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBlbC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoZWwubXNNYXRjaGVzU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVsLm1zTWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50T3JIb3N0KGVsKSB7XG4gIHJldHVybiBlbC5ob3N0ICYmIGVsICE9PSBkb2N1bWVudCAmJiBlbC5ob3N0Lm5vZGVUeXBlID8gZWwuaG9zdCA6IGVsLnBhcmVudE5vZGU7XG59XG5mdW5jdGlvbiBjbG9zZXN0KCAvKipIVE1MRWxlbWVudCovZWwsIC8qKlN0cmluZyovc2VsZWN0b3IsIC8qKkhUTUxFbGVtZW50Ki9jdHgsIGluY2x1ZGVDVFgpIHtcbiAgaWYgKGVsKSB7XG4gICAgY3R4ID0gY3R4IHx8IGRvY3VtZW50O1xuICAgIGRvIHtcbiAgICAgIGlmIChzZWxlY3RvciAhPSBudWxsICYmIChzZWxlY3RvclswXSA9PT0gJz4nID8gZWwucGFyZW50Tm9kZSA9PT0gY3R4ICYmIG1hdGNoZXMoZWwsIHNlbGVjdG9yKSA6IG1hdGNoZXMoZWwsIHNlbGVjdG9yKSkgfHwgaW5jbHVkZUNUWCAmJiBlbCA9PT0gY3R4KSB7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cbiAgICAgIGlmIChlbCA9PT0gY3R4KSBicmVhaztcbiAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICB9IHdoaWxlIChlbCA9IGdldFBhcmVudE9ySG9zdChlbCkpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxudmFyIFJfU1BBQ0UgPSAvXFxzKy9nO1xuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWwsIG5hbWUsIHN0YXRlKSB7XG4gIGlmIChlbCAmJiBuYW1lKSB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgZWwuY2xhc3NMaXN0W3N0YXRlID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjbGFzc05hbWUgPSAoJyAnICsgZWwuY2xhc3NOYW1lICsgJyAnKS5yZXBsYWNlKFJfU1BBQ0UsICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpO1xuICAgICAgZWwuY2xhc3NOYW1lID0gKGNsYXNzTmFtZSArIChzdGF0ZSA/ICcgJyArIG5hbWUgOiAnJykpLnJlcGxhY2UoUl9TUEFDRSwgJyAnKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNzcyhlbCwgcHJvcCwgdmFsKSB7XG4gIHZhciBzdHlsZSA9IGVsICYmIGVsLnN0eWxlO1xuICBpZiAoc3R5bGUpIHtcbiAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChkb2N1bWVudC5kZWZhdWx0VmlldyAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICAgIHZhbCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsICcnKTtcbiAgICAgIH0gZWxzZSBpZiAoZWwuY3VycmVudFN0eWxlKSB7XG4gICAgICAgIHZhbCA9IGVsLmN1cnJlbnRTdHlsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wID09PSB2b2lkIDAgPyB2YWwgOiB2YWxbcHJvcF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKHByb3AgaW4gc3R5bGUpICYmIHByb3AuaW5kZXhPZignd2Via2l0JykgPT09IC0xKSB7XG4gICAgICAgIHByb3AgPSAnLXdlYmtpdC0nICsgcHJvcDtcbiAgICAgIH1cbiAgICAgIHN0eWxlW3Byb3BdID0gdmFsICsgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gJycgOiAncHgnKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hdHJpeChlbCwgc2VsZk9ubHkpIHtcbiAgdmFyIGFwcGxpZWRUcmFuc2Zvcm1zID0gJyc7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgYXBwbGllZFRyYW5zZm9ybXMgPSBlbDtcbiAgfSBlbHNlIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gY3NzKGVsLCAndHJhbnNmb3JtJyk7XG4gICAgICBpZiAodHJhbnNmb3JtICYmIHRyYW5zZm9ybSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGFwcGxpZWRUcmFuc2Zvcm1zID0gdHJhbnNmb3JtICsgJyAnICsgYXBwbGllZFRyYW5zZm9ybXM7XG4gICAgICB9XG4gICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gICAgfSB3aGlsZSAoIXNlbGZPbmx5ICYmIChlbCA9IGVsLnBhcmVudE5vZGUpKTtcbiAgfVxuICB2YXIgbWF0cml4Rm4gPSB3aW5kb3cuRE9NTWF0cml4IHx8IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXggfHwgd2luZG93LkNTU01hdHJpeCB8fCB3aW5kb3cuTVNDU1NNYXRyaXg7XG4gIC8qanNoaW50IC1XMDU2ICovXG4gIHJldHVybiBtYXRyaXhGbiAmJiBuZXcgbWF0cml4Rm4oYXBwbGllZFRyYW5zZm9ybXMpO1xufVxuZnVuY3Rpb24gZmluZChjdHgsIHRhZ05hbWUsIGl0ZXJhdG9yKSB7XG4gIGlmIChjdHgpIHtcbiAgICB2YXIgbGlzdCA9IGN0eC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKSxcbiAgICAgIGkgPSAwLFxuICAgICAgbiA9IGxpc3QubGVuZ3RoO1xuICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaXRlcmF0b3IobGlzdFtpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSB7XG4gIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudDtcbiAgaWYgKHNjcm9sbGluZ0VsZW1lbnQpIHtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBcImJvdW5kaW5nIGNsaWVudCByZWN0XCIgb2YgZ2l2ZW4gZWxlbWVudFxyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgICAgICAgICAgICAgICAgICAgIFRoZSBlbGVtZW50IHdob3NlIGJvdW5kaW5nQ2xpZW50UmVjdCBpcyB3YW50ZWRcclxuICogQHBhcmFtICB7W0Jvb2xlYW5dfSByZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrICBXaGV0aGVyIHRoZSByZWN0IHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgY29udGFpbmluZyBibG9jayBvZiAoaW5jbHVkaW5nKSB0aGUgY29udGFpbmVyXHJcbiAqIEBwYXJhbSAge1tCb29sZWFuXX0gcmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCAgV2hldGhlciB0aGUgcmVjdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIHJlbGF0aXZlIHBhcmVudCBvZiAoaW5jbHVkaW5nKSB0aGUgY29udGFpZW5yXHJcbiAqIEBwYXJhbSAge1tCb29sZWFuXX0gdW5kb1NjYWxlICAgICAgICAgICAgICAgICAgV2hldGhlciB0aGUgY29udGFpbmVyJ3Mgc2NhbGUoKSBzaG91bGQgYmUgdW5kb25lXHJcbiAqIEBwYXJhbSAge1tIVE1MRWxlbWVudF19IGNvbnRhaW5lciAgICAgICAgICAgICAgVGhlIHBhcmVudCB0aGUgZWxlbWVudCB3aWxsIGJlIHBsYWNlZCBpblxyXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBib3VuZGluZ0NsaWVudFJlY3Qgb2YgZWwsIHdpdGggc3BlY2lmaWVkIGFkanVzdG1lbnRzXHJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVjdChlbCwgcmVsYXRpdmVUb0NvbnRhaW5pbmdCbG9jaywgcmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCwgdW5kb1NjYWxlLCBjb250YWluZXIpIHtcbiAgaWYgKCFlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgZWwgIT09IHdpbmRvdykgcmV0dXJuO1xuICB2YXIgZWxSZWN0LCB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIGhlaWdodCwgd2lkdGg7XG4gIGlmIChlbCAhPT0gd2luZG93ICYmIGVsLnBhcmVudE5vZGUgJiYgZWwgIT09IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSkge1xuICAgIGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRvcCA9IGVsUmVjdC50b3A7XG4gICAgbGVmdCA9IGVsUmVjdC5sZWZ0O1xuICAgIGJvdHRvbSA9IGVsUmVjdC5ib3R0b207XG4gICAgcmlnaHQgPSBlbFJlY3QucmlnaHQ7XG4gICAgaGVpZ2h0ID0gZWxSZWN0LmhlaWdodDtcbiAgICB3aWR0aCA9IGVsUmVjdC53aWR0aDtcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSAwO1xuICAgIGxlZnQgPSAwO1xuICAgIGJvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICByaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICB9XG4gIGlmICgocmVsYXRpdmVUb0NvbnRhaW5pbmdCbG9jayB8fCByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50KSAmJiBlbCAhPT0gd2luZG93KSB7XG4gICAgLy8gQWRqdXN0IGZvciB0cmFuc2xhdGUoKVxuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBlbC5wYXJlbnROb2RlO1xuXG4gICAgLy8gc29sdmVzICMxMTIzIChzZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNzk1MzgwNi82MDg4MzEyKVxuICAgIC8vIE5vdCBuZWVkZWQgb24gPD0gSUUxMVxuICAgIGlmICghSUUxMU9yTGVzcykge1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgKGNzcyhjb250YWluZXIsICd0cmFuc2Zvcm0nKSAhPT0gJ25vbmUnIHx8IHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQgJiYgY3NzKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJykgIT09ICdzdGF0aWMnKSkge1xuICAgICAgICAgIHZhciBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgLy8gU2V0IHJlbGF0aXZlIHRvIGVkZ2VzIG9mIHBhZGRpbmcgYm94IG9mIGNvbnRhaW5lclxuICAgICAgICAgIHRvcCAtPSBjb250YWluZXJSZWN0LnRvcCArIHBhcnNlSW50KGNzcyhjb250YWluZXIsICdib3JkZXItdG9wLXdpZHRoJykpO1xuICAgICAgICAgIGxlZnQgLT0gY29udGFpbmVyUmVjdC5sZWZ0ICsgcGFyc2VJbnQoY3NzKGNvbnRhaW5lciwgJ2JvcmRlci1sZWZ0LXdpZHRoJykpO1xuICAgICAgICAgIGJvdHRvbSA9IHRvcCArIGVsUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgcmlnaHQgPSBsZWZ0ICsgZWxSZWN0LndpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICAgIH0gd2hpbGUgKGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlKTtcbiAgICB9XG4gIH1cbiAgaWYgKHVuZG9TY2FsZSAmJiBlbCAhPT0gd2luZG93KSB7XG4gICAgLy8gQWRqdXN0IGZvciBzY2FsZSgpXG4gICAgdmFyIGVsTWF0cml4ID0gbWF0cml4KGNvbnRhaW5lciB8fCBlbCksXG4gICAgICBzY2FsZVggPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5hLFxuICAgICAgc2NhbGVZID0gZWxNYXRyaXggJiYgZWxNYXRyaXguZDtcbiAgICBpZiAoZWxNYXRyaXgpIHtcbiAgICAgIHRvcCAvPSBzY2FsZVk7XG4gICAgICBsZWZ0IC89IHNjYWxlWDtcbiAgICAgIHdpZHRoIC89IHNjYWxlWDtcbiAgICAgIGhlaWdodCAvPSBzY2FsZVk7XG4gICAgICBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gICAgICByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHRvcCxcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIGJvdHRvbTogYm90dG9tLFxuICAgIHJpZ2h0OiByaWdodCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn1cblxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHNpZGUgb2YgYW4gZWxlbWVudCBpcyBzY3JvbGxlZCBwYXN0IGEgc2lkZSBvZiBpdHMgcGFyZW50c1xyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gIGVsICAgICAgICAgICBUaGUgZWxlbWVudCB3aG8ncyBzaWRlIGJlaW5nIHNjcm9sbGVkIG91dCBvZiB2aWV3IGlzIGluIHF1ZXN0aW9uXHJcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgZWxTaWRlICAgICAgIFNpZGUgb2YgdGhlIGVsZW1lbnQgaW4gcXVlc3Rpb24gKCd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nKVxyXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIHBhcmVudFNpZGUgICBTaWRlIG9mIHRoZSBwYXJlbnQgaW4gcXVlc3Rpb24gKCd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nKVxyXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICAgICAgICAgICAgICBUaGUgcGFyZW50IHNjcm9sbCBlbGVtZW50IHRoYXQgdGhlIGVsJ3Mgc2lkZSBpcyBzY3JvbGxlZCBwYXN0LCBvciBudWxsIGlmIHRoZXJlIGlzIG5vIHN1Y2ggZWxlbWVudFxyXG4gKi9cbmZ1bmN0aW9uIGlzU2Nyb2xsZWRQYXN0KGVsLCBlbFNpZGUsIHBhcmVudFNpZGUpIHtcbiAgdmFyIHBhcmVudCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsLCB0cnVlKSxcbiAgICBlbFNpZGVWYWwgPSBnZXRSZWN0KGVsKVtlbFNpZGVdO1xuXG4gIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIHZhciBwYXJlbnRTaWRlVmFsID0gZ2V0UmVjdChwYXJlbnQpW3BhcmVudFNpZGVdLFxuICAgICAgdmlzaWJsZSA9IHZvaWQgMDtcbiAgICBpZiAocGFyZW50U2lkZSA9PT0gJ3RvcCcgfHwgcGFyZW50U2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICB2aXNpYmxlID0gZWxTaWRlVmFsID49IHBhcmVudFNpZGVWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpc2libGUgPSBlbFNpZGVWYWwgPD0gcGFyZW50U2lkZVZhbDtcbiAgICB9XG4gICAgaWYgKCF2aXNpYmxlKSByZXR1cm4gcGFyZW50O1xuICAgIGlmIChwYXJlbnQgPT09IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSkgYnJlYWs7XG4gICAgcGFyZW50ID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQocGFyZW50LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcclxuICogR2V0cyBudGggY2hpbGQgb2YgZWwsIGlnbm9yaW5nIGhpZGRlbiBjaGlsZHJlbiwgc29ydGFibGUncyBlbGVtZW50cyAoZG9lcyBub3QgaWdub3JlIGNsb25lIGlmIGl0J3MgdmlzaWJsZSlcclxuICogYW5kIG5vbi1kcmFnZ2FibGUgZWxlbWVudHNcclxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgICAgIFRoZSBwYXJlbnQgZWxlbWVudFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNoaWxkTnVtICAgICAgVGhlIGluZGV4IG9mIHRoZSBjaGlsZFxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgICAgICAgUGFyZW50IFNvcnRhYmxlJ3Mgb3B0aW9uc1xyXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICAgICAgICAgVGhlIGNoaWxkIGF0IGluZGV4IGNoaWxkTnVtLCBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gKi9cbmZ1bmN0aW9uIGdldENoaWxkKGVsLCBjaGlsZE51bSwgb3B0aW9ucywgaW5jbHVkZURyYWdFbCkge1xuICB2YXIgY3VycmVudENoaWxkID0gMCxcbiAgICBpID0gMCxcbiAgICBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICB3aGlsZSAoaSA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGlmIChjaGlsZHJlbltpXS5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScgJiYgY2hpbGRyZW5baV0gIT09IFNvcnRhYmxlLmdob3N0ICYmIChpbmNsdWRlRHJhZ0VsIHx8IGNoaWxkcmVuW2ldICE9PSBTb3J0YWJsZS5kcmFnZ2VkKSAmJiBjbG9zZXN0KGNoaWxkcmVuW2ldLCBvcHRpb25zLmRyYWdnYWJsZSwgZWwsIGZhbHNlKSkge1xuICAgICAgaWYgKGN1cnJlbnRDaGlsZCA9PT0gY2hpbGROdW0pIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldO1xuICAgICAgfVxuICAgICAgY3VycmVudENoaWxkKys7XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXHJcbiAqIEdldHMgdGhlIGxhc3QgY2hpbGQgaW4gdGhlIGVsLCBpZ25vcmluZyBnaG9zdEVsIG9yIGludmlzaWJsZSBlbGVtZW50cyAoY2xvbmVzKVxyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgICAgUGFyZW50IGVsZW1lbnRcclxuICogQHBhcmFtICB7c2VsZWN0b3J9IHNlbGVjdG9yICAgIEFueSBvdGhlciBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBpZ25vcmVkXHJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICBUaGUgbGFzdCBjaGlsZCwgaWdub3JpbmcgZ2hvc3RFbFxyXG4gKi9cbmZ1bmN0aW9uIGxhc3RDaGlsZChlbCwgc2VsZWN0b3IpIHtcbiAgdmFyIGxhc3QgPSBlbC5sYXN0RWxlbWVudENoaWxkO1xuICB3aGlsZSAobGFzdCAmJiAobGFzdCA9PT0gU29ydGFibGUuZ2hvc3QgfHwgY3NzKGxhc3QsICdkaXNwbGF5JykgPT09ICdub25lJyB8fCBzZWxlY3RvciAmJiAhbWF0Y2hlcyhsYXN0LCBzZWxlY3RvcikpKSB7XG4gICAgbGFzdCA9IGxhc3QucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgfVxuICByZXR1cm4gbGFzdCB8fCBudWxsO1xufVxuXG4vKipcclxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgYW4gZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudCBmb3IgYSBzZWxlY3RlZCBzZXQgb2ZcclxuICogZWxlbWVudHNcclxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsXHJcbiAqIEBwYXJhbSAge3NlbGVjdG9yfSBzZWxlY3RvclxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAqL1xuZnVuY3Rpb24gaW5kZXgoZWwsIHNlbGVjdG9yKSB7XG4gIHZhciBpbmRleCA9IDA7XG4gIGlmICghZWwgfHwgIWVsLnBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gIHdoaWxlIChlbCA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICBpZiAoZWwubm9kZU5hbWUudG9VcHBlckNhc2UoKSAhPT0gJ1RFTVBMQVRFJyAmJiBlbCAhPT0gU29ydGFibGUuY2xvbmUgJiYgKCFzZWxlY3RvciB8fCBtYXRjaGVzKGVsLCBzZWxlY3RvcikpKSB7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5kZXg7XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGwgb2Zmc2V0IG9mIHRoZSBnaXZlbiBlbGVtZW50LCBhZGRlZCB3aXRoIGFsbCB0aGUgc2Nyb2xsIG9mZnNldHMgb2YgcGFyZW50IGVsZW1lbnRzLlxyXG4gKiBUaGUgdmFsdWUgaXMgcmV0dXJuZWQgaW4gcmVhbCBwaXhlbHMuXHJcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbFxyXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgT2Zmc2V0cyBpbiB0aGUgZm9ybWF0IG9mIFtsZWZ0LCB0b3BdXHJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQoZWwpIHtcbiAgdmFyIG9mZnNldExlZnQgPSAwLFxuICAgIG9mZnNldFRvcCA9IDAsXG4gICAgd2luU2Nyb2xsZXIgPSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gIGlmIChlbCkge1xuICAgIGRvIHtcbiAgICAgIHZhciBlbE1hdHJpeCA9IG1hdHJpeChlbCksXG4gICAgICAgIHNjYWxlWCA9IGVsTWF0cml4LmEsXG4gICAgICAgIHNjYWxlWSA9IGVsTWF0cml4LmQ7XG4gICAgICBvZmZzZXRMZWZ0ICs9IGVsLnNjcm9sbExlZnQgKiBzY2FsZVg7XG4gICAgICBvZmZzZXRUb3AgKz0gZWwuc2Nyb2xsVG9wICogc2NhbGVZO1xuICAgIH0gd2hpbGUgKGVsICE9PSB3aW5TY3JvbGxlciAmJiAoZWwgPSBlbC5wYXJlbnROb2RlKSk7XG4gIH1cbiAgcmV0dXJuIFtvZmZzZXRMZWZ0LCBvZmZzZXRUb3BdO1xufVxuXG4vKipcclxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG9iamVjdCB3aXRoaW4gdGhlIGdpdmVuIGFycmF5XHJcbiAqIEBwYXJhbSAge0FycmF5fSBhcnIgICBBcnJheSB0aGF0IG1heSBvciBtYXkgbm90IGhvbGQgdGhlIG9iamVjdFxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iaiAgQW4gb2JqZWN0IHRoYXQgaGFzIGEga2V5LXZhbHVlIHBhaXIgdW5pcXVlIHRvIGFuZCBpZGVudGljYWwgdG8gYSBrZXktdmFsdWUgcGFpciBpbiB0aGUgb2JqZWN0IHlvdSB3YW50IHRvIGZpbmRcclxuICogQHJldHVybiB7TnVtYmVyfSAgICAgIFRoZSBpbmRleCBvZiB0aGUgb2JqZWN0IGluIHRoZSBhcnJheSwgb3IgLTFcclxuICovXG5mdW5jdGlvbiBpbmRleE9mT2JqZWN0KGFyciwgb2JqKSB7XG4gIGZvciAodmFyIGkgaW4gYXJyKSB7XG4gICAgaWYgKCFhcnIuaGFzT3duUHJvcGVydHkoaSkpIGNvbnRpbnVlO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiBvYmpba2V5XSA9PT0gYXJyW2ldW2tleV0pIHJldHVybiBOdW1iZXIoaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsLCBpbmNsdWRlU2VsZikge1xuICAvLyBza2lwIHRvIHdpbmRvd1xuICBpZiAoIWVsIHx8ICFlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHJldHVybiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gIHZhciBlbGVtID0gZWw7XG4gIHZhciBnb3RTZWxmID0gZmFsc2U7XG4gIGRvIHtcbiAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIGdldCBlbGVtIGNzcyBpZiBpdCBpc24ndCBldmVuIG92ZXJmbG93aW5nIGluIHRoZSBmaXJzdCBwbGFjZSAocGVyZm9ybWFuY2UpXG4gICAgaWYgKGVsZW0uY2xpZW50V2lkdGggPCBlbGVtLnNjcm9sbFdpZHRoIHx8IGVsZW0uY2xpZW50SGVpZ2h0IDwgZWxlbS5zY3JvbGxIZWlnaHQpIHtcbiAgICAgIHZhciBlbGVtQ1NTID0gY3NzKGVsZW0pO1xuICAgICAgaWYgKGVsZW0uY2xpZW50V2lkdGggPCBlbGVtLnNjcm9sbFdpZHRoICYmIChlbGVtQ1NTLm92ZXJmbG93WCA9PSAnYXV0bycgfHwgZWxlbUNTUy5vdmVyZmxvd1ggPT0gJ3Njcm9sbCcpIHx8IGVsZW0uY2xpZW50SGVpZ2h0IDwgZWxlbS5zY3JvbGxIZWlnaHQgJiYgKGVsZW1DU1Mub3ZlcmZsb3dZID09ICdhdXRvJyB8fCBlbGVtQ1NTLm92ZXJmbG93WSA9PSAnc2Nyb2xsJykpIHtcbiAgICAgICAgaWYgKCFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCB8fCBlbGVtID09PSBkb2N1bWVudC5ib2R5KSByZXR1cm4gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICBpZiAoZ290U2VsZiB8fCBpbmNsdWRlU2VsZikgcmV0dXJuIGVsZW07XG4gICAgICAgIGdvdFNlbGYgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gIH0gd2hpbGUgKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpO1xuICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xufVxuZnVuY3Rpb24gZXh0ZW5kKGRzdCwgc3JjKSB7XG4gIGlmIChkc3QgJiYgc3JjKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkc3Q7XG59XG5mdW5jdGlvbiBpc1JlY3RFcXVhbChyZWN0MSwgcmVjdDIpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQocmVjdDEudG9wKSA9PT0gTWF0aC5yb3VuZChyZWN0Mi50b3ApICYmIE1hdGgucm91bmQocmVjdDEubGVmdCkgPT09IE1hdGgucm91bmQocmVjdDIubGVmdCkgJiYgTWF0aC5yb3VuZChyZWN0MS5oZWlnaHQpID09PSBNYXRoLnJvdW5kKHJlY3QyLmhlaWdodCkgJiYgTWF0aC5yb3VuZChyZWN0MS53aWR0aCkgPT09IE1hdGgucm91bmQocmVjdDIud2lkdGgpO1xufVxudmFyIF90aHJvdHRsZVRpbWVvdXQ7XG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaywgbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIV90aHJvdHRsZVRpbWVvdXQpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChfdGhpcywgYXJnc1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjay5hcHBseShfdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICBfdGhyb3R0bGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aHJvdHRsZVRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICB9LCBtcyk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY2FuY2VsVGhyb3R0bGUoKSB7XG4gIGNsZWFyVGltZW91dChfdGhyb3R0bGVUaW1lb3V0KTtcbiAgX3Rocm90dGxlVGltZW91dCA9IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHNjcm9sbEJ5KGVsLCB4LCB5KSB7XG4gIGVsLnNjcm9sbExlZnQgKz0geDtcbiAgZWwuc2Nyb2xsVG9wICs9IHk7XG59XG5mdW5jdGlvbiBjbG9uZShlbCkge1xuICB2YXIgUG9seW1lciA9IHdpbmRvdy5Qb2x5bWVyO1xuICB2YXIgJCA9IHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvO1xuICBpZiAoUG9seW1lciAmJiBQb2x5bWVyLmRvbSkge1xuICAgIHJldHVybiBQb2x5bWVyLmRvbShlbCkuY2xvbmVOb2RlKHRydWUpO1xuICB9IGVsc2UgaWYgKCQpIHtcbiAgICByZXR1cm4gJChlbCkuY2xvbmUodHJ1ZSlbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsLmNsb25lTm9kZSh0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0UmVjdChlbCwgcmVjdCkge1xuICBjc3MoZWwsICdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICBjc3MoZWwsICd0b3AnLCByZWN0LnRvcCk7XG4gIGNzcyhlbCwgJ2xlZnQnLCByZWN0LmxlZnQpO1xuICBjc3MoZWwsICd3aWR0aCcsIHJlY3Qud2lkdGgpO1xuICBjc3MoZWwsICdoZWlnaHQnLCByZWN0LmhlaWdodCk7XG59XG5mdW5jdGlvbiB1bnNldFJlY3QoZWwpIHtcbiAgY3NzKGVsLCAncG9zaXRpb24nLCAnJyk7XG4gIGNzcyhlbCwgJ3RvcCcsICcnKTtcbiAgY3NzKGVsLCAnbGVmdCcsICcnKTtcbiAgY3NzKGVsLCAnd2lkdGgnLCAnJyk7XG4gIGNzcyhlbCwgJ2hlaWdodCcsICcnKTtcbn1cbmZ1bmN0aW9uIGdldENoaWxkQ29udGFpbmluZ1JlY3RGcm9tRWxlbWVudChjb250YWluZXIsIG9wdGlvbnMsIGdob3N0RWwpIHtcbiAgdmFyIHJlY3QgPSB7fTtcbiAgQXJyYXkuZnJvbShjb250YWluZXIuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdmFyIF9yZWN0JGxlZnQsIF9yZWN0JHRvcCwgX3JlY3QkcmlnaHQsIF9yZWN0JGJvdHRvbTtcbiAgICBpZiAoIWNsb3Nlc3QoY2hpbGQsIG9wdGlvbnMuZHJhZ2dhYmxlLCBjb250YWluZXIsIGZhbHNlKSB8fCBjaGlsZC5hbmltYXRlZCB8fCBjaGlsZCA9PT0gZ2hvc3RFbCkgcmV0dXJuO1xuICAgIHZhciBjaGlsZFJlY3QgPSBnZXRSZWN0KGNoaWxkKTtcbiAgICByZWN0LmxlZnQgPSBNYXRoLm1pbigoX3JlY3QkbGVmdCA9IHJlY3QubGVmdCkgIT09IG51bGwgJiYgX3JlY3QkbGVmdCAhPT0gdm9pZCAwID8gX3JlY3QkbGVmdCA6IEluZmluaXR5LCBjaGlsZFJlY3QubGVmdCk7XG4gICAgcmVjdC50b3AgPSBNYXRoLm1pbigoX3JlY3QkdG9wID0gcmVjdC50b3ApICE9PSBudWxsICYmIF9yZWN0JHRvcCAhPT0gdm9pZCAwID8gX3JlY3QkdG9wIDogSW5maW5pdHksIGNoaWxkUmVjdC50b3ApO1xuICAgIHJlY3QucmlnaHQgPSBNYXRoLm1heCgoX3JlY3QkcmlnaHQgPSByZWN0LnJpZ2h0KSAhPT0gbnVsbCAmJiBfcmVjdCRyaWdodCAhPT0gdm9pZCAwID8gX3JlY3QkcmlnaHQgOiAtSW5maW5pdHksIGNoaWxkUmVjdC5yaWdodCk7XG4gICAgcmVjdC5ib3R0b20gPSBNYXRoLm1heCgoX3JlY3QkYm90dG9tID0gcmVjdC5ib3R0b20pICE9PSBudWxsICYmIF9yZWN0JGJvdHRvbSAhPT0gdm9pZCAwID8gX3JlY3QkYm90dG9tIDogLUluZmluaXR5LCBjaGlsZFJlY3QuYm90dG9tKTtcbiAgfSk7XG4gIHJlY3Qud2lkdGggPSByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0O1xuICByZWN0LmhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3A7XG4gIHJlY3QueCA9IHJlY3QubGVmdDtcbiAgcmVjdC55ID0gcmVjdC50b3A7XG4gIHJldHVybiByZWN0O1xufVxudmFyIGV4cGFuZG8gPSAnU29ydGFibGUnICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbmZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlTWFuYWdlcigpIHtcbiAgdmFyIGFuaW1hdGlvblN0YXRlcyA9IFtdLFxuICAgIGFuaW1hdGlvbkNhbGxiYWNrSWQ7XG4gIHJldHVybiB7XG4gICAgY2FwdHVyZUFuaW1hdGlvblN0YXRlOiBmdW5jdGlvbiBjYXB0dXJlQW5pbWF0aW9uU3RhdGUoKSB7XG4gICAgICBhbmltYXRpb25TdGF0ZXMgPSBbXTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmFuaW1hdGlvbikgcmV0dXJuO1xuICAgICAgdmFyIGNoaWxkcmVuID0gW10uc2xpY2UuY2FsbCh0aGlzLmVsLmNoaWxkcmVuKTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChjc3MoY2hpbGQsICdkaXNwbGF5JykgPT09ICdub25lJyB8fCBjaGlsZCA9PT0gU29ydGFibGUuZ2hvc3QpIHJldHVybjtcbiAgICAgICAgYW5pbWF0aW9uU3RhdGVzLnB1c2goe1xuICAgICAgICAgIHRhcmdldDogY2hpbGQsXG4gICAgICAgICAgcmVjdDogZ2V0UmVjdChjaGlsZClcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBmcm9tUmVjdCA9IF9vYmplY3RTcHJlYWQyKHt9LCBhbmltYXRpb25TdGF0ZXNbYW5pbWF0aW9uU3RhdGVzLmxlbmd0aCAtIDFdLnJlY3QpO1xuXG4gICAgICAgIC8vIElmIGFuaW1hdGluZzogY29tcGVuc2F0ZSBmb3IgY3VycmVudCBhbmltYXRpb25cbiAgICAgICAgaWYgKGNoaWxkLnRoaXNBbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgIHZhciBjaGlsZE1hdHJpeCA9IG1hdHJpeChjaGlsZCwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKGNoaWxkTWF0cml4KSB7XG4gICAgICAgICAgICBmcm9tUmVjdC50b3AgLT0gY2hpbGRNYXRyaXguZjtcbiAgICAgICAgICAgIGZyb21SZWN0LmxlZnQgLT0gY2hpbGRNYXRyaXguZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQuZnJvbVJlY3QgPSBmcm9tUmVjdDtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYWRkQW5pbWF0aW9uU3RhdGU6IGZ1bmN0aW9uIGFkZEFuaW1hdGlvblN0YXRlKHN0YXRlKSB7XG4gICAgICBhbmltYXRpb25TdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgfSxcbiAgICByZW1vdmVBbmltYXRpb25TdGF0ZTogZnVuY3Rpb24gcmVtb3ZlQW5pbWF0aW9uU3RhdGUodGFyZ2V0KSB7XG4gICAgICBhbmltYXRpb25TdGF0ZXMuc3BsaWNlKGluZGV4T2ZPYmplY3QoYW5pbWF0aW9uU3RhdGVzLCB7XG4gICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICB9KSwgMSk7XG4gICAgfSxcbiAgICBhbmltYXRlQWxsOiBmdW5jdGlvbiBhbmltYXRlQWxsKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25DYWxsYmFja0lkKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGFuaW1hdGluZyA9IGZhbHNlLFxuICAgICAgICBhbmltYXRpb25UaW1lID0gMDtcbiAgICAgIGFuaW1hdGlvblN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgdGltZSA9IDAsXG4gICAgICAgICAgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0LFxuICAgICAgICAgIGZyb21SZWN0ID0gdGFyZ2V0LmZyb21SZWN0LFxuICAgICAgICAgIHRvUmVjdCA9IGdldFJlY3QodGFyZ2V0KSxcbiAgICAgICAgICBwcmV2RnJvbVJlY3QgPSB0YXJnZXQucHJldkZyb21SZWN0LFxuICAgICAgICAgIHByZXZUb1JlY3QgPSB0YXJnZXQucHJldlRvUmVjdCxcbiAgICAgICAgICBhbmltYXRpbmdSZWN0ID0gc3RhdGUucmVjdCxcbiAgICAgICAgICB0YXJnZXRNYXRyaXggPSBtYXRyaXgodGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgaWYgKHRhcmdldE1hdHJpeCkge1xuICAgICAgICAgIC8vIENvbXBlbnNhdGUgZm9yIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICAgICAgdG9SZWN0LnRvcCAtPSB0YXJnZXRNYXRyaXguZjtcbiAgICAgICAgICB0b1JlY3QubGVmdCAtPSB0YXJnZXRNYXRyaXguZTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQudG9SZWN0ID0gdG9SZWN0O1xuICAgICAgICBpZiAodGFyZ2V0LnRoaXNBbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgIC8vIENvdWxkIGFsc28gY2hlY2sgaWYgYW5pbWF0aW5nUmVjdCBpcyBiZXR3ZWVuIGZyb21SZWN0IGFuZCB0b1JlY3RcbiAgICAgICAgICBpZiAoaXNSZWN0RXF1YWwocHJldkZyb21SZWN0LCB0b1JlY3QpICYmICFpc1JlY3RFcXVhbChmcm9tUmVjdCwgdG9SZWN0KSAmJlxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBhbmltYXRpbmdSZWN0IGlzIG9uIGxpbmUgYmV0d2VlbiB0b1JlY3QgJiBmcm9tUmVjdFxuICAgICAgICAgIChhbmltYXRpbmdSZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKGFuaW1hdGluZ1JlY3QubGVmdCAtIHRvUmVjdC5sZWZ0KSA9PT0gKGZyb21SZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKGZyb21SZWN0LmxlZnQgLSB0b1JlY3QubGVmdCkpIHtcbiAgICAgICAgICAgIC8vIElmIHJldHVybmluZyB0byBzYW1lIHBsYWNlIGFzIHN0YXJ0ZWQgZnJvbSBhbmltYXRpb24gYW5kIG9uIHNhbWUgYXhpc1xuICAgICAgICAgICAgdGltZSA9IGNhbGN1bGF0ZVJlYWxUaW1lKGFuaW1hdGluZ1JlY3QsIHByZXZGcm9tUmVjdCwgcHJldlRvUmVjdCwgX3RoaXMub3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgZnJvbVJlY3QgIT0gdG9SZWN0OiBhbmltYXRlXG4gICAgICAgIGlmICghaXNSZWN0RXF1YWwodG9SZWN0LCBmcm9tUmVjdCkpIHtcbiAgICAgICAgICB0YXJnZXQucHJldkZyb21SZWN0ID0gZnJvbVJlY3Q7XG4gICAgICAgICAgdGFyZ2V0LnByZXZUb1JlY3QgPSB0b1JlY3Q7XG4gICAgICAgICAgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICB0aW1lID0gX3RoaXMub3B0aW9ucy5hbmltYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzLmFuaW1hdGUodGFyZ2V0LCBhbmltYXRpbmdSZWN0LCB0b1JlY3QsIHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lKSB7XG4gICAgICAgICAgYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBhbmltYXRpb25UaW1lID0gTWF0aC5tYXgoYW5pbWF0aW9uVGltZSwgdGltZSk7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRhcmdldC5hbmltYXRpb25SZXNldFRpbWVyKTtcbiAgICAgICAgICB0YXJnZXQuYW5pbWF0aW9uUmVzZXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGFyZ2V0LmFuaW1hdGlvblRpbWUgPSAwO1xuICAgICAgICAgICAgdGFyZ2V0LnByZXZGcm9tUmVjdCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQuZnJvbVJlY3QgPSBudWxsO1xuICAgICAgICAgICAgdGFyZ2V0LnByZXZUb1JlY3QgPSBudWxsO1xuICAgICAgICAgICAgdGFyZ2V0LnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgfSwgdGltZSk7XG4gICAgICAgICAgdGFyZ2V0LnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IHRpbWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvbkNhbGxiYWNrSWQpO1xuICAgICAgaWYgKCFhbmltYXRpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuaW1hdGlvbkNhbGxiYWNrSWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgICB9LCBhbmltYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICAgIGFuaW1hdGlvblN0YXRlcyA9IFtdO1xuICAgIH0sXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24gYW5pbWF0ZSh0YXJnZXQsIGN1cnJlbnRSZWN0LCB0b1JlY3QsIGR1cmF0aW9uKSB7XG4gICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgIHZhciBlbE1hdHJpeCA9IG1hdHJpeCh0aGlzLmVsKSxcbiAgICAgICAgICBzY2FsZVggPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5hLFxuICAgICAgICAgIHNjYWxlWSA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmQsXG4gICAgICAgICAgdHJhbnNsYXRlWCA9IChjdXJyZW50UmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQpIC8gKHNjYWxlWCB8fCAxKSxcbiAgICAgICAgICB0cmFuc2xhdGVZID0gKGN1cnJlbnRSZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKHNjYWxlWSB8fCAxKTtcbiAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1ggPSAhIXRyYW5zbGF0ZVg7XG4gICAgICAgIHRhcmdldC5hbmltYXRpbmdZID0gISF0cmFuc2xhdGVZO1xuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKCcgKyB0cmFuc2xhdGVYICsgJ3B4LCcgKyB0cmFuc2xhdGVZICsgJ3B4LDApJyk7XG4gICAgICAgIHRoaXMuZm9yUmVwYWludER1bW15ID0gcmVwYWludCh0YXJnZXQpOyAvLyByZXBhaW50XG5cbiAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAndHJhbnNmb3JtICcgKyBkdXJhdGlvbiArICdtcycgKyAodGhpcy5vcHRpb25zLmVhc2luZyA/ICcgJyArIHRoaXMub3B0aW9ucy5lYXNpbmcgOiAnJykpO1xuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKDAsMCwwKScpO1xuICAgICAgICB0eXBlb2YgdGFyZ2V0LmFuaW1hdGVkID09PSAnbnVtYmVyJyAmJiBjbGVhclRpbWVvdXQodGFyZ2V0LmFuaW1hdGVkKTtcbiAgICAgICAgdGFyZ2V0LmFuaW1hdGVkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgICAgICB0YXJnZXQuYW5pbWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0YXJnZXQuYW5pbWF0aW5nWCA9IGZhbHNlO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRpbmdZID0gZmFsc2U7XG4gICAgICAgIH0sIGR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiByZXBhaW50KHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0Lm9mZnNldFdpZHRoO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVhbFRpbWUoYW5pbWF0aW5nUmVjdCwgZnJvbVJlY3QsIHRvUmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGZyb21SZWN0LnRvcCAtIGFuaW1hdGluZ1JlY3QudG9wLCAyKSArIE1hdGgucG93KGZyb21SZWN0LmxlZnQgLSBhbmltYXRpbmdSZWN0LmxlZnQsIDIpKSAvIE1hdGguc3FydChNYXRoLnBvdyhmcm9tUmVjdC50b3AgLSB0b1JlY3QudG9wLCAyKSArIE1hdGgucG93KGZyb21SZWN0LmxlZnQgLSB0b1JlY3QubGVmdCwgMikpICogb3B0aW9ucy5hbmltYXRpb247XG59XG5cbnZhciBwbHVnaW5zID0gW107XG52YXIgZGVmYXVsdHMgPSB7XG4gIGluaXRpYWxpemVCeURlZmF1bHQ6IHRydWVcbn07XG52YXIgUGx1Z2luTWFuYWdlciA9IHtcbiAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KHBsdWdpbikge1xuICAgIC8vIFNldCBkZWZhdWx0IHN0YXRpYyBwcm9wZXJ0aWVzXG4gICAgZm9yICh2YXIgb3B0aW9uIGluIGRlZmF1bHRzKSB7XG4gICAgICBpZiAoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkob3B0aW9uKSAmJiAhKG9wdGlvbiBpbiBwbHVnaW4pKSB7XG4gICAgICAgIHBsdWdpbltvcHRpb25dID0gZGVmYXVsdHNbb3B0aW9uXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICBpZiAocC5wbHVnaW5OYW1lID09PSBwbHVnaW4ucGx1Z2luTmFtZSkge1xuICAgICAgICB0aHJvdyBcIlNvcnRhYmxlOiBDYW5ub3QgbW91bnQgcGx1Z2luIFwiLmNvbmNhdChwbHVnaW4ucGx1Z2luTmFtZSwgXCIgbW9yZSB0aGFuIG9uY2VcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gIH0sXG4gIHBsdWdpbkV2ZW50OiBmdW5jdGlvbiBwbHVnaW5FdmVudChldmVudE5hbWUsIHNvcnRhYmxlLCBldnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuZXZlbnRDYW5jZWxlZCA9IGZhbHNlO1xuICAgIGV2dC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5ldmVudENhbmNlbGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIHZhciBldmVudE5hbWVHbG9iYWwgPSBldmVudE5hbWUgKyAnR2xvYmFsJztcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgaWYgKCFzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV0pIHJldHVybjtcbiAgICAgIC8vIEZpcmUgZ2xvYmFsIGV2ZW50cyBpZiBpdCBleGlzdHMgaW4gdGhpcyBzb3J0YWJsZVxuICAgICAgaWYgKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVHbG9iYWxdKSB7XG4gICAgICAgIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVHbG9iYWxdKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGVcbiAgICAgICAgfSwgZXZ0KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgZmlyZSBwbHVnaW4gZXZlbnQgaWYgcGx1Z2luIGlzIGVuYWJsZWQgaW4gdGhpcyBzb3J0YWJsZSxcbiAgICAgIC8vIGFuZCBwbHVnaW4gaGFzIGV2ZW50IGRlZmluZWRcbiAgICAgIGlmIChzb3J0YWJsZS5vcHRpb25zW3BsdWdpbi5wbHVnaW5OYW1lXSAmJiBzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV1bZXZlbnROYW1lXSkge1xuICAgICAgICBzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV1bZXZlbnROYW1lXShfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlXG4gICAgICAgIH0sIGV2dCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBpbml0aWFsaXplUGx1Z2luczogZnVuY3Rpb24gaW5pdGlhbGl6ZVBsdWdpbnMoc29ydGFibGUsIGVsLCBkZWZhdWx0cywgb3B0aW9ucykge1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICB2YXIgcGx1Z2luTmFtZSA9IHBsdWdpbi5wbHVnaW5OYW1lO1xuICAgICAgaWYgKCFzb3J0YWJsZS5vcHRpb25zW3BsdWdpbk5hbWVdICYmICFwbHVnaW4uaW5pdGlhbGl6ZUJ5RGVmYXVsdCkgcmV0dXJuO1xuICAgICAgdmFyIGluaXRpYWxpemVkID0gbmV3IHBsdWdpbihzb3J0YWJsZSwgZWwsIHNvcnRhYmxlLm9wdGlvbnMpO1xuICAgICAgaW5pdGlhbGl6ZWQuc29ydGFibGUgPSBzb3J0YWJsZTtcbiAgICAgIGluaXRpYWxpemVkLm9wdGlvbnMgPSBzb3J0YWJsZS5vcHRpb25zO1xuICAgICAgc29ydGFibGVbcGx1Z2luTmFtZV0gPSBpbml0aWFsaXplZDtcblxuICAgICAgLy8gQWRkIGRlZmF1bHQgb3B0aW9ucyBmcm9tIHBsdWdpblxuICAgICAgX2V4dGVuZHMoZGVmYXVsdHMsIGluaXRpYWxpemVkLmRlZmF1bHRzKTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBvcHRpb24gaW4gc29ydGFibGUub3B0aW9ucykge1xuICAgICAgaWYgKCFzb3J0YWJsZS5vcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIGNvbnRpbnVlO1xuICAgICAgdmFyIG1vZGlmaWVkID0gdGhpcy5tb2RpZnlPcHRpb24oc29ydGFibGUsIG9wdGlvbiwgc29ydGFibGUub3B0aW9uc1tvcHRpb25dKTtcbiAgICAgIGlmICh0eXBlb2YgbW9kaWZpZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNvcnRhYmxlLm9wdGlvbnNbb3B0aW9uXSA9IG1vZGlmaWVkO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZ2V0RXZlbnRQcm9wZXJ0aWVzOiBmdW5jdGlvbiBnZXRFdmVudFByb3BlcnRpZXMobmFtZSwgc29ydGFibGUpIHtcbiAgICB2YXIgZXZlbnRQcm9wZXJ0aWVzID0ge307XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luLmV2ZW50UHJvcGVydGllcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuICAgICAgX2V4dGVuZHMoZXZlbnRQcm9wZXJ0aWVzLCBwbHVnaW4uZXZlbnRQcm9wZXJ0aWVzLmNhbGwoc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdLCBuYW1lKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGV2ZW50UHJvcGVydGllcztcbiAgfSxcbiAgbW9kaWZ5T3B0aW9uOiBmdW5jdGlvbiBtb2RpZnlPcHRpb24oc29ydGFibGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIG1vZGlmaWVkVmFsdWU7XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIC8vIFBsdWdpbiBtdXN0IGV4aXN0IG9uIHRoZSBTb3J0YWJsZVxuICAgICAgaWYgKCFzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV0pIHJldHVybjtcblxuICAgICAgLy8gSWYgc3RhdGljIG9wdGlvbiBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgb3B0aW9uLCBjYWxsIGluIHRoZSBjb250ZXh0IG9mIHRoZSBTb3J0YWJsZSdzIGluc3RhbmNlIG9mIHRoaXMgcGx1Z2luXG4gICAgICBpZiAocGx1Z2luLm9wdGlvbkxpc3RlbmVycyAmJiB0eXBlb2YgcGx1Z2luLm9wdGlvbkxpc3RlbmVyc1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtb2RpZmllZFZhbHVlID0gcGx1Z2luLm9wdGlvbkxpc3RlbmVyc1tuYW1lXS5jYWxsKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtb2RpZmllZFZhbHVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KF9yZWYpIHtcbiAgdmFyIHNvcnRhYmxlID0gX3JlZi5zb3J0YWJsZSxcbiAgICByb290RWwgPSBfcmVmLnJvb3RFbCxcbiAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgIHRhcmdldEVsID0gX3JlZi50YXJnZXRFbCxcbiAgICBjbG9uZUVsID0gX3JlZi5jbG9uZUVsLFxuICAgIHRvRWwgPSBfcmVmLnRvRWwsXG4gICAgZnJvbUVsID0gX3JlZi5mcm9tRWwsXG4gICAgb2xkSW5kZXggPSBfcmVmLm9sZEluZGV4LFxuICAgIG5ld0luZGV4ID0gX3JlZi5uZXdJbmRleCxcbiAgICBvbGREcmFnZ2FibGVJbmRleCA9IF9yZWYub2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBfcmVmLm5ld0RyYWdnYWJsZUluZGV4LFxuICAgIG9yaWdpbmFsRXZlbnQgPSBfcmVmLm9yaWdpbmFsRXZlbnQsXG4gICAgcHV0U29ydGFibGUgPSBfcmVmLnB1dFNvcnRhYmxlLFxuICAgIGV4dHJhRXZlbnRQcm9wZXJ0aWVzID0gX3JlZi5leHRyYUV2ZW50UHJvcGVydGllcztcbiAgc29ydGFibGUgPSBzb3J0YWJsZSB8fCByb290RWwgJiYgcm9vdEVsW2V4cGFuZG9dO1xuICBpZiAoIXNvcnRhYmxlKSByZXR1cm47XG4gIHZhciBldnQsXG4gICAgb3B0aW9ucyA9IHNvcnRhYmxlLm9wdGlvbnMsXG4gICAgb25OYW1lID0gJ29uJyArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKTtcbiAgLy8gU3VwcG9ydCBmb3IgbmV3IEN1c3RvbUV2ZW50IGZlYXR1cmVcbiAgaWYgKHdpbmRvdy5DdXN0b21FdmVudCAmJiAhSUUxMU9yTGVzcyAmJiAhRWRnZSkge1xuICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChuYW1lLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2dC5pbml0RXZlbnQobmFtZSwgdHJ1ZSwgdHJ1ZSk7XG4gIH1cbiAgZXZ0LnRvID0gdG9FbCB8fCByb290RWw7XG4gIGV2dC5mcm9tID0gZnJvbUVsIHx8IHJvb3RFbDtcbiAgZXZ0Lml0ZW0gPSB0YXJnZXRFbCB8fCByb290RWw7XG4gIGV2dC5jbG9uZSA9IGNsb25lRWw7XG4gIGV2dC5vbGRJbmRleCA9IG9sZEluZGV4O1xuICBldnQubmV3SW5kZXggPSBuZXdJbmRleDtcbiAgZXZ0Lm9sZERyYWdnYWJsZUluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXg7XG4gIGV2dC5uZXdEcmFnZ2FibGVJbmRleCA9IG5ld0RyYWdnYWJsZUluZGV4O1xuICBldnQub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gIGV2dC5wdWxsTW9kZSA9IHB1dFNvcnRhYmxlID8gcHV0U29ydGFibGUubGFzdFB1dE1vZGUgOiB1bmRlZmluZWQ7XG4gIHZhciBhbGxFdmVudFByb3BlcnRpZXMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZXh0cmFFdmVudFByb3BlcnRpZXMpLCBQbHVnaW5NYW5hZ2VyLmdldEV2ZW50UHJvcGVydGllcyhuYW1lLCBzb3J0YWJsZSkpO1xuICBmb3IgKHZhciBvcHRpb24gaW4gYWxsRXZlbnRQcm9wZXJ0aWVzKSB7XG4gICAgZXZ0W29wdGlvbl0gPSBhbGxFdmVudFByb3BlcnRpZXNbb3B0aW9uXTtcbiAgfVxuICBpZiAocm9vdEVsKSB7XG4gICAgcm9vdEVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfVxuICBpZiAob3B0aW9uc1tvbk5hbWVdKSB7XG4gICAgb3B0aW9uc1tvbk5hbWVdLmNhbGwoc29ydGFibGUsIGV2dCk7XG4gIH1cbn1cblxudmFyIF9leGNsdWRlZCA9IFtcImV2dFwiXTtcbnZhciBwbHVnaW5FdmVudCA9IGZ1bmN0aW9uIHBsdWdpbkV2ZW50KGV2ZW50TmFtZSwgc29ydGFibGUpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgIG9yaWdpbmFsRXZlbnQgPSBfcmVmLmV2dCxcbiAgICBkYXRhID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG4gIFBsdWdpbk1hbmFnZXIucGx1Z2luRXZlbnQuYmluZChTb3J0YWJsZSkoZXZlbnROYW1lLCBzb3J0YWJsZSwgX29iamVjdFNwcmVhZDIoe1xuICAgIGRyYWdFbDogZHJhZ0VsLFxuICAgIHBhcmVudEVsOiBwYXJlbnRFbCxcbiAgICBnaG9zdEVsOiBnaG9zdEVsLFxuICAgIHJvb3RFbDogcm9vdEVsLFxuICAgIG5leHRFbDogbmV4dEVsLFxuICAgIGxhc3REb3duRWw6IGxhc3REb3duRWwsXG4gICAgY2xvbmVFbDogY2xvbmVFbCxcbiAgICBjbG9uZUhpZGRlbjogY2xvbmVIaWRkZW4sXG4gICAgZHJhZ1N0YXJ0ZWQ6IG1vdmVkLFxuICAgIHB1dFNvcnRhYmxlOiBwdXRTb3J0YWJsZSxcbiAgICBhY3RpdmVTb3J0YWJsZTogU29ydGFibGUuYWN0aXZlLFxuICAgIG9yaWdpbmFsRXZlbnQ6IG9yaWdpbmFsRXZlbnQsXG4gICAgb2xkSW5kZXg6IG9sZEluZGV4LFxuICAgIG9sZERyYWdnYWJsZUluZGV4OiBvbGREcmFnZ2FibGVJbmRleCxcbiAgICBuZXdJbmRleDogbmV3SW5kZXgsXG4gICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG5ld0RyYWdnYWJsZUluZGV4LFxuICAgIGhpZGVHaG9zdEZvclRhcmdldDogX2hpZGVHaG9zdEZvclRhcmdldCxcbiAgICB1bmhpZGVHaG9zdEZvclRhcmdldDogX3VuaGlkZUdob3N0Rm9yVGFyZ2V0LFxuICAgIGNsb25lTm93SGlkZGVuOiBmdW5jdGlvbiBjbG9uZU5vd0hpZGRlbigpIHtcbiAgICAgIGNsb25lSGlkZGVuID0gdHJ1ZTtcbiAgICB9LFxuICAgIGNsb25lTm93U2hvd246IGZ1bmN0aW9uIGNsb25lTm93U2hvd24oKSB7XG4gICAgICBjbG9uZUhpZGRlbiA9IGZhbHNlO1xuICAgIH0sXG4gICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50OiBmdW5jdGlvbiBkaXNwYXRjaFNvcnRhYmxlRXZlbnQobmFtZSkge1xuICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICBzb3J0YWJsZTogc29ydGFibGUsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IG9yaWdpbmFsRXZlbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgZGF0YSkpO1xufTtcbmZ1bmN0aW9uIF9kaXNwYXRjaEV2ZW50KGluZm8pIHtcbiAgZGlzcGF0Y2hFdmVudChfb2JqZWN0U3ByZWFkMih7XG4gICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlLFxuICAgIGNsb25lRWw6IGNsb25lRWwsXG4gICAgdGFyZ2V0RWw6IGRyYWdFbCxcbiAgICByb290RWw6IHJvb3RFbCxcbiAgICBvbGRJbmRleDogb2xkSW5kZXgsXG4gICAgb2xkRHJhZ2dhYmxlSW5kZXg6IG9sZERyYWdnYWJsZUluZGV4LFxuICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXhcbiAgfSwgaW5mbykpO1xufVxudmFyIGRyYWdFbCxcbiAgcGFyZW50RWwsXG4gIGdob3N0RWwsXG4gIHJvb3RFbCxcbiAgbmV4dEVsLFxuICBsYXN0RG93bkVsLFxuICBjbG9uZUVsLFxuICBjbG9uZUhpZGRlbixcbiAgb2xkSW5kZXgsXG4gIG5ld0luZGV4LFxuICBvbGREcmFnZ2FibGVJbmRleCxcbiAgbmV3RHJhZ2dhYmxlSW5kZXgsXG4gIGFjdGl2ZUdyb3VwLFxuICBwdXRTb3J0YWJsZSxcbiAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IGZhbHNlLFxuICBpZ25vcmVOZXh0Q2xpY2sgPSBmYWxzZSxcbiAgc29ydGFibGVzID0gW10sXG4gIHRhcEV2dCxcbiAgdG91Y2hFdnQsXG4gIGxhc3REeCxcbiAgbGFzdER5LFxuICB0YXBEaXN0YW5jZUxlZnQsXG4gIHRhcERpc3RhbmNlVG9wLFxuICBtb3ZlZCxcbiAgbGFzdFRhcmdldCxcbiAgbGFzdERpcmVjdGlvbixcbiAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2UsXG4gIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQgPSBmYWxzZSxcbiAgdGFyZ2V0TW92ZURpc3RhbmNlLFxuICAvLyBGb3IgcG9zaXRpb25pbmcgZ2hvc3QgYWJzb2x1dGVseVxuICBnaG9zdFJlbGF0aXZlUGFyZW50LFxuICBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbCA9IFtdLFxuICAvLyAobGVmdCwgdG9wKVxuXG4gIF9zaWxlbnQgPSBmYWxzZSxcbiAgc2F2ZWRJbnB1dENoZWNrZWQgPSBbXTtcblxuLyoqIEBjb25zdCAqL1xudmFyIGRvY3VtZW50RXhpc3RzID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgUG9zaXRpb25HaG9zdEFic29sdXRlbHkgPSBJT1MsXG4gIENTU0Zsb2F0UHJvcGVydHkgPSBFZGdlIHx8IElFMTFPckxlc3MgPyAnY3NzRmxvYXQnIDogJ2Zsb2F0JyxcbiAgLy8gVGhpcyB3aWxsIG5vdCBwYXNzIGZvciBJRTksIGJlY2F1c2UgSUU5IERuRCBvbmx5IHdvcmtzIG9uIGFuY2hvcnNcbiAgc3VwcG9ydERyYWdnYWJsZSA9IGRvY3VtZW50RXhpc3RzICYmICFDaHJvbWVGb3JBbmRyb2lkICYmICFJT1MgJiYgJ2RyYWdnYWJsZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gIHN1cHBvcnRDc3NQb2ludGVyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghZG9jdW1lbnRFeGlzdHMpIHJldHVybjtcbiAgICAvLyBmYWxzZSB3aGVuIDw9IElFMTFcbiAgICBpZiAoSUUxMU9yTGVzcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd4Jyk7XG4gICAgZWwuc3R5bGUuY3NzVGV4dCA9ICdwb2ludGVyLWV2ZW50czphdXRvJztcbiAgICByZXR1cm4gZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9PT0gJ2F1dG8nO1xuICB9KCksXG4gIF9kZXRlY3REaXJlY3Rpb24gPSBmdW5jdGlvbiBfZGV0ZWN0RGlyZWN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIGVsQ1NTID0gY3NzKGVsKSxcbiAgICAgIGVsV2lkdGggPSBwYXJzZUludChlbENTUy53aWR0aCkgLSBwYXJzZUludChlbENTUy5wYWRkaW5nTGVmdCkgLSBwYXJzZUludChlbENTUy5wYWRkaW5nUmlnaHQpIC0gcGFyc2VJbnQoZWxDU1MuYm9yZGVyTGVmdFdpZHRoKSAtIHBhcnNlSW50KGVsQ1NTLmJvcmRlclJpZ2h0V2lkdGgpLFxuICAgICAgY2hpbGQxID0gZ2V0Q2hpbGQoZWwsIDAsIG9wdGlvbnMpLFxuICAgICAgY2hpbGQyID0gZ2V0Q2hpbGQoZWwsIDEsIG9wdGlvbnMpLFxuICAgICAgZmlyc3RDaGlsZENTUyA9IGNoaWxkMSAmJiBjc3MoY2hpbGQxKSxcbiAgICAgIHNlY29uZENoaWxkQ1NTID0gY2hpbGQyICYmIGNzcyhjaGlsZDIpLFxuICAgICAgZmlyc3RDaGlsZFdpZHRoID0gZmlyc3RDaGlsZENTUyAmJiBwYXJzZUludChmaXJzdENoaWxkQ1NTLm1hcmdpbkxlZnQpICsgcGFyc2VJbnQoZmlyc3RDaGlsZENTUy5tYXJnaW5SaWdodCkgKyBnZXRSZWN0KGNoaWxkMSkud2lkdGgsXG4gICAgICBzZWNvbmRDaGlsZFdpZHRoID0gc2Vjb25kQ2hpbGRDU1MgJiYgcGFyc2VJbnQoc2Vjb25kQ2hpbGRDU1MubWFyZ2luTGVmdCkgKyBwYXJzZUludChzZWNvbmRDaGlsZENTUy5tYXJnaW5SaWdodCkgKyBnZXRSZWN0KGNoaWxkMikud2lkdGg7XG4gICAgaWYgKGVsQ1NTLmRpc3BsYXkgPT09ICdmbGV4Jykge1xuICAgICAgcmV0dXJuIGVsQ1NTLmZsZXhEaXJlY3Rpb24gPT09ICdjb2x1bW4nIHx8IGVsQ1NTLmZsZXhEaXJlY3Rpb24gPT09ICdjb2x1bW4tcmV2ZXJzZScgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICAgIH1cbiAgICBpZiAoZWxDU1MuZGlzcGxheSA9PT0gJ2dyaWQnKSB7XG4gICAgICByZXR1cm4gZWxDU1MuZ3JpZFRlbXBsYXRlQ29sdW1ucy5zcGxpdCgnICcpLmxlbmd0aCA8PSAxID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgICB9XG4gICAgaWYgKGNoaWxkMSAmJiBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gJiYgZmlyc3RDaGlsZENTU1tcImZsb2F0XCJdICE9PSAnbm9uZScpIHtcbiAgICAgIHZhciB0b3VjaGluZ1NpZGVDaGlsZDIgPSBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gPT09ICdsZWZ0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICByZXR1cm4gY2hpbGQyICYmIChzZWNvbmRDaGlsZENTUy5jbGVhciA9PT0gJ2JvdGgnIHx8IHNlY29uZENoaWxkQ1NTLmNsZWFyID09PSB0b3VjaGluZ1NpZGVDaGlsZDIpID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkMSAmJiAoZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAnYmxvY2snIHx8IGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ2ZsZXgnIHx8IGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ3RhYmxlJyB8fCBmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICdncmlkJyB8fCBmaXJzdENoaWxkV2lkdGggPj0gZWxXaWR0aCAmJiBlbENTU1tDU1NGbG9hdFByb3BlcnR5XSA9PT0gJ25vbmUnIHx8IGNoaWxkMiAmJiBlbENTU1tDU1NGbG9hdFByb3BlcnR5XSA9PT0gJ25vbmUnICYmIGZpcnN0Q2hpbGRXaWR0aCArIHNlY29uZENoaWxkV2lkdGggPiBlbFdpZHRoKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH0sXG4gIF9kcmFnRWxJblJvd0NvbHVtbiA9IGZ1bmN0aW9uIF9kcmFnRWxJblJvd0NvbHVtbihkcmFnUmVjdCwgdGFyZ2V0UmVjdCwgdmVydGljYWwpIHtcbiAgICB2YXIgZHJhZ0VsUzFPcHAgPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LmxlZnQgOiBkcmFnUmVjdC50b3AsXG4gICAgICBkcmFnRWxTMk9wcCA9IHZlcnRpY2FsID8gZHJhZ1JlY3QucmlnaHQgOiBkcmFnUmVjdC5ib3R0b20sXG4gICAgICBkcmFnRWxPcHBMZW5ndGggPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LndpZHRoIDogZHJhZ1JlY3QuaGVpZ2h0LFxuICAgICAgdGFyZ2V0UzFPcHAgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QubGVmdCA6IHRhcmdldFJlY3QudG9wLFxuICAgICAgdGFyZ2V0UzJPcHAgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QucmlnaHQgOiB0YXJnZXRSZWN0LmJvdHRvbSxcbiAgICAgIHRhcmdldE9wcExlbmd0aCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC53aWR0aCA6IHRhcmdldFJlY3QuaGVpZ2h0O1xuICAgIHJldHVybiBkcmFnRWxTMU9wcCA9PT0gdGFyZ2V0UzFPcHAgfHwgZHJhZ0VsUzJPcHAgPT09IHRhcmdldFMyT3BwIHx8IGRyYWdFbFMxT3BwICsgZHJhZ0VsT3BwTGVuZ3RoIC8gMiA9PT0gdGFyZ2V0UzFPcHAgKyB0YXJnZXRPcHBMZW5ndGggLyAyO1xuICB9LFxuICAvKipcclxuICAgKiBEZXRlY3RzIGZpcnN0IG5lYXJlc3QgZW1wdHkgc29ydGFibGUgdG8gWCBhbmQgWSBwb3NpdGlvbiB1c2luZyBlbXB0eUluc2VydFRocmVzaG9sZC5cclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHggICAgICBYIHBvc2l0aW9uXHJcbiAgICogQHBhcmFtICB7TnVtYmVyfSB5ICAgICAgWSBwb3NpdGlvblxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgIEVsZW1lbnQgb2YgdGhlIGZpcnN0IGZvdW5kIG5lYXJlc3QgU29ydGFibGVcclxuICAgKi9cbiAgX2RldGVjdE5lYXJlc3RFbXB0eVNvcnRhYmxlID0gZnVuY3Rpb24gX2RldGVjdE5lYXJlc3RFbXB0eVNvcnRhYmxlKHgsIHkpIHtcbiAgICB2YXIgcmV0O1xuICAgIHNvcnRhYmxlcy5zb21lKGZ1bmN0aW9uIChzb3J0YWJsZSkge1xuICAgICAgdmFyIHRocmVzaG9sZCA9IHNvcnRhYmxlW2V4cGFuZG9dLm9wdGlvbnMuZW1wdHlJbnNlcnRUaHJlc2hvbGQ7XG4gICAgICBpZiAoIXRocmVzaG9sZCB8fCBsYXN0Q2hpbGQoc29ydGFibGUpKSByZXR1cm47XG4gICAgICB2YXIgcmVjdCA9IGdldFJlY3Qoc29ydGFibGUpLFxuICAgICAgICBpbnNpZGVIb3Jpem9udGFsbHkgPSB4ID49IHJlY3QubGVmdCAtIHRocmVzaG9sZCAmJiB4IDw9IHJlY3QucmlnaHQgKyB0aHJlc2hvbGQsXG4gICAgICAgIGluc2lkZVZlcnRpY2FsbHkgPSB5ID49IHJlY3QudG9wIC0gdGhyZXNob2xkICYmIHkgPD0gcmVjdC5ib3R0b20gKyB0aHJlc2hvbGQ7XG4gICAgICBpZiAoaW5zaWRlSG9yaXpvbnRhbGx5ICYmIGluc2lkZVZlcnRpY2FsbHkpIHtcbiAgICAgICAgcmV0dXJuIHJldCA9IHNvcnRhYmxlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIF9wcmVwYXJlR3JvdXAgPSBmdW5jdGlvbiBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiB0b0ZuKHZhbHVlLCBwdWxsKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCkge1xuICAgICAgICB2YXIgc2FtZUdyb3VwID0gdG8ub3B0aW9ucy5ncm91cC5uYW1lICYmIGZyb20ub3B0aW9ucy5ncm91cC5uYW1lICYmIHRvLm9wdGlvbnMuZ3JvdXAubmFtZSA9PT0gZnJvbS5vcHRpb25zLmdyb3VwLm5hbWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIChwdWxsIHx8IHNhbWVHcm91cCkpIHtcbiAgICAgICAgICAvLyBEZWZhdWx0IHB1bGwgdmFsdWVcbiAgICAgICAgICAvLyBEZWZhdWx0IHB1bGwgYW5kIHB1dCB2YWx1ZSBpZiBzYW1lIGdyb3VwXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAocHVsbCAmJiB2YWx1ZSA9PT0gJ2Nsb25lJykge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gdG9Gbih2YWx1ZSh0bywgZnJvbSwgZHJhZ0VsLCBldnQpLCBwdWxsKSh0bywgZnJvbSwgZHJhZ0VsLCBldnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvdGhlckdyb3VwID0gKHB1bGwgPyB0byA6IGZyb20pLm9wdGlvbnMuZ3JvdXAubmFtZTtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZSA9PT0gb3RoZXJHcm91cCB8fCB2YWx1ZS5qb2luICYmIHZhbHVlLmluZGV4T2Yob3RoZXJHcm91cCkgPiAtMTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGdyb3VwID0ge307XG4gICAgdmFyIG9yaWdpbmFsR3JvdXAgPSBvcHRpb25zLmdyb3VwO1xuICAgIGlmICghb3JpZ2luYWxHcm91cCB8fCBfdHlwZW9mKG9yaWdpbmFsR3JvdXApICE9ICdvYmplY3QnKSB7XG4gICAgICBvcmlnaW5hbEdyb3VwID0ge1xuICAgICAgICBuYW1lOiBvcmlnaW5hbEdyb3VwXG4gICAgICB9O1xuICAgIH1cbiAgICBncm91cC5uYW1lID0gb3JpZ2luYWxHcm91cC5uYW1lO1xuICAgIGdyb3VwLmNoZWNrUHVsbCA9IHRvRm4ob3JpZ2luYWxHcm91cC5wdWxsLCB0cnVlKTtcbiAgICBncm91cC5jaGVja1B1dCA9IHRvRm4ob3JpZ2luYWxHcm91cC5wdXQpO1xuICAgIGdyb3VwLnJldmVydENsb25lID0gb3JpZ2luYWxHcm91cC5yZXZlcnRDbG9uZTtcbiAgICBvcHRpb25zLmdyb3VwID0gZ3JvdXA7XG4gIH0sXG4gIF9oaWRlR2hvc3RGb3JUYXJnZXQgPSBmdW5jdGlvbiBfaGlkZUdob3N0Rm9yVGFyZ2V0KCkge1xuICAgIGlmICghc3VwcG9ydENzc1BvaW50ZXJFdmVudHMgJiYgZ2hvc3RFbCkge1xuICAgICAgY3NzKGdob3N0RWwsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICB9XG4gIH0sXG4gIF91bmhpZGVHaG9zdEZvclRhcmdldCA9IGZ1bmN0aW9uIF91bmhpZGVHaG9zdEZvclRhcmdldCgpIHtcbiAgICBpZiAoIXN1cHBvcnRDc3NQb2ludGVyRXZlbnRzICYmIGdob3N0RWwpIHtcbiAgICAgIGNzcyhnaG9zdEVsLCAnZGlzcGxheScsICcnKTtcbiAgICB9XG4gIH07XG5cbi8vICMxMTg0IGZpeCAtIFByZXZlbnQgY2xpY2sgZXZlbnQgb24gZmFsbGJhY2sgaWYgZHJhZ2dlZCBidXQgaXRlbSBub3QgY2hhbmdlZCBwb3NpdGlvblxuaWYgKGRvY3VtZW50RXhpc3RzICYmICFDaHJvbWVGb3JBbmRyb2lkKSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xuICAgIGlmIChpZ25vcmVOZXh0Q2xpY2spIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbiAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBldnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uICYmIGV2dC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIGlnbm9yZU5leHRDbGljayA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG59XG52YXIgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQgPSBmdW5jdGlvbiBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudChldnQpIHtcbiAgaWYgKGRyYWdFbCkge1xuICAgIGV2dCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQ7XG4gICAgdmFyIG5lYXJlc3QgPSBfZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcbiAgICBpZiAobmVhcmVzdCkge1xuICAgICAgLy8gQ3JlYXRlIGltaXRhdGlvbiBldmVudFxuICAgICAgdmFyIGV2ZW50ID0ge307XG4gICAgICBmb3IgKHZhciBpIGluIGV2dCkge1xuICAgICAgICBpZiAoZXZ0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgZXZlbnRbaV0gPSBldnRbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LnJvb3RFbCA9IG5lYXJlc3Q7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IHZvaWQgMDtcbiAgICAgIG5lYXJlc3RbZXhwYW5kb10uX29uRHJhZ092ZXIoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcbnZhciBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwgPSBmdW5jdGlvbiBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwoZXZ0KSB7XG4gIGlmIChkcmFnRWwpIHtcbiAgICBkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5faXNPdXRzaWRlVGhpc0VsKGV2dC50YXJnZXQpO1xuICB9XG59O1xuXG4vKipcclxuICogQGNsYXNzICBTb3J0YWJsZVxyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gIGVsXHJcbiAqIEBwYXJhbSAge09iamVjdH0gICAgICAgW29wdGlvbnNdXHJcbiAqL1xuZnVuY3Rpb24gU29ydGFibGUoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKCEoZWwgJiYgZWwubm9kZVR5cGUgJiYgZWwubm9kZVR5cGUgPT09IDEpKSB7XG4gICAgdGhyb3cgXCJTb3J0YWJsZTogYGVsYCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50LCBub3QgXCIuY29uY2F0KHt9LnRvU3RyaW5nLmNhbGwoZWwpKTtcbiAgfVxuICB0aGlzLmVsID0gZWw7IC8vIHJvb3QgZWxlbWVudFxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMpO1xuXG4gIC8vIEV4cG9ydCBpbnN0YW5jZVxuICBlbFtleHBhbmRvXSA9IHRoaXM7XG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBncm91cDogbnVsbCxcbiAgICBzb3J0OiB0cnVlLFxuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBzdG9yZTogbnVsbCxcbiAgICBoYW5kbGU6IG51bGwsXG4gICAgZHJhZ2dhYmxlOiAvXlt1b11sJC9pLnRlc3QoZWwubm9kZU5hbWUpID8gJz5saScgOiAnPionLFxuICAgIHN3YXBUaHJlc2hvbGQ6IDEsXG4gICAgLy8gcGVyY2VudGFnZTsgMCA8PSB4IDw9IDFcbiAgICBpbnZlcnRTd2FwOiBmYWxzZSxcbiAgICAvLyBpbnZlcnQgYWx3YXlzXG4gICAgaW52ZXJ0ZWRTd2FwVGhyZXNob2xkOiBudWxsLFxuICAgIC8vIHdpbGwgYmUgc2V0IHRvIHNhbWUgYXMgc3dhcFRocmVzaG9sZCBpZiBkZWZhdWx0XG4gICAgcmVtb3ZlQ2xvbmVPbkhpZGU6IHRydWUsXG4gICAgZGlyZWN0aW9uOiBmdW5jdGlvbiBkaXJlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX2RldGVjdERpcmVjdGlvbihlbCwgdGhpcy5vcHRpb25zKTtcbiAgICB9LFxuICAgIGdob3N0Q2xhc3M6ICdzb3J0YWJsZS1naG9zdCcsXG4gICAgY2hvc2VuQ2xhc3M6ICdzb3J0YWJsZS1jaG9zZW4nLFxuICAgIGRyYWdDbGFzczogJ3NvcnRhYmxlLWRyYWcnLFxuICAgIGlnbm9yZTogJ2EsIGltZycsXG4gICAgZmlsdGVyOiBudWxsLFxuICAgIHByZXZlbnRPbkZpbHRlcjogdHJ1ZSxcbiAgICBhbmltYXRpb246IDAsXG4gICAgZWFzaW5nOiBudWxsLFxuICAgIHNldERhdGE6IGZ1bmN0aW9uIHNldERhdGEoZGF0YVRyYW5zZmVyLCBkcmFnRWwpIHtcbiAgICAgIGRhdGFUcmFuc2Zlci5zZXREYXRhKCdUZXh0JywgZHJhZ0VsLnRleHRDb250ZW50KTtcbiAgICB9LFxuICAgIGRyb3BCdWJibGU6IGZhbHNlLFxuICAgIGRyYWdvdmVyQnViYmxlOiBmYWxzZSxcbiAgICBkYXRhSWRBdHRyOiAnZGF0YS1pZCcsXG4gICAgZGVsYXk6IDAsXG4gICAgZGVsYXlPblRvdWNoT25seTogZmFsc2UsXG4gICAgdG91Y2hTdGFydFRocmVzaG9sZDogKE51bWJlci5wYXJzZUludCA/IE51bWJlciA6IHdpbmRvdykucGFyc2VJbnQod2luZG93LmRldmljZVBpeGVsUmF0aW8sIDEwKSB8fCAxLFxuICAgIGZvcmNlRmFsbGJhY2s6IGZhbHNlLFxuICAgIGZhbGxiYWNrQ2xhc3M6ICdzb3J0YWJsZS1mYWxsYmFjaycsXG4gICAgZmFsbGJhY2tPbkJvZHk6IGZhbHNlLFxuICAgIGZhbGxiYWNrVG9sZXJhbmNlOiAwLFxuICAgIGZhbGxiYWNrT2Zmc2V0OiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH0sXG4gICAgLy8gRGlzYWJsZWQgb24gU2FmYXJpOiAjMTU3MTsgRW5hYmxlZCBvbiBTYWZhcmkgSU9TOiAjMjI0NFxuICAgIHN1cHBvcnRQb2ludGVyOiBTb3J0YWJsZS5zdXBwb3J0UG9pbnRlciAhPT0gZmFsc2UgJiYgJ1BvaW50ZXJFdmVudCcgaW4gd2luZG93ICYmICghU2FmYXJpIHx8IElPUyksXG4gICAgZW1wdHlJbnNlcnRUaHJlc2hvbGQ6IDVcbiAgfTtcbiAgUGx1Z2luTWFuYWdlci5pbml0aWFsaXplUGx1Z2lucyh0aGlzLCBlbCwgZGVmYXVsdHMpO1xuXG4gIC8vIFNldCBkZWZhdWx0IG9wdGlvbnNcbiAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0cykge1xuICAgICEobmFtZSBpbiBvcHRpb25zKSAmJiAob3B0aW9uc1tuYW1lXSA9IGRlZmF1bHRzW25hbWVdKTtcbiAgfVxuICBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpO1xuXG4gIC8vIEJpbmQgYWxsIHByaXZhdGUgbWV0aG9kc1xuICBmb3IgKHZhciBmbiBpbiB0aGlzKSB7XG4gICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tmbl0gPSB0aGlzW2ZuXS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNldHVwIGRyYWcgbW9kZVxuICB0aGlzLm5hdGl2ZURyYWdnYWJsZSA9IG9wdGlvbnMuZm9yY2VGYWxsYmFjayA/IGZhbHNlIDogc3VwcG9ydERyYWdnYWJsZTtcbiAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgLy8gVG91Y2ggc3RhcnQgdGhyZXNob2xkIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIG5hdGl2ZSBkcmFnc3RhcnQgdGhyZXNob2xkXG4gICAgdGhpcy5vcHRpb25zLnRvdWNoU3RhcnRUaHJlc2hvbGQgPSAxO1xuICB9XG5cbiAgLy8gQmluZCBldmVudHNcbiAgaWYgKG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICBvbihlbCwgJ3BvaW50ZXJkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG4gIH0gZWxzZSB7XG4gICAgb24oZWwsICdtb3VzZWRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICBvbihlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgfVxuICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICBvbihlbCwgJ2RyYWdvdmVyJywgdGhpcyk7XG4gICAgb24oZWwsICdkcmFnZW50ZXInLCB0aGlzKTtcbiAgfVxuICBzb3J0YWJsZXMucHVzaCh0aGlzLmVsKTtcblxuICAvLyBSZXN0b3JlIHNvcnRpbmdcbiAgb3B0aW9ucy5zdG9yZSAmJiBvcHRpb25zLnN0b3JlLmdldCAmJiB0aGlzLnNvcnQob3B0aW9ucy5zdG9yZS5nZXQodGhpcykgfHwgW10pO1xuXG4gIC8vIEFkZCBhbmltYXRpb24gc3RhdGUgbWFuYWdlclxuICBfZXh0ZW5kcyh0aGlzLCBBbmltYXRpb25TdGF0ZU1hbmFnZXIoKSk7XG59XG5Tb3J0YWJsZS5wcm90b3R5cGUgPSAvKiogQGxlbmRzIFNvcnRhYmxlLnByb3RvdHlwZSAqL3tcbiAgY29uc3RydWN0b3I6IFNvcnRhYmxlLFxuICBfaXNPdXRzaWRlVGhpc0VsOiBmdW5jdGlvbiBfaXNPdXRzaWRlVGhpc0VsKHRhcmdldCkge1xuICAgIGlmICghdGhpcy5lbC5jb250YWlucyh0YXJnZXQpICYmIHRhcmdldCAhPT0gdGhpcy5lbCkge1xuICAgICAgbGFzdFRhcmdldCA9IG51bGw7XG4gICAgfVxuICB9LFxuICBfZ2V0RGlyZWN0aW9uOiBmdW5jdGlvbiBfZ2V0RGlyZWN0aW9uKGV2dCwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uID09PSAnZnVuY3Rpb24nID8gdGhpcy5vcHRpb25zLmRpcmVjdGlvbi5jYWxsKHRoaXMsIGV2dCwgdGFyZ2V0LCBkcmFnRWwpIDogdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgfSxcbiAgX29uVGFwU3RhcnQ6IGZ1bmN0aW9uIF9vblRhcFN0YXJ0KCAvKiogRXZlbnR8VG91Y2hFdmVudCAqL2V2dCkge1xuICAgIGlmICghZXZ0LmNhbmNlbGFibGUpIHJldHVybjtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgZWwgPSB0aGlzLmVsLFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIHByZXZlbnRPbkZpbHRlciA9IG9wdGlvbnMucHJldmVudE9uRmlsdGVyLFxuICAgICAgdHlwZSA9IGV2dC50eXBlLFxuICAgICAgdG91Y2ggPSBldnQudG91Y2hlcyAmJiBldnQudG91Y2hlc1swXSB8fCBldnQucG9pbnRlclR5cGUgJiYgZXZ0LnBvaW50ZXJUeXBlID09PSAndG91Y2gnICYmIGV2dCxcbiAgICAgIHRhcmdldCA9ICh0b3VjaCB8fCBldnQpLnRhcmdldCxcbiAgICAgIG9yaWdpbmFsVGFyZ2V0ID0gZXZ0LnRhcmdldC5zaGFkb3dSb290ICYmIChldnQucGF0aCAmJiBldnQucGF0aFswXSB8fCBldnQuY29tcG9zZWRQYXRoICYmIGV2dC5jb21wb3NlZFBhdGgoKVswXSkgfHwgdGFyZ2V0LFxuICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgX3NhdmVJbnB1dENoZWNrZWRTdGF0ZShlbCk7XG5cbiAgICAvLyBEb24ndCB0cmlnZ2VyIHN0YXJ0IGV2ZW50IHdoZW4gYW4gZWxlbWVudCBpcyBiZWVuIGRyYWdnZWQsIG90aGVyd2lzZSB0aGUgZXZ0Lm9sZGluZGV4IGFsd2F5cyB3cm9uZyB3aGVuIHNldCBvcHRpb24uZ3JvdXAuXG4gICAgaWYgKGRyYWdFbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoL21vdXNlZG93bnxwb2ludGVyZG93bi8udGVzdCh0eXBlKSAmJiBldnQuYnV0dG9uICE9PSAwIHx8IG9wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjsgLy8gb25seSBsZWZ0IGJ1dHRvbiBhbmQgZW5hYmxlZFxuICAgIH1cblxuICAgIC8vIGNhbmNlbCBkbmQgaWYgb3JpZ2luYWwgdGFyZ2V0IGlzIGNvbnRlbnQgZWRpdGFibGVcbiAgICBpZiAob3JpZ2luYWxUYXJnZXQuaXNDb250ZW50RWRpdGFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTYWZhcmkgaWdub3JlcyBmdXJ0aGVyIGV2ZW50IGhhbmRsaW5nIGFmdGVyIG1vdXNlZG93blxuICAgIGlmICghdGhpcy5uYXRpdmVEcmFnZ2FibGUgJiYgU2FmYXJpICYmIHRhcmdldCAmJiB0YXJnZXQudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnU0VMRUNUJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0YXJnZXQgPSBjbG9zZXN0KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCBmYWxzZSk7XG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuYW5pbWF0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGxhc3REb3duRWwgPT09IHRhcmdldCkge1xuICAgICAgLy8gSWdub3JpbmcgZHVwbGljYXRlIGBkb3duYFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRyYWdnZWQgZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudFxuICAgIG9sZEluZGV4ID0gaW5kZXgodGFyZ2V0KTtcbiAgICBvbGREcmFnZ2FibGVJbmRleCA9IGluZGV4KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuXG4gICAgLy8gQ2hlY2sgZmlsdGVyXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChmaWx0ZXIuY2FsbCh0aGlzLCBldnQsIHRhcmdldCwgdGhpcykpIHtcbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICByb290RWw6IG9yaWdpbmFsVGFyZ2V0LFxuICAgICAgICAgIG5hbWU6ICdmaWx0ZXInLFxuICAgICAgICAgIHRhcmdldEVsOiB0YXJnZXQsXG4gICAgICAgICAgdG9FbDogZWwsXG4gICAgICAgICAgZnJvbUVsOiBlbFxuICAgICAgICB9KTtcbiAgICAgICAgcGx1Z2luRXZlbnQoJ2ZpbHRlcicsIF90aGlzLCB7XG4gICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZlbnRPbkZpbHRlciAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuOyAvLyBjYW5jZWwgZG5kXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWx0ZXIpIHtcbiAgICAgIGZpbHRlciA9IGZpbHRlci5zcGxpdCgnLCcpLnNvbWUoZnVuY3Rpb24gKGNyaXRlcmlhKSB7XG4gICAgICAgIGNyaXRlcmlhID0gY2xvc2VzdChvcmlnaW5hbFRhcmdldCwgY3JpdGVyaWEudHJpbSgpLCBlbCwgZmFsc2UpO1xuICAgICAgICBpZiAoY3JpdGVyaWEpIHtcbiAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgICAgICByb290RWw6IGNyaXRlcmlhLFxuICAgICAgICAgICAgbmFtZTogJ2ZpbHRlcicsXG4gICAgICAgICAgICB0YXJnZXRFbDogdGFyZ2V0LFxuICAgICAgICAgICAgZnJvbUVsOiBlbCxcbiAgICAgICAgICAgIHRvRWw6IGVsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcGx1Z2luRXZlbnQoJ2ZpbHRlcicsIF90aGlzLCB7XG4gICAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgcHJldmVudE9uRmlsdGVyICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47IC8vIGNhbmNlbCBkbmRcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlICYmICFjbG9zZXN0KG9yaWdpbmFsVGFyZ2V0LCBvcHRpb25zLmhhbmRsZSwgZWwsIGZhbHNlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByZXBhcmUgYGRyYWdzdGFydGBcbiAgICB0aGlzLl9wcmVwYXJlRHJhZ1N0YXJ0KGV2dCwgdG91Y2gsIHRhcmdldCk7XG4gIH0sXG4gIF9wcmVwYXJlRHJhZ1N0YXJ0OiBmdW5jdGlvbiBfcHJlcGFyZURyYWdTdGFydCggLyoqIEV2ZW50ICovZXZ0LCAvKiogVG91Y2ggKi90b3VjaCwgLyoqIEhUTUxFbGVtZW50ICovdGFyZ2V0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgIGVsID0gX3RoaXMuZWwsXG4gICAgICBvcHRpb25zID0gX3RoaXMub3B0aW9ucyxcbiAgICAgIG93bmVyRG9jdW1lbnQgPSBlbC5vd25lckRvY3VtZW50LFxuICAgICAgZHJhZ1N0YXJ0Rm47XG4gICAgaWYgKHRhcmdldCAmJiAhZHJhZ0VsICYmIHRhcmdldC5wYXJlbnROb2RlID09PSBlbCkge1xuICAgICAgdmFyIGRyYWdSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuICAgICAgcm9vdEVsID0gZWw7XG4gICAgICBkcmFnRWwgPSB0YXJnZXQ7XG4gICAgICBwYXJlbnRFbCA9IGRyYWdFbC5wYXJlbnROb2RlO1xuICAgICAgbmV4dEVsID0gZHJhZ0VsLm5leHRTaWJsaW5nO1xuICAgICAgbGFzdERvd25FbCA9IHRhcmdldDtcbiAgICAgIGFjdGl2ZUdyb3VwID0gb3B0aW9ucy5ncm91cDtcbiAgICAgIFNvcnRhYmxlLmRyYWdnZWQgPSBkcmFnRWw7XG4gICAgICB0YXBFdnQgPSB7XG4gICAgICAgIHRhcmdldDogZHJhZ0VsLFxuICAgICAgICBjbGllbnRYOiAodG91Y2ggfHwgZXZ0KS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiAodG91Y2ggfHwgZXZ0KS5jbGllbnRZXG4gICAgICB9O1xuICAgICAgdGFwRGlzdGFuY2VMZWZ0ID0gdGFwRXZ0LmNsaWVudFggLSBkcmFnUmVjdC5sZWZ0O1xuICAgICAgdGFwRGlzdGFuY2VUb3AgPSB0YXBFdnQuY2xpZW50WSAtIGRyYWdSZWN0LnRvcDtcbiAgICAgIHRoaXMuX2xhc3RYID0gKHRvdWNoIHx8IGV2dCkuY2xpZW50WDtcbiAgICAgIHRoaXMuX2xhc3RZID0gKHRvdWNoIHx8IGV2dCkuY2xpZW50WTtcbiAgICAgIGRyYWdFbC5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICdhbGwnO1xuICAgICAgZHJhZ1N0YXJ0Rm4gPSBmdW5jdGlvbiBkcmFnU3RhcnRGbigpIHtcbiAgICAgICAgcGx1Z2luRXZlbnQoJ2RlbGF5RW5kZWQnLCBfdGhpcywge1xuICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICAgIF90aGlzLl9vbkRyb3AoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVsYXllZCBkcmFnIGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgICAgICAvLyB3ZSBjYW4gcmUtZW5hYmxlIHRoZSBldmVudHM6IHRvdWNobW92ZS9tb3VzZW1vdmVcbiAgICAgICAgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpO1xuICAgICAgICBpZiAoIUZpcmVGb3ggJiYgX3RoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgZHJhZ0VsLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCaW5kIHRoZSBldmVudHM6IGRyYWdzdGFydC9kcmFnZW5kXG4gICAgICAgIF90aGlzLl90cmlnZ2VyRHJhZ1N0YXJ0KGV2dCwgdG91Y2gpO1xuXG4gICAgICAgIC8vIERyYWcgc3RhcnQgZXZlbnRcbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICBuYW1lOiAnY2hvb3NlJyxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2hvc2VuIGl0ZW1cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmNob3NlbkNsYXNzLCB0cnVlKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIERpc2FibGUgXCJkcmFnZ2FibGVcIlxuICAgICAgb3B0aW9ucy5pZ25vcmUuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uIChjcml0ZXJpYSkge1xuICAgICAgICBmaW5kKGRyYWdFbCwgY3JpdGVyaWEudHJpbSgpLCBfZGlzYWJsZURyYWdnYWJsZSk7XG4gICAgICB9KTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdkcmFnb3ZlcicsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2htb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgICAgaWYgKG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJ1cCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgICAvLyBOYXRpdmUgRCZEIHRyaWdnZXJzIHBvaW50ZXJjYW5jZWxcbiAgICAgICAgIXRoaXMubmF0aXZlRHJhZ2dhYmxlICYmIG9uKG93bmVyRG9jdW1lbnQsICdwb2ludGVyY2FuY2VsJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2UgZHJhZ0VsIGRyYWdnYWJsZSAobXVzdCBiZSBiZWZvcmUgZGVsYXkgZm9yIEZpcmVGb3gpXG4gICAgICBpZiAoRmlyZUZveCAmJiB0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudG91Y2hTdGFydFRocmVzaG9sZCA9IDQ7XG4gICAgICAgIGRyYWdFbC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcGx1Z2luRXZlbnQoJ2RlbGF5U3RhcnQnLCB0aGlzLCB7XG4gICAgICAgIGV2dDogZXZ0XG4gICAgICB9KTtcblxuICAgICAgLy8gRGVsYXkgaXMgaW1wb3NzaWJsZSBmb3IgbmF0aXZlIERuRCBpbiBFZGdlIG9yIElFXG4gICAgICBpZiAob3B0aW9ucy5kZWxheSAmJiAoIW9wdGlvbnMuZGVsYXlPblRvdWNoT25seSB8fCB0b3VjaCkgJiYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSB8fCAhKEVkZ2UgfHwgSUUxMU9yTGVzcykpKSB7XG4gICAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgICAgdGhpcy5fb25Ecm9wKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIG1vdmVzIHRoZSBwb2ludGVyIG9yIGxldCBnbyB0aGUgY2xpY2sgb3IgdG91Y2hcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBkZWxheSBoYXMgYmVlbiByZWFjaGVkOlxuICAgICAgICAvLyBkaXNhYmxlIHRoZSBkZWxheWVkIGRyYWdcbiAgICAgICAgaWYgKG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICAgICAgICBvbihvd25lckRvY3VtZW50LCAncG9pbnRlcnVwJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJjYW5jZWwnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICB9XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBfdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIF90aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgICAgICBvcHRpb25zLnN1cHBvcnRQb2ludGVyICYmIG9uKG93bmVyRG9jdW1lbnQsICdwb2ludGVybW92ZScsIF90aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgICAgICBfdGhpcy5fZHJhZ1N0YXJ0VGltZXIgPSBzZXRUaW1lb3V0KGRyYWdTdGFydEZuLCBvcHRpb25zLmRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYWdTdGFydEZuKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyOiBmdW5jdGlvbiBfZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKCAvKiogVG91Y2hFdmVudHxQb2ludGVyRXZlbnQgKiovZSkge1xuICAgIHZhciB0b3VjaCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XG4gICAgaWYgKE1hdGgubWF4KE1hdGguYWJzKHRvdWNoLmNsaWVudFggLSB0aGlzLl9sYXN0WCksIE1hdGguYWJzKHRvdWNoLmNsaWVudFkgLSB0aGlzLl9sYXN0WSkpID49IE1hdGguZmxvb3IodGhpcy5vcHRpb25zLnRvdWNoU3RhcnRUaHJlc2hvbGQgLyAodGhpcy5uYXRpdmVEcmFnZ2FibGUgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkpKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcoKTtcbiAgICB9XG4gIH0sXG4gIF9kaXNhYmxlRGVsYXllZERyYWc6IGZ1bmN0aW9uIF9kaXNhYmxlRGVsYXllZERyYWcoKSB7XG4gICAgZHJhZ0VsICYmIF9kaXNhYmxlRHJhZ2dhYmxlKGRyYWdFbCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RyYWdTdGFydFRpbWVyKTtcbiAgICB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKTtcbiAgfSxcbiAgX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50czogZnVuY3Rpb24gX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IHRoaXMuZWwub3duZXJEb2N1bWVudDtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJjYW5jZWwnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gIH0sXG4gIF90cmlnZ2VyRHJhZ1N0YXJ0OiBmdW5jdGlvbiBfdHJpZ2dlckRyYWdTdGFydCggLyoqIEV2ZW50ICovZXZ0LCAvKiogVG91Y2ggKi90b3VjaCkge1xuICAgIHRvdWNoID0gdG91Y2ggfHwgZXZ0LnBvaW50ZXJUeXBlID09ICd0b3VjaCcgJiYgZXZ0O1xuICAgIGlmICghdGhpcy5uYXRpdmVEcmFnZ2FibGUgfHwgdG91Y2gpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgIH0gZWxzZSBpZiAodG91Y2gpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb24oZHJhZ0VsLCAnZHJhZ2VuZCcsIHRoaXMpO1xuICAgICAgb24ocm9vdEVsLCAnZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgICAgICBfbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHt9XG4gIH0sXG4gIF9kcmFnU3RhcnRlZDogZnVuY3Rpb24gX2RyYWdTdGFydGVkKGZhbGxiYWNrLCBldnQpIHtcbiAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgaWYgKHJvb3RFbCAmJiBkcmFnRWwpIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdkcmFnU3RhcnRlZCcsIHRoaXMsIHtcbiAgICAgICAgZXZ0OiBldnRcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAnZHJhZ292ZXInLCBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwpO1xuICAgICAgfVxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgIC8vIEFwcGx5IGVmZmVjdFxuICAgICAgIWZhbGxiYWNrICYmIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5kcmFnQ2xhc3MsIGZhbHNlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5naG9zdENsYXNzLCB0cnVlKTtcbiAgICAgIFNvcnRhYmxlLmFjdGl2ZSA9IHRoaXM7XG4gICAgICBmYWxsYmFjayAmJiB0aGlzLl9hcHBlbmRHaG9zdCgpO1xuXG4gICAgICAvLyBEcmFnIHN0YXJ0IGV2ZW50XG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICBuYW1lOiAnc3RhcnQnLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9udWxsaW5nKCk7XG4gICAgfVxuICB9LFxuICBfZW11bGF0ZURyYWdPdmVyOiBmdW5jdGlvbiBfZW11bGF0ZURyYWdPdmVyKCkge1xuICAgIGlmICh0b3VjaEV2dCkge1xuICAgICAgdGhpcy5fbGFzdFggPSB0b3VjaEV2dC5jbGllbnRYO1xuICAgICAgdGhpcy5fbGFzdFkgPSB0b3VjaEV2dC5jbGllbnRZO1xuICAgICAgX2hpZGVHaG9zdEZvclRhcmdldCgpO1xuICAgICAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2hFdnQuY2xpZW50WCwgdG91Y2hFdnQuY2xpZW50WSk7XG4gICAgICB2YXIgcGFyZW50ID0gdGFyZ2V0O1xuICAgICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQuc2hhZG93Um9vdCkge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQuc2hhZG93Um9vdC5lbGVtZW50RnJvbVBvaW50KHRvdWNoRXZ0LmNsaWVudFgsIHRvdWNoRXZ0LmNsaWVudFkpO1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBwYXJlbnQpIGJyZWFrO1xuICAgICAgICBwYXJlbnQgPSB0YXJnZXQ7XG4gICAgICB9XG4gICAgICBkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5faXNPdXRzaWRlVGhpc0VsKHRhcmdldCk7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAocGFyZW50W2V4cGFuZG9dKSB7XG4gICAgICAgICAgICB2YXIgaW5zZXJ0ZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpbnNlcnRlZCA9IHBhcmVudFtleHBhbmRvXS5fb25EcmFnT3Zlcih7XG4gICAgICAgICAgICAgIGNsaWVudFg6IHRvdWNoRXZ0LmNsaWVudFgsXG4gICAgICAgICAgICAgIGNsaWVudFk6IHRvdWNoRXZ0LmNsaWVudFksXG4gICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICByb290RWw6IHBhcmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0ZWQgJiYgIXRoaXMub3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0ID0gcGFyZW50OyAvLyBzdG9yZSBsYXN0IGVsZW1lbnRcbiAgICAgICAgfVxuICAgICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovIHdoaWxlIChwYXJlbnQgPSBnZXRQYXJlbnRPckhvc3QocGFyZW50KSk7XG4gICAgICB9XG4gICAgICBfdW5oaWRlR2hvc3RGb3JUYXJnZXQoKTtcbiAgICB9XG4gIH0sXG4gIF9vblRvdWNoTW92ZTogZnVuY3Rpb24gX29uVG91Y2hNb3ZlKCAvKipUb3VjaEV2ZW50Ki9ldnQpIHtcbiAgICBpZiAodGFwRXZ0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZmFsbGJhY2tUb2xlcmFuY2UgPSBvcHRpb25zLmZhbGxiYWNrVG9sZXJhbmNlLFxuICAgICAgICBmYWxsYmFja09mZnNldCA9IG9wdGlvbnMuZmFsbGJhY2tPZmZzZXQsXG4gICAgICAgIHRvdWNoID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCxcbiAgICAgICAgZ2hvc3RNYXRyaXggPSBnaG9zdEVsICYmIG1hdHJpeChnaG9zdEVsLCB0cnVlKSxcbiAgICAgICAgc2NhbGVYID0gZ2hvc3RFbCAmJiBnaG9zdE1hdHJpeCAmJiBnaG9zdE1hdHJpeC5hLFxuICAgICAgICBzY2FsZVkgPSBnaG9zdEVsICYmIGdob3N0TWF0cml4ICYmIGdob3N0TWF0cml4LmQsXG4gICAgICAgIHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID0gUG9zaXRpb25HaG9zdEFic29sdXRlbHkgJiYgZ2hvc3RSZWxhdGl2ZVBhcmVudCAmJiBnZXRSZWxhdGl2ZVNjcm9sbE9mZnNldChnaG9zdFJlbGF0aXZlUGFyZW50KSxcbiAgICAgICAgZHggPSAodG91Y2guY2xpZW50WCAtIHRhcEV2dC5jbGllbnRYICsgZmFsbGJhY2tPZmZzZXQueCkgLyAoc2NhbGVYIHx8IDEpICsgKHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID8gcmVsYXRpdmVTY3JvbGxPZmZzZXRbMF0gLSBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbFswXSA6IDApIC8gKHNjYWxlWCB8fCAxKSxcbiAgICAgICAgZHkgPSAodG91Y2guY2xpZW50WSAtIHRhcEV2dC5jbGllbnRZICsgZmFsbGJhY2tPZmZzZXQueSkgLyAoc2NhbGVZIHx8IDEpICsgKHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID8gcmVsYXRpdmVTY3JvbGxPZmZzZXRbMV0gLSBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbFsxXSA6IDApIC8gKHNjYWxlWSB8fCAxKTtcblxuICAgICAgLy8gb25seSBzZXQgdGhlIHN0YXR1cyB0byBkcmFnZ2luZywgd2hlbiB3ZSBhcmUgYWN0dWFsbHkgZHJhZ2dpbmdcbiAgICAgIGlmICghU29ydGFibGUuYWN0aXZlICYmICFhd2FpdGluZ0RyYWdTdGFydGVkKSB7XG4gICAgICAgIGlmIChmYWxsYmFja1RvbGVyYW5jZSAmJiBNYXRoLm1heChNYXRoLmFicyh0b3VjaC5jbGllbnRYIC0gdGhpcy5fbGFzdFgpLCBNYXRoLmFicyh0b3VjaC5jbGllbnRZIC0gdGhpcy5fbGFzdFkpKSA8IGZhbGxiYWNrVG9sZXJhbmNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29uRHJhZ1N0YXJ0KGV2dCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoZ2hvc3RFbCkge1xuICAgICAgICBpZiAoZ2hvc3RNYXRyaXgpIHtcbiAgICAgICAgICBnaG9zdE1hdHJpeC5lICs9IGR4IC0gKGxhc3REeCB8fCAwKTtcbiAgICAgICAgICBnaG9zdE1hdHJpeC5mICs9IGR5IC0gKGxhc3REeSB8fCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnaG9zdE1hdHJpeCA9IHtcbiAgICAgICAgICAgIGE6IDEsXG4gICAgICAgICAgICBiOiAwLFxuICAgICAgICAgICAgYzogMCxcbiAgICAgICAgICAgIGQ6IDEsXG4gICAgICAgICAgICBlOiBkeCxcbiAgICAgICAgICAgIGY6IGR5XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3NzTWF0cml4ID0gXCJtYXRyaXgoXCIuY29uY2F0KGdob3N0TWF0cml4LmEsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguYiwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5jLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmQsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguZSwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5mLCBcIilcIik7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnd2Via2l0VHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgY3NzKGdob3N0RWwsICdtb3pUcmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ21zVHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICBsYXN0RHggPSBkeDtcbiAgICAgICAgbGFzdER5ID0gZHk7XG4gICAgICAgIHRvdWNoRXZ0ID0gdG91Y2g7XG4gICAgICB9XG4gICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sXG4gIF9hcHBlbmRHaG9zdDogZnVuY3Rpb24gX2FwcGVuZEdob3N0KCkge1xuICAgIC8vIEJ1ZyBpZiB1c2luZyBzY2FsZSgpOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjM3MDU4XG4gICAgLy8gTm90IGJlaW5nIGFkanVzdGVkIGZvclxuICAgIGlmICghZ2hvc3RFbCkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5mYWxsYmFja09uQm9keSA/IGRvY3VtZW50LmJvZHkgOiByb290RWwsXG4gICAgICAgIHJlY3QgPSBnZXRSZWN0KGRyYWdFbCwgdHJ1ZSwgUG9zaXRpb25HaG9zdEFic29sdXRlbHksIHRydWUsIGNvbnRhaW5lciksXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgIC8vIFBvc2l0aW9uIGFic29sdXRlbHlcbiAgICAgIGlmIChQb3NpdGlvbkdob3N0QWJzb2x1dGVseSkge1xuICAgICAgICAvLyBHZXQgcmVsYXRpdmVseSBwb3NpdGlvbmVkIHBhcmVudFxuICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50ID0gY29udGFpbmVyO1xuICAgICAgICB3aGlsZSAoY3NzKGdob3N0UmVsYXRpdmVQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJyAmJiBjc3MoZ2hvc3RSZWxhdGl2ZVBhcmVudCwgJ3RyYW5zZm9ybScpID09PSAnbm9uZScgJiYgZ2hvc3RSZWxhdGl2ZVBhcmVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50ID0gZ2hvc3RSZWxhdGl2ZVBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIGdob3N0UmVsYXRpdmVQYXJlbnQgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgIGlmIChnaG9zdFJlbGF0aXZlUGFyZW50ID09PSBkb2N1bWVudCkgZ2hvc3RSZWxhdGl2ZVBhcmVudCA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgICAgICAgICByZWN0LnRvcCArPSBnaG9zdFJlbGF0aXZlUGFyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICByZWN0LmxlZnQgKz0gZ2hvc3RSZWxhdGl2ZVBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGwgPSBnZXRSZWxhdGl2ZVNjcm9sbE9mZnNldChnaG9zdFJlbGF0aXZlUGFyZW50KTtcbiAgICAgIH1cbiAgICAgIGdob3N0RWwgPSBkcmFnRWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgdG9nZ2xlQ2xhc3MoZ2hvc3RFbCwgb3B0aW9ucy5naG9zdENsYXNzLCBmYWxzZSk7XG4gICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmZhbGxiYWNrQ2xhc3MsIHRydWUpO1xuICAgICAgdG9nZ2xlQ2xhc3MoZ2hvc3RFbCwgb3B0aW9ucy5kcmFnQ2xhc3MsIHRydWUpO1xuICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2l0aW9uJywgJycpO1xuICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ2JveC1zaXppbmcnLCAnYm9yZGVyLWJveCcpO1xuICAgICAgY3NzKGdob3N0RWwsICdtYXJnaW4nLCAwKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAndG9wJywgcmVjdC50b3ApO1xuICAgICAgY3NzKGdob3N0RWwsICdsZWZ0JywgcmVjdC5sZWZ0KTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnd2lkdGgnLCByZWN0LndpZHRoKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnaGVpZ2h0JywgcmVjdC5oZWlnaHQpO1xuICAgICAgY3NzKGdob3N0RWwsICdvcGFjaXR5JywgJzAuOCcpO1xuICAgICAgY3NzKGdob3N0RWwsICdwb3NpdGlvbicsIFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5ID8gJ2Fic29sdXRlJyA6ICdmaXhlZCcpO1xuICAgICAgY3NzKGdob3N0RWwsICd6SW5kZXgnLCAnMTAwMDAwJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3BvaW50ZXJFdmVudHMnLCAnbm9uZScpO1xuICAgICAgU29ydGFibGUuZ2hvc3QgPSBnaG9zdEVsO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGdob3N0RWwpO1xuXG4gICAgICAvLyBTZXQgdHJhbnNmb3JtLW9yaWdpblxuICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2Zvcm0tb3JpZ2luJywgdGFwRGlzdGFuY2VMZWZ0IC8gcGFyc2VJbnQoZ2hvc3RFbC5zdHlsZS53aWR0aCkgKiAxMDAgKyAnJSAnICsgdGFwRGlzdGFuY2VUb3AgLyBwYXJzZUludChnaG9zdEVsLnN0eWxlLmhlaWdodCkgKiAxMDAgKyAnJScpO1xuICAgIH1cbiAgfSxcbiAgX29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiBfb25EcmFnU3RhcnQoIC8qKkV2ZW50Ki9ldnQsIC8qKmJvb2xlYW4qL2ZhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZGF0YVRyYW5zZmVyID0gZXZ0LmRhdGFUcmFuc2ZlcjtcbiAgICB2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG4gICAgcGx1Z2luRXZlbnQoJ2RyYWdTdGFydCcsIHRoaXMsIHtcbiAgICAgIGV2dDogZXZ0XG4gICAgfSk7XG4gICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgIHRoaXMuX29uRHJvcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwbHVnaW5FdmVudCgnc2V0dXBDbG9uZScsIHRoaXMpO1xuICAgIGlmICghU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgY2xvbmVFbCA9IGNsb25lKGRyYWdFbCk7XG4gICAgICBjbG9uZUVsLnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpO1xuICAgICAgY2xvbmVFbC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgIGNsb25lRWwuc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnJztcbiAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuICAgICAgdG9nZ2xlQ2xhc3MoY2xvbmVFbCwgdGhpcy5vcHRpb25zLmNob3NlbkNsYXNzLCBmYWxzZSk7XG4gICAgICBTb3J0YWJsZS5jbG9uZSA9IGNsb25lRWw7XG4gICAgfVxuXG4gICAgLy8gIzExNDM6IElGcmFtZSBzdXBwb3J0IHdvcmthcm91bmRcbiAgICBfdGhpcy5jbG9uZUlkID0gX25leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdjbG9uZScsIF90aGlzKTtcbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm47XG4gICAgICBpZiAoIV90aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUpIHtcbiAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZUVsLCBkcmFnRWwpO1xuICAgICAgfVxuICAgICAgX3RoaXMuX2hpZGVDbG9uZSgpO1xuICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgIG5hbWU6ICdjbG9uZSdcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgICFmYWxsYmFjayAmJiB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZHJhZ0NsYXNzLCB0cnVlKTtcblxuICAgIC8vIFNldCBwcm9wZXIgZHJvcCBldmVudHNcbiAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgIGlnbm9yZU5leHRDbGljayA9IHRydWU7XG4gICAgICBfdGhpcy5fbG9vcElkID0gc2V0SW50ZXJ2YWwoX3RoaXMuX2VtdWxhdGVEcmFnT3ZlciwgNTApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVbmRvIHdoYXQgd2FzIHNldCBpbiBfcHJlcGFyZURyYWdTdGFydCBiZWZvcmUgZHJhZyBzdGFydGVkXG4gICAgICBvZmYoZG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgIGlmIChkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSAnbW92ZSc7XG4gICAgICAgIG9wdGlvbnMuc2V0RGF0YSAmJiBvcHRpb25zLnNldERhdGEuY2FsbChfdGhpcywgZGF0YVRyYW5zZmVyLCBkcmFnRWwpO1xuICAgICAgfVxuICAgICAgb24oZG9jdW1lbnQsICdkcm9wJywgX3RoaXMpO1xuXG4gICAgICAvLyAjMTI3NiBmaXg6XG4gICAgICBjc3MoZHJhZ0VsLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVooMCknKTtcbiAgICB9XG4gICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgX3RoaXMuX2RyYWdTdGFydElkID0gX25leHRUaWNrKF90aGlzLl9kcmFnU3RhcnRlZC5iaW5kKF90aGlzLCBmYWxsYmFjaywgZXZ0KSk7XG4gICAgb24oZG9jdW1lbnQsICdzZWxlY3RzdGFydCcsIF90aGlzKTtcbiAgICBtb3ZlZCA9IHRydWU7XG4gICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIGlmIChTYWZhcmkpIHtcbiAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCAndXNlci1zZWxlY3QnLCAnbm9uZScpO1xuICAgIH1cbiAgfSxcbiAgLy8gUmV0dXJucyB0cnVlIC0gaWYgbm8gZnVydGhlciBhY3Rpb24gaXMgbmVlZGVkIChlaXRoZXIgaW5zZXJ0ZWQgb3IgYW5vdGhlciBjb25kaXRpb24pXG4gIF9vbkRyYWdPdmVyOiBmdW5jdGlvbiBfb25EcmFnT3ZlciggLyoqRXZlbnQqL2V2dCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWwsXG4gICAgICB0YXJnZXQgPSBldnQudGFyZ2V0LFxuICAgICAgZHJhZ1JlY3QsXG4gICAgICB0YXJnZXRSZWN0LFxuICAgICAgcmV2ZXJ0LFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGdyb3VwID0gb3B0aW9ucy5ncm91cCxcbiAgICAgIGFjdGl2ZVNvcnRhYmxlID0gU29ydGFibGUuYWN0aXZlLFxuICAgICAgaXNPd25lciA9IGFjdGl2ZUdyb3VwID09PSBncm91cCxcbiAgICAgIGNhblNvcnQgPSBvcHRpb25zLnNvcnQsXG4gICAgICBmcm9tU29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCBhY3RpdmVTb3J0YWJsZSxcbiAgICAgIHZlcnRpY2FsLFxuICAgICAgX3RoaXMgPSB0aGlzLFxuICAgICAgY29tcGxldGVkRmlyZWQgPSBmYWxzZTtcbiAgICBpZiAoX3NpbGVudCkgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIGRyYWdPdmVyRXZlbnQobmFtZSwgZXh0cmEpIHtcbiAgICAgIHBsdWdpbkV2ZW50KG5hbWUsIF90aGlzLCBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgIGV2dDogZXZ0LFxuICAgICAgICBpc093bmVyOiBpc093bmVyLFxuICAgICAgICBheGlzOiB2ZXJ0aWNhbCA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgIHJldmVydDogcmV2ZXJ0LFxuICAgICAgICBkcmFnUmVjdDogZHJhZ1JlY3QsXG4gICAgICAgIHRhcmdldFJlY3Q6IHRhcmdldFJlY3QsXG4gICAgICAgIGNhblNvcnQ6IGNhblNvcnQsXG4gICAgICAgIGZyb21Tb3J0YWJsZTogZnJvbVNvcnRhYmxlLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgY29tcGxldGVkOiBjb21wbGV0ZWQsXG4gICAgICAgIG9uTW92ZTogZnVuY3Rpb24gb25Nb3ZlKHRhcmdldCwgYWZ0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIGdldFJlY3QodGFyZ2V0KSwgZXZ0LCBhZnRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5nZWQ6IGNoYW5nZWRcbiAgICAgIH0sIGV4dHJhKSk7XG4gICAgfVxuXG4gICAgLy8gQ2FwdHVyZSBhbmltYXRpb24gc3RhdGVcbiAgICBmdW5jdGlvbiBjYXB0dXJlKCkge1xuICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJBbmltYXRpb25DYXB0dXJlJyk7XG4gICAgICBfdGhpcy5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgIGZyb21Tb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gaW52b2NhdGlvbiB3aGVuIGRyYWdFbCBpcyBpbnNlcnRlZCAob3IgY29tcGxldGVkKVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlZChpbnNlcnRpb24pIHtcbiAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyQ29tcGxldGVkJywge1xuICAgICAgICBpbnNlcnRpb246IGluc2VydGlvblxuICAgICAgfSk7XG4gICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgIC8vIENsb25lcyBtdXN0IGJlIGhpZGRlbiBiZWZvcmUgZm9sZGluZyBhbmltYXRpb24gdG8gY2FwdHVyZSBkcmFnUmVjdEFic29sdXRlIHByb3Blcmx5XG4gICAgICAgIGlmIChpc093bmVyKSB7XG4gICAgICAgICAgYWN0aXZlU29ydGFibGUuX2hpZGVDbG9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9zaG93Q2xvbmUoX3RoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgICAgLy8gU2V0IGdob3N0IGNsYXNzIHRvIG5ldyBzb3J0YWJsZSdzIGdob3N0IGNsYXNzXG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBwdXRTb3J0YWJsZSA/IHB1dFNvcnRhYmxlLm9wdGlvbnMuZ2hvc3RDbGFzcyA6IGFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5naG9zdENsYXNzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHV0U29ydGFibGUgIT09IF90aGlzICYmIF90aGlzICE9PSBTb3J0YWJsZS5hY3RpdmUpIHtcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IF90aGlzO1xuICAgICAgICB9IGVsc2UgaWYgKF90aGlzID09PSBTb3J0YWJsZS5hY3RpdmUgJiYgcHV0U29ydGFibGUpIHtcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbmltYXRpb25cbiAgICAgICAgaWYgKGZyb21Tb3J0YWJsZSA9PT0gX3RoaXMpIHtcbiAgICAgICAgICBfdGhpcy5faWdub3JlV2hpbGVBbmltYXRpbmcgPSB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuYW5pbWF0ZUFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJBbmltYXRpb25Db21wbGV0ZScpO1xuICAgICAgICAgIF90aGlzLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoX3RoaXMgIT09IGZyb21Tb3J0YWJsZSkge1xuICAgICAgICAgIGZyb21Tb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICAgICAgZnJvbVNvcnRhYmxlLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTnVsbCBsYXN0VGFyZ2V0IGlmIGl0IGlzIG5vdCBpbnNpZGUgYSBwcmV2aW91c2x5IHN3YXBwZWQgZWxlbWVudFxuICAgICAgaWYgKHRhcmdldCA9PT0gZHJhZ0VsICYmICFkcmFnRWwuYW5pbWF0ZWQgfHwgdGFyZ2V0ID09PSBlbCAmJiAhdGFyZ2V0LmFuaW1hdGVkKSB7XG4gICAgICAgIGxhc3RUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBubyBidWJibGluZyBhbmQgbm90IGZhbGxiYWNrXG4gICAgICBpZiAoIW9wdGlvbnMuZHJhZ292ZXJCdWJibGUgJiYgIWV2dC5yb290RWwgJiYgdGFyZ2V0ICE9PSBkb2N1bWVudCkge1xuICAgICAgICBkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5faXNPdXRzaWRlVGhpc0VsKGV2dC50YXJnZXQpO1xuXG4gICAgICAgIC8vIERvIG5vdCBkZXRlY3QgZm9yIGVtcHR5IGluc2VydCBpZiBhbHJlYWR5IGluc2VydGVkXG4gICAgICAgICFpbnNlcnRpb24gJiYgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQoZXZ0KTtcbiAgICAgIH1cbiAgICAgICFvcHRpb25zLmRyYWdvdmVyQnViYmxlICYmIGV2dC5zdG9wUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgcmV0dXJuIGNvbXBsZXRlZEZpcmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDYWxsIHdoZW4gZHJhZ0VsIGhhcyBiZWVuIGluc2VydGVkXG4gICAgZnVuY3Rpb24gY2hhbmdlZCgpIHtcbiAgICAgIG5ld0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcbiAgICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gaW5kZXgoZHJhZ0VsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgbmFtZTogJ2NoYW5nZScsXG4gICAgICAgIHRvRWw6IGVsLFxuICAgICAgICBuZXdJbmRleDogbmV3SW5kZXgsXG4gICAgICAgIG5ld0RyYWdnYWJsZUluZGV4OiBuZXdEcmFnZ2FibGVJbmRleCxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgdGFyZ2V0ID0gY2xvc2VzdCh0YXJnZXQsIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCwgdHJ1ZSk7XG4gICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXInKTtcbiAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuIGNvbXBsZXRlZEZpcmVkO1xuICAgIGlmIChkcmFnRWwuY29udGFpbnMoZXZ0LnRhcmdldCkgfHwgdGFyZ2V0LmFuaW1hdGVkICYmIHRhcmdldC5hbmltYXRpbmdYICYmIHRhcmdldC5hbmltYXRpbmdZIHx8IF90aGlzLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9PT0gdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICB9XG4gICAgaWdub3JlTmV4dENsaWNrID0gZmFsc2U7XG4gICAgaWYgKGFjdGl2ZVNvcnRhYmxlICYmICFvcHRpb25zLmRpc2FibGVkICYmIChpc093bmVyID8gY2FuU29ydCB8fCAocmV2ZXJ0ID0gcGFyZW50RWwgIT09IHJvb3RFbCkgLy8gUmV2ZXJ0aW5nIGl0ZW0gaW50byB0aGUgb3JpZ2luYWwgbGlzdFxuICAgIDogcHV0U29ydGFibGUgPT09IHRoaXMgfHwgKHRoaXMubGFzdFB1dE1vZGUgPSBhY3RpdmVHcm91cC5jaGVja1B1bGwodGhpcywgYWN0aXZlU29ydGFibGUsIGRyYWdFbCwgZXZ0KSkgJiYgZ3JvdXAuY2hlY2tQdXQodGhpcywgYWN0aXZlU29ydGFibGUsIGRyYWdFbCwgZXZ0KSkpIHtcbiAgICAgIHZlcnRpY2FsID0gdGhpcy5fZ2V0RGlyZWN0aW9uKGV2dCwgdGFyZ2V0KSA9PT0gJ3ZlcnRpY2FsJztcbiAgICAgIGRyYWdSZWN0ID0gZ2V0UmVjdChkcmFnRWwpO1xuICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJWYWxpZCcpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybiBjb21wbGV0ZWRGaXJlZDtcbiAgICAgIGlmIChyZXZlcnQpIHtcbiAgICAgICAgcGFyZW50RWwgPSByb290RWw7IC8vIGFjdHVhbGl6YXRpb25cbiAgICAgICAgY2FwdHVyZSgpO1xuICAgICAgICB0aGlzLl9oaWRlQ2xvbmUoKTtcbiAgICAgICAgZHJhZ092ZXJFdmVudCgncmV2ZXJ0Jyk7XG4gICAgICAgIGlmICghU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICAgIGlmIChuZXh0RWwpIHtcbiAgICAgICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBuZXh0RWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBlbExhc3RDaGlsZCA9IGxhc3RDaGlsZChlbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgICAgaWYgKCFlbExhc3RDaGlsZCB8fCBfZ2hvc3RJc0xhc3QoZXZ0LCB2ZXJ0aWNhbCwgdGhpcykgJiYgIWVsTGFzdENoaWxkLmFuaW1hdGVkKSB7XG4gICAgICAgIC8vIEluc2VydCB0byBlbmQgb2YgbGlzdFxuXG4gICAgICAgIC8vIElmIGFscmVhZHkgYXQgZW5kIG9mIGxpc3Q6IERvIG5vdCBpbnNlcnRcbiAgICAgICAgaWYgKGVsTGFzdENoaWxkID09PSBkcmFnRWwpIHtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgbGFzdCBlbGVtZW50LCBpdCBpcyB0aGUgdGFyZ2V0XG4gICAgICAgIGlmIChlbExhc3RDaGlsZCAmJiBlbCA9PT0gZXZ0LnRhcmdldCkge1xuICAgICAgICAgIHRhcmdldCA9IGVsTGFzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICB0YXJnZXRSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgdGFyZ2V0UmVjdCwgZXZ0LCAhIXRhcmdldCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgY2FwdHVyZSgpO1xuICAgICAgICAgIGlmIChlbExhc3RDaGlsZCAmJiBlbExhc3RDaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgLy8gdGhlIGxhc3QgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgbm90IHRoZSBsYXN0IG5vZGVcbiAgICAgICAgICAgIGVsLmluc2VydEJlZm9yZShkcmFnRWwsIGVsTGFzdENoaWxkLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50RWwgPSBlbDsgLy8gYWN0dWFsaXphdGlvblxuXG4gICAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWxMYXN0Q2hpbGQgJiYgX2dob3N0SXNGaXJzdChldnQsIHZlcnRpY2FsLCB0aGlzKSkge1xuICAgICAgICAvLyBJbnNlcnQgdG8gc3RhcnQgb2YgbGlzdFxuICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IGdldENoaWxkKGVsLCAwLCBvcHRpb25zLCB0cnVlKTtcbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQgPT09IGRyYWdFbCkge1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IGZpcnN0Q2hpbGQ7XG4gICAgICAgIHRhcmdldFJlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICAgIGlmIChfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgdGFyZ2V0UmVjdCwgZXZ0LCBmYWxzZSkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgY2FwdHVyZSgpO1xuICAgICAgICAgIGVsLmluc2VydEJlZm9yZShkcmFnRWwsIGZpcnN0Q2hpbGQpO1xuICAgICAgICAgIHBhcmVudEVsID0gZWw7IC8vIGFjdHVhbGl6YXRpb25cblxuICAgICAgICAgIGNoYW5nZWQoKTtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldC5wYXJlbnROb2RlID09PSBlbCkge1xuICAgICAgICB0YXJnZXRSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gMCxcbiAgICAgICAgICB0YXJnZXRCZWZvcmVGaXJzdFN3YXAsXG4gICAgICAgICAgZGlmZmVyZW50TGV2ZWwgPSBkcmFnRWwucGFyZW50Tm9kZSAhPT0gZWwsXG4gICAgICAgICAgZGlmZmVyZW50Um93Q29sID0gIV9kcmFnRWxJblJvd0NvbHVtbihkcmFnRWwuYW5pbWF0ZWQgJiYgZHJhZ0VsLnRvUmVjdCB8fCBkcmFnUmVjdCwgdGFyZ2V0LmFuaW1hdGVkICYmIHRhcmdldC50b1JlY3QgfHwgdGFyZ2V0UmVjdCwgdmVydGljYWwpLFxuICAgICAgICAgIHNpZGUxID0gdmVydGljYWwgPyAndG9wJyA6ICdsZWZ0JyxcbiAgICAgICAgICBzY3JvbGxlZFBhc3RUb3AgPSBpc1Njcm9sbGVkUGFzdCh0YXJnZXQsICd0b3AnLCAndG9wJykgfHwgaXNTY3JvbGxlZFBhc3QoZHJhZ0VsLCAndG9wJywgJ3RvcCcpLFxuICAgICAgICAgIHNjcm9sbEJlZm9yZSA9IHNjcm9sbGVkUGFzdFRvcCA/IHNjcm9sbGVkUGFzdFRvcC5zY3JvbGxUb3AgOiB2b2lkIDA7XG4gICAgICAgIGlmIChsYXN0VGFyZ2V0ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICB0YXJnZXRCZWZvcmVGaXJzdFN3YXAgPSB0YXJnZXRSZWN0W3NpZGUxXTtcbiAgICAgICAgICBwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSBmYWxzZTtcbiAgICAgICAgICBpc0NpcmN1bXN0YW50aWFsSW52ZXJ0ID0gIWRpZmZlcmVudFJvd0NvbCAmJiBvcHRpb25zLmludmVydFN3YXAgfHwgZGlmZmVyZW50TGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgZGlyZWN0aW9uID0gX2dldFN3YXBEaXJlY3Rpb24oZXZ0LCB0YXJnZXQsIHRhcmdldFJlY3QsIHZlcnRpY2FsLCBkaWZmZXJlbnRSb3dDb2wgPyAxIDogb3B0aW9ucy5zd2FwVGhyZXNob2xkLCBvcHRpb25zLmludmVydGVkU3dhcFRocmVzaG9sZCA9PSBudWxsID8gb3B0aW9ucy5zd2FwVGhyZXNob2xkIDogb3B0aW9ucy5pbnZlcnRlZFN3YXBUaHJlc2hvbGQsIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQsIGxhc3RUYXJnZXQgPT09IHRhcmdldCk7XG4gICAgICAgIHZhciBzaWJsaW5nO1xuICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSAwKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGJlc2lkZSBkcmFnRWwgaW4gcmVzcGVjdGl2ZSBkaXJlY3Rpb24gKGlnbm9yaW5nIGhpZGRlbiBlbGVtZW50cylcbiAgICAgICAgICB2YXIgZHJhZ0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBkcmFnSW5kZXggLT0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgc2libGluZyA9IHBhcmVudEVsLmNoaWxkcmVuW2RyYWdJbmRleF07XG4gICAgICAgICAgfSB3aGlsZSAoc2libGluZyAmJiAoY3NzKHNpYmxpbmcsICdkaXNwbGF5JykgPT09ICdub25lJyB8fCBzaWJsaW5nID09PSBnaG9zdEVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgZHJhZ0VsIGlzIGFscmVhZHkgYmVzaWRlIHRhcmdldDogRG8gbm90IGluc2VydFxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAwIHx8IHNpYmxpbmcgPT09IHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIGxhc3REaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IHRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgYWZ0ZXIgPSBmYWxzZTtcbiAgICAgICAgYWZ0ZXIgPSBkaXJlY3Rpb24gPT09IDE7XG4gICAgICAgIHZhciBtb3ZlVmVjdG9yID0gX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIHRhcmdldFJlY3QsIGV2dCwgYWZ0ZXIpO1xuICAgICAgICBpZiAobW92ZVZlY3RvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAobW92ZVZlY3RvciA9PT0gMSB8fCBtb3ZlVmVjdG9yID09PSAtMSkge1xuICAgICAgICAgICAgYWZ0ZXIgPSBtb3ZlVmVjdG9yID09PSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgICBzZXRUaW1lb3V0KF91bnNpbGVudCwgMzApO1xuICAgICAgICAgIGNhcHR1cmUoKTtcbiAgICAgICAgICBpZiAoYWZ0ZXIgJiYgIW5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBhZnRlciA/IG5leHRTaWJsaW5nIDogdGFyZ2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVbmRvIGNocm9tZSdzIHNjcm9sbCBhZGp1c3RtZW50IChoYXMgbm8gZWZmZWN0IG9uIG90aGVyIGJyb3dzZXJzKVxuICAgICAgICAgIGlmIChzY3JvbGxlZFBhc3RUb3ApIHtcbiAgICAgICAgICAgIHNjcm9sbEJ5KHNjcm9sbGVkUGFzdFRvcCwgMCwgc2Nyb2xsQmVmb3JlIC0gc2Nyb2xsZWRQYXN0VG9wLnNjcm9sbFRvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudEVsID0gZHJhZ0VsLnBhcmVudE5vZGU7IC8vIGFjdHVhbGl6YXRpb25cblxuICAgICAgICAgIC8vIG11c3QgYmUgZG9uZSBiZWZvcmUgYW5pbWF0aW9uXG4gICAgICAgICAgaWYgKHRhcmdldEJlZm9yZUZpcnN0U3dhcCAhPT0gdW5kZWZpbmVkICYmICFpc0NpcmN1bXN0YW50aWFsSW52ZXJ0KSB7XG4gICAgICAgICAgICB0YXJnZXRNb3ZlRGlzdGFuY2UgPSBNYXRoLmFicyh0YXJnZXRCZWZvcmVGaXJzdFN3YXAgLSBnZXRSZWN0KHRhcmdldClbc2lkZTFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbC5jb250YWlucyhkcmFnRWwpKSB7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIF9pZ25vcmVXaGlsZUFuaW1hdGluZzogbnVsbCxcbiAgX29mZk1vdmVFdmVudHM6IGZ1bmN0aW9uIF9vZmZNb3ZlRXZlbnRzKCkge1xuICAgIG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICBvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgb2ZmKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgb2ZmKGRvY3VtZW50LCAnZHJhZ292ZXInLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgb2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgIG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgfSxcbiAgX29mZlVwRXZlbnRzOiBmdW5jdGlvbiBfb2ZmVXBFdmVudHMoKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSB0aGlzLmVsLm93bmVyRG9jdW1lbnQ7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fb25Ecm9wKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ecm9wKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJ1cCcsIHRoaXMuX29uRHJvcCk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdwb2ludGVyY2FuY2VsJywgdGhpcy5fb25Ecm9wKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25Ecm9wKTtcbiAgICBvZmYoZG9jdW1lbnQsICdzZWxlY3RzdGFydCcsIHRoaXMpO1xuICB9LFxuICBfb25Ecm9wOiBmdW5jdGlvbiBfb25Ecm9wKCAvKipFdmVudCovZXZ0KSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbCxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnRcbiAgICBuZXdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG4gICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICBwbHVnaW5FdmVudCgnZHJvcCcsIHRoaXMsIHtcbiAgICAgIGV2dDogZXZ0XG4gICAgfSk7XG4gICAgcGFyZW50RWwgPSBkcmFnRWwgJiYgZHJhZ0VsLnBhcmVudE5vZGU7XG5cbiAgICAvLyBHZXQgYWdhaW4gYWZ0ZXIgcGx1Z2luIGV2ZW50XG4gICAgbmV3SW5kZXggPSBpbmRleChkcmFnRWwpO1xuICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gaW5kZXgoZHJhZ0VsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG4gICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgIHRoaXMuX251bGxpbmcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQgPSBmYWxzZTtcbiAgICBwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSBmYWxzZTtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2xvb3BJZCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RyYWdTdGFydFRpbWVyKTtcbiAgICBfY2FuY2VsTmV4dFRpY2sodGhpcy5jbG9uZUlkKTtcbiAgICBfY2FuY2VsTmV4dFRpY2sodGhpcy5fZHJhZ1N0YXJ0SWQpO1xuXG4gICAgLy8gVW5iaW5kIGV2ZW50c1xuICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgb2ZmKGRvY3VtZW50LCAnZHJvcCcsIHRoaXMpO1xuICAgICAgb2ZmKGVsLCAnZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgIH1cbiAgICB0aGlzLl9vZmZNb3ZlRXZlbnRzKCk7XG4gICAgdGhpcy5fb2ZmVXBFdmVudHMoKTtcbiAgICBpZiAoU2FmYXJpKSB7XG4gICAgICBjc3MoZG9jdW1lbnQuYm9keSwgJ3VzZXItc2VsZWN0JywgJycpO1xuICAgIH1cbiAgICBjc3MoZHJhZ0VsLCAndHJhbnNmb3JtJywgJycpO1xuICAgIGlmIChldnQpIHtcbiAgICAgIGlmIChtb3ZlZCkge1xuICAgICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgIW9wdGlvbnMuZHJvcEJ1YmJsZSAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBnaG9zdEVsICYmIGdob3N0RWwucGFyZW50Tm9kZSAmJiBnaG9zdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZ2hvc3RFbCk7XG4gICAgICBpZiAocm9vdEVsID09PSBwYXJlbnRFbCB8fCBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5sYXN0UHV0TW9kZSAhPT0gJ2Nsb25lJykge1xuICAgICAgICAvLyBSZW1vdmUgY2xvbmUocylcbiAgICAgICAgY2xvbmVFbCAmJiBjbG9uZUVsLnBhcmVudE5vZGUgJiYgY2xvbmVFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lRWwpO1xuICAgICAgfVxuICAgICAgaWYgKGRyYWdFbCkge1xuICAgICAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgICBvZmYoZHJhZ0VsLCAnZHJhZ2VuZCcsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIF9kaXNhYmxlRHJhZ2dhYmxlKGRyYWdFbCk7XG4gICAgICAgIGRyYWdFbC5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICcnO1xuXG4gICAgICAgIC8vIFJlbW92ZSBjbGFzc2VzXG4gICAgICAgIC8vIGdob3N0Q2xhc3MgaXMgYWRkZWQgaW4gZHJhZ1N0YXJ0ZWRcbiAgICAgICAgaWYgKG1vdmVkICYmICFhd2FpdGluZ0RyYWdTdGFydGVkKSB7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBwdXRTb3J0YWJsZSA/IHB1dFNvcnRhYmxlLm9wdGlvbnMuZ2hvc3RDbGFzcyA6IHRoaXMub3B0aW9ucy5naG9zdENsYXNzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsIGZhbHNlKTtcblxuICAgICAgICAvLyBEcmFnIHN0b3AgZXZlbnRcbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgIG5hbWU6ICd1bmNob29zZScsXG4gICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgbmV3SW5kZXg6IG51bGwsXG4gICAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG51bGwsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocm9vdEVsICE9PSBwYXJlbnRFbCkge1xuICAgICAgICAgIGlmIChuZXdJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBBZGQgZXZlbnRcbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgcm9vdEVsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgbmFtZTogJ2FkZCcsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBmcm9tRWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGV2ZW50XG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICBuYW1lOiAncmVtb3ZlJyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGRyYWcgZnJvbSBvbmUgbGlzdCBhbmQgZHJvcCBpbnRvIGFub3RoZXJcbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgcm9vdEVsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgbmFtZTogJ3NvcnQnLFxuICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgZnJvbUVsOiByb290RWwsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICBuYW1lOiAnc29ydCcsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5zYXZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG5ld0luZGV4ICE9PSBvbGRJbmRleCkge1xuICAgICAgICAgICAgaWYgKG5ld0luZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgLy8gZHJhZyAmIGRyb3Agd2l0aGluIHRoZSBzYW1lIGxpc3RcbiAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1cGRhdGUnLFxuICAgICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzb3J0JyxcbiAgICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChTb3J0YWJsZS5hY3RpdmUpIHtcbiAgICAgICAgICAvKiBqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICAgICAgICBpZiAobmV3SW5kZXggPT0gbnVsbCB8fCBuZXdJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5ld0luZGV4ID0gb2xkSW5kZXg7XG4gICAgICAgICAgICBuZXdEcmFnZ2FibGVJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgIG5hbWU6ICdlbmQnLFxuICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFNhdmUgc29ydGluZ1xuICAgICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX251bGxpbmcoKTtcbiAgfSxcbiAgX251bGxpbmc6IGZ1bmN0aW9uIF9udWxsaW5nKCkge1xuICAgIHBsdWdpbkV2ZW50KCdudWxsaW5nJywgdGhpcyk7XG4gICAgcm9vdEVsID0gZHJhZ0VsID0gcGFyZW50RWwgPSBnaG9zdEVsID0gbmV4dEVsID0gY2xvbmVFbCA9IGxhc3REb3duRWwgPSBjbG9uZUhpZGRlbiA9IHRhcEV2dCA9IHRvdWNoRXZ0ID0gbW92ZWQgPSBuZXdJbmRleCA9IG5ld0RyYWdnYWJsZUluZGV4ID0gb2xkSW5kZXggPSBvbGREcmFnZ2FibGVJbmRleCA9IGxhc3RUYXJnZXQgPSBsYXN0RGlyZWN0aW9uID0gcHV0U29ydGFibGUgPSBhY3RpdmVHcm91cCA9IFNvcnRhYmxlLmRyYWdnZWQgPSBTb3J0YWJsZS5naG9zdCA9IFNvcnRhYmxlLmNsb25lID0gU29ydGFibGUuYWN0aXZlID0gbnVsbDtcbiAgICBzYXZlZElucHV0Q2hlY2tlZC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWwuY2hlY2tlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgc2F2ZWRJbnB1dENoZWNrZWQubGVuZ3RoID0gbGFzdER4ID0gbGFzdER5ID0gMDtcbiAgfSxcbiAgaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KCAvKipFdmVudCovZXZ0KSB7XG4gICAgc3dpdGNoIChldnQudHlwZSkge1xuICAgICAgY2FzZSAnZHJvcCc6XG4gICAgICBjYXNlICdkcmFnZW5kJzpcbiAgICAgICAgdGhpcy5fb25Ecm9wKGV2dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZHJhZ2VudGVyJzpcbiAgICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICAgICAgaWYgKGRyYWdFbCkge1xuICAgICAgICAgIHRoaXMuX29uRHJhZ092ZXIoZXZ0KTtcbiAgICAgICAgICBfZ2xvYmFsRHJhZ092ZXIoZXZ0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdHN0YXJ0JzpcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcbiAgLyoqXHJcbiAgICogU2VyaWFsaXplcyB0aGUgaXRlbSBpbnRvIGFuIGFycmF5IG9mIHN0cmluZy5cclxuICAgKiBAcmV0dXJucyB7U3RyaW5nW119XHJcbiAgICovXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgdmFyIG9yZGVyID0gW10sXG4gICAgICBlbCxcbiAgICAgIGNoaWxkcmVuID0gdGhpcy5lbC5jaGlsZHJlbixcbiAgICAgIGkgPSAwLFxuICAgICAgbiA9IGNoaWxkcmVuLmxlbmd0aCxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGVsID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2xvc2VzdChlbCwgb3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuZWwsIGZhbHNlKSkge1xuICAgICAgICBvcmRlci5wdXNoKGVsLmdldEF0dHJpYnV0ZShvcHRpb25zLmRhdGFJZEF0dHIpIHx8IF9nZW5lcmF0ZUlkKGVsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcmRlcjtcbiAgfSxcbiAgLyoqXHJcbiAgICogU29ydHMgdGhlIGVsZW1lbnRzIGFjY29yZGluZyB0byB0aGUgYXJyYXkuXHJcbiAgICogQHBhcmFtICB7U3RyaW5nW119ICBvcmRlciAgb3JkZXIgb2YgdGhlIGl0ZW1zXHJcbiAgICovXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQob3JkZXIsIHVzZUFuaW1hdGlvbikge1xuICAgIHZhciBpdGVtcyA9IHt9LFxuICAgICAgcm9vdEVsID0gdGhpcy5lbDtcbiAgICB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCwgaSkge1xuICAgICAgdmFyIGVsID0gcm9vdEVsLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNsb3Nlc3QoZWwsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHJvb3RFbCwgZmFsc2UpKSB7XG4gICAgICAgIGl0ZW1zW2lkXSA9IGVsO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHVzZUFuaW1hdGlvbiAmJiB0aGlzLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICBpZiAoaXRlbXNbaWRdKSB7XG4gICAgICAgIHJvb3RFbC5yZW1vdmVDaGlsZChpdGVtc1tpZF0pO1xuICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoaXRlbXNbaWRdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1c2VBbmltYXRpb24gJiYgdGhpcy5hbmltYXRlQWxsKCk7XG4gIH0sXG4gIC8qKlxyXG4gICAqIFNhdmUgdGhlIGN1cnJlbnQgc29ydGluZ1xyXG4gICAqL1xuICBzYXZlOiBmdW5jdGlvbiBzYXZlKCkge1xuICAgIHZhciBzdG9yZSA9IHRoaXMub3B0aW9ucy5zdG9yZTtcbiAgICBzdG9yZSAmJiBzdG9yZS5zZXQgJiYgc3RvcmUuc2V0KHRoaXMpO1xuICB9LFxuICAvKipcclxuICAgKiBGb3IgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQsIGdldCB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdG9yIGJ5IHRlc3RpbmcgdGhlIGVsZW1lbnQgaXRzZWxmIGFuZCB0cmF2ZXJzaW5nIHVwIHRocm91Z2ggaXRzIGFuY2VzdG9ycyBpbiB0aGUgRE9NIHRyZWUuXHJcbiAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgZWxcclxuICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICAgICBbc2VsZWN0b3JdICBkZWZhdWx0OiBgb3B0aW9ucy5kcmFnZ2FibGVgXHJcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fG51bGx9XHJcbiAgICovXG4gIGNsb3Nlc3Q6IGZ1bmN0aW9uIGNsb3Nlc3QkMShlbCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gY2xvc2VzdChlbCwgc2VsZWN0b3IgfHwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgdGhpcy5lbCwgZmFsc2UpO1xuICB9LFxuICAvKipcclxuICAgKiBTZXQvZ2V0IG9wdGlvblxyXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcclxuICAgKiBAcGFyYW0gICB7Kn0gICAgICBbdmFsdWVdXHJcbiAgICogQHJldHVybnMgeyp9XHJcbiAgICovXG4gIG9wdGlvbjogZnVuY3Rpb24gb3B0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBvcHRpb25zW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbW9kaWZpZWRWYWx1ZSA9IFBsdWdpbk1hbmFnZXIubW9kaWZ5T3B0aW9uKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIGlmICh0eXBlb2YgbW9kaWZpZWRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0aW9uc1tuYW1lXSA9IG1vZGlmaWVkVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAobmFtZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXHJcbiAgICogRGVzdHJveVxyXG4gICAqL1xuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHBsdWdpbkV2ZW50KCdkZXN0cm95JywgdGhpcyk7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBlbFtleHBhbmRvXSA9IG51bGw7XG4gICAgb2ZmKGVsLCAnbW91c2Vkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgb2ZmKGVsLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVGFwU3RhcnQpO1xuICAgIG9mZihlbCwgJ3BvaW50ZXJkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICBvZmYoZWwsICdkcmFnb3ZlcicsIHRoaXMpO1xuICAgICAgb2ZmKGVsLCAnZHJhZ2VudGVyJywgdGhpcyk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBkcmFnZ2FibGUgYXR0cmlidXRlc1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWwucXVlcnlTZWxlY3RvckFsbCgnW2RyYWdnYWJsZV0nKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RyYWdnYWJsZScpO1xuICAgIH0pO1xuICAgIHRoaXMuX29uRHJvcCgpO1xuICAgIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpO1xuICAgIHNvcnRhYmxlcy5zcGxpY2Uoc29ydGFibGVzLmluZGV4T2YodGhpcy5lbCksIDEpO1xuICAgIHRoaXMuZWwgPSBlbCA9IG51bGw7XG4gIH0sXG4gIF9oaWRlQ2xvbmU6IGZ1bmN0aW9uIF9oaWRlQ2xvbmUoKSB7XG4gICAgaWYgKCFjbG9uZUhpZGRlbikge1xuICAgICAgcGx1Z2luRXZlbnQoJ2hpZGVDbG9uZScsIHRoaXMpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybjtcbiAgICAgIGNzcyhjbG9uZUVsLCAnZGlzcGxheScsICdub25lJyk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlICYmIGNsb25lRWwucGFyZW50Tm9kZSkge1xuICAgICAgICBjbG9uZUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmVFbCk7XG4gICAgICB9XG4gICAgICBjbG9uZUhpZGRlbiA9IHRydWU7XG4gICAgfVxuICB9LFxuICBfc2hvd0Nsb25lOiBmdW5jdGlvbiBfc2hvd0Nsb25lKHB1dFNvcnRhYmxlKSB7XG4gICAgaWYgKHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlICE9PSAnY2xvbmUnKSB7XG4gICAgICB0aGlzLl9oaWRlQ2xvbmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNsb25lSGlkZGVuKSB7XG4gICAgICBwbHVnaW5FdmVudCgnc2hvd0Nsb25lJywgdGhpcyk7XG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBzaG93IGNsb25lIGF0IGRyYWdFbCBvciBvcmlnaW5hbCBwb3NpdGlvblxuICAgICAgaWYgKGRyYWdFbC5wYXJlbnROb2RlID09IHJvb3RFbCAmJiAhdGhpcy5vcHRpb25zLmdyb3VwLnJldmVydENsb25lKSB7XG4gICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgZHJhZ0VsKTtcbiAgICAgIH0gZWxzZSBpZiAobmV4dEVsKSB7XG4gICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgbmV4dEVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChjbG9uZUVsKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3JvdXAucmV2ZXJ0Q2xvbmUpIHtcbiAgICAgICAgdGhpcy5hbmltYXRlKGRyYWdFbCwgY2xvbmVFbCk7XG4gICAgICB9XG4gICAgICBjc3MoY2xvbmVFbCwgJ2Rpc3BsYXknLCAnJyk7XG4gICAgICBjbG9uZUhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIF9nbG9iYWxEcmFnT3ZlciggLyoqRXZlbnQqL2V2dCkge1xuICBpZiAoZXZ0LmRhdGFUcmFuc2Zlcikge1xuICAgIGV2dC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdtb3ZlJztcbiAgfVxuICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbn1cbmZ1bmN0aW9uIF9vbk1vdmUoZnJvbUVsLCB0b0VsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXRFbCwgdGFyZ2V0UmVjdCwgb3JpZ2luYWxFdmVudCwgd2lsbEluc2VydEFmdGVyKSB7XG4gIHZhciBldnQsXG4gICAgc29ydGFibGUgPSBmcm9tRWxbZXhwYW5kb10sXG4gICAgb25Nb3ZlRm4gPSBzb3J0YWJsZS5vcHRpb25zLm9uTW92ZSxcbiAgICByZXRWYWw7XG4gIC8vIFN1cHBvcnQgZm9yIG5ldyBDdXN0b21FdmVudCBmZWF0dXJlXG4gIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQgJiYgIUlFMTFPckxlc3MgJiYgIUVkZ2UpIHtcbiAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ21vdmUnLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2dC5pbml0RXZlbnQoJ21vdmUnLCB0cnVlLCB0cnVlKTtcbiAgfVxuICBldnQudG8gPSB0b0VsO1xuICBldnQuZnJvbSA9IGZyb21FbDtcbiAgZXZ0LmRyYWdnZWQgPSBkcmFnRWw7XG4gIGV2dC5kcmFnZ2VkUmVjdCA9IGRyYWdSZWN0O1xuICBldnQucmVsYXRlZCA9IHRhcmdldEVsIHx8IHRvRWw7XG4gIGV2dC5yZWxhdGVkUmVjdCA9IHRhcmdldFJlY3QgfHwgZ2V0UmVjdCh0b0VsKTtcbiAgZXZ0LndpbGxJbnNlcnRBZnRlciA9IHdpbGxJbnNlcnRBZnRlcjtcbiAgZXZ0Lm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICBmcm9tRWwuZGlzcGF0Y2hFdmVudChldnQpO1xuICBpZiAob25Nb3ZlRm4pIHtcbiAgICByZXRWYWwgPSBvbk1vdmVGbi5jYWxsKHNvcnRhYmxlLCBldnQsIG9yaWdpbmFsRXZlbnQpO1xuICB9XG4gIHJldHVybiByZXRWYWw7XG59XG5mdW5jdGlvbiBfZGlzYWJsZURyYWdnYWJsZShlbCkge1xuICBlbC5kcmFnZ2FibGUgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIF91bnNpbGVudCgpIHtcbiAgX3NpbGVudCA9IGZhbHNlO1xufVxuZnVuY3Rpb24gX2dob3N0SXNGaXJzdChldnQsIHZlcnRpY2FsLCBzb3J0YWJsZSkge1xuICB2YXIgZmlyc3RFbFJlY3QgPSBnZXRSZWN0KGdldENoaWxkKHNvcnRhYmxlLmVsLCAwLCBzb3J0YWJsZS5vcHRpb25zLCB0cnVlKSk7XG4gIHZhciBjaGlsZENvbnRhaW5pbmdSZWN0ID0gZ2V0Q2hpbGRDb250YWluaW5nUmVjdEZyb21FbGVtZW50KHNvcnRhYmxlLmVsLCBzb3J0YWJsZS5vcHRpb25zLCBnaG9zdEVsKTtcbiAgdmFyIHNwYWNlciA9IDEwO1xuICByZXR1cm4gdmVydGljYWwgPyBldnQuY2xpZW50WCA8IGNoaWxkQ29udGFpbmluZ1JlY3QubGVmdCAtIHNwYWNlciB8fCBldnQuY2xpZW50WSA8IGZpcnN0RWxSZWN0LnRvcCAmJiBldnQuY2xpZW50WCA8IGZpcnN0RWxSZWN0LnJpZ2h0IDogZXZ0LmNsaWVudFkgPCBjaGlsZENvbnRhaW5pbmdSZWN0LnRvcCAtIHNwYWNlciB8fCBldnQuY2xpZW50WSA8IGZpcnN0RWxSZWN0LmJvdHRvbSAmJiBldnQuY2xpZW50WCA8IGZpcnN0RWxSZWN0LmxlZnQ7XG59XG5mdW5jdGlvbiBfZ2hvc3RJc0xhc3QoZXZ0LCB2ZXJ0aWNhbCwgc29ydGFibGUpIHtcbiAgdmFyIGxhc3RFbFJlY3QgPSBnZXRSZWN0KGxhc3RDaGlsZChzb3J0YWJsZS5lbCwgc29ydGFibGUub3B0aW9ucy5kcmFnZ2FibGUpKTtcbiAgdmFyIGNoaWxkQ29udGFpbmluZ1JlY3QgPSBnZXRDaGlsZENvbnRhaW5pbmdSZWN0RnJvbUVsZW1lbnQoc29ydGFibGUuZWwsIHNvcnRhYmxlLm9wdGlvbnMsIGdob3N0RWwpO1xuICB2YXIgc3BhY2VyID0gMTA7XG4gIHJldHVybiB2ZXJ0aWNhbCA/IGV2dC5jbGllbnRYID4gY2hpbGRDb250YWluaW5nUmVjdC5yaWdodCArIHNwYWNlciB8fCBldnQuY2xpZW50WSA+IGxhc3RFbFJlY3QuYm90dG9tICYmIGV2dC5jbGllbnRYID4gbGFzdEVsUmVjdC5sZWZ0IDogZXZ0LmNsaWVudFkgPiBjaGlsZENvbnRhaW5pbmdSZWN0LmJvdHRvbSArIHNwYWNlciB8fCBldnQuY2xpZW50WCA+IGxhc3RFbFJlY3QucmlnaHQgJiYgZXZ0LmNsaWVudFkgPiBsYXN0RWxSZWN0LnRvcDtcbn1cbmZ1bmN0aW9uIF9nZXRTd2FwRGlyZWN0aW9uKGV2dCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCwgc3dhcFRocmVzaG9sZCwgaW52ZXJ0ZWRTd2FwVGhyZXNob2xkLCBpbnZlcnRTd2FwLCBpc0xhc3RUYXJnZXQpIHtcbiAgdmFyIG1vdXNlT25BeGlzID0gdmVydGljYWwgPyBldnQuY2xpZW50WSA6IGV2dC5jbGllbnRYLFxuICAgIHRhcmdldExlbmd0aCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5oZWlnaHQgOiB0YXJnZXRSZWN0LndpZHRoLFxuICAgIHRhcmdldFMxID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LnRvcCA6IHRhcmdldFJlY3QubGVmdCxcbiAgICB0YXJnZXRTMiA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5ib3R0b20gOiB0YXJnZXRSZWN0LnJpZ2h0LFxuICAgIGludmVydCA9IGZhbHNlO1xuICBpZiAoIWludmVydFN3YXApIHtcbiAgICAvLyBOZXZlciBpbnZlcnQgb3IgY3JlYXRlIGRyYWdFbCBzaGFkb3cgd2hlbiB0YXJnZXQgbW92ZW1lbmV0IGNhdXNlcyBtb3VzZSB0byBtb3ZlIHBhc3QgdGhlIGVuZCBvZiByZWd1bGFyIHN3YXBUaHJlc2hvbGRcbiAgICBpZiAoaXNMYXN0VGFyZ2V0ICYmIHRhcmdldE1vdmVEaXN0YW5jZSA8IHRhcmdldExlbmd0aCAqIHN3YXBUaHJlc2hvbGQpIHtcbiAgICAgIC8vIG11bHRpcGxpZWQgb25seSBieSBzd2FwVGhyZXNob2xkIGJlY2F1c2UgbW91c2Ugd2lsbCBhbHJlYWR5IGJlIGluc2lkZSB0YXJnZXQgYnkgKDEgLSB0aHJlc2hvbGQpICogdGFyZ2V0TGVuZ3RoIC8gMlxuICAgICAgLy8gY2hlY2sgaWYgcGFzdCBmaXJzdCBpbnZlcnQgdGhyZXNob2xkIG9uIHNpZGUgb3Bwb3NpdGUgb2YgbGFzdERpcmVjdGlvblxuICAgICAgaWYgKCFwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggJiYgKGxhc3REaXJlY3Rpb24gPT09IDEgPyBtb3VzZU9uQXhpcyA+IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoICogaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIC8gMiA6IG1vdXNlT25BeGlzIDwgdGFyZ2V0UzIgLSB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyKSkge1xuICAgICAgICAvLyBwYXN0IGZpcnN0IGludmVydCB0aHJlc2hvbGQsIGRvIG5vdCByZXN0cmljdCBpbnZlcnRlZCB0aHJlc2hvbGQgdG8gZHJhZ0VsIHNoYWRvd1xuICAgICAgICBwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFwYXN0Rmlyc3RJbnZlcnRUaHJlc2gpIHtcbiAgICAgICAgLy8gZHJhZ0VsIHNoYWRvdyAodGFyZ2V0IG1vdmUgZGlzdGFuY2Ugc2hhZG93KVxuICAgICAgICBpZiAobGFzdERpcmVjdGlvbiA9PT0gMSA/IG1vdXNlT25BeGlzIDwgdGFyZ2V0UzEgKyB0YXJnZXRNb3ZlRGlzdGFuY2UgLy8gb3ZlciBkcmFnRWwgc2hhZG93XG4gICAgICAgIDogbW91c2VPbkF4aXMgPiB0YXJnZXRTMiAtIHRhcmdldE1vdmVEaXN0YW5jZSkge1xuICAgICAgICAgIHJldHVybiAtbGFzdERpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52ZXJ0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVndWxhclxuICAgICAgaWYgKG1vdXNlT25BeGlzID4gdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiAoMSAtIHN3YXBUaHJlc2hvbGQpIC8gMiAmJiBtb3VzZU9uQXhpcyA8IHRhcmdldFMyIC0gdGFyZ2V0TGVuZ3RoICogKDEgLSBzd2FwVGhyZXNob2xkKSAvIDIpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRJbnNlcnREaXJlY3Rpb24odGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaW52ZXJ0ID0gaW52ZXJ0IHx8IGludmVydFN3YXA7XG4gIGlmIChpbnZlcnQpIHtcbiAgICAvLyBJbnZlcnQgb2YgcmVndWxhclxuICAgIGlmIChtb3VzZU9uQXhpcyA8IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoICogaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIC8gMiB8fCBtb3VzZU9uQXhpcyA+IHRhcmdldFMyIC0gdGFyZ2V0TGVuZ3RoICogaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIC8gMikge1xuICAgICAgcmV0dXJuIG1vdXNlT25BeGlzID4gdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggLyAyID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLyoqXHJcbiAqIEdldHMgdGhlIGRpcmVjdGlvbiBkcmFnRWwgbXVzdCBiZSBzd2FwcGVkIHJlbGF0aXZlIHRvIHRhcmdldCBpbiBvcmRlciB0byBtYWtlIGl0XHJcbiAqIHNlZW0gdGhhdCBkcmFnRWwgaGFzIGJlZW4gXCJpbnNlcnRlZFwiIGludG8gdGhhdCBlbGVtZW50J3MgcG9zaXRpb25cclxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IHRhcmdldCAgICAgICBUaGUgdGFyZ2V0IHdob3NlIHBvc2l0aW9uIGRyYWdFbCBpcyBiZWluZyBpbnNlcnRlZCBhdFxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgIERpcmVjdGlvbiBkcmFnRWwgbXVzdCBiZSBzd2FwcGVkXHJcbiAqL1xuZnVuY3Rpb24gX2dldEluc2VydERpcmVjdGlvbih0YXJnZXQpIHtcbiAgaWYgKGluZGV4KGRyYWdFbCkgPCBpbmRleCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59XG5cbi8qKlxyXG4gKiBHZW5lcmF0ZSBpZFxyXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IGVsXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xuZnVuY3Rpb24gX2dlbmVyYXRlSWQoZWwpIHtcbiAgdmFyIHN0ciA9IGVsLnRhZ05hbWUgKyBlbC5jbGFzc05hbWUgKyBlbC5zcmMgKyBlbC5ocmVmICsgZWwudGV4dENvbnRlbnQsXG4gICAgaSA9IHN0ci5sZW5ndGgsXG4gICAgc3VtID0gMDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHN1bSArPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gc3VtLnRvU3RyaW5nKDM2KTtcbn1cbmZ1bmN0aW9uIF9zYXZlSW5wdXRDaGVja2VkU3RhdGUocm9vdCkge1xuICBzYXZlZElucHV0Q2hlY2tlZC5sZW5ndGggPSAwO1xuICB2YXIgaW5wdXRzID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKTtcbiAgdmFyIGlkeCA9IGlucHV0cy5sZW5ndGg7XG4gIHdoaWxlIChpZHgtLSkge1xuICAgIHZhciBlbCA9IGlucHV0c1tpZHhdO1xuICAgIGVsLmNoZWNrZWQgJiYgc2F2ZWRJbnB1dENoZWNrZWQucHVzaChlbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9uZXh0VGljayhmbikge1xuICByZXR1cm4gc2V0VGltZW91dChmbiwgMCk7XG59XG5mdW5jdGlvbiBfY2FuY2VsTmV4dFRpY2soaWQpIHtcbiAgcmV0dXJuIGNsZWFyVGltZW91dChpZCk7XG59XG5cbi8vIEZpeGVkICM5NzM6XG5pZiAoZG9jdW1lbnRFeGlzdHMpIHtcbiAgb24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgaWYgKChTb3J0YWJsZS5hY3RpdmUgfHwgYXdhaXRpbmdEcmFnU3RhcnRlZCkgJiYgZXZ0LmNhbmNlbGFibGUpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIEV4cG9ydCB1dGlsc1xuU29ydGFibGUudXRpbHMgPSB7XG4gIG9uOiBvbixcbiAgb2ZmOiBvZmYsXG4gIGNzczogY3NzLFxuICBmaW5kOiBmaW5kLFxuICBpczogZnVuY3Rpb24gaXMoZWwsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuICEhY2xvc2VzdChlbCwgc2VsZWN0b3IsIGVsLCBmYWxzZSk7XG4gIH0sXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0aHJvdHRsZTogdGhyb3R0bGUsXG4gIGNsb3Nlc3Q6IGNsb3Nlc3QsXG4gIHRvZ2dsZUNsYXNzOiB0b2dnbGVDbGFzcyxcbiAgY2xvbmU6IGNsb25lLFxuICBpbmRleDogaW5kZXgsXG4gIG5leHRUaWNrOiBfbmV4dFRpY2ssXG4gIGNhbmNlbE5leHRUaWNrOiBfY2FuY2VsTmV4dFRpY2ssXG4gIGRldGVjdERpcmVjdGlvbjogX2RldGVjdERpcmVjdGlvbixcbiAgZ2V0Q2hpbGQ6IGdldENoaWxkLFxuICBleHBhbmRvOiBleHBhbmRvXG59O1xuXG4vKipcclxuICogR2V0IHRoZSBTb3J0YWJsZSBpbnN0YW5jZSBvZiBhbiBlbGVtZW50XHJcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge1NvcnRhYmxlfHVuZGVmaW5lZH0gICAgICAgICBUaGUgaW5zdGFuY2Ugb2YgU29ydGFibGVcclxuICovXG5Tb3J0YWJsZS5nZXQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudFtleHBhbmRvXTtcbn07XG5cbi8qKlxyXG4gKiBNb3VudCBhIHBsdWdpbiB0byBTb3J0YWJsZVxyXG4gKiBAcGFyYW0gIHsuLi5Tb3J0YWJsZVBsdWdpbnxTb3J0YWJsZVBsdWdpbltdfSBwbHVnaW5zICAgICAgIFBsdWdpbnMgYmVpbmcgbW91bnRlZFxyXG4gKi9cblNvcnRhYmxlLm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGx1Z2lucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBwbHVnaW5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGlmIChwbHVnaW5zWzBdLmNvbnN0cnVjdG9yID09PSBBcnJheSkgcGx1Z2lucyA9IHBsdWdpbnNbMF07XG4gIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgaWYgKCFwbHVnaW4ucHJvdG90eXBlIHx8ICFwbHVnaW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBcIlNvcnRhYmxlOiBNb3VudGVkIHBsdWdpbiBtdXN0IGJlIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIG5vdCBcIi5jb25jYXQoe30udG9TdHJpbmcuY2FsbChwbHVnaW4pKTtcbiAgICB9XG4gICAgaWYgKHBsdWdpbi51dGlscykgU29ydGFibGUudXRpbHMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgU29ydGFibGUudXRpbHMpLCBwbHVnaW4udXRpbHMpO1xuICAgIFBsdWdpbk1hbmFnZXIubW91bnQocGx1Z2luKTtcbiAgfSk7XG59O1xuXG4vKipcclxuICogQ3JlYXRlIHNvcnRhYmxlIGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICBlbFxyXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICBbb3B0aW9uc11cclxuICovXG5Tb3J0YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBTb3J0YWJsZShlbCwgb3B0aW9ucyk7XG59O1xuXG4vLyBFeHBvcnRcblNvcnRhYmxlLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG52YXIgYXV0b1Njcm9sbHMgPSBbXSxcbiAgc2Nyb2xsRWwsXG4gIHNjcm9sbFJvb3RFbCxcbiAgc2Nyb2xsaW5nID0gZmFsc2UsXG4gIGxhc3RBdXRvU2Nyb2xsWCxcbiAgbGFzdEF1dG9TY3JvbGxZLFxuICB0b3VjaEV2dCQxLFxuICBwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbDtcbmZ1bmN0aW9uIEF1dG9TY3JvbGxQbHVnaW4oKSB7XG4gIGZ1bmN0aW9uIEF1dG9TY3JvbGwoKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgIGZvcmNlQXV0b1Njcm9sbEZhbGxiYWNrOiBmYWxzZSxcbiAgICAgIHNjcm9sbFNlbnNpdGl2aXR5OiAzMCxcbiAgICAgIHNjcm9sbFNwZWVkOiAxMCxcbiAgICAgIGJ1YmJsZVNjcm9sbDogdHJ1ZVxuICAgIH07XG5cbiAgICAvLyBCaW5kIGFsbCBwcml2YXRlIG1ldGhvZHNcbiAgICBmb3IgKHZhciBmbiBpbiB0aGlzKSB7XG4gICAgICBpZiAoZm4uY2hhckF0KDApID09PSAnXycgJiYgdHlwZW9mIHRoaXNbZm5dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXNbZm5dID0gdGhpc1tmbl0uYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgQXV0b1Njcm9sbC5wcm90b3R5cGUgPSB7XG4gICAgZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uIGRyYWdTdGFydGVkKF9yZWYpIHtcbiAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gX3JlZi5vcmlnaW5hbEV2ZW50O1xuICAgICAgaWYgKHRoaXMuc29ydGFibGUubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAnZHJhZ292ZXInLCB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbEV2ZW50LnRvdWNoZXMpIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb24oZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmFnT3ZlckNvbXBsZXRlZDogZnVuY3Rpb24gZHJhZ092ZXJDb21wbGV0ZWQoX3JlZjIpIHtcbiAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gX3JlZjIub3JpZ2luYWxFdmVudDtcbiAgICAgIC8vIEZvciB3aGVuIGJ1YmJsaW5nIGlzIGNhbmNlbGVkIGFuZCB1c2luZyBmYWxsYmFjayAoZmFsbGJhY2sgJ3RvdWNobW92ZScgYWx3YXlzIHJlYWNoZWQpXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5kcmFnT3ZlckJ1YmJsZSAmJiAhb3JpZ2luYWxFdmVudC5yb290RWwpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlQXV0b1Njcm9sbChvcmlnaW5hbEV2ZW50KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyb3A6IGZ1bmN0aW9uIGRyb3AoKSB7XG4gICAgICBpZiAodGhpcy5zb3J0YWJsZS5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAnZHJhZ292ZXInLCB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgIH1cbiAgICAgIGNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwoKTtcbiAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgIGNhbmNlbFRocm90dGxlKCk7XG4gICAgfSxcbiAgICBudWxsaW5nOiBmdW5jdGlvbiBudWxsaW5nKCkge1xuICAgICAgdG91Y2hFdnQkMSA9IHNjcm9sbFJvb3RFbCA9IHNjcm9sbEVsID0gc2Nyb2xsaW5nID0gcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgPSBsYXN0QXV0b1Njcm9sbFggPSBsYXN0QXV0b1Njcm9sbFkgPSBudWxsO1xuICAgICAgYXV0b1Njcm9sbHMubGVuZ3RoID0gMDtcbiAgICB9LFxuICAgIF9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGw6IGZ1bmN0aW9uIF9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwoZXZ0KSB7XG4gICAgICB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKGV2dCwgdHJ1ZSk7XG4gICAgfSxcbiAgICBfaGFuZGxlQXV0b1Njcm9sbDogZnVuY3Rpb24gX2hhbmRsZUF1dG9TY3JvbGwoZXZ0LCBmYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciB4ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFgsXG4gICAgICAgIHkgPSAoZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCkuY2xpZW50WSxcbiAgICAgICAgZWxlbSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICB0b3VjaEV2dCQxID0gZXZ0O1xuXG4gICAgICAvLyBJRSBkb2VzIG5vdCBzZWVtIHRvIGhhdmUgbmF0aXZlIGF1dG9zY3JvbGwsXG4gICAgICAvLyBFZGdlJ3MgYXV0b3Njcm9sbCBzZWVtcyB0b28gY29uZGl0aW9uYWwsXG4gICAgICAvLyBNQUNPUyBTYWZhcmkgZG9lcyBub3QgaGF2ZSBhdXRvc2Nyb2xsLFxuICAgICAgLy8gRmlyZWZveCBhbmQgQ2hyb21lIGFyZSBnb29kXG4gICAgICBpZiAoZmFsbGJhY2sgfHwgdGhpcy5vcHRpb25zLmZvcmNlQXV0b1Njcm9sbEZhbGxiYWNrIHx8IEVkZ2UgfHwgSUUxMU9yTGVzcyB8fCBTYWZhcmkpIHtcbiAgICAgICAgYXV0b1Njcm9sbChldnQsIHRoaXMub3B0aW9ucywgZWxlbSwgZmFsbGJhY2spO1xuXG4gICAgICAgIC8vIExpc3RlbmVyIGZvciBwb2ludGVyIGVsZW1lbnQgY2hhbmdlXG4gICAgICAgIHZhciBvZ0VsZW1TY3JvbGxlciA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsZW0sIHRydWUpO1xuICAgICAgICBpZiAoc2Nyb2xsaW5nICYmICghcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgfHwgeCAhPT0gbGFzdEF1dG9TY3JvbGxYIHx8IHkgIT09IGxhc3RBdXRvU2Nyb2xsWSkpIHtcbiAgICAgICAgICBwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCAmJiBjbGVhclBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKCk7XG4gICAgICAgICAgLy8gRGV0ZWN0IGZvciBwb2ludGVyIGVsZW0gY2hhbmdlLCBlbXVsYXRpbmcgbmF0aXZlIERuRCBiZWhhdmlvdXJcbiAgICAgICAgICBwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbGVtID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAobmV3RWxlbSAhPT0gb2dFbGVtU2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgb2dFbGVtU2Nyb2xsZXIgPSBuZXdFbGVtO1xuICAgICAgICAgICAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdXRvU2Nyb2xsKGV2dCwgX3RoaXMub3B0aW9ucywgbmV3RWxlbSwgZmFsbGJhY2spO1xuICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICBsYXN0QXV0b1Njcm9sbFggPSB4O1xuICAgICAgICAgIGxhc3RBdXRvU2Nyb2xsWSA9IHk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIERuRCBpcyBlbmFibGVkIChhbmQgYnJvd3NlciBoYXMgZ29vZCBhdXRvc2Nyb2xsaW5nKSwgZmlyc3QgYXV0b3Njcm9sbCB3aWxsIGFscmVhZHkgc2Nyb2xsLCBzbyBnZXQgcGFyZW50IGF1dG9zY3JvbGwgb2YgZmlyc3QgYXV0b3Njcm9sbFxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5idWJibGVTY3JvbGwgfHwgZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWxlbSwgdHJ1ZSkgPT09IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSkge1xuICAgICAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXV0b1Njcm9sbChldnQsIHRoaXMub3B0aW9ucywgZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWxlbSwgZmFsc2UpLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gX2V4dGVuZHMoQXV0b1Njcm9sbCwge1xuICAgIHBsdWdpbk5hbWU6ICdzY3JvbGwnLFxuICAgIGluaXRpYWxpemVCeURlZmF1bHQ6IHRydWVcbiAgfSk7XG59XG5mdW5jdGlvbiBjbGVhckF1dG9TY3JvbGxzKCkge1xuICBhdXRvU2Nyb2xscy5mb3JFYWNoKGZ1bmN0aW9uIChhdXRvU2Nyb2xsKSB7XG4gICAgY2xlYXJJbnRlcnZhbChhdXRvU2Nyb2xsLnBpZCk7XG4gIH0pO1xuICBhdXRvU2Nyb2xscyA9IFtdO1xufVxuZnVuY3Rpb24gY2xlYXJQb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCgpIHtcbiAgY2xlYXJJbnRlcnZhbChwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCk7XG59XG52YXIgYXV0b1Njcm9sbCA9IHRocm90dGxlKGZ1bmN0aW9uIChldnQsIG9wdGlvbnMsIHJvb3RFbCwgaXNGYWxsYmFjaykge1xuICAvLyBCdWc6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTUwNTUyMVxuICBpZiAoIW9wdGlvbnMuc2Nyb2xsKSByZXR1cm47XG4gIHZhciB4ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFgsXG4gICAgeSA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRZLFxuICAgIHNlbnMgPSBvcHRpb25zLnNjcm9sbFNlbnNpdGl2aXR5LFxuICAgIHNwZWVkID0gb3B0aW9ucy5zY3JvbGxTcGVlZCxcbiAgICB3aW5TY3JvbGxlciA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgdmFyIHNjcm9sbFRoaXNJbnN0YW5jZSA9IGZhbHNlLFxuICAgIHNjcm9sbEN1c3RvbUZuO1xuXG4gIC8vIE5ldyBzY3JvbGwgcm9vdCwgc2V0IHNjcm9sbEVsXG4gIGlmIChzY3JvbGxSb290RWwgIT09IHJvb3RFbCkge1xuICAgIHNjcm9sbFJvb3RFbCA9IHJvb3RFbDtcbiAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgc2Nyb2xsRWwgPSBvcHRpb25zLnNjcm9sbDtcbiAgICBzY3JvbGxDdXN0b21GbiA9IG9wdGlvbnMuc2Nyb2xsRm47XG4gICAgaWYgKHNjcm9sbEVsID09PSB0cnVlKSB7XG4gICAgICBzY3JvbGxFbCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KHJvb3RFbCwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIHZhciBsYXllcnNPdXQgPSAwO1xuICB2YXIgY3VycmVudFBhcmVudCA9IHNjcm9sbEVsO1xuICBkbyB7XG4gICAgdmFyIGVsID0gY3VycmVudFBhcmVudCxcbiAgICAgIHJlY3QgPSBnZXRSZWN0KGVsKSxcbiAgICAgIHRvcCA9IHJlY3QudG9wLFxuICAgICAgYm90dG9tID0gcmVjdC5ib3R0b20sXG4gICAgICBsZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgcmlnaHQgPSByZWN0LnJpZ2h0LFxuICAgICAgd2lkdGggPSByZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQsXG4gICAgICBjYW5TY3JvbGxYID0gdm9pZCAwLFxuICAgICAgY2FuU2Nyb2xsWSA9IHZvaWQgMCxcbiAgICAgIHNjcm9sbFdpZHRoID0gZWwuc2Nyb2xsV2lkdGgsXG4gICAgICBzY3JvbGxIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHQsXG4gICAgICBlbENTUyA9IGNzcyhlbCksXG4gICAgICBzY3JvbGxQb3NYID0gZWwuc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFBvc1kgPSBlbC5zY3JvbGxUb3A7XG4gICAgaWYgKGVsID09PSB3aW5TY3JvbGxlcikge1xuICAgICAgY2FuU2Nyb2xsWCA9IHdpZHRoIDwgc2Nyb2xsV2lkdGggJiYgKGVsQ1NTLm92ZXJmbG93WCA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WCA9PT0gJ3Njcm9sbCcgfHwgZWxDU1Mub3ZlcmZsb3dYID09PSAndmlzaWJsZScpO1xuICAgICAgY2FuU2Nyb2xsWSA9IGhlaWdodCA8IHNjcm9sbEhlaWdodCAmJiAoZWxDU1Mub3ZlcmZsb3dZID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dZID09PSAnc2Nyb2xsJyB8fCBlbENTUy5vdmVyZmxvd1kgPT09ICd2aXNpYmxlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhblNjcm9sbFggPSB3aWR0aCA8IHNjcm9sbFdpZHRoICYmIChlbENTUy5vdmVyZmxvd1ggPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1ggPT09ICdzY3JvbGwnKTtcbiAgICAgIGNhblNjcm9sbFkgPSBoZWlnaHQgPCBzY3JvbGxIZWlnaHQgJiYgKGVsQ1NTLm92ZXJmbG93WSA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WSA9PT0gJ3Njcm9sbCcpO1xuICAgIH1cbiAgICB2YXIgdnggPSBjYW5TY3JvbGxYICYmIChNYXRoLmFicyhyaWdodCAtIHgpIDw9IHNlbnMgJiYgc2Nyb2xsUG9zWCArIHdpZHRoIDwgc2Nyb2xsV2lkdGgpIC0gKE1hdGguYWJzKGxlZnQgLSB4KSA8PSBzZW5zICYmICEhc2Nyb2xsUG9zWCk7XG4gICAgdmFyIHZ5ID0gY2FuU2Nyb2xsWSAmJiAoTWF0aC5hYnMoYm90dG9tIC0geSkgPD0gc2VucyAmJiBzY3JvbGxQb3NZICsgaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0KSAtIChNYXRoLmFicyh0b3AgLSB5KSA8PSBzZW5zICYmICEhc2Nyb2xsUG9zWSk7XG4gICAgaWYgKCFhdXRvU2Nyb2xsc1tsYXllcnNPdXRdKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsYXllcnNPdXQ7IGkrKykge1xuICAgICAgICBpZiAoIWF1dG9TY3JvbGxzW2ldKSB7XG4gICAgICAgICAgYXV0b1Njcm9sbHNbaV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS52eCAhPSB2eCB8fCBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ5ICE9IHZ5IHx8IGF1dG9TY3JvbGxzW2xheWVyc091dF0uZWwgIT09IGVsKSB7XG4gICAgICBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLmVsID0gZWw7XG4gICAgICBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ4ID0gdng7XG4gICAgICBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ5ID0gdnk7XG4gICAgICBjbGVhckludGVydmFsKGF1dG9TY3JvbGxzW2xheWVyc091dF0ucGlkKTtcbiAgICAgIGlmICh2eCAhPSAwIHx8IHZ5ICE9IDApIHtcbiAgICAgICAgc2Nyb2xsVGhpc0luc3RhbmNlID0gdHJ1ZTtcbiAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cbiAgICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5waWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gZW11bGF0ZSBkcmFnIG92ZXIgZHVyaW5nIGF1dG9zY3JvbGwgKGZhbGxiYWNrKSwgZW11bGF0aW5nIG5hdGl2ZSBEbkQgYmVoYXZpb3VyXG4gICAgICAgICAgaWYgKGlzRmFsbGJhY2sgJiYgdGhpcy5sYXllciA9PT0gMCkge1xuICAgICAgICAgICAgU29ydGFibGUuYWN0aXZlLl9vblRvdWNoTW92ZSh0b3VjaEV2dCQxKTsgLy8gVG8gbW92ZSBnaG9zdCBpZiBpdCBpcyBwb3NpdGlvbmVkIGFic29sdXRlbHlcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNjcm9sbE9mZnNldFkgPSBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eSA/IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ5ICogc3BlZWQgOiAwO1xuICAgICAgICAgIHZhciBzY3JvbGxPZmZzZXRYID0gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnggPyBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eCAqIHNwZWVkIDogMDtcbiAgICAgICAgICBpZiAodHlwZW9mIHNjcm9sbEN1c3RvbUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsQ3VzdG9tRm4uY2FsbChTb3J0YWJsZS5kcmFnZ2VkLnBhcmVudE5vZGVbZXhwYW5kb10sIHNjcm9sbE9mZnNldFgsIHNjcm9sbE9mZnNldFksIGV2dCwgdG91Y2hFdnQkMSwgYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0uZWwpICE9PSAnY29udGludWUnKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc2Nyb2xsQnkoYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0uZWwsIHNjcm9sbE9mZnNldFgsIHNjcm9sbE9mZnNldFkpO1xuICAgICAgICB9LmJpbmQoe1xuICAgICAgICAgIGxheWVyOiBsYXllcnNPdXRcbiAgICAgICAgfSksIDI0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGF5ZXJzT3V0Kys7XG4gIH0gd2hpbGUgKG9wdGlvbnMuYnViYmxlU2Nyb2xsICYmIGN1cnJlbnRQYXJlbnQgIT09IHdpblNjcm9sbGVyICYmIChjdXJyZW50UGFyZW50ID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoY3VycmVudFBhcmVudCwgZmFsc2UpKSk7XG4gIHNjcm9sbGluZyA9IHNjcm9sbFRoaXNJbnN0YW5jZTsgLy8gaW4gY2FzZSBhbm90aGVyIGZ1bmN0aW9uIGNhdGNoZXMgc2Nyb2xsaW5nIGFzIGZhbHNlIGluIGJldHdlZW4gd2hlbiBpdCBpcyBub3Rcbn0sIDMwKTtcblxudmFyIGRyb3AgPSBmdW5jdGlvbiBkcm9wKF9yZWYpIHtcbiAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmLm9yaWdpbmFsRXZlbnQsXG4gICAgcHV0U29ydGFibGUgPSBfcmVmLnB1dFNvcnRhYmxlLFxuICAgIGRyYWdFbCA9IF9yZWYuZHJhZ0VsLFxuICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZi5hY3RpdmVTb3J0YWJsZSxcbiAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQgPSBfcmVmLmRpc3BhdGNoU29ydGFibGVFdmVudCxcbiAgICBoaWRlR2hvc3RGb3JUYXJnZXQgPSBfcmVmLmhpZGVHaG9zdEZvclRhcmdldCxcbiAgICB1bmhpZGVHaG9zdEZvclRhcmdldCA9IF9yZWYudW5oaWRlR2hvc3RGb3JUYXJnZXQ7XG4gIGlmICghb3JpZ2luYWxFdmVudCkgcmV0dXJuO1xuICB2YXIgdG9Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IGFjdGl2ZVNvcnRhYmxlO1xuICBoaWRlR2hvc3RGb3JUYXJnZXQoKTtcbiAgdmFyIHRvdWNoID0gb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA/IG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBvcmlnaW5hbEV2ZW50O1xuICB2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcbiAgdW5oaWRlR2hvc3RGb3JUYXJnZXQoKTtcbiAgaWYgKHRvU29ydGFibGUgJiYgIXRvU29ydGFibGUuZWwuY29udGFpbnModGFyZ2V0KSkge1xuICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCgnc3BpbGwnKTtcbiAgICB0aGlzLm9uU3BpbGwoe1xuICAgICAgZHJhZ0VsOiBkcmFnRWwsXG4gICAgICBwdXRTb3J0YWJsZTogcHV0U29ydGFibGVcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIFJldmVydCgpIHt9XG5SZXZlcnQucHJvdG90eXBlID0ge1xuICBzdGFydEluZGV4OiBudWxsLFxuICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIGRyYWdTdGFydChfcmVmMikge1xuICAgIHZhciBvbGREcmFnZ2FibGVJbmRleCA9IF9yZWYyLm9sZERyYWdnYWJsZUluZGV4O1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICB9LFxuICBvblNwaWxsOiBmdW5jdGlvbiBvblNwaWxsKF9yZWYzKSB7XG4gICAgdmFyIGRyYWdFbCA9IF9yZWYzLmRyYWdFbCxcbiAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjMucHV0U29ydGFibGU7XG4gICAgdGhpcy5zb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICBpZiAocHV0U29ydGFibGUpIHtcbiAgICAgIHB1dFNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgIH1cbiAgICB2YXIgbmV4dFNpYmxpbmcgPSBnZXRDaGlsZCh0aGlzLnNvcnRhYmxlLmVsLCB0aGlzLnN0YXJ0SW5kZXgsIHRoaXMub3B0aW9ucyk7XG4gICAgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICB0aGlzLnNvcnRhYmxlLmVsLmluc2VydEJlZm9yZShkcmFnRWwsIG5leHRTaWJsaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zb3J0YWJsZS5lbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgIH1cbiAgICB0aGlzLnNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICBpZiAocHV0U29ydGFibGUpIHtcbiAgICAgIHB1dFNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICB9XG4gIH0sXG4gIGRyb3A6IGRyb3Bcbn07XG5fZXh0ZW5kcyhSZXZlcnQsIHtcbiAgcGx1Z2luTmFtZTogJ3JldmVydE9uU3BpbGwnXG59KTtcbmZ1bmN0aW9uIFJlbW92ZSgpIHt9XG5SZW1vdmUucHJvdG90eXBlID0ge1xuICBvblNwaWxsOiBmdW5jdGlvbiBvblNwaWxsKF9yZWY0KSB7XG4gICAgdmFyIGRyYWdFbCA9IF9yZWY0LmRyYWdFbCxcbiAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjQucHV0U29ydGFibGU7XG4gICAgdmFyIHBhcmVudFNvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgdGhpcy5zb3J0YWJsZTtcbiAgICBwYXJlbnRTb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICBkcmFnRWwucGFyZW50Tm9kZSAmJiBkcmFnRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkcmFnRWwpO1xuICAgIHBhcmVudFNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgfSxcbiAgZHJvcDogZHJvcFxufTtcbl9leHRlbmRzKFJlbW92ZSwge1xuICBwbHVnaW5OYW1lOiAncmVtb3ZlT25TcGlsbCdcbn0pO1xuXG52YXIgbGFzdFN3YXBFbDtcbmZ1bmN0aW9uIFN3YXBQbHVnaW4oKSB7XG4gIGZ1bmN0aW9uIFN3YXAoKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgIHN3YXBDbGFzczogJ3NvcnRhYmxlLXN3YXAtaGlnaGxpZ2h0J1xuICAgIH07XG4gIH1cbiAgU3dhcC5wcm90b3R5cGUgPSB7XG4gICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiBkcmFnU3RhcnQoX3JlZikge1xuICAgICAgdmFyIGRyYWdFbCA9IF9yZWYuZHJhZ0VsO1xuICAgICAgbGFzdFN3YXBFbCA9IGRyYWdFbDtcbiAgICB9LFxuICAgIGRyYWdPdmVyVmFsaWQ6IGZ1bmN0aW9uIGRyYWdPdmVyVmFsaWQoX3JlZjIpIHtcbiAgICAgIHZhciBjb21wbGV0ZWQgPSBfcmVmMi5jb21wbGV0ZWQsXG4gICAgICAgIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgICAgb25Nb3ZlID0gX3JlZjIub25Nb3ZlLFxuICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IF9yZWYyLmFjdGl2ZVNvcnRhYmxlLFxuICAgICAgICBjaGFuZ2VkID0gX3JlZjIuY2hhbmdlZCxcbiAgICAgICAgY2FuY2VsID0gX3JlZjIuY2FuY2VsO1xuICAgICAgaWYgKCFhY3RpdmVTb3J0YWJsZS5vcHRpb25zLnN3YXApIHJldHVybjtcbiAgICAgIHZhciBlbCA9IHRoaXMuc29ydGFibGUuZWwsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgdmFyIHByZXZTd2FwRWwgPSBsYXN0U3dhcEVsO1xuICAgICAgICBpZiAob25Nb3ZlKHRhcmdldCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3ModGFyZ2V0LCBvcHRpb25zLnN3YXBDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgbGFzdFN3YXBFbCA9IHRhcmdldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0U3dhcEVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlN3YXBFbCAmJiBwcmV2U3dhcEVsICE9PSBsYXN0U3dhcEVsKSB7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MocHJldlN3YXBFbCwgb3B0aW9ucy5zd2FwQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hhbmdlZCgpO1xuICAgICAgY29tcGxldGVkKHRydWUpO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfSxcbiAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKF9yZWYzKSB7XG4gICAgICB2YXIgYWN0aXZlU29ydGFibGUgPSBfcmVmMy5hY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmMy5wdXRTb3J0YWJsZSxcbiAgICAgICAgZHJhZ0VsID0gX3JlZjMuZHJhZ0VsO1xuICAgICAgdmFyIHRvU29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCB0aGlzLnNvcnRhYmxlO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBsYXN0U3dhcEVsICYmIHRvZ2dsZUNsYXNzKGxhc3RTd2FwRWwsIG9wdGlvbnMuc3dhcENsYXNzLCBmYWxzZSk7XG4gICAgICBpZiAobGFzdFN3YXBFbCAmJiAob3B0aW9ucy5zd2FwIHx8IHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLm9wdGlvbnMuc3dhcCkpIHtcbiAgICAgICAgaWYgKGRyYWdFbCAhPT0gbGFzdFN3YXBFbCkge1xuICAgICAgICAgIHRvU29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgICAgICAgaWYgKHRvU29ydGFibGUgIT09IGFjdGl2ZVNvcnRhYmxlKSBhY3RpdmVTb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgICAgICBzd2FwTm9kZXMoZHJhZ0VsLCBsYXN0U3dhcEVsKTtcbiAgICAgICAgICB0b1NvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgICBpZiAodG9Tb3J0YWJsZSAhPT0gYWN0aXZlU29ydGFibGUpIGFjdGl2ZVNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbnVsbGluZzogZnVuY3Rpb24gbnVsbGluZygpIHtcbiAgICAgIGxhc3RTd2FwRWwgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzKFN3YXAsIHtcbiAgICBwbHVnaW5OYW1lOiAnc3dhcCcsXG4gICAgZXZlbnRQcm9wZXJ0aWVzOiBmdW5jdGlvbiBldmVudFByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzd2FwSXRlbTogbGFzdFN3YXBFbFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gc3dhcE5vZGVzKG4xLCBuMikge1xuICB2YXIgcDEgPSBuMS5wYXJlbnROb2RlLFxuICAgIHAyID0gbjIucGFyZW50Tm9kZSxcbiAgICBpMSxcbiAgICBpMjtcbiAgaWYgKCFwMSB8fCAhcDIgfHwgcDEuaXNFcXVhbE5vZGUobjIpIHx8IHAyLmlzRXF1YWxOb2RlKG4xKSkgcmV0dXJuO1xuICBpMSA9IGluZGV4KG4xKTtcbiAgaTIgPSBpbmRleChuMik7XG4gIGlmIChwMS5pc0VxdWFsTm9kZShwMikgJiYgaTEgPCBpMikge1xuICAgIGkyKys7XG4gIH1cbiAgcDEuaW5zZXJ0QmVmb3JlKG4yLCBwMS5jaGlsZHJlbltpMV0pO1xuICBwMi5pbnNlcnRCZWZvcmUobjEsIHAyLmNoaWxkcmVuW2kyXSk7XG59XG5cbnZhciBtdWx0aURyYWdFbGVtZW50cyA9IFtdLFxuICBtdWx0aURyYWdDbG9uZXMgPSBbXSxcbiAgbGFzdE11bHRpRHJhZ1NlbGVjdCxcbiAgLy8gZm9yIHNlbGVjdGlvbiB3aXRoIG1vZGlmaWVyIGtleSBkb3duIChTSElGVClcbiAgbXVsdGlEcmFnU29ydGFibGUsXG4gIGluaXRpYWxGb2xkaW5nID0gZmFsc2UsXG4gIC8vIEluaXRpYWwgbXVsdGktZHJhZyBmb2xkIHdoZW4gZHJhZyBzdGFydGVkXG4gIGZvbGRpbmcgPSBmYWxzZSxcbiAgLy8gRm9sZGluZyBhbnkgb3RoZXIgdGltZVxuICBkcmFnU3RhcnRlZCA9IGZhbHNlLFxuICBkcmFnRWwkMSxcbiAgY2xvbmVzRnJvbVJlY3QsXG4gIGNsb25lc0hpZGRlbjtcbmZ1bmN0aW9uIE11bHRpRHJhZ1BsdWdpbigpIHtcbiAgZnVuY3Rpb24gTXVsdGlEcmFnKHNvcnRhYmxlKSB7XG4gICAgLy8gQmluZCBhbGwgcHJpdmF0ZSBtZXRob2RzXG4gICAgZm9yICh2YXIgZm4gaW4gdGhpcykge1xuICAgICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc29ydGFibGUub3B0aW9ucy5hdm9pZEltcGxpY2l0RGVzZWxlY3QpIHtcbiAgICAgIGlmIChzb3J0YWJsZS5vcHRpb25zLnN1cHBvcnRQb2ludGVyKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgICBvbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgfVxuICAgIH1cbiAgICBvbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9jaGVja0tleURvd24pO1xuICAgIG9uKGRvY3VtZW50LCAna2V5dXAnLCB0aGlzLl9jaGVja0tleVVwKTtcbiAgICB0aGlzLmRlZmF1bHRzID0ge1xuICAgICAgc2VsZWN0ZWRDbGFzczogJ3NvcnRhYmxlLXNlbGVjdGVkJyxcbiAgICAgIG11bHRpRHJhZ0tleTogbnVsbCxcbiAgICAgIGF2b2lkSW1wbGljaXREZXNlbGVjdDogZmFsc2UsXG4gICAgICBzZXREYXRhOiBmdW5jdGlvbiBzZXREYXRhKGRhdGFUcmFuc2ZlciwgZHJhZ0VsKSB7XG4gICAgICAgIHZhciBkYXRhID0gJyc7XG4gICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggJiYgbXVsdGlEcmFnU29ydGFibGUgPT09IHNvcnRhYmxlKSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCwgaSkge1xuICAgICAgICAgICAgZGF0YSArPSAoIWkgPyAnJyA6ICcsICcpICsgbXVsdGlEcmFnRWxlbWVudC50ZXh0Q29udGVudDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhID0gZHJhZ0VsLnRleHRDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGRhdGFUcmFuc2Zlci5zZXREYXRhKCdUZXh0JywgZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBNdWx0aURyYWcucHJvdG90eXBlID0ge1xuICAgIG11bHRpRHJhZ0tleURvd246IGZhbHNlLFxuICAgIGlzTXVsdGlEcmFnOiBmYWxzZSxcbiAgICBkZWxheVN0YXJ0R2xvYmFsOiBmdW5jdGlvbiBkZWxheVN0YXJ0R2xvYmFsKF9yZWYpIHtcbiAgICAgIHZhciBkcmFnZ2VkID0gX3JlZi5kcmFnRWw7XG4gICAgICBkcmFnRWwkMSA9IGRyYWdnZWQ7XG4gICAgfSxcbiAgICBkZWxheUVuZGVkOiBmdW5jdGlvbiBkZWxheUVuZGVkKCkge1xuICAgICAgdGhpcy5pc011bHRpRHJhZyA9IH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGRyYWdFbCQxKTtcbiAgICB9LFxuICAgIHNldHVwQ2xvbmU6IGZ1bmN0aW9uIHNldHVwQ2xvbmUoX3JlZjIpIHtcbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWYyLnNvcnRhYmxlLFxuICAgICAgICBjYW5jZWwgPSBfcmVmMi5jYW5jZWw7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbXVsdGlEcmFnQ2xvbmVzLnB1c2goY2xvbmUobXVsdGlEcmFnRWxlbWVudHNbaV0pKTtcbiAgICAgICAgbXVsdGlEcmFnQ2xvbmVzW2ldLnNvcnRhYmxlSW5kZXggPSBtdWx0aURyYWdFbGVtZW50c1tpXS5zb3J0YWJsZUluZGV4O1xuICAgICAgICBtdWx0aURyYWdDbG9uZXNbaV0uZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lc1tpXS5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICcnO1xuICAgICAgICB0b2dnbGVDbGFzcyhtdWx0aURyYWdDbG9uZXNbaV0sIHRoaXMub3B0aW9ucy5zZWxlY3RlZENsYXNzLCBmYWxzZSk7XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzW2ldID09PSBkcmFnRWwkMSAmJiB0b2dnbGVDbGFzcyhtdWx0aURyYWdDbG9uZXNbaV0sIHRoaXMub3B0aW9ucy5jaG9zZW5DbGFzcywgZmFsc2UpO1xuICAgICAgfVxuICAgICAgc29ydGFibGUuX2hpZGVDbG9uZSgpO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoX3JlZjMpIHtcbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWYzLnNvcnRhYmxlLFxuICAgICAgICByb290RWwgPSBfcmVmMy5yb290RWwsXG4gICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCA9IF9yZWYzLmRpc3BhdGNoU29ydGFibGVFdmVudCxcbiAgICAgICAgY2FuY2VsID0gX3JlZjMuY2FuY2VsO1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSkge1xuICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoICYmIG11bHRpRHJhZ1NvcnRhYmxlID09PSBzb3J0YWJsZSkge1xuICAgICAgICAgIGluc2VydE11bHRpRHJhZ0Nsb25lcyh0cnVlLCByb290RWwpO1xuICAgICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCgnY2xvbmUnKTtcbiAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2hvd0Nsb25lOiBmdW5jdGlvbiBzaG93Q2xvbmUoX3JlZjQpIHtcbiAgICAgIHZhciBjbG9uZU5vd1Nob3duID0gX3JlZjQuY2xvbmVOb3dTaG93bixcbiAgICAgICAgcm9vdEVsID0gX3JlZjQucm9vdEVsLFxuICAgICAgICBjYW5jZWwgPSBfcmVmNC5jYW5jZWw7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcbiAgICAgIGluc2VydE11bHRpRHJhZ0Nsb25lcyhmYWxzZSwgcm9vdEVsKTtcbiAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICBjc3MoY2xvbmUsICdkaXNwbGF5JywgJycpO1xuICAgICAgfSk7XG4gICAgICBjbG9uZU5vd1Nob3duKCk7XG4gICAgICBjbG9uZXNIaWRkZW4gPSBmYWxzZTtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH0sXG4gICAgaGlkZUNsb25lOiBmdW5jdGlvbiBoaWRlQ2xvbmUoX3JlZjUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgc29ydGFibGUgPSBfcmVmNS5zb3J0YWJsZSxcbiAgICAgICAgY2xvbmVOb3dIaWRkZW4gPSBfcmVmNS5jbG9uZU5vd0hpZGRlbixcbiAgICAgICAgY2FuY2VsID0gX3JlZjUuY2FuY2VsO1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG4gICAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgY3NzKGNsb25lLCAnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlICYmIGNsb25lLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjbG9uZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjbG9uZU5vd0hpZGRlbigpO1xuICAgICAgY2xvbmVzSGlkZGVuID0gdHJ1ZTtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH0sXG4gICAgZHJhZ1N0YXJ0R2xvYmFsOiBmdW5jdGlvbiBkcmFnU3RhcnRHbG9iYWwoX3JlZjYpIHtcbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWY2LnNvcnRhYmxlO1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnICYmIG11bHRpRHJhZ1NvcnRhYmxlKSB7XG4gICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlLm11bHRpRHJhZy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcbiAgICAgIH1cbiAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudC5zb3J0YWJsZUluZGV4ID0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU29ydCBtdWx0aS1kcmFnIGVsZW1lbnRzXG4gICAgICBtdWx0aURyYWdFbGVtZW50cyA9IG11bHRpRHJhZ0VsZW1lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuc29ydGFibGVJbmRleCAtIGIuc29ydGFibGVJbmRleDtcbiAgICAgIH0pO1xuICAgICAgZHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uIGRyYWdTdGFydGVkKF9yZWY3KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWY3LnNvcnRhYmxlO1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNvcnQpIHtcbiAgICAgICAgLy8gQ2FwdHVyZSByZWN0cyxcbiAgICAgICAgLy8gaGlkZSBtdWx0aSBkcmFnIGVsZW1lbnRzIChieSBwb3NpdGlvbmluZyB0aGVtIGFic29sdXRlKSxcbiAgICAgICAgLy8gc2V0IG11bHRpIGRyYWcgZWxlbWVudHMgcmVjdHMgdG8gZHJhZ1JlY3QsXG4gICAgICAgIC8vIHNob3cgbXVsdGkgZHJhZyBlbGVtZW50cyxcbiAgICAgICAgLy8gYW5pbWF0ZSB0byByZWN0cyxcbiAgICAgICAgLy8gdW5zZXQgcmVjdHMgJiByZW1vdmUgZnJvbSBET01cblxuICAgICAgICBzb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCA9PT0gZHJhZ0VsJDEpIHJldHVybjtcbiAgICAgICAgICAgIGNzcyhtdWx0aURyYWdFbGVtZW50LCAncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgZHJhZ1JlY3QgPSBnZXRSZWN0KGRyYWdFbCQxLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgPT09IGRyYWdFbCQxKSByZXR1cm47XG4gICAgICAgICAgICBzZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQsIGRyYWdSZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb2xkaW5nID0gdHJ1ZTtcbiAgICAgICAgICBpbml0aWFsRm9sZGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNvcnRhYmxlLmFuaW1hdGVBbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICBmb2xkaW5nID0gZmFsc2U7XG4gICAgICAgIGluaXRpYWxGb2xkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICB1bnNldFJlY3QobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgYWxsIGF1eGlsaWFyeSBtdWx0aWRyYWcgaXRlbXMgZnJvbSBlbCwgaWYgc29ydGluZyBlbmFibGVkXG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5zb3J0KSB7XG4gICAgICAgICAgcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBkcmFnT3ZlcjogZnVuY3Rpb24gZHJhZ092ZXIoX3JlZjgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBfcmVmOC50YXJnZXQsXG4gICAgICAgIGNvbXBsZXRlZCA9IF9yZWY4LmNvbXBsZXRlZCxcbiAgICAgICAgY2FuY2VsID0gX3JlZjguY2FuY2VsO1xuICAgICAgaWYgKGZvbGRpbmcgJiYgfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YodGFyZ2V0KSkge1xuICAgICAgICBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJldmVydDogZnVuY3Rpb24gcmV2ZXJ0KF9yZWY5KSB7XG4gICAgICB2YXIgZnJvbVNvcnRhYmxlID0gX3JlZjkuZnJvbVNvcnRhYmxlLFxuICAgICAgICByb290RWwgPSBfcmVmOS5yb290RWwsXG4gICAgICAgIHNvcnRhYmxlID0gX3JlZjkuc29ydGFibGUsXG4gICAgICAgIGRyYWdSZWN0ID0gX3JlZjkuZHJhZ1JlY3Q7XG4gICAgICBpZiAobXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBTZXR1cCB1bmZvbGQgYW5pbWF0aW9uXG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICBzb3J0YWJsZS5hZGRBbmltYXRpb25TdGF0ZSh7XG4gICAgICAgICAgICB0YXJnZXQ6IG11bHRpRHJhZ0VsZW1lbnQsXG4gICAgICAgICAgICByZWN0OiBmb2xkaW5nID8gZ2V0UmVjdChtdWx0aURyYWdFbGVtZW50KSA6IGRyYWdSZWN0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdW5zZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQuZnJvbVJlY3QgPSBkcmFnUmVjdDtcbiAgICAgICAgICBmcm9tU29ydGFibGUucmVtb3ZlQW5pbWF0aW9uU3RhdGUobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb2xkaW5nID0gZmFsc2U7XG4gICAgICAgIGluc2VydE11bHRpRHJhZ0VsZW1lbnRzKCF0aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUsIHJvb3RFbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmFnT3ZlckNvbXBsZXRlZDogZnVuY3Rpb24gZHJhZ092ZXJDb21wbGV0ZWQoX3JlZjEwKSB7XG4gICAgICB2YXIgc29ydGFibGUgPSBfcmVmMTAuc29ydGFibGUsXG4gICAgICAgIGlzT3duZXIgPSBfcmVmMTAuaXNPd25lcixcbiAgICAgICAgaW5zZXJ0aW9uID0gX3JlZjEwLmluc2VydGlvbixcbiAgICAgICAgYWN0aXZlU29ydGFibGUgPSBfcmVmMTAuYWN0aXZlU29ydGFibGUsXG4gICAgICAgIHBhcmVudEVsID0gX3JlZjEwLnBhcmVudEVsLFxuICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYxMC5wdXRTb3J0YWJsZTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAvLyBDbG9uZXMgbXVzdCBiZSBoaWRkZW4gYmVmb3JlIGZvbGRpbmcgYW5pbWF0aW9uIHRvIGNhcHR1cmUgZHJhZ1JlY3RBYnNvbHV0ZSBwcm9wZXJseVxuICAgICAgICBpZiAoaXNPd25lcikge1xuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9oaWRlQ2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpbml0aWFsRm9sZGluZyA9IGZhbHNlO1xuICAgICAgICAvLyBJZiBsZWF2aW5nIHNvcnQ6ZmFsc2Ugcm9vdCwgb3IgYWxyZWFkeSBmb2xkaW5nIC0gRm9sZCB0byBuZXcgbG9jYXRpb25cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uICYmIG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEgJiYgKGZvbGRpbmcgfHwgIWlzT3duZXIgJiYgIWFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuc29ydCAmJiAhcHV0U29ydGFibGUpKSB7XG4gICAgICAgICAgLy8gRm9sZDogU2V0IGFsbCBtdWx0aSBkcmFnIGVsZW1lbnRzJ3MgcmVjdHMgdG8gZHJhZ0VsJ3MgcmVjdCB3aGVuIG11bHRpLWRyYWcgZWxlbWVudHMgYXJlIGludmlzaWJsZVxuICAgICAgICAgIHZhciBkcmFnUmVjdEFic29sdXRlID0gZ2V0UmVjdChkcmFnRWwkMSwgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgICAgICAgICAgc2V0UmVjdChtdWx0aURyYWdFbGVtZW50LCBkcmFnUmVjdEFic29sdXRlKTtcblxuICAgICAgICAgICAgLy8gTW92ZSBlbGVtZW50KHMpIHRvIGVuZCBvZiBwYXJlbnRFbCBzbyB0aGF0IGl0IGRvZXMgbm90IGludGVyZmVyZSB3aXRoIG11bHRpLWRyYWcgY2xvbmVzIGluc2VydGlvbiBpZiB0aGV5IGFyZSBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gd2hpbGUgZm9sZGluZywgYW5kIHNvIHRoYXQgd2UgY2FuIGNhcHR1cmUgdGhlbSBhZ2FpbiBiZWNhdXNlIG9sZCBzb3J0YWJsZSB3aWxsIG5vIGxvbmdlciBiZSBmcm9tU29ydGFibGVcbiAgICAgICAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvbGRpbmcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xvbmVzIG11c3QgYmUgc2hvd24gKGFuZCBjaGVjayB0byByZW1vdmUgbXVsdGkgZHJhZ3MpIGFmdGVyIGZvbGRpbmcgd2hlbiBpbnRlcmZlcmluZyBtdWx0aURyYWdFbGVtZW50cyBhcmUgbW92ZWQgb3V0XG4gICAgICAgIGlmICghaXNPd25lcikge1xuICAgICAgICAgIC8vIE9ubHkgcmVtb3ZlIGlmIG5vdCBmb2xkaW5nIChmb2xkaW5nIHdpbGwgcmVtb3ZlIHRoZW0gYW55d2F5cylcbiAgICAgICAgICBpZiAoIWZvbGRpbmcpIHtcbiAgICAgICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmVzSGlkZGVuQmVmb3JlID0gY2xvbmVzSGlkZGVuO1xuICAgICAgICAgICAgYWN0aXZlU29ydGFibGUuX3Nob3dDbG9uZShzb3J0YWJsZSk7XG5cbiAgICAgICAgICAgIC8vIFVuZm9sZCBhbmltYXRpb24gZm9yIGNsb25lcyBpZiBzaG93aW5nIGZyb20gaGlkZGVuXG4gICAgICAgICAgICBpZiAoYWN0aXZlU29ydGFibGUub3B0aW9ucy5hbmltYXRpb24gJiYgIWNsb25lc0hpZGRlbiAmJiBjbG9uZXNIaWRkZW5CZWZvcmUpIHtcbiAgICAgICAgICAgICAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlU29ydGFibGUuYWRkQW5pbWF0aW9uU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBjbG9uZSxcbiAgICAgICAgICAgICAgICAgIHJlY3Q6IGNsb25lc0Zyb21SZWN0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2xvbmUuZnJvbVJlY3QgPSBjbG9uZXNGcm9tUmVjdDtcbiAgICAgICAgICAgICAgICBjbG9uZS50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlU29ydGFibGUuX3Nob3dDbG9uZShzb3J0YWJsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmFnT3ZlckFuaW1hdGlvbkNhcHR1cmU6IGZ1bmN0aW9uIGRyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZShfcmVmMTEpIHtcbiAgICAgIHZhciBkcmFnUmVjdCA9IF9yZWYxMS5kcmFnUmVjdCxcbiAgICAgICAgaXNPd25lciA9IF9yZWYxMS5pc093bmVyLFxuICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IF9yZWYxMS5hY3RpdmVTb3J0YWJsZTtcbiAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudC50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBpZiAoYWN0aXZlU29ydGFibGUub3B0aW9ucy5hbmltYXRpb24gJiYgIWlzT3duZXIgJiYgYWN0aXZlU29ydGFibGUubXVsdGlEcmFnLmlzTXVsdGlEcmFnKSB7XG4gICAgICAgIGNsb25lc0Zyb21SZWN0ID0gX2V4dGVuZHMoe30sIGRyYWdSZWN0KTtcbiAgICAgICAgdmFyIGRyYWdNYXRyaXggPSBtYXRyaXgoZHJhZ0VsJDEsIHRydWUpO1xuICAgICAgICBjbG9uZXNGcm9tUmVjdC50b3AgLT0gZHJhZ01hdHJpeC5mO1xuICAgICAgICBjbG9uZXNGcm9tUmVjdC5sZWZ0IC09IGRyYWdNYXRyaXguZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQW5pbWF0aW9uQ29tcGxldGU6IGZ1bmN0aW9uIGRyYWdPdmVyQW5pbWF0aW9uQ29tcGxldGUoKSB7XG4gICAgICBpZiAoZm9sZGluZykge1xuICAgICAgICBmb2xkaW5nID0gZmFsc2U7XG4gICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKF9yZWYxMikge1xuICAgICAgdmFyIGV2dCA9IF9yZWYxMi5vcmlnaW5hbEV2ZW50LFxuICAgICAgICByb290RWwgPSBfcmVmMTIucm9vdEVsLFxuICAgICAgICBwYXJlbnRFbCA9IF9yZWYxMi5wYXJlbnRFbCxcbiAgICAgICAgc29ydGFibGUgPSBfcmVmMTIuc29ydGFibGUsXG4gICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCA9IF9yZWYxMi5kaXNwYXRjaFNvcnRhYmxlRXZlbnQsXG4gICAgICAgIG9sZEluZGV4ID0gX3JlZjEyLm9sZEluZGV4LFxuICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYxMi5wdXRTb3J0YWJsZTtcbiAgICAgIHZhciB0b1NvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgdGhpcy5zb3J0YWJsZTtcbiAgICAgIGlmICghZXZ0KSByZXR1cm47XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgY2hpbGRyZW4gPSBwYXJlbnRFbC5jaGlsZHJlbjtcblxuICAgICAgLy8gTXVsdGktZHJhZyBzZWxlY3Rpb25cbiAgICAgIGlmICghZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubXVsdGlEcmFnS2V5ICYmICF0aGlzLm11bHRpRHJhZ0tleURvd24pIHtcbiAgICAgICAgICB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZygpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCQxLCBvcHRpb25zLnNlbGVjdGVkQ2xhc3MsICF+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSkpO1xuICAgICAgICBpZiAoIX5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGRyYWdFbCQxKSkge1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnB1c2goZHJhZ0VsJDEpO1xuICAgICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICAgICAgcm9vdEVsOiByb290RWwsXG4gICAgICAgICAgICBuYW1lOiAnc2VsZWN0JyxcbiAgICAgICAgICAgIHRhcmdldEVsOiBkcmFnRWwkMSxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gTW9kaWZpZXIgYWN0aXZhdGVkLCBzZWxlY3QgZnJvbSBsYXN0IHRvIGRyYWdFbFxuICAgICAgICAgIGlmIChldnQuc2hpZnRLZXkgJiYgbGFzdE11bHRpRHJhZ1NlbGVjdCAmJiBzb3J0YWJsZS5lbC5jb250YWlucyhsYXN0TXVsdGlEcmFnU2VsZWN0KSkge1xuICAgICAgICAgICAgdmFyIGxhc3RJbmRleCA9IGluZGV4KGxhc3RNdWx0aURyYWdTZWxlY3QpLFxuICAgICAgICAgICAgICBjdXJyZW50SW5kZXggPSBpbmRleChkcmFnRWwkMSk7XG4gICAgICAgICAgICBpZiAofmxhc3RJbmRleCAmJiB+Y3VycmVudEluZGV4ICYmIGxhc3RJbmRleCAhPT0gY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gTXVzdCBpbmNsdWRlIGxhc3RNdWx0aURyYWdTZWxlY3QgKHNlbGVjdCBpdCksIGluIGNhc2UgbW9kaWZpZWQgc2VsZWN0aW9uIGZyb20gbm8gc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gKGJ1dCBwcmV2aW91cyBzZWxlY3Rpb24gZXhpc3RlZClcbiAgICAgICAgICAgICAgICB2YXIgbiwgaTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICBpID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgbiA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaSA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICAgIG4gPSBsYXN0SW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmICh+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihjaGlsZHJlbltpXSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZWxlbWVudCBpcyBkcmFnZ2FibGVcbiAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VzdChjaGlsZHJlbltpXSwgb3B0aW9ucy5kcmFnZ2FibGUsIHBhcmVudEVsLCBmYWxzZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZWxlbWVudCBpcyBmaWx0ZXJlZFxuICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gZmlsdGVyICYmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nID8gZmlsdGVyLmNhbGwoc29ydGFibGUsIGV2dCwgY2hpbGRyZW5baV0sIHNvcnRhYmxlKSA6IGZpbHRlci5zcGxpdCgnLCcpLnNvbWUoZnVuY3Rpb24gKGNyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZXN0KGNoaWxkcmVuW2ldLCBjcml0ZXJpYS50cmltKCksIHBhcmVudEVsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoY2hpbGRyZW5baV0sIG9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGUsXG4gICAgICAgICAgICAgICAgICAgIHJvb3RFbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2VsZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWw6IGNoaWxkcmVuW2ldLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdE11bHRpRHJhZ1NlbGVjdCA9IGRyYWdFbCQxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtdWx0aURyYWdTb3J0YWJsZSA9IHRvU29ydGFibGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuc3BsaWNlKG11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZHJhZ0VsJDEpLCAxKTtcbiAgICAgICAgICBsYXN0TXVsdGlEcmFnU2VsZWN0ID0gbnVsbDtcbiAgICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgICAgIHJvb3RFbDogcm9vdEVsLFxuICAgICAgICAgICAgbmFtZTogJ2Rlc2VsZWN0JyxcbiAgICAgICAgICAgIHRhcmdldEVsOiBkcmFnRWwkMSxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE11bHRpLWRyYWcgZHJvcFxuICAgICAgaWYgKGRyYWdTdGFydGVkICYmIHRoaXMuaXNNdWx0aURyYWcpIHtcbiAgICAgICAgZm9sZGluZyA9IGZhbHNlO1xuICAgICAgICAvLyBEbyBub3QgXCJ1bmZvbGRcIiBhZnRlciBhcm91bmQgZHJhZ0VsIGlmIHJldmVydGVkXG4gICAgICAgIGlmICgocGFyZW50RWxbZXhwYW5kb10ub3B0aW9ucy5zb3J0IHx8IHBhcmVudEVsICE9PSByb290RWwpICYmIG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB2YXIgZHJhZ1JlY3QgPSBnZXRSZWN0KGRyYWdFbCQxKSxcbiAgICAgICAgICAgIG11bHRpRHJhZ0luZGV4ID0gaW5kZXgoZHJhZ0VsJDEsICc6bm90KC4nICsgdGhpcy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MgKyAnKScpO1xuICAgICAgICAgIGlmICghaW5pdGlhbEZvbGRpbmcgJiYgb3B0aW9ucy5hbmltYXRpb24pIGRyYWdFbCQxLnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgdG9Tb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgICAgICBpZiAoIWluaXRpYWxGb2xkaW5nKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgZHJhZ0VsJDEuZnJvbVJlY3QgPSBkcmFnUmVjdDtcbiAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCAhPT0gZHJhZ0VsJDEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gZm9sZGluZyA/IGdldFJlY3QobXVsdGlEcmFnRWxlbWVudCkgOiBkcmFnUmVjdDtcbiAgICAgICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQuZnJvbVJlY3QgPSByZWN0O1xuXG4gICAgICAgICAgICAgICAgICAvLyBQcmVwYXJlIHVuZm9sZCBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgIHRvU29ydGFibGUuYWRkQW5pbWF0aW9uU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG11bHRpRHJhZ0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlY3Q6IHJlY3RcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE11bHRpIGRyYWcgZWxlbWVudHMgYXJlIG5vdCBuZWNlc3NhcmlseSByZW1vdmVkIGZyb20gdGhlIERPTSBvbiBkcm9wLCBzbyB0byByZWluc2VydFxuICAgICAgICAgICAgLy8gcHJvcGVybHkgdGhleSBtdXN0IGFsbCBiZSByZW1vdmVkXG4gICAgICAgICAgICByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpO1xuICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICBpZiAoY2hpbGRyZW5bbXVsdGlEcmFnSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50RWwuaW5zZXJ0QmVmb3JlKG11bHRpRHJhZ0VsZW1lbnQsIGNoaWxkcmVuW211bHRpRHJhZ0luZGV4XSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbXVsdGlEcmFnSW5kZXgrKztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBJZiBpbml0aWFsIGZvbGRpbmcgaXMgZG9uZSwgdGhlIGVsZW1lbnRzIG1heSBoYXZlIGNoYW5nZWQgcG9zaXRpb24gYmVjYXVzZSB0aGV5IGFyZSBub3dcbiAgICAgICAgICAgIC8vIHVuZm9sZGluZyBhcm91bmQgZHJhZ0VsLCBldmVuIHRob3VnaCBkcmFnRWwgbWF5IG5vdCBoYXZlIGhpcyBpbmRleCBjaGFuZ2VkLCBzbyB1cGRhdGUgZXZlbnRcbiAgICAgICAgICAgIC8vIG11c3QgYmUgZmlyZWQgaGVyZSBhcyBTb3J0YWJsZSB3aWxsIG5vdC5cbiAgICAgICAgICAgIGlmIChvbGRJbmRleCA9PT0gaW5kZXgoZHJhZ0VsJDEpKSB7XG4gICAgICAgICAgICAgIHZhciB1cGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXggIT09IGluZGV4KG11bHRpRHJhZ0VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICB1cGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQoJ3VwZGF0ZScpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCgnc29ydCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTXVzdCBiZSBkb25lIGFmdGVyIGNhcHR1cmluZyBpbmRpdmlkdWFsIHJlY3RzIChzY3JvbGwgYmFyKVxuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHVuc2V0UmVjdChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0b1NvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBtdWx0aURyYWdTb3J0YWJsZSA9IHRvU29ydGFibGU7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBjbG9uZXMgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAocm9vdEVsID09PSBwYXJlbnRFbCB8fCBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5sYXN0UHV0TW9kZSAhPT0gJ2Nsb25lJykge1xuICAgICAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICBjbG9uZS5wYXJlbnROb2RlICYmIGNsb25lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG51bGxpbmdHbG9iYWw6IGZ1bmN0aW9uIG51bGxpbmdHbG9iYWwoKSB7XG4gICAgICB0aGlzLmlzTXVsdGlEcmFnID0gZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIG11bHRpRHJhZ0Nsb25lcy5sZW5ndGggPSAwO1xuICAgIH0sXG4gICAgZGVzdHJveUdsb2JhbDogZnVuY3Rpb24gZGVzdHJveUdsb2JhbCgpIHtcbiAgICAgIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKCk7XG4gICAgICBvZmYoZG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICBvZmYoZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICBvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fY2hlY2tLZXlEb3duKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ2tleXVwJywgdGhpcy5fY2hlY2tLZXlVcCk7XG4gICAgfSxcbiAgICBfZGVzZWxlY3RNdWx0aURyYWc6IGZ1bmN0aW9uIF9kZXNlbGVjdE11bHRpRHJhZyhldnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZHJhZ1N0YXJ0ZWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZHJhZ1N0YXJ0ZWQpIHJldHVybjtcblxuICAgICAgLy8gT25seSBkZXNlbGVjdCBpZiBzZWxlY3Rpb24gaXMgaW4gdGhpcyBzb3J0YWJsZVxuICAgICAgaWYgKG11bHRpRHJhZ1NvcnRhYmxlICE9PSB0aGlzLnNvcnRhYmxlKSByZXR1cm47XG5cbiAgICAgIC8vIE9ubHkgZGVzZWxlY3QgaWYgdGFyZ2V0IGlzIG5vdCBpdGVtIGluIHRoaXMgc29ydGFibGVcbiAgICAgIGlmIChldnQgJiYgY2xvc2VzdChldnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlLCB0aGlzLnNvcnRhYmxlLmVsLCBmYWxzZSkpIHJldHVybjtcblxuICAgICAgLy8gT25seSBkZXNlbGVjdCBpZiBsZWZ0IGNsaWNrXG4gICAgICBpZiAoZXZ0ICYmIGV2dC5idXR0b24gIT09IDApIHJldHVybjtcbiAgICAgIHdoaWxlIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGVsID0gbXVsdGlEcmFnRWxlbWVudHNbMF07XG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsLCB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgZmFsc2UpO1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5zaGlmdCgpO1xuICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogdGhpcy5zb3J0YWJsZSxcbiAgICAgICAgICByb290RWw6IHRoaXMuc29ydGFibGUuZWwsXG4gICAgICAgICAgbmFtZTogJ2Rlc2VsZWN0JyxcbiAgICAgICAgICB0YXJnZXRFbDogZWwsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2NoZWNrS2V5RG93bjogZnVuY3Rpb24gX2NoZWNrS2V5RG93bihldnQpIHtcbiAgICAgIGlmIChldnQua2V5ID09PSB0aGlzLm9wdGlvbnMubXVsdGlEcmFnS2V5KSB7XG4gICAgICAgIHRoaXMubXVsdGlEcmFnS2V5RG93biA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2hlY2tLZXlVcDogZnVuY3Rpb24gX2NoZWNrS2V5VXAoZXZ0KSB7XG4gICAgICBpZiAoZXZ0LmtleSA9PT0gdGhpcy5vcHRpb25zLm11bHRpRHJhZ0tleSkge1xuICAgICAgICB0aGlzLm11bHRpRHJhZ0tleURvd24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcyhNdWx0aURyYWcsIHtcbiAgICAvLyBTdGF0aWMgbWV0aG9kcyAmIHByb3BlcnRpZXNcbiAgICBwbHVnaW5OYW1lOiAnbXVsdGlEcmFnJyxcbiAgICB1dGlsczoge1xuICAgICAgLyoqXHJcbiAgICAgICAqIFNlbGVjdHMgdGhlIHByb3ZpZGVkIG11bHRpLWRyYWcgaXRlbVxyXG4gICAgICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgVGhlIGVsZW1lbnQgdG8gYmUgc2VsZWN0ZWRcclxuICAgICAgICovXG4gICAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChlbCkge1xuICAgICAgICB2YXIgc29ydGFibGUgPSBlbC5wYXJlbnROb2RlW2V4cGFuZG9dO1xuICAgICAgICBpZiAoIXNvcnRhYmxlIHx8ICFzb3J0YWJsZS5vcHRpb25zLm11bHRpRHJhZyB8fCB+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihlbCkpIHJldHVybjtcbiAgICAgICAgaWYgKG11bHRpRHJhZ1NvcnRhYmxlICYmIG11bHRpRHJhZ1NvcnRhYmxlICE9PSBzb3J0YWJsZSkge1xuICAgICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlLm11bHRpRHJhZy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcbiAgICAgICAgICBtdWx0aURyYWdTb3J0YWJsZSA9IHNvcnRhYmxlO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsLCBzb3J0YWJsZS5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIHRydWUpO1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgIH0sXG4gICAgICAvKipcclxuICAgICAgICogRGVzZWxlY3RzIHRoZSBwcm92aWRlZCBtdWx0aS1kcmFnIGl0ZW1cclxuICAgICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgIFRoZSBlbGVtZW50IHRvIGJlIGRlc2VsZWN0ZWRcclxuICAgICAgICovXG4gICAgICBkZXNlbGVjdDogZnVuY3Rpb24gZGVzZWxlY3QoZWwpIHtcbiAgICAgICAgdmFyIHNvcnRhYmxlID0gZWwucGFyZW50Tm9kZVtleHBhbmRvXSxcbiAgICAgICAgICBpbmRleCA9IG11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZWwpO1xuICAgICAgICBpZiAoIXNvcnRhYmxlIHx8ICFzb3J0YWJsZS5vcHRpb25zLm11bHRpRHJhZyB8fCAhfmluZGV4KSByZXR1cm47XG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsLCBzb3J0YWJsZS5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV2ZW50UHJvcGVydGllczogZnVuY3Rpb24gZXZlbnRQcm9wZXJ0aWVzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgb2xkSW5kaWNpZXMgPSBbXSxcbiAgICAgICAgbmV3SW5kaWNpZXMgPSBbXTtcbiAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgb2xkSW5kaWNpZXMucHVzaCh7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICBpbmRleDogbXVsdGlEcmFnRWxlbWVudC5zb3J0YWJsZUluZGV4XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG11bHRpRHJhZ0VsZW1lbnRzIHdpbGwgYWxyZWFkeSBiZSBzb3J0ZWQgaWYgZm9sZGluZ1xuICAgICAgICB2YXIgbmV3SW5kZXg7XG4gICAgICAgIGlmIChmb2xkaW5nICYmIG11bHRpRHJhZ0VsZW1lbnQgIT09IGRyYWdFbCQxKSB7XG4gICAgICAgICAgbmV3SW5kZXggPSAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChmb2xkaW5nKSB7XG4gICAgICAgICAgbmV3SW5kZXggPSBpbmRleChtdWx0aURyYWdFbGVtZW50LCAnOm5vdCguJyArIF90aGlzMy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MgKyAnKScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0luZGV4ID0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3SW5kaWNpZXMucHVzaCh7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICBpbmRleDogbmV3SW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGl0ZW1zOiBfdG9Db25zdW1hYmxlQXJyYXkobXVsdGlEcmFnRWxlbWVudHMpLFxuICAgICAgICBjbG9uZXM6IFtdLmNvbmNhdChtdWx0aURyYWdDbG9uZXMpLFxuICAgICAgICBvbGRJbmRpY2llczogb2xkSW5kaWNpZXMsXG4gICAgICAgIG5ld0luZGljaWVzOiBuZXdJbmRpY2llc1xuICAgICAgfTtcbiAgICB9LFxuICAgIG9wdGlvbkxpc3RlbmVyczoge1xuICAgICAgbXVsdGlEcmFnS2V5OiBmdW5jdGlvbiBtdWx0aURyYWdLZXkoa2V5KSB7XG4gICAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoa2V5ID09PSAnY3RybCcpIHtcbiAgICAgICAgICBrZXkgPSAnQ29udHJvbCc7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBrZXkgPSBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGluc2VydE11bHRpRHJhZ0VsZW1lbnRzKGNsb25lc0luc2VydGVkLCByb290RWwpIHtcbiAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCwgaSkge1xuICAgIHZhciB0YXJnZXQgPSByb290RWwuY2hpbGRyZW5bbXVsdGlEcmFnRWxlbWVudC5zb3J0YWJsZUluZGV4ICsgKGNsb25lc0luc2VydGVkID8gTnVtYmVyKGkpIDogMCldO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUobXVsdGlEcmFnRWxlbWVudCwgdGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxyXG4gKiBJbnNlcnQgbXVsdGktZHJhZyBjbG9uZXNcclxuICogQHBhcmFtICB7W0Jvb2xlYW5dfSBlbGVtZW50c0luc2VydGVkICBXaGV0aGVyIHRoZSBtdWx0aS1kcmFnIGVsZW1lbnRzIGFyZSBpbnNlcnRlZFxyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gcm9vdEVsXHJcbiAqL1xuZnVuY3Rpb24gaW5zZXJ0TXVsdGlEcmFnQ2xvbmVzKGVsZW1lbnRzSW5zZXJ0ZWQsIHJvb3RFbCkge1xuICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUsIGkpIHtcbiAgICB2YXIgdGFyZ2V0ID0gcm9vdEVsLmNoaWxkcmVuW2Nsb25lLnNvcnRhYmxlSW5kZXggKyAoZWxlbWVudHNJbnNlcnRlZCA/IE51bWJlcihpKSA6IDApXTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lLCB0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290RWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpIHtcbiAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgIG11bHRpRHJhZ0VsZW1lbnQucGFyZW50Tm9kZSAmJiBtdWx0aURyYWdFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gIH0pO1xufVxuXG5Tb3J0YWJsZS5tb3VudChuZXcgQXV0b1Njcm9sbFBsdWdpbigpKTtcblNvcnRhYmxlLm1vdW50KFJlbW92ZSwgUmV2ZXJ0KTtcblxuZXhwb3J0IGRlZmF1bHQgU29ydGFibGU7XG5leHBvcnQgeyBNdWx0aURyYWdQbHVnaW4gYXMgTXVsdGlEcmFnLCBTb3J0YWJsZSwgU3dhcFBsdWdpbiBhcyBTd2FwIH07XG4iLCAiaW1wb3J0IFNvcnRhYmxlIGZyb20gXCJzb3J0YWJsZWpzXCI7XG5cbmxldCBEcmFnSG9vayA9IHtcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLnNvcnRhYmxlID0gU29ydGFibGUuY3JlYXRlKHRoaXMuZWwsIHtcbiAgICAgIGFuaW1hdGlvbjogMTUwLFxuICAgICAgb25FbmQ6IChldmVudCkgPT4ge1xuICAgICAgICBsZXQgaWRzID0gQXJyYXkuZnJvbSh0aGlzLmVsLmNoaWxkcmVuKS5tYXAoKGVsKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGVsLmRhdGFzZXQuaWQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucHVzaEV2ZW50KFwicmVvcmRlclwiLCB7IGlkczogaWRzIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBkZXN0cm95ZWQoKSB7XG4gICAgaWYgKHRoaXMuc29ydGFibGUpIHtcbiAgICAgIHRoaXMuc29ydGFibGUuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRHJhZ0hvb2s7XG4iLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiZXhwb3J0IHZhciB0b3AgPSAndG9wJztcbmV4cG9ydCB2YXIgYm90dG9tID0gJ2JvdHRvbSc7XG5leHBvcnQgdmFyIHJpZ2h0ID0gJ3JpZ2h0JztcbmV4cG9ydCB2YXIgbGVmdCA9ICdsZWZ0JztcbmV4cG9ydCB2YXIgYXV0byA9ICdhdXRvJztcbmV4cG9ydCB2YXIgYmFzZVBsYWNlbWVudHMgPSBbdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0XTtcbmV4cG9ydCB2YXIgc3RhcnQgPSAnc3RhcnQnO1xuZXhwb3J0IHZhciBlbmQgPSAnZW5kJztcbmV4cG9ydCB2YXIgY2xpcHBpbmdQYXJlbnRzID0gJ2NsaXBwaW5nUGFyZW50cyc7XG5leHBvcnQgdmFyIHZpZXdwb3J0ID0gJ3ZpZXdwb3J0JztcbmV4cG9ydCB2YXIgcG9wcGVyID0gJ3BvcHBlcic7XG5leHBvcnQgdmFyIHJlZmVyZW5jZSA9ICdyZWZlcmVuY2UnO1xuZXhwb3J0IHZhciB2YXJpYXRpb25QbGFjZW1lbnRzID0gLyojX19QVVJFX18qL2Jhc2VQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7XG5leHBvcnQgdmFyIHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovW10uY29uY2F0KGJhc2VQbGFjZW1lbnRzLCBbYXV0b10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cblxuZXhwb3J0IHZhciBiZWZvcmVSZWFkID0gJ2JlZm9yZVJlYWQnO1xuZXhwb3J0IHZhciByZWFkID0gJ3JlYWQnO1xuZXhwb3J0IHZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcblxuZXhwb3J0IHZhciBiZWZvcmVNYWluID0gJ2JlZm9yZU1haW4nO1xuZXhwb3J0IHZhciBtYWluID0gJ21haW4nO1xuZXhwb3J0IHZhciBhZnRlck1haW4gPSAnYWZ0ZXJNYWluJzsgLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuXG5leHBvcnQgdmFyIGJlZm9yZVdyaXRlID0gJ2JlZm9yZVdyaXRlJztcbmV4cG9ydCB2YXIgd3JpdGUgPSAnd3JpdGUnO1xuZXhwb3J0IHZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xuZXhwb3J0IHZhciBtb2RpZmllclBoYXNlcyA9IFtiZWZvcmVSZWFkLCByZWFkLCBhZnRlclJlYWQsIGJlZm9yZU1haW4sIG1haW4sIGFmdGVyTWFpbiwgYmVmb3JlV3JpdGUsIHdyaXRlLCBhZnRlcldyaXRlXTsiLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0iLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuSFRNTEVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChub2RlKSB7XG4gIC8vIElFIDExIGhhcyBubyBTaGFkb3dSb290XG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5TaGFkb3dSb290O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5cbmV4cG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNTaGFkb3dSb290IH07IiwgImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXG4vLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcbiAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdG8gZXh0ZW5kIHRoaXMgcHJvcGVydHksIGJ1dCBpdCdzIHRoZSBtb3N0XG4gICAgLy8gZWZmZWN0aXZlIHdheSB0byBhcHBseSBzdHlsZXMgdG8gYW4gSFRNTEVsZW1lbnRcbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cblxuXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXVxufTsiLCAiaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufSIsICJleHBvcnQgdmFyIG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IHZhciBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCB2YXIgcm91bmQgPSBNYXRoLnJvdW5kOyIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRVQVN0cmluZygpIHtcbiAgdmFyIHVhRGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuXG4gIGlmICh1YURhdGEgIT0gbnVsbCAmJiB1YURhdGEuYnJhbmRzICYmIEFycmF5LmlzQXJyYXkodWFEYXRhLmJyYW5kcykpIHtcbiAgICByZXR1cm4gdWFEYXRhLmJyYW5kcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmJyYW5kICsgXCIvXCIgKyBpdGVtLnZlcnNpb247XG4gICAgfSkuam9pbignICcpO1xuICB9XG5cbiAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG59IiwgImltcG9ydCBnZXRVQVN0cmluZyBmcm9tIFwiLi4vdXRpbHMvdXNlckFnZW50LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG59IiwgImltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tIFwiLi9pc0xheW91dFZpZXdwb3J0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpbmNsdWRlU2NhbGUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHNjYWxlWCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPiAwID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEgOiAxO1xuICAgIHNjYWxlWSA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMCA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEgOiAxO1xuICB9XG5cbiAgdmFyIF9yZWYgPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3csXG4gICAgICB2aXN1YWxWaWV3cG9ydCA9IF9yZWYudmlzdWFsVmlld3BvcnQ7XG5cbiAgdmFyIGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcbiAgdmFyIHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0IDogMCkpIC8gc2NhbGVYO1xuICB2YXIgeSA9IChjbGllbnRSZWN0LnRvcCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wIDogMCkpIC8gc2NhbGVZO1xuICB2YXIgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGVYO1xuICB2YXIgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsICJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiOyAvLyBSZXR1cm5zIHRoZSBsYXlvdXQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuIExheW91dFxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcblxuICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xuICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59IiwgImltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgICAgdmFyIG5leHQgPSBjaGlsZDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cblxuXG4gICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgICAgfSB3aGlsZSAobmV4dCk7XG4gICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG5cblxuICByZXR1cm4gZmFsc2U7XG59IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufSIsICJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufSIsICJpbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn0iLCAiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gKC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8ICggLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuXG4gICk7XG59IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBpc1RhYmxlRWxlbWVudCBmcm9tIFwiLi9pc1RhYmxlRWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGdldFVBU3RyaW5nIGZyb20gXCIuLi91dGlscy91c2VyQWdlbnQuanNcIjtcblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuICB2YXIgaXNJRSA9IC9UcmlkZW50L2kudGVzdChnZXRVQVN0cmluZygpKTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XG59IiwgImltcG9ydCB7IG1heCBhcyBtYXRoTWF4LCBtaW4gYXMgbWF0aE1pbiB9IGZyb20gXCIuL21hdGguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KSB7XG4gIHJldHVybiBtYXRoTWF4KG1pbiwgbWF0aE1pbih2YWx1ZSwgbWF4KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluTWF4Q2xhbXAobWluLCB2YWx1ZSwgbWF4KSB7XG4gIHZhciB2ID0gd2l0aGluKG1pbiwgdmFsdWUsIG1heCk7XG4gIHJldHVybiB2ID4gbWF4ID8gbWF4IDogdjtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufSIsICJpbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VQYWRkaW5nT2JqZWN0KHBhZGRpbmdPYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGdldEZyZXNoU2lkZU9iamVjdCgpLCBwYWRkaW5nT2JqZWN0KTtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn0iLCAiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuLi9kb20tdXRpbHMvY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgd2l0aGluIH0gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi4vdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuLi91dGlscy9leHBhbmRUb0hhc2hNYXAuanNcIjtcbmltcG9ydCB7IGxlZnQsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdG9wLCBib3R0b20gfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiBwYWRkaW5nO1xuICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbn07XG5cbmZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcbiAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICB2YXIgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGFycm93RWxlbWVudCk7XG4gIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xuXG4gIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgdmFyIGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dSZWN0W2xlbl0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICB2YXIgYXhpc1Byb3AgPSBheGlzO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTsiLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59IiwgImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdW5zZXRTaWRlcyA9IHtcbiAgdG9wOiAnYXV0bycsXG4gIHJpZ2h0OiAnYXV0bycsXG4gIGJvdHRvbTogJ2F1dG8nLFxuICBsZWZ0OiAnYXV0bydcbn07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXG4vLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxuLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXG5cbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0c0J5RFBSKF9yZWYsIHdpbikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggKiBkcHIpIC8gZHByIHx8IDAsXG4gICAgeTogcm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICB2YXJpYXRpb24gPSBfcmVmMi52YXJpYXRpb24sXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzLFxuICAgICAgaXNGaXhlZCA9IF9yZWYyLmlzRml4ZWQ7XG4gIHZhciBfb2Zmc2V0cyR4ID0gb2Zmc2V0cy54LFxuICAgICAgeCA9IF9vZmZzZXRzJHggPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR4LFxuICAgICAgX29mZnNldHMkeSA9IG9mZnNldHMueSxcbiAgICAgIHkgPSBfb2Zmc2V0cyR5ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeTtcblxuICB2YXIgX3JlZjMgPSB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWYzLng7XG4gIHkgPSBfcmVmMy55O1xuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IHRvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWSA9IGJvdHRvbTtcbiAgICAgIHZhciBvZmZzZXRZID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQuaGVpZ2h0IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF07XG4gICAgICB5IC09IG9mZnNldFkgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQgfHwgKHBsYWNlbWVudCA9PT0gdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgIHZhciBvZmZzZXRYID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgdmFyIF9yZWY0ID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9LCBnZXRXaW5kb3cocG9wcGVyKSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWY0Lng7XG4gIHkgPSBfcmVmNC55O1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY1KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY1LnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxuICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fVxufTsiLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn07IiwgInZhciBoYXNoID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsICJ2YXIgaGFzaCA9IHtcbiAgc3RhcnQ6ICdlbmQnLFxuICBlbmQ6ICdzdGFydCdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59IiwgImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn0iLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tIFwiLi9pc0xheW91dFZpZXdwb3J0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgdmFyIHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICB2YXIgbGF5b3V0Vmlld3BvcnQgPSBpc0xheW91dFZpZXdwb3J0KCk7XG5cbiAgICBpZiAobGF5b3V0Vmlld3BvcnQgfHwgIWxheW91dFZpZXdwb3J0ICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeTogeVxuICB9O1xufSIsICJpbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCB7IG1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGVcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gIHZhciB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5zY3JvbGxXaWR0aCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCk7XG4gIHZhciBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCkgLSB3aWR0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsICJpbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1Njcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIEZpcmVmb3ggd2FudHMgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcbiAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1k7XG5cbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCk7XG59IiwgImltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59IiwgImltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSBcIi4vZ2V0U2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG4vKlxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbnVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXG50bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cblxuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcbiAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZWN0LCB7XG4gICAgbGVmdDogcmVjdC54LFxuICAgIHRvcDogcmVjdC55LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfSk7XG59IiwgImltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0Vmlld3BvcnRSZWN0IGZyb20gXCIuL2dldFZpZXdwb3J0UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tIFwiLi9nZXREb2N1bWVudFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuLi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXgsIG1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGZhbHNlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpKSA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSkge1xuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xuICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn0iLCAiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4vZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHN0YXJ0LCBlbmQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHJlZmVyZW5jZSA9IF9yZWYucmVmZXJlbmNlLFxuICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudCA/IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZWxlbWVudC53aWR0aCAvIDI7XG4gIHZhciBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcbiAgdmFyIG9mZnNldHM7XG5cbiAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSB0b3A6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGJvdHRvbTpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSByaWdodDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGxlZnQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cblxuICB2YXIgbWFpbkF4aXMgPSBiYXNlUGxhY2VtZW50ID8gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpIDogbnVsbDtcblxuICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgc3dpdGNoICh2YXJpYXRpb24pIHtcbiAgICAgIGNhc2Ugc3RhcnQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gLSAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGVuZDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSArIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59IiwgImltcG9ydCBnZXRDbGlwcGluZ1JlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4vcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgY2xpcHBpbmdQYXJlbnRzLCByZWZlcmVuY2UsIHBvcHBlciwgYm90dG9tLCB0b3AsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4vZXhwYW5kVG9IYXNoTWFwLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgIF9vcHRpb25zJHN0cmF0ZWd5ID0gX29wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBzdHJhdGVneSA9IF9vcHRpb25zJHN0cmF0ZWd5ID09PSB2b2lkIDAgPyBzdGF0ZS5zdHJhdGVneSA6IF9vcHRpb25zJHN0cmF0ZWd5LFxuICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxuICAgICAgZWxlbWVudENvbnRleHQgPSBfb3B0aW9ucyRlbGVtZW50Q29udGUgPT09IHZvaWQgMCA/IHBvcHBlciA6IF9vcHRpb25zJGVsZW1lbnRDb250ZSxcbiAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnksIHN0cmF0ZWd5KTtcbiAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxuICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgaWYgKGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgJiYgb2Zmc2V0RGF0YSkge1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtdWx0aXBseSA9IFtyaWdodCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn0iLCAiaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHZhcmlhdGlvblBsYWNlbWVudHMsIGJhc2VQbGFjZW1lbnRzLCBwbGFjZW1lbnRzIGFzIGFsbFBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBhbGxQbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICB9KSA6IGJhc2VQbGFjZW1lbnRzO1xuICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59IiwgImltcG9ydCBnZXRPcHBvc2l0ZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgY29tcHV0ZUF1dG9QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyBib3R0b20sIHRvcCwgc3RhcnQsIHJpZ2h0LCBsZWZ0LCBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgaWYgKGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5cbmZ1bmN0aW9uIGZsaXAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgPSBvcHRpb25zLmZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9IG9wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGZsaXBWYXJpYXRpbyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IG9wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzO1xuICB2YXIgcHJlZmVycmVkUGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gYmFzZVBsYWNlbWVudCA9PT0gcHJlZmVycmVkUGxhY2VtZW50O1xuICB2YXIgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBWYXJpYXRpb25zID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocHJlZmVycmVkUGxhY2VtZW50KSk7XG4gIHZhciBwbGFjZW1lbnRzID0gW3ByZWZlcnJlZFBsYWNlbWVudF0uY29uY2F0KGZhbGxiYWNrUGxhY2VtZW50cykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0byA/IGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zOiBmbGlwVmFyaWF0aW9ucyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYWxsb3dlZEF1dG9QbGFjZW1lbnRzXG4gICAgfSkgOiBwbGFjZW1lbnQpO1xuICB9LCBbXSk7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGNoZWNrc01hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIG1ha2VGYWxsYmFja0NoZWNrcyA9IHRydWU7XG4gIHZhciBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbGFjZW1lbnQgPSBwbGFjZW1lbnRzW2ldO1xuXG4gICAgdmFyIF9iYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIGlzU3RhcnRWYXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gc3RhcnQ7XG4gICAgdmFyIGlzVmVydGljYWwgPSBbdG9wLCBib3R0b21dLmluZGV4T2YoX2Jhc2VQbGFjZW1lbnQpID49IDA7XG4gICAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSk7XG4gICAgdmFyIG1haW5WYXJpYXRpb25TaWRlID0gaXNWZXJ0aWNhbCA/IGlzU3RhcnRWYXJpYXRpb24gPyByaWdodCA6IGxlZnQgOiBpc1N0YXJ0VmFyaWF0aW9uID8gYm90dG9tIDogdG9wO1xuXG4gICAgaWYgKHJlZmVyZW5jZVJlY3RbbGVuXSA+IHBvcHBlclJlY3RbbGVuXSkge1xuICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgfVxuXG4gICAgdmFyIGFsdFZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgdmFyIGNoZWNrcyA9IFtdO1xuXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W19iYXNlUGxhY2VtZW50XSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1ttYWluVmFyaWF0aW9uU2lkZV0gPD0gMCwgb3ZlcmZsb3dbYWx0VmFyaWF0aW9uU2lkZV0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgIHJldHVybiBjaGVjaztcbiAgICB9KSkge1xuICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgbWFrZUZhbGxiYWNrQ2hlY2tzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjaGVja3NNYXAuc2V0KHBsYWNlbWVudCwgY2hlY2tzKTtcbiAgfVxuXG4gIGlmIChtYWtlRmFsbGJhY2tDaGVja3MpIHtcbiAgICAvLyBgMmAgbWF5IGJlIGRlc2lyZWQgaW4gc29tZSBjYXNlcyBcdTIwMTMgcmVzZWFyY2ggbGF0ZXJcbiAgICB2YXIgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcbiAgICAgIHZhciBmaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50cy5maW5kKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcblxuICAgICAgICBpZiAoY2hlY2tzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoZWNrcy5zbGljZSgwLCBfaSkuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZml0dGluZ1BsYWNlbWVudCkge1xuICAgICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBmaXR0aW5nUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaSA9IG51bWJlck9mQ2hlY2tzOyBfaSA+IDA7IF9pLS0pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoX2kpO1xuXG4gICAgICBpZiAoX3JldCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUucGxhY2VtZW50ICE9PSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwID0gdHJ1ZTtcbiAgICBzdGF0ZS5wbGFjZW1lbnQgPSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgc3RhdGUucmVzZXQgPSB0cnVlO1xuICB9XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogZmFsc2VcbiAgfVxufTsiLCAiaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcbiAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTsiLCAiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIHBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbbGVmdCwgdG9wXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XG5cbiAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSkpIDogb2Zmc2V0LFxuICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxuICAgICAgZGlzdGFuY2UgPSBfcmVmWzFdO1xuXG4gIHNraWRkaW5nID0gc2tpZGRpbmcgfHwgMDtcbiAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xuICAgIHg6IGRpc3RhbmNlLFxuICAgIHk6IHNraWRkaW5nXG4gIH0gOiB7XG4gICAgeDogc2tpZGRpbmcsXG4gICAgeTogZGlzdGFuY2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX29wdGlvbnMkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfb3B0aW9ucyRvZmZzZXQ7XG4gIHZhciBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcbiAgICAgIHggPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueCxcbiAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ29mZnNldCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgZm46IG9mZnNldFxufTsiLCAiaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gXCIuLi91dGlscy9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuXG5mdW5jdGlvbiBwb3BwZXJPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIC8vIE9mZnNldHMgYXJlIHRoZSBhY3R1YWwgcG9zaXRpb24gdGhlIHBvcHBlciBuZWVkcyB0byBoYXZlIHRvIGJlXG4gIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBwbGFjZW1lbnQsIGFuZCB3aWxsIGJlIGFkanVzdGVkIGJ5XG4gIC8vIHRoZSBtb2RpZmllcnMgaW4gdGhlIG5leHQgc3RlcFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogc3RhdGUucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3BvcHBlck9mZnNldHMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3JlYWQnLFxuICBmbjogcG9wcGVyT2Zmc2V0cyxcbiAgZGF0YToge31cbn07IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufSIsICJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHN0YXJ0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QWx0QXhpcyBmcm9tIFwiLi4vdXRpbHMvZ2V0QWx0QXhpcy5qc1wiO1xuaW1wb3J0IHsgd2l0aGluLCB3aXRoaW5NYXhDbGFtcCB9IGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmltcG9ydCB7IG1pbiBhcyBtYXRoTWluLCBtYXggYXMgbWF0aE1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICB2YXIgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldFZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogdGV0aGVyT2Zmc2V0VmFsdWUsXG4gICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgdGV0aGVyT2Zmc2V0VmFsdWUpO1xuICB2YXIgb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XSA6IG51bGw7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDtcblxuICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIHZhciBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICB2YXIgbWluID0gb2Zmc2V0ICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xuICAgIHZhciBtYXggPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgIHZhciBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudCA/IG1haW5BeGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRUb3AgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudExlZnQgfHwgMCA6IDA7XG4gICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVttYWluQXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgIHZhciB0ZXRoZXJNYXggPSBvZmZzZXQgKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWF0aE1pbihtaW4sIHRldGhlck1pbikgOiBtaW4sIG9mZnNldCwgdGV0aGVyID8gbWF0aE1heChtYXgsIHRldGhlck1heCkgOiBtYXgpO1xuICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyO1xuXG4gICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgdmFyIF9sZW4gPSBhbHRBeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgdmFyIGlzT3JpZ2luU2lkZSA9IFt0b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XG5cbiAgICB2YXIgX3RldGhlck1pbiA9IGlzT3JpZ2luU2lkZSA/IF9taW4gOiBfb2Zmc2V0IC0gcmVmZXJlbmNlUmVjdFtfbGVuXSAtIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xuXG4gICAgdmFyIF90ZXRoZXJNYXggPSBpc09yaWdpblNpZGUgPyBfb2Zmc2V0ICsgcmVmZXJlbmNlUmVjdFtfbGVuXSArIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzIDogX21heDtcblxuICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XG5cbiAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldCAtIF9vZmZzZXQ7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbn07IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufSIsICJpbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0SFRNTEVsZW1lbnRTY3JvbGwgZnJvbSBcIi4vZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZSkge1xuICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XG4gIH1cbn0iLCAiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXROb2RlU2Nyb2xsIGZyb20gXCIuL2dldE5vZGVTY3JvbGwuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50U2NhbGVkKGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gIHZhciBzY2FsZVkgPSByb3VuZChyZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbn0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50SXNTY2FsZWQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNFbGVtZW50U2NhbGVkKG9mZnNldFBhcmVudCk7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudElzU2NhbGVkLCBpc0ZpeGVkKTtcbiAgdmFyIHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59IiwgImltcG9ydCB7IG1vZGlmaWVyUGhhc2VzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk4NzUyNTVcblxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxuXG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcbiAgICB2YXIgcmVxdWlyZXMgPSBbXS5jb25jYXQobW9kaWZpZXIucmVxdWlyZXMgfHwgW10sIG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgIHZhciBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcblxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgc29ydChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7IC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXG5cbiAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcbiAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xuICAgIHZhciBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgY3VycmVudCwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywgY3VycmVudC5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLmRhdGEsIGN1cnJlbnQuZGF0YSlcbiAgICB9KSA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICB9KTtcbn0iLCAiaW1wb3J0IGdldENvbXBvc2l0ZVJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBvcmRlck1vZGlmaWVycyBmcm9tIFwiLi91dGlscy9vcmRlck1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gXCIuL3V0aWxzL2RlYm91bmNlLmpzXCI7XG5pbXBvcnQgbWVyZ2VCeU5hbWUgZnJvbSBcIi4vdXRpbHMvbWVyZ2VCeU5hbWUuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXI6IHBvcHBlclxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH07XG4gICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiBzZXRPcHRpb25zKHNldE9wdGlvbnNBY3Rpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHNldE9wdGlvbnNBY3Rpb24oc3RhdGUub3B0aW9ucykgOiBzZXRPcHRpb25zQWN0aW9uO1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgc3RhdGUub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBsaXN0U2Nyb2xsUGFyZW50cyhwb3BwZXIpXG4gICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xuICAgICAgICB9KTtcbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSBcdTIwMTMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhdGUkZWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXG4gICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgLy8gYW55bW9yZVxuXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXG5cblxuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGdldENvbXBvc2l0ZVJlY3QocmVmZXJlbmNlLCBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSwgc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJyksXG4gICAgICAgICAgcG9wcGVyOiBnZXRMYXlvdXRSZWN0KHBvcHBlcilcbiAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgLy8gbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdGhlIGBmbGlwYCBtb2RpZmllciBjaGFuZ2luZyB0aGVcbiAgICAgICAgLy8gcGxhY2VtZW50LCB3aGljaCB0aGVuIG5lZWRzIHRvIHJlLXJ1biBhbGwgdGhlIG1vZGlmaWVycywgYmVjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgLy8gc3RhbGUvaW5jb3JyZWN0XG5cbiAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIFx1MjAxMyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG5cbiAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgICAgICBfcmVmJG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zID0gX3JlZiRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkb3B0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYuZWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xuXG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0pO1xuICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cbmV4cG9ydCB2YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93IH07IiwgImltcG9ydCB7IHBvcHBlckdlbmVyYXRvciwgZGV0ZWN0T3ZlcmZsb3cgfSBmcm9tIFwiLi9jcmVhdGVQb3BwZXIuanNcIjtcbmltcG9ydCBldmVudExpc3RlbmVycyBmcm9tIFwiLi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanNcIjtcbmltcG9ydCBwb3BwZXJPZmZzZXRzIGZyb20gXCIuL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzXCI7XG5pbXBvcnQgY29tcHV0ZVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qc1wiO1xuaW1wb3J0IGFwcGx5U3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9hcHBseVN0eWxlcy5qc1wiO1xuaW1wb3J0IG9mZnNldCBmcm9tIFwiLi9tb2RpZmllcnMvb2Zmc2V0LmpzXCI7XG5pbXBvcnQgZmxpcCBmcm9tIFwiLi9tb2RpZmllcnMvZmxpcC5qc1wiO1xuaW1wb3J0IHByZXZlbnRPdmVyZmxvdyBmcm9tIFwiLi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgYXJyb3cgZnJvbSBcIi4vbW9kaWZpZXJzL2Fycm93LmpzXCI7XG5pbXBvcnQgaGlkZSBmcm9tIFwiLi9tb2RpZmllcnMvaGlkZS5qc1wiO1xudmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMsIGNvbXB1dGVTdHlsZXMsIGFwcGx5U3R5bGVzLCBvZmZzZXQsIGZsaXAsIHByZXZlbnRPdmVyZmxvdywgYXJyb3csIGhpZGVdO1xudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIgYXMgY3JlYXRlUG9wcGVyTGl0ZSB9IGZyb20gXCIuL3BvcHBlci1saXRlLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0ICogZnJvbSBcIi4vbW9kaWZpZXJzL2luZGV4LmpzXCI7IiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHtcbiAgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpO1xuICBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMocikge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIpO1xufVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChlKSB7XG4gIGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHtcbiAgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7XG4gIGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG8gPSByW3RdO1xuICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkge1xuICByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gX2dldCgpIHtcbiAgcmV0dXJuIF9nZXQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuZ2V0ID8gUmVmbGVjdC5nZXQuYmluZCgpIDogZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICB2YXIgcCA9IF9zdXBlclByb3BCYXNlKGUsIHQpO1xuICAgIGlmIChwKSB7XG4gICAgICB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocCwgdCk7XG4gICAgICByZXR1cm4gbi5nZXQgPyBuLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gZSA6IHIpIDogbi52YWx1ZTtcbiAgICB9XG4gIH0sIF9nZXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZih0KSB7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO1xuICB9LCBfZ2V0UHJvdG90eXBlT2YodCk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHModCwgZSkge1xuICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHQsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgfVxuICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogITFcbiAgfSksIGUgJiYgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xufVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gIH0gY2F0Y2ggKHQpIHt9XG4gIHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0O1xuICB9KSgpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShyKSB7XG4gIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkge1xuICB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobnVsbCAhPSB0KSB7XG4gICAgdmFyIGUsXG4gICAgICBuLFxuICAgICAgaSxcbiAgICAgIHUsXG4gICAgICBhID0gW10sXG4gICAgICBmID0gITAsXG4gICAgICBvID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHtcbiAgICAgICAgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuO1xuICAgICAgICBmID0gITE7XG4gICAgICB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgbyA9ICEwLCBuID0gcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFmICYmIG51bGwgIT0gdC5yZXR1cm4gJiYgKHUgPSB0LnJldHVybigpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAobykgdGhyb3cgbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbn1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgZSkge1xuICBpZiAoZSAmJiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZCh0KTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZih0LCBlKSB7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gPSBlLCB0O1xuICB9LCBfc2V0UHJvdG90eXBlT2YodCwgZSk7XG59XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZSh0LCBvKSB7XG4gIGZvciAoOyAhe30uaGFzT3duUHJvcGVydHkuY2FsbCh0LCBvKSAmJiBudWxsICE9PSAodCA9IF9nZXRQcm90b3R5cGVPZih0KSk7KTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkocikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXkocikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiO1xufVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7XG4gIGlmIChyKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTtcbiAgICB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpO1xuICAgIHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1Byb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5mdW5jdGlvbiBsYXN0SXRlbU9mKGFycikge1xuICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbn1cblxuLy8gcHVzaCBvbmx5IHRoZSBpdGVtcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5XG5mdW5jdGlvbiBwdXNoVW5pcXVlKGFycikge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGl0ZW1zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGFyci5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhcnIucHVzaChpdGVtKTtcbiAgfSk7XG4gIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0ciwgc2VwYXJhdG9yKSB7XG4gIC8vIGNvbnZlcnQgZW1wdHkgc3RyaW5nIHRvIGFuIGVtcHR5IGFycmF5XG4gIHJldHVybiBzdHIgPyBzdHIuc3BsaXQoc2VwYXJhdG9yKSA6IFtdO1xufVxuZnVuY3Rpb24gaXNJblJhbmdlKHRlc3RWYWwsIG1pbiwgbWF4KSB7XG4gIHZhciBtaW5PSyA9IG1pbiA9PT0gdW5kZWZpbmVkIHx8IHRlc3RWYWwgPj0gbWluO1xuICB2YXIgbWF4T0sgPSBtYXggPT09IHVuZGVmaW5lZCB8fCB0ZXN0VmFsIDw9IG1heDtcbiAgcmV0dXJuIG1pbk9LICYmIG1heE9LO1xufVxuZnVuY3Rpb24gbGltaXRUb1JhbmdlKHZhbCwgbWluLCBtYXgpIHtcbiAgaWYgKHZhbCA8IG1pbikge1xuICAgIHJldHVybiBtaW47XG4gIH1cbiAgaWYgKHZhbCA+IG1heCkge1xuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhZ1JlcGVhdCh0YWdOYW1lLCByZXBlYXQpIHtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gIHZhciBodG1sID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAnJztcbiAgdmFyIG9wZW5UYWdTcmMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5yZWR1Y2UoZnVuY3Rpb24gKHNyYywgYXR0cikge1xuICAgIHZhciB2YWwgPSBhdHRyaWJ1dGVzW2F0dHJdO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWwgPSB2YWwoaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoc3JjLCBcIiBcIikuY29uY2F0KGF0dHIsIFwiPVxcXCJcIikuY29uY2F0KHZhbCwgXCJcXFwiXCIpO1xuICB9LCB0YWdOYW1lKTtcbiAgaHRtbCArPSBcIjxcIi5jb25jYXQob3BlblRhZ1NyYywgXCI+PC9cIikuY29uY2F0KHRhZ05hbWUsIFwiPlwiKTtcbiAgdmFyIG5leHQgPSBpbmRleCArIDE7XG4gIHJldHVybiBuZXh0IDwgcmVwZWF0ID8gY3JlYXRlVGFnUmVwZWF0KHRhZ05hbWUsIHJlcGVhdCwgYXR0cmlidXRlcywgbmV4dCwgaHRtbCkgOiBodG1sO1xufVxuXG4vLyBSZW1vdmUgdGhlIHNwYWNpbmcgc3Vycm91bmRpbmcgdGFncyBmb3IgSFRNTCBwYXJzZXIgbm90IHRvIGNyZWF0ZSB0ZXh0IG5vZGVzXG4vLyBiZWZvcmUvYWZ0ZXIgZWxlbWVudHNcbmZ1bmN0aW9uIG9wdGltaXplVGVtcGxhdGVIVE1MKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwucmVwbGFjZSgvPlxccysvZywgJz4nKS5yZXBsYWNlKC9cXHMrPC8sICc8Jyk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwVGltZSh0aW1lVmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWVWYWx1ZSkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59XG5mdW5jdGlvbiB0b2RheSgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59XG5cbi8vIEdldCB0aGUgdGltZSB2YWx1ZSBvZiB0aGUgc3RhcnQgb2YgZ2l2ZW4gZGF0ZSBvciB5ZWFyLCBtb250aCBhbmQgZGF5XG5mdW5jdGlvbiBkYXRlVmFsdWUoKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB0b2RheSgpO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBzdHJpcFRpbWUoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdKTtcbiAgfVxuXG4gIC8vIHVzZSBzZXRGdWxsWWVhcigpIHRvIGtlZXAgMi1kaWdpdCB5ZWFyIGZyb20gYmVpbmcgbWFwcGVkIHRvIDE5MDAtMTk5OVxuICB2YXIgbmV3RGF0ZSA9IG5ldyBEYXRlKDApO1xuICBuZXdEYXRlLnNldEZ1bGxZZWFyLmFwcGx5KG5ld0RhdGUsIGFyZ3VtZW50cyk7XG4gIHJldHVybiBuZXdEYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufVxuZnVuY3Rpb24gYWRkRGF5cyhkYXRlLCBhbW91bnQpIHtcbiAgdmFyIG5ld0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgcmV0dXJuIG5ld0RhdGUuc2V0RGF0ZShuZXdEYXRlLmdldERhdGUoKSArIGFtb3VudCk7XG59XG5mdW5jdGlvbiBhZGRXZWVrcyhkYXRlLCBhbW91bnQpIHtcbiAgcmV0dXJuIGFkZERheXMoZGF0ZSwgYW1vdW50ICogNyk7XG59XG5mdW5jdGlvbiBhZGRNb250aHMoZGF0ZSwgYW1vdW50KSB7XG4gIC8vIElmIHRoZSBkYXkgb2YgdGhlIGRhdGUgaXMgbm90IGluIHRoZSBuZXcgbW9udGgsIHRoZSBsYXN0IGRheSBvZiB0aGUgbmV3XG4gIC8vIG1vbnRoIHdpbGwgYmUgcmV0dXJuZWQuIGUuZy4gSmFuIDMxICsgMSBtb250aCBcdTIxOTIgRmViIDI4IChub3QgTWFyIDAzKVxuICB2YXIgbmV3RGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICB2YXIgbW9udGhzVG9TZXQgPSBuZXdEYXRlLmdldE1vbnRoKCkgKyBhbW91bnQ7XG4gIHZhciBleHBlY3RlZE1vbnRoID0gbW9udGhzVG9TZXQgJSAxMjtcbiAgaWYgKGV4cGVjdGVkTW9udGggPCAwKSB7XG4gICAgZXhwZWN0ZWRNb250aCArPSAxMjtcbiAgfVxuICB2YXIgdGltZSA9IG5ld0RhdGUuc2V0TW9udGgobW9udGhzVG9TZXQpO1xuICByZXR1cm4gbmV3RGF0ZS5nZXRNb250aCgpICE9PSBleHBlY3RlZE1vbnRoID8gbmV3RGF0ZS5zZXREYXRlKDApIDogdGltZTtcbn1cbmZ1bmN0aW9uIGFkZFllYXJzKGRhdGUsIGFtb3VudCkge1xuICAvLyBJZiB0aGUgZGF0ZSBpcyBGZWIgMjkgYW5kIHRoZSBuZXcgeWVhciBpcyBub3QgYSBsZWFwIHllYXIsIEZlYiAyOCBvZiB0aGVcbiAgLy8gbmV3IHllYXIgd2lsbCBiZSByZXR1cm5lZC5cbiAgdmFyIG5ld0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgdmFyIGV4cGVjdGVkTW9udGggPSBuZXdEYXRlLmdldE1vbnRoKCk7XG4gIHZhciB0aW1lID0gbmV3RGF0ZS5zZXRGdWxsWWVhcihuZXdEYXRlLmdldEZ1bGxZZWFyKCkgKyBhbW91bnQpO1xuICByZXR1cm4gZXhwZWN0ZWRNb250aCA9PT0gMSAmJiBuZXdEYXRlLmdldE1vbnRoKCkgPT09IDIgPyBuZXdEYXRlLnNldERhdGUoMCkgOiB0aW1lO1xufVxuXG4vLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHR3ZW4gMiBkYXlzIG9mIHRoZSB3ZWVrXG5mdW5jdGlvbiBkYXlEaWZmKGRheSwgZnJvbSkge1xuICByZXR1cm4gKGRheSAtIGZyb20gKyA3KSAlIDc7XG59XG5cbi8vIEdldCB0aGUgZGF0ZSBvZiB0aGUgc3BlY2lmaWVkIGRheSBvZiB0aGUgd2VlayBvZiBnaXZlbiBiYXNlIGRhdGVcbmZ1bmN0aW9uIGRheU9mVGhlV2Vla09mKGJhc2VEYXRlLCBkYXlPZldlZWspIHtcbiAgdmFyIHdlZWtTdGFydCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgdmFyIGJhc2VEYXkgPSBuZXcgRGF0ZShiYXNlRGF0ZSkuZ2V0RGF5KCk7XG4gIHJldHVybiBhZGREYXlzKGJhc2VEYXRlLCBkYXlEaWZmKGRheU9mV2Vlaywgd2Vla1N0YXJ0KSAtIGRheURpZmYoYmFzZURheSwgd2Vla1N0YXJ0KSk7XG59XG5cbi8vIEdldCB0aGUgSVNPIHdlZWsgb2YgYSBkYXRlXG5mdW5jdGlvbiBnZXRXZWVrKGRhdGUpIHtcbiAgLy8gc3RhcnQgb2YgSVNPIHdlZWsgaXMgTW9uZGF5XG4gIHZhciB0aHVPZlRoZVdlZWsgPSBkYXlPZlRoZVdlZWtPZihkYXRlLCA0LCAxKTtcbiAgLy8gMXN0IHdlZWsgPT0gdGhlIHdlZWsgd2hlcmUgdGhlIDR0aCBvZiBKYW51YXJ5IGlzIGluXG4gIHZhciBmaXJzdFRodSA9IGRheU9mVGhlV2Vla09mKG5ldyBEYXRlKHRodU9mVGhlV2Vlaykuc2V0TW9udGgoMCwgNCksIDQsIDEpO1xuICByZXR1cm4gTWF0aC5yb3VuZCgodGh1T2ZUaGVXZWVrIC0gZmlyc3RUaHUpIC8gNjA0ODAwMDAwKSArIDE7XG59XG5cbi8vIEdldCB0aGUgc3RhcnQgeWVhciBvZiB0aGUgcGVyaW9kIG9mIHllYXJzIHRoYXQgaW5jbHVkZXMgZ2l2ZW4gZGF0ZVxuLy8geWVhcnM6IGxlbmd0aCBvZiB0aGUgeWVhciBwZXJpb2RcbmZ1bmN0aW9uIHN0YXJ0T2ZZZWFyUGVyaW9kKGRhdGUsIHllYXJzKSB7XG4gIC8qIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWWVhcl96ZXJvI0lTT184NjAxICovXG4gIHZhciB5ZWFyID0gbmV3IERhdGUoZGF0ZSkuZ2V0RnVsbFllYXIoKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoeWVhciAvIHllYXJzKSAqIHllYXJzO1xufVxuXG4vLyBwYXR0ZXJuIGZvciBmb3JtYXQgcGFydHNcbnZhciByZUZvcm1hdFRva2VucyA9IC9kZD98REQ/fG1tP3xNTT98eXk/KD86eXkpPy87XG4vLyBwYXR0ZXJuIGZvciBub24gZGF0ZSBwYXJ0c1xudmFyIHJlTm9uRGF0ZVBhcnRzID0gL1tcXHMhLS86LUBbLWB7LX5cdTVFNzRcdTY3MDhcdTY1RTVdKy87XG4vLyBjYWNoZSBmb3IgcGVyc2VkIGZvcm1hdHNcbnZhciBrbm93bkZvcm1hdHMgPSB7fTtcbi8vIHBhcnNlIGZ1bnRpb25zIGZvciBkYXRlIHBhcnRzXG52YXIgcGFyc2VGbnMgPSB7XG4gIHk6IGZ1bmN0aW9uIHkoZGF0ZSwgeWVhcikge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKS5zZXRGdWxsWWVhcihwYXJzZUludCh5ZWFyLCAxMCkpO1xuICB9LFxuICBtOiBmdW5jdGlvbiBtKGRhdGUsIG1vbnRoLCBsb2NhbGUpIHtcbiAgICB2YXIgbmV3RGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgIHZhciBtb250aEluZGV4ID0gcGFyc2VJbnQobW9udGgsIDEwKSAtIDE7XG4gICAgaWYgKGlzTmFOKG1vbnRoSW5kZXgpKSB7XG4gICAgICBpZiAoIW1vbnRoKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG4gICAgICB2YXIgbW9udGhOYW1lID0gbW9udGgudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBjb21wYXJlTmFtZXMgPSBmdW5jdGlvbiBjb21wYXJlTmFtZXMobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgobW9udGhOYW1lKTtcbiAgICAgIH07XG4gICAgICAvLyBjb21wYXJlIHdpdGggYm90aCBzaG9ydCBhbmQgZnVsbCBuYW1lcyBiZWNhdXNlIHNvbWUgbG9jYWxlcyBoYXZlIHBlcmlvZHNcbiAgICAgIC8vIGluIHRoZSBzaG9ydCBuYW1lcyAobm90IGVxdWFsIHRvIHRoZSBmaXJzdCBYIGxldHRlcnMgb2YgdGhlIGZ1bGwgbmFtZXMpXG4gICAgICBtb250aEluZGV4ID0gbG9jYWxlLm1vbnRoc1Nob3J0LmZpbmRJbmRleChjb21wYXJlTmFtZXMpO1xuICAgICAgaWYgKG1vbnRoSW5kZXggPCAwKSB7XG4gICAgICAgIG1vbnRoSW5kZXggPSBsb2NhbGUubW9udGhzLmZpbmRJbmRleChjb21wYXJlTmFtZXMpO1xuICAgICAgfVxuICAgICAgaWYgKG1vbnRoSW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG4gICAgfVxuICAgIG5ld0RhdGUuc2V0TW9udGgobW9udGhJbmRleCk7XG4gICAgcmV0dXJuIG5ld0RhdGUuZ2V0TW9udGgoKSAhPT0gbm9ybWFsaXplTW9udGgobW9udGhJbmRleCkgPyBuZXdEYXRlLnNldERhdGUoMCkgOiBuZXdEYXRlLmdldFRpbWUoKTtcbiAgfSxcbiAgZDogZnVuY3Rpb24gZChkYXRlLCBkYXkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSkuc2V0RGF0ZShwYXJzZUludChkYXksIDEwKSk7XG4gIH1cbn07XG4vLyBmb3JtYXQgZnVuY3Rpb25zIGZvciBkYXRlIHBhcnRzXG52YXIgZm9ybWF0Rm5zID0ge1xuICBkOiBmdW5jdGlvbiBkKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXREYXRlKCk7XG4gIH0sXG4gIGRkOiBmdW5jdGlvbiBkZChkYXRlKSB7XG4gICAgcmV0dXJuIHBhZFplcm8oZGF0ZS5nZXREYXRlKCksIDIpO1xuICB9LFxuICBEOiBmdW5jdGlvbiBEKGRhdGUsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUuZGF5c1Nob3J0W2RhdGUuZ2V0RGF5KCldO1xuICB9LFxuICBERDogZnVuY3Rpb24gREQoZGF0ZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5kYXlzW2RhdGUuZ2V0RGF5KCldO1xuICB9LFxuICBtOiBmdW5jdGlvbiBtKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgfSxcbiAgbW06IGZ1bmN0aW9uIG1tKGRhdGUpIHtcbiAgICByZXR1cm4gcGFkWmVybyhkYXRlLmdldE1vbnRoKCkgKyAxLCAyKTtcbiAgfSxcbiAgTTogZnVuY3Rpb24gTShkYXRlLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0W2RhdGUuZ2V0TW9udGgoKV07XG4gIH0sXG4gIE1NOiBmdW5jdGlvbiBNTShkYXRlLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1tkYXRlLmdldE1vbnRoKCldO1xuICB9LFxuICB5OiBmdW5jdGlvbiB5KGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICB9LFxuICB5eTogZnVuY3Rpb24geXkoZGF0ZSkge1xuICAgIHJldHVybiBwYWRaZXJvKGRhdGUuZ2V0RnVsbFllYXIoKSwgMikuc2xpY2UoLTIpO1xuICB9LFxuICB5eXl5OiBmdW5jdGlvbiB5eXl5KGRhdGUpIHtcbiAgICByZXR1cm4gcGFkWmVybyhkYXRlLmdldEZ1bGxZZWFyKCksIDQpO1xuICB9XG59O1xuXG4vLyBnZXQgbW9udGggaW5kZXggaW4gbm9ybWFsIHJhbmdlICgwIC0gMTEpIGZyb20gYW55IG51bWJlclxuZnVuY3Rpb24gbm9ybWFsaXplTW9udGgobW9udGhJbmRleCkge1xuICByZXR1cm4gbW9udGhJbmRleCA+IC0xID8gbW9udGhJbmRleCAlIDEyIDogbm9ybWFsaXplTW9udGgobW9udGhJbmRleCArIDEyKTtcbn1cbmZ1bmN0aW9uIHBhZFplcm8obnVtLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG51bS50b1N0cmluZygpLnBhZFN0YXJ0KGxlbmd0aCwgJzAnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRm9ybWF0U3RyaW5nKGZvcm1hdCkge1xuICBpZiAodHlwZW9mIGZvcm1hdCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgZm9ybWF0LlwiKTtcbiAgfVxuICBpZiAoZm9ybWF0IGluIGtub3duRm9ybWF0cykge1xuICAgIHJldHVybiBrbm93bkZvcm1hdHNbZm9ybWF0XTtcbiAgfVxuXG4gIC8vIHNwcml0IHRoZSBmb3JtYXQgc3RyaW5nIGludG8gcGFydHMgYW5kIHNlcHJhdG9yc1xuICB2YXIgc2VwYXJhdG9ycyA9IGZvcm1hdC5zcGxpdChyZUZvcm1hdFRva2Vucyk7XG4gIHZhciBwYXJ0cyA9IGZvcm1hdC5tYXRjaChuZXcgUmVnRXhwKHJlRm9ybWF0VG9rZW5zLCAnZycpKTtcbiAgaWYgKHNlcGFyYXRvcnMubGVuZ3RoID09PSAwIHx8ICFwYXJ0cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXQuXCIpO1xuICB9XG5cbiAgLy8gY29sbGVjdCBmb3JtYXQgZnVuY3Rpb25zIHVzZWQgaW4gdGhlIGZvcm1hdFxuICB2YXIgcGFydEZvcm1hdHRlcnMgPSBwYXJ0cy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgcmV0dXJuIGZvcm1hdEZuc1t0b2tlbl07XG4gIH0pO1xuXG4gIC8vIGNvbGxlY3QgcGFyc2UgZnVuY3Rpb24ga2V5cyB1c2VkIGluIHRoZSBmb3JtYXRcbiAgLy8gaXRlcmF0ZSBvdmVyIHBhcnNlRm5zJyBrZXlzIGluIG9yZGVyIHRvIGtlZXAgdGhlIG9yZGVyIG9mIHRoZSBrZXlzLlxuICB2YXIgcGFydFBhcnNlcktleXMgPSBPYmplY3Qua2V5cyhwYXJzZUZucykucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBrZXkpIHtcbiAgICB2YXIgdG9rZW4gPSBwYXJ0cy5maW5kKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICByZXR1cm4gcGFydFswXSAhPT0gJ0QnICYmIHBhcnRbMF0udG9Mb3dlckNhc2UoKSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmICh0b2tlbikge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9LCBbXSk7XG4gIHJldHVybiBrbm93bkZvcm1hdHNbZm9ybWF0XSA9IHtcbiAgICBwYXJzZXI6IGZ1bmN0aW9uIHBhcnNlcihkYXRlU3RyLCBsb2NhbGUpIHtcbiAgICAgIHZhciBkYXRlUGFydHMgPSBkYXRlU3RyLnNwbGl0KHJlTm9uRGF0ZVBhcnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGR0UGFydHMsIHBhcnQsIGluZGV4KSB7XG4gICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA+IDAgJiYgcGFydHNbaW5kZXhdKSB7XG4gICAgICAgICAgdmFyIHRva2VuID0gcGFydHNbaW5kZXhdWzBdO1xuICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ00nKSB7XG4gICAgICAgICAgICBkdFBhcnRzLm0gPSBwYXJ0O1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4gIT09ICdEJykge1xuICAgICAgICAgICAgZHRQYXJ0c1t0b2tlbl0gPSBwYXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHRQYXJ0cztcbiAgICAgIH0sIHt9KTtcblxuICAgICAgLy8gaXRlcmF0ZSBvdmVyIHBhcnRQYXJzZXJrZXlzIHNvIHRoYXQgdGhlIHBhcnNpbmcgaXMgbWFkZSBpbiB0aGUgb2RlclxuICAgICAgLy8gb2YgeWVhciwgbW9udGggYW5kIGRheSB0byBwcmV2ZW50IHRoZSBkYXkgcGFyc2VyIGZyb20gY29ycmVjdGluZyBsYXN0XG4gICAgICAvLyBkYXkgb2YgbW9udGggd3JvbmdseVxuICAgICAgcmV0dXJuIHBhcnRQYXJzZXJLZXlzLnJlZHVjZShmdW5jdGlvbiAob3JpZ0RhdGUsIGtleSkge1xuICAgICAgICB2YXIgbmV3RGF0ZSA9IHBhcnNlRm5zW2tleV0ob3JpZ0RhdGUsIGRhdGVQYXJ0c1trZXldLCBsb2NhbGUpO1xuICAgICAgICAvLyBpbmdub3JlIHRoZSBwYXJ0IGZhaWxlZCB0byBwYXJzZVxuICAgICAgICByZXR1cm4gaXNOYU4obmV3RGF0ZSkgPyBvcmlnRGF0ZSA6IG5ld0RhdGU7XG4gICAgICB9LCB0b2RheSgpKTtcbiAgICB9LFxuICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKGRhdGUsIGxvY2FsZSkge1xuICAgICAgdmFyIGRhdGVTdHIgPSBwYXJ0Rm9ybWF0dGVycy5yZWR1Y2UoZnVuY3Rpb24gKHN0ciwgZm4sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBzdHIgKz0gXCJcIi5jb25jYXQoc2VwYXJhdG9yc1tpbmRleF0pLmNvbmNhdChmbihkYXRlLCBsb2NhbGUpKTtcbiAgICAgIH0sICcnKTtcbiAgICAgIC8vIHNlcGFyYXRvcnMnIGxlbmd0aCBpcyBhbHdheXMgcGFydHMnIGxlbmd0aCArIDEsXG4gICAgICByZXR1cm4gZGF0ZVN0ciArPSBsYXN0SXRlbU9mKHNlcGFyYXRvcnMpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRGF0ZShkYXRlU3RyLCBmb3JtYXQsIGxvY2FsZSkge1xuICBpZiAoZGF0ZVN0ciBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGRhdGVTdHIgPT09ICdudW1iZXInKSB7XG4gICAgdmFyIGRhdGUgPSBzdHJpcFRpbWUoZGF0ZVN0cik7XG4gICAgcmV0dXJuIGlzTmFOKGRhdGUpID8gdW5kZWZpbmVkIDogZGF0ZTtcbiAgfVxuICBpZiAoIWRhdGVTdHIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChkYXRlU3RyID09PSAndG9kYXknKSB7XG4gICAgcmV0dXJuIHRvZGF5KCk7XG4gIH1cbiAgaWYgKGZvcm1hdCAmJiBmb3JtYXQudG9WYWx1ZSkge1xuICAgIHZhciBfZGF0ZSA9IGZvcm1hdC50b1ZhbHVlKGRhdGVTdHIsIGZvcm1hdCwgbG9jYWxlKTtcbiAgICByZXR1cm4gaXNOYU4oX2RhdGUpID8gdW5kZWZpbmVkIDogc3RyaXBUaW1lKF9kYXRlKTtcbiAgfVxuICByZXR1cm4gcGFyc2VGb3JtYXRTdHJpbmcoZm9ybWF0KS5wYXJzZXIoZGF0ZVN0ciwgbG9jYWxlKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCBsb2NhbGUpIHtcbiAgaWYgKGlzTmFOKGRhdGUpIHx8ICFkYXRlICYmIGRhdGUgIT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgdmFyIGRhdGVPYmogPSB0eXBlb2YgZGF0ZSA9PT0gJ251bWJlcicgPyBuZXcgRGF0ZShkYXRlKSA6IGRhdGU7XG4gIGlmIChmb3JtYXQudG9EaXNwbGF5KSB7XG4gICAgcmV0dXJuIGZvcm1hdC50b0Rpc3BsYXkoZGF0ZU9iaiwgZm9ybWF0LCBsb2NhbGUpO1xuICB9XG4gIHJldHVybiBwYXJzZUZvcm1hdFN0cmluZyhmb3JtYXQpLmZvcm1hdHRlcihkYXRlT2JqLCBsb2NhbGUpO1xufVxuXG52YXIgbGlzdGVuZXJSZWdpc3RyeSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgX0V2ZW50VGFyZ2V0JHByb3RvdHlwID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLFxuICBhZGRFdmVudExpc3RlbmVyID0gX0V2ZW50VGFyZ2V0JHByb3RvdHlwLmFkZEV2ZW50TGlzdGVuZXIsXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSBfRXZlbnRUYXJnZXQkcHJvdG90eXAucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxuLy8gUmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIHRvIGEga2V5IG9iamVjdFxuLy8gbGlzdGVuZXJzOiBhcnJheSBvZiBsaXN0ZW5lciBkZWZpbml0aW9ucztcbi8vICAgLSBlYWNoIGRlZmluaXRpb24gbXVzdCBiZSBhIGZsYXQgYXJyYXkgb2YgZXZlbnQgdGFyZ2V0IGFuZCB0aGUgYXJndW1lbnRzXG4vLyAgICAgdXNlZCB0byBjYWxsIGFkZEV2ZW50TGlzdGVuZXIoKSBvbiB0aGUgdGFyZ2V0XG5mdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycyhrZXlPYmosIGxpc3RlbmVycykge1xuICB2YXIgcmVnaXN0ZXJlZCA9IGxpc3RlbmVyUmVnaXN0cnkuZ2V0KGtleU9iaik7XG4gIGlmICghcmVnaXN0ZXJlZCkge1xuICAgIHJlZ2lzdGVyZWQgPSBbXTtcbiAgICBsaXN0ZW5lclJlZ2lzdHJ5LnNldChrZXlPYmosIHJlZ2lzdGVyZWQpO1xuICB9XG4gIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIGFkZEV2ZW50TGlzdGVuZXIuY2FsbC5hcHBseShhZGRFdmVudExpc3RlbmVyLCBfdG9Db25zdW1hYmxlQXJyYXkobGlzdGVuZXIpKTtcbiAgICByZWdpc3RlcmVkLnB1c2gobGlzdGVuZXIpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoa2V5T2JqKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSBsaXN0ZW5lclJlZ2lzdHJ5LmdldChrZXlPYmopO1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyLmNhbGwuYXBwbHkocmVtb3ZlRXZlbnRMaXN0ZW5lciwgX3RvQ29uc3VtYWJsZUFycmF5KGxpc3RlbmVyKSk7XG4gIH0pO1xuICBsaXN0ZW5lclJlZ2lzdHJ5W1wiZGVsZXRlXCJdKGtleU9iaik7XG59XG5cbi8vIEV2ZW50LmNvbXBvc2VkUGF0aCgpIHBvbHlmaWxsIGZvciBFZGdlXG4vLyBiYXNlZCBvbiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9rbGVpbmZyZXVuZC9lOTc4N2Q3Mzc3NmMwZTM3NTBkY2ZjZGM4OWYxMDBlY1xuaWYgKCFFdmVudC5wcm90b3R5cGUuY29tcG9zZWRQYXRoKSB7XG4gIHZhciBnZXRDb21wb3NlZFBhdGggPSBmdW5jdGlvbiBnZXRDb21wb3NlZFBhdGgobm9kZSkge1xuICAgIHZhciBwYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgdmFyIHBhcmVudDtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmhvc3QpIHtcbiAgICAgIC8vIFNoYWRvd1Jvb3RcbiAgICAgIHBhcmVudCA9IG5vZGUuaG9zdDtcbiAgICB9IGVsc2UgaWYgKG5vZGUuZGVmYXVsdFZpZXcpIHtcbiAgICAgIC8vIERvY3VtZW50XG4gICAgICBwYXJlbnQgPSBub2RlLmRlZmF1bHRWaWV3O1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50ID8gZ2V0Q29tcG9zZWRQYXRoKHBhcmVudCwgcGF0aCkgOiBwYXRoO1xuICB9O1xuICBFdmVudC5wcm90b3R5cGUuY29tcG9zZWRQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRDb21wb3NlZFBhdGgodGhpcy50YXJnZXQpO1xuICB9O1xufVxuZnVuY3Rpb24gZmluZEZyb21QYXRoKHBhdGgsIGNyaXRlcmlhLCBjdXJyZW50VGFyZ2V0KSB7XG4gIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgdmFyIGVsID0gcGF0aFtpbmRleF07XG4gIGlmIChjcml0ZXJpYShlbCkpIHtcbiAgICByZXR1cm4gZWw7XG4gIH0gZWxzZSBpZiAoZWwgPT09IGN1cnJlbnRUYXJnZXQgfHwgIWVsLnBhcmVudEVsZW1lbnQpIHtcbiAgICAvLyBzdG9wIHdoZW4gcmVhY2hpbmcgY3VycmVudFRhcmdldCBvciA8aHRtbD5cbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIGZpbmRGcm9tUGF0aChwYXRoLCBjcml0ZXJpYSwgY3VycmVudFRhcmdldCwgaW5kZXggKyAxKTtcbn1cblxuLy8gU2VhcmNoIGZvciB0aGUgYWN0dWFsIHRhcmdldCBvZiBhIGRlbGVnYXRlZCBldmVudFxuZnVuY3Rpb24gZmluZEVsZW1lbnRJbkV2ZW50UGF0aChldiwgc2VsZWN0b3IpIHtcbiAgdmFyIGNyaXRlcmlhID0gdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nID8gc2VsZWN0b3IgOiBmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwubWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH07XG4gIHJldHVybiBmaW5kRnJvbVBhdGgoZXYuY29tcG9zZWRQYXRoKCksIGNyaXRlcmlhLCBldi5jdXJyZW50VGFyZ2V0KTtcbn1cblxuLy8gZGVmYXVsdCBsb2NhbGVzXG52YXIgbG9jYWxlcyA9IHtcbiAgZW46IHtcbiAgICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgICBkYXlzU2hvcnQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgICBkYXlzTWluOiBbXCJTdVwiLCBcIk1vXCIsIFwiVHVcIiwgXCJXZVwiLCBcIlRoXCIsIFwiRnJcIiwgXCJTYVwiXSxcbiAgICBtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuICAgIG1vbnRoc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sXG4gICAgdG9kYXk6IFwiVG9kYXlcIixcbiAgICBjbGVhcjogXCJDbGVhclwiLFxuICAgIHRpdGxlRm9ybWF0OiBcIk1NIHlcIlxuICB9XG59O1xuXG4vLyBjb25maWcgb3B0aW9ucyB1cGRhdGFibGUgYnkgc2V0T3B0aW9ucygpIGFuZCB0aGVpciBkZWZhdWx0IHZhbHVlc1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBhdXRvaGlkZTogZmFsc2UsXG4gIGJlZm9yZVNob3dEYXk6IG51bGwsXG4gIGJlZm9yZVNob3dEZWNhZGU6IG51bGwsXG4gIGJlZm9yZVNob3dNb250aDogbnVsbCxcbiAgYmVmb3JlU2hvd1llYXI6IG51bGwsXG4gIGNhbGVuZGFyV2Vla3M6IGZhbHNlLFxuICBjbGVhckJ0bjogZmFsc2UsXG4gIGRhdGVEZWxpbWl0ZXI6ICcsJyxcbiAgZGF0ZXNEaXNhYmxlZDogW10sXG4gIGRheXNPZldlZWtEaXNhYmxlZDogW10sXG4gIGRheXNPZldlZWtIaWdobGlnaHRlZDogW10sXG4gIGRlZmF1bHRWaWV3RGF0ZTogdW5kZWZpbmVkLFxuICAvLyBwbGFjZWhvbGRlciwgZGVmYXVsdHMgdG8gdG9kYXkoKSBieSB0aGUgcHJvZ3JhbVxuICBkaXNhYmxlVG91Y2hLZXlib2FyZDogZmFsc2UsXG4gIGZvcm1hdDogJ21tL2RkL3l5eXknLFxuICBsYW5ndWFnZTogJ2VuJyxcbiAgbWF4RGF0ZTogbnVsbCxcbiAgbWF4TnVtYmVyT2ZEYXRlczogMSxcbiAgbWF4VmlldzogMyxcbiAgbWluRGF0ZTogbnVsbCxcbiAgbmV4dEFycm93OiAnPHN2ZyBjbGFzcz1cInctNCBoLTQgcnRsOnJvdGF0ZS0xODAgdGV4dC1ncmF5LTgwMCBkYXJrOnRleHQtd2hpdGVcIiBhcmlhLWhpZGRlbj1cInRydWVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDE0IDEwXCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMSA1aDEybTAgMEw5IDFtNCA0TDkgOVwiLz48L3N2Zz4nLFxuICBvcmllbnRhdGlvbjogJ2F1dG8nLFxuICBwaWNrTGV2ZWw6IDAsXG4gIHByZXZBcnJvdzogJzxzdmcgY2xhc3M9XCJ3LTQgaC00IHJ0bDpyb3RhdGUtMTgwIHRleHQtZ3JheS04MDAgZGFyazp0ZXh0LXdoaXRlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAxNCAxMFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTEzIDVIMW0wIDAgNCA0TTEgNWw0LTRcIi8+PC9zdmc+JyxcbiAgc2hvd0RheXNPZldlZWs6IHRydWUsXG4gIHNob3dPbkNsaWNrOiB0cnVlLFxuICBzaG93T25Gb2N1czogdHJ1ZSxcbiAgc3RhcnRWaWV3OiAwLFxuICB0aXRsZTogJycsXG4gIHRvZGF5QnRuOiBmYWxzZSxcbiAgdG9kYXlCdG5Nb2RlOiAwLFxuICB0b2RheUhpZ2hsaWdodDogZmFsc2UsXG4gIHVwZGF0ZU9uQmx1cjogdHJ1ZSxcbiAgd2Vla1N0YXJ0OiAwXG59O1xuXG52YXIgcmFuZ2UgPSBudWxsO1xuZnVuY3Rpb24gcGFyc2VIVE1MKGh0bWwpIHtcbiAgaWYgKHJhbmdlID09IG51bGwpIHtcbiAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIH1cbiAgcmV0dXJuIHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChodG1sKTtcbn1cbmZ1bmN0aW9uIGhpZGVFbGVtZW50KGVsKSB7XG4gIGlmIChlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gYmFjayB1cCB0aGUgZXhpc3RpbmcgZGlzcGxheSBzZXR0aW5nIGluIGRhdGEtc3R5bGUtZGlzcGxheVxuICBpZiAoZWwuc3R5bGUuZGlzcGxheSkge1xuICAgIGVsLmRhdGFzZXQuc3R5bGVEaXNwbGF5ID0gZWwuc3R5bGUuZGlzcGxheTtcbiAgfVxuICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xufVxuZnVuY3Rpb24gc2hvd0VsZW1lbnQoZWwpIHtcbiAgaWYgKGVsLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWwuZGF0YXNldC5zdHlsZURpc3BsYXkpIHtcbiAgICAvLyByZXN0b3JlIGJhY2tlZC11cCBkaXNwYXkgcHJvcGVydHlcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuZGF0YXNldC5zdHlsZURpc3BsYXk7XG4gICAgZGVsZXRlIGVsLmRhdGFzZXQuc3R5bGVEaXNwbGF5O1xuICB9IGVsc2Uge1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgfVxufVxuZnVuY3Rpb24gZW1wdHlDaGlsZE5vZGVzKGVsKSB7XG4gIGlmIChlbC5maXJzdENoaWxkKSB7XG4gICAgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gICAgZW1wdHlDaGlsZE5vZGVzKGVsKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZUNoaWxkTm9kZXMoZWwsIG5ld0NoaWxkTm9kZXMpIHtcbiAgZW1wdHlDaGlsZE5vZGVzKGVsKTtcbiAgaWYgKG5ld0NoaWxkTm9kZXMgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgZWwuYXBwZW5kQ2hpbGQobmV3Q2hpbGROb2Rlcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5ld0NoaWxkTm9kZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgZWwuYXBwZW5kQ2hpbGQocGFyc2VIVE1MKG5ld0NoaWxkTm9kZXMpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbmV3Q2hpbGROb2Rlcy5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbmV3Q2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBlbC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgZGVmYXVsdExhbmcgPSBkZWZhdWx0T3B0aW9ucy5sYW5ndWFnZSxcbiAgZGVmYXVsdEZvcm1hdCA9IGRlZmF1bHRPcHRpb25zLmZvcm1hdCxcbiAgZGVmYXVsdFdlZWtTdGFydCA9IGRlZmF1bHRPcHRpb25zLndlZWtTdGFydDtcblxuLy8gUmVkdWNlciBmdW5jdGlvbiB0byBmaWx0ZXIgb3V0IGludmFsaWQgZGF5LW9mLXdlZWsgZnJvbSB0aGUgaW5wdXRcbmZ1bmN0aW9uIHNhbml0aXplRE9XKGRvdywgZGF5KSB7XG4gIHJldHVybiBkb3cubGVuZ3RoIDwgNiAmJiBkYXkgPj0gMCAmJiBkYXkgPCA3ID8gcHVzaFVuaXF1ZShkb3csIGRheSkgOiBkb3c7XG59XG5mdW5jdGlvbiBjYWxjRW5kT2ZXZWVrKHN0YXJ0T2ZXZWVrKSB7XG4gIHJldHVybiAoc3RhcnRPZldlZWsgKyA2KSAlIDc7XG59XG5cbi8vIHZhbGlkYXRlIGlucHV0IGRhdGUuIGlmIGludmFsaWQsIGZhbGxiYWNrIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZVxuZnVuY3Rpb24gdmFsaWRhdGVEYXRlKHZhbHVlLCBmb3JtYXQsIGxvY2FsZSwgb3JpZ1ZhbHVlKSB7XG4gIHZhciBkYXRlID0gcGFyc2VEYXRlKHZhbHVlLCBmb3JtYXQsIGxvY2FsZSk7XG4gIHJldHVybiBkYXRlICE9PSB1bmRlZmluZWQgPyBkYXRlIDogb3JpZ1ZhbHVlO1xufVxuXG4vLyBWYWxpZGF0ZSB2aWV3SWQuIGlmIGludmFsaWQsIGZhbGxiYWNrIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZVxuZnVuY3Rpb24gdmFsaWRhdGVWaWV3SWQodmFsdWUsIG9yaWdWYWx1ZSkge1xuICB2YXIgbWF4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAzO1xuICB2YXIgdmlld0lkID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgcmV0dXJuIHZpZXdJZCA+PSAwICYmIHZpZXdJZCA8PSBtYXggPyB2aWV3SWQgOiBvcmlnVmFsdWU7XG59XG5cbi8vIENyZWF0ZSBEYXRlcGlja2VyIGNvbmZpZ3VyYXRpb24gdG8gc2V0XG5mdW5jdGlvbiBwcm9jZXNzT3B0aW9ucyhvcHRpb25zLCBkYXRlcGlja2VyKSB7XG4gIHZhciBpbk9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgdmFyIGNvbmZpZyA9IHt9O1xuICB2YXIgbG9jYWxlcyA9IGRhdGVwaWNrZXIuY29uc3RydWN0b3IubG9jYWxlcztcbiAgdmFyIF9yZWYgPSBkYXRlcGlja2VyLmNvbmZpZyB8fCB7fSxcbiAgICBmb3JtYXQgPSBfcmVmLmZvcm1hdCxcbiAgICBsYW5ndWFnZSA9IF9yZWYubGFuZ3VhZ2UsXG4gICAgbG9jYWxlID0gX3JlZi5sb2NhbGUsXG4gICAgbWF4RGF0ZSA9IF9yZWYubWF4RGF0ZSxcbiAgICBtYXhWaWV3ID0gX3JlZi5tYXhWaWV3LFxuICAgIG1pbkRhdGUgPSBfcmVmLm1pbkRhdGUsXG4gICAgcGlja0xldmVsID0gX3JlZi5waWNrTGV2ZWwsXG4gICAgc3RhcnRWaWV3ID0gX3JlZi5zdGFydFZpZXcsXG4gICAgd2Vla1N0YXJ0ID0gX3JlZi53ZWVrU3RhcnQ7XG4gIGlmIChpbk9wdHMubGFuZ3VhZ2UpIHtcbiAgICB2YXIgbGFuZztcbiAgICBpZiAoaW5PcHRzLmxhbmd1YWdlICE9PSBsYW5ndWFnZSkge1xuICAgICAgaWYgKGxvY2FsZXNbaW5PcHRzLmxhbmd1YWdlXSkge1xuICAgICAgICBsYW5nID0gaW5PcHRzLmxhbmd1YWdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgbGFuZ2F1Z2UgKyByZWdpb24gdGFnIGNhbiBmYWxsYmFjayB0byB0aGUgb25lIHdpdGhvdXRcbiAgICAgICAgLy8gcmVnaW9uIChlLmcuIGZyLUNBIFx1MjE5MiBmcilcbiAgICAgICAgbGFuZyA9IGluT3B0cy5sYW5ndWFnZS5zcGxpdCgnLScpWzBdO1xuICAgICAgICBpZiAobG9jYWxlc1tsYW5nXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGFuZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZSBpbk9wdHMubGFuZ3VhZ2U7XG4gICAgaWYgKGxhbmcpIHtcbiAgICAgIGxhbmd1YWdlID0gY29uZmlnLmxhbmd1YWdlID0gbGFuZztcblxuICAgICAgLy8gdXBkYXRlIGxvY2FsZSBhcyB3ZWxsIHdoZW4gdXBkYXRpbmcgbGFuZ3VhZ2VcbiAgICAgIHZhciBvcmlnTG9jYWxlID0gbG9jYWxlIHx8IGxvY2FsZXNbZGVmYXVsdExhbmddO1xuICAgICAgLy8gdXNlIGRlZmF1bHQgbGFuZ3VhZ2UncyBwcm9wZXJ0aWVzIGZvciB0aGUgZmFsbGJhY2tcbiAgICAgIGxvY2FsZSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBmb3JtYXQ6IGRlZmF1bHRGb3JtYXQsXG4gICAgICAgIHdlZWtTdGFydDogZGVmYXVsdFdlZWtTdGFydFxuICAgICAgfSwgbG9jYWxlc1tkZWZhdWx0TGFuZ10pO1xuICAgICAgaWYgKGxhbmd1YWdlICE9PSBkZWZhdWx0TGFuZykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGxvY2FsZSwgbG9jYWxlc1tsYW5ndWFnZV0pO1xuICAgICAgfVxuICAgICAgY29uZmlnLmxvY2FsZSA9IGxvY2FsZTtcbiAgICAgIC8vIGlmIGZvcm1hdCBhbmQvb3Igd2Vla1N0YXJ0IGFyZSB0aGUgc2FtZSBhcyBvbGQgbG9jYWxlJ3MgZGVmYXVsdHMsXG4gICAgICAvLyB1cGRhdGUgdGhlbSB0byBuZXcgbG9jYWxlJ3MgZGVmYXVsdHNcbiAgICAgIGlmIChmb3JtYXQgPT09IG9yaWdMb2NhbGUuZm9ybWF0KSB7XG4gICAgICAgIGZvcm1hdCA9IGNvbmZpZy5mb3JtYXQgPSBsb2NhbGUuZm9ybWF0O1xuICAgICAgfVxuICAgICAgaWYgKHdlZWtTdGFydCA9PT0gb3JpZ0xvY2FsZS53ZWVrU3RhcnQpIHtcbiAgICAgICAgd2Vla1N0YXJ0ID0gY29uZmlnLndlZWtTdGFydCA9IGxvY2FsZS53ZWVrU3RhcnQ7XG4gICAgICAgIGNvbmZpZy53ZWVrRW5kID0gY2FsY0VuZE9mV2Vlayhsb2NhbGUud2Vla1N0YXJ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGluT3B0cy5mb3JtYXQpIHtcbiAgICB2YXIgaGFzVG9EaXNwbGF5ID0gdHlwZW9mIGluT3B0cy5mb3JtYXQudG9EaXNwbGF5ID09PSAnZnVuY3Rpb24nO1xuICAgIHZhciBoYXNUb1ZhbHVlID0gdHlwZW9mIGluT3B0cy5mb3JtYXQudG9WYWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB2YXIgdmFsaWRGb3JtYXRTdHJpbmcgPSByZUZvcm1hdFRva2Vucy50ZXN0KGluT3B0cy5mb3JtYXQpO1xuICAgIGlmIChoYXNUb0Rpc3BsYXkgJiYgaGFzVG9WYWx1ZSB8fCB2YWxpZEZvcm1hdFN0cmluZykge1xuICAgICAgZm9ybWF0ID0gY29uZmlnLmZvcm1hdCA9IGluT3B0cy5mb3JtYXQ7XG4gICAgfVxuICAgIGRlbGV0ZSBpbk9wdHMuZm9ybWF0O1xuICB9XG5cbiAgLy8qKiogZGF0ZXMgKioqLy9cbiAgLy8gd2hpbGUgbWluIGFuZCBtYXhEYXRlIGZvciBcIm5vIGxpbWl0XCIgaW4gdGhlIG9wdGlvbnMgYXJlIGJldHRlciB0byBiZSBudWxsXG4gIC8vIChlc3BlY2lhbGx5IHdoZW4gdXBkYXRpbmcpLCB0aGUgb25lcyBpbiB0aGUgY29uZmlnIGhhdmUgdG8gYmUgdW5kZWZpbmVkXG4gIC8vIGJlY2F1c2UgbnVsbCBpcyB0cmVhdGVkIGFzIDAgKD0gdW5peCBlcG9jaCkgd2hlbiBjb21wYXJpbmcgd2l0aCB0aW1lIHZhbHVlXG4gIHZhciBtaW5EdCA9IG1pbkRhdGU7XG4gIHZhciBtYXhEdCA9IG1heERhdGU7XG4gIGlmIChpbk9wdHMubWluRGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbWluRHQgPSBpbk9wdHMubWluRGF0ZSA9PT0gbnVsbCA/IGRhdGVWYWx1ZSgwLCAwLCAxKSAvLyBzZXQgMDAwMC0wMS0wMSB0byBwcmV2ZW50IG5lZ2F0aXZlIHZhbHVlcyBmb3IgeWVhclxuICAgIDogdmFsaWRhdGVEYXRlKGluT3B0cy5taW5EYXRlLCBmb3JtYXQsIGxvY2FsZSwgbWluRHQpO1xuICAgIGRlbGV0ZSBpbk9wdHMubWluRGF0ZTtcbiAgfVxuICBpZiAoaW5PcHRzLm1heERhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIG1heER0ID0gaW5PcHRzLm1heERhdGUgPT09IG51bGwgPyB1bmRlZmluZWQgOiB2YWxpZGF0ZURhdGUoaW5PcHRzLm1heERhdGUsIGZvcm1hdCwgbG9jYWxlLCBtYXhEdCk7XG4gICAgZGVsZXRlIGluT3B0cy5tYXhEYXRlO1xuICB9XG4gIGlmIChtYXhEdCA8IG1pbkR0KSB7XG4gICAgbWluRGF0ZSA9IGNvbmZpZy5taW5EYXRlID0gbWF4RHQ7XG4gICAgbWF4RGF0ZSA9IGNvbmZpZy5tYXhEYXRlID0gbWluRHQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG1pbkRhdGUgIT09IG1pbkR0KSB7XG4gICAgICBtaW5EYXRlID0gY29uZmlnLm1pbkRhdGUgPSBtaW5EdDtcbiAgICB9XG4gICAgaWYgKG1heERhdGUgIT09IG1heER0KSB7XG4gICAgICBtYXhEYXRlID0gY29uZmlnLm1heERhdGUgPSBtYXhEdDtcbiAgICB9XG4gIH1cbiAgaWYgKGluT3B0cy5kYXRlc0Rpc2FibGVkKSB7XG4gICAgY29uZmlnLmRhdGVzRGlzYWJsZWQgPSBpbk9wdHMuZGF0ZXNEaXNhYmxlZC5yZWR1Y2UoZnVuY3Rpb24gKGRhdGVzLCBkdCkge1xuICAgICAgdmFyIGRhdGUgPSBwYXJzZURhdGUoZHQsIGZvcm1hdCwgbG9jYWxlKTtcbiAgICAgIHJldHVybiBkYXRlICE9PSB1bmRlZmluZWQgPyBwdXNoVW5pcXVlKGRhdGVzLCBkYXRlKSA6IGRhdGVzO1xuICAgIH0sIFtdKTtcbiAgICBkZWxldGUgaW5PcHRzLmRhdGVzRGlzYWJsZWQ7XG4gIH1cbiAgaWYgKGluT3B0cy5kZWZhdWx0Vmlld0RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciB2aWV3RGF0ZSA9IHBhcnNlRGF0ZShpbk9wdHMuZGVmYXVsdFZpZXdEYXRlLCBmb3JtYXQsIGxvY2FsZSk7XG4gICAgaWYgKHZpZXdEYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbmZpZy5kZWZhdWx0Vmlld0RhdGUgPSB2aWV3RGF0ZTtcbiAgICB9XG4gICAgZGVsZXRlIGluT3B0cy5kZWZhdWx0Vmlld0RhdGU7XG4gIH1cblxuICAvLyoqKiBkYXlzIG9mIHdlZWsgKioqLy9cbiAgaWYgKGluT3B0cy53ZWVrU3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciB3a1N0YXJ0ID0gTnVtYmVyKGluT3B0cy53ZWVrU3RhcnQpICUgNztcbiAgICBpZiAoIWlzTmFOKHdrU3RhcnQpKSB7XG4gICAgICB3ZWVrU3RhcnQgPSBjb25maWcud2Vla1N0YXJ0ID0gd2tTdGFydDtcbiAgICAgIGNvbmZpZy53ZWVrRW5kID0gY2FsY0VuZE9mV2Vlayh3a1N0YXJ0KTtcbiAgICB9XG4gICAgZGVsZXRlIGluT3B0cy53ZWVrU3RhcnQ7XG4gIH1cbiAgaWYgKGluT3B0cy5kYXlzT2ZXZWVrRGlzYWJsZWQpIHtcbiAgICBjb25maWcuZGF5c09mV2Vla0Rpc2FibGVkID0gaW5PcHRzLmRheXNPZldlZWtEaXNhYmxlZC5yZWR1Y2Uoc2FuaXRpemVET1csIFtdKTtcbiAgICBkZWxldGUgaW5PcHRzLmRheXNPZldlZWtEaXNhYmxlZDtcbiAgfVxuICBpZiAoaW5PcHRzLmRheXNPZldlZWtIaWdobGlnaHRlZCkge1xuICAgIGNvbmZpZy5kYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQgPSBpbk9wdHMuZGF5c09mV2Vla0hpZ2hsaWdodGVkLnJlZHVjZShzYW5pdGl6ZURPVywgW10pO1xuICAgIGRlbGV0ZSBpbk9wdHMuZGF5c09mV2Vla0hpZ2hsaWdodGVkO1xuICB9XG5cbiAgLy8qKiogbXVsdGkgZGF0ZSAqKiovL1xuICBpZiAoaW5PcHRzLm1heE51bWJlck9mRGF0ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBtYXhOdW1iZXJPZkRhdGVzID0gcGFyc2VJbnQoaW5PcHRzLm1heE51bWJlck9mRGF0ZXMsIDEwKTtcbiAgICBpZiAobWF4TnVtYmVyT2ZEYXRlcyA+PSAwKSB7XG4gICAgICBjb25maWcubWF4TnVtYmVyT2ZEYXRlcyA9IG1heE51bWJlck9mRGF0ZXM7XG4gICAgICBjb25maWcubXVsdGlkYXRlID0gbWF4TnVtYmVyT2ZEYXRlcyAhPT0gMTtcbiAgICB9XG4gICAgZGVsZXRlIGluT3B0cy5tYXhOdW1iZXJPZkRhdGVzO1xuICB9XG4gIGlmIChpbk9wdHMuZGF0ZURlbGltaXRlcikge1xuICAgIGNvbmZpZy5kYXRlRGVsaW1pdGVyID0gU3RyaW5nKGluT3B0cy5kYXRlRGVsaW1pdGVyKTtcbiAgICBkZWxldGUgaW5PcHRzLmRhdGVEZWxpbWl0ZXI7XG4gIH1cblxuICAvLyoqKiBwaWNrIGxldmVsICYgdmlldyAqKiovL1xuICB2YXIgbmV3UGlja0xldmVsID0gcGlja0xldmVsO1xuICBpZiAoaW5PcHRzLnBpY2tMZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbmV3UGlja0xldmVsID0gdmFsaWRhdGVWaWV3SWQoaW5PcHRzLnBpY2tMZXZlbCwgMik7XG4gICAgZGVsZXRlIGluT3B0cy5waWNrTGV2ZWw7XG4gIH1cbiAgaWYgKG5ld1BpY2tMZXZlbCAhPT0gcGlja0xldmVsKSB7XG4gICAgcGlja0xldmVsID0gY29uZmlnLnBpY2tMZXZlbCA9IG5ld1BpY2tMZXZlbDtcbiAgfVxuICB2YXIgbmV3TWF4VmlldyA9IG1heFZpZXc7XG4gIGlmIChpbk9wdHMubWF4VmlldyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbmV3TWF4VmlldyA9IHZhbGlkYXRlVmlld0lkKGluT3B0cy5tYXhWaWV3LCBtYXhWaWV3KTtcbiAgICBkZWxldGUgaW5PcHRzLm1heFZpZXc7XG4gIH1cbiAgLy8gZW5zdXJlIG1heCB2aWV3ID49IHBpY2sgbGV2ZWxcbiAgbmV3TWF4VmlldyA9IHBpY2tMZXZlbCA+IG5ld01heFZpZXcgPyBwaWNrTGV2ZWwgOiBuZXdNYXhWaWV3O1xuICBpZiAobmV3TWF4VmlldyAhPT0gbWF4Vmlldykge1xuICAgIG1heFZpZXcgPSBjb25maWcubWF4VmlldyA9IG5ld01heFZpZXc7XG4gIH1cbiAgdmFyIG5ld1N0YXJ0VmlldyA9IHN0YXJ0VmlldztcbiAgaWYgKGluT3B0cy5zdGFydFZpZXcgIT09IHVuZGVmaW5lZCkge1xuICAgIG5ld1N0YXJ0VmlldyA9IHZhbGlkYXRlVmlld0lkKGluT3B0cy5zdGFydFZpZXcsIG5ld1N0YXJ0Vmlldyk7XG4gICAgZGVsZXRlIGluT3B0cy5zdGFydFZpZXc7XG4gIH1cbiAgLy8gZW5zdXJlIHBpY2sgbGV2ZWwgPD0gc3RhcnQgdmlldyA8PSBtYXggdmlld1xuICBpZiAobmV3U3RhcnRWaWV3IDwgcGlja0xldmVsKSB7XG4gICAgbmV3U3RhcnRWaWV3ID0gcGlja0xldmVsO1xuICB9IGVsc2UgaWYgKG5ld1N0YXJ0VmlldyA+IG1heFZpZXcpIHtcbiAgICBuZXdTdGFydFZpZXcgPSBtYXhWaWV3O1xuICB9XG4gIGlmIChuZXdTdGFydFZpZXcgIT09IHN0YXJ0Vmlldykge1xuICAgIGNvbmZpZy5zdGFydFZpZXcgPSBuZXdTdGFydFZpZXc7XG4gIH1cblxuICAvLyoqKiB0ZW1wbGF0ZSAqKiovL1xuICBpZiAoaW5PcHRzLnByZXZBcnJvdykge1xuICAgIHZhciBwcmV2QXJyb3cgPSBwYXJzZUhUTUwoaW5PcHRzLnByZXZBcnJvdyk7XG4gICAgaWYgKHByZXZBcnJvdy5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbmZpZy5wcmV2QXJyb3cgPSBwcmV2QXJyb3cuY2hpbGROb2RlcztcbiAgICB9XG4gICAgZGVsZXRlIGluT3B0cy5wcmV2QXJyb3c7XG4gIH1cbiAgaWYgKGluT3B0cy5uZXh0QXJyb3cpIHtcbiAgICB2YXIgbmV4dEFycm93ID0gcGFyc2VIVE1MKGluT3B0cy5uZXh0QXJyb3cpO1xuICAgIGlmIChuZXh0QXJyb3cuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25maWcubmV4dEFycm93ID0gbmV4dEFycm93LmNoaWxkTm9kZXM7XG4gICAgfVxuICAgIGRlbGV0ZSBpbk9wdHMubmV4dEFycm93O1xuICB9XG5cbiAgLy8qKiogbWlzYyAqKiovL1xuICBpZiAoaW5PcHRzLmRpc2FibGVUb3VjaEtleWJvYXJkICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25maWcuZGlzYWJsZVRvdWNoS2V5Ym9hcmQgPSAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudCAmJiAhIWluT3B0cy5kaXNhYmxlVG91Y2hLZXlib2FyZDtcbiAgICBkZWxldGUgaW5PcHRzLmRpc2FibGVUb3VjaEtleWJvYXJkO1xuICB9XG4gIGlmIChpbk9wdHMub3JpZW50YXRpb24pIHtcbiAgICB2YXIgb3JpZW50YXRpb24gPSBpbk9wdHMub3JpZW50YXRpb24udG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKy9nKTtcbiAgICBjb25maWcub3JpZW50YXRpb24gPSB7XG4gICAgICB4OiBvcmllbnRhdGlvbi5maW5kKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4ID09PSAnbGVmdCcgfHwgeCA9PT0gJ3JpZ2h0JztcbiAgICAgIH0pIHx8ICdhdXRvJyxcbiAgICAgIHk6IG9yaWVudGF0aW9uLmZpbmQoZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgcmV0dXJuIHkgPT09ICd0b3AnIHx8IHkgPT09ICdib3R0b20nO1xuICAgICAgfSkgfHwgJ2F1dG8nXG4gICAgfTtcbiAgICBkZWxldGUgaW5PcHRzLm9yaWVudGF0aW9uO1xuICB9XG4gIGlmIChpbk9wdHMudG9kYXlCdG5Nb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICBzd2l0Y2ggKGluT3B0cy50b2RheUJ0bk1vZGUpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgY29uZmlnLnRvZGF5QnRuTW9kZSA9IGluT3B0cy50b2RheUJ0bk1vZGU7XG4gICAgfVxuICAgIGRlbGV0ZSBpbk9wdHMudG9kYXlCdG5Nb2RlO1xuICB9XG5cbiAgLy8qKiogY29weSB0aGUgcmVzdCAqKiovL1xuICBPYmplY3Qua2V5cyhpbk9wdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChpbk9wdHNba2V5XSAhPT0gdW5kZWZpbmVkICYmIGhhc1Byb3BlcnR5KGRlZmF1bHRPcHRpb25zLCBrZXkpKSB7XG4gICAgICBjb25maWdba2V5XSA9IGluT3B0c1trZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb25maWc7XG59XG5cbnZhciBwaWNrZXJUZW1wbGF0ZSA9IG9wdGltaXplVGVtcGxhdGVIVE1MKFwiPGRpdiBjbGFzcz1cXFwiZGF0ZXBpY2tlciBoaWRkZW5cXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiZGF0ZXBpY2tlci1waWNrZXIgaW5saW5lLWJsb2NrIHJvdW5kZWQtbGcgYmctd2hpdGUgZGFyazpiZy1ncmF5LTcwMCBzaGFkb3ctbGcgcC00XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZGF0ZXBpY2tlci1oZWFkZXJcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImRhdGVwaWNrZXItdGl0bGUgYmctd2hpdGUgZGFyazpiZy1ncmF5LTcwMCBkYXJrOnRleHQtd2hpdGUgcHgtMiBweS0zIHRleHQtY2VudGVyIGZvbnQtc2VtaWJvbGRcXFwiPjwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImRhdGVwaWNrZXItY29udHJvbHMgZmxleCBqdXN0aWZ5LWJldHdlZW4gbWItMlxcXCI+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJnLXdoaXRlIGRhcms6YmctZ3JheS03MDAgcm91bmRlZC1sZyB0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC13aGl0ZSBob3ZlcjpiZy1ncmF5LTEwMCBkYXJrOmhvdmVyOmJnLWdyYXktNjAwIGhvdmVyOnRleHQtZ3JheS05MDAgZGFyazpob3Zlcjp0ZXh0LXdoaXRlIHRleHQtbGcgcC0yLjUgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktMjAwIHByZXYtYnRuXFxcIj48L2J1dHRvbj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwidGV4dC1zbSByb3VuZGVkLWxnIHRleHQtZ3JheS05MDAgZGFyazp0ZXh0LXdoaXRlIGJnLXdoaXRlIGRhcms6YmctZ3JheS03MDAgZm9udC1zZW1pYm9sZCBweS0yLjUgcHgtNSBob3ZlcjpiZy1ncmF5LTEwMCBkYXJrOmhvdmVyOmJnLWdyYXktNjAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ncmF5LTIwMCB2aWV3LXN3aXRjaFxcXCI+PC9idXR0b24+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJnLXdoaXRlIGRhcms6YmctZ3JheS03MDAgcm91bmRlZC1sZyB0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC13aGl0ZSBob3ZlcjpiZy1ncmF5LTEwMCBkYXJrOmhvdmVyOmJnLWdyYXktNjAwIGhvdmVyOnRleHQtZ3JheS05MDAgZGFyazpob3Zlcjp0ZXh0LXdoaXRlIHRleHQtbGcgcC0yLjUgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktMjAwIG5leHQtYnRuXFxcIj48L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImRhdGVwaWNrZXItbWFpbiBwLTFcXFwiPjwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJkYXRlcGlja2VyLWZvb3RlclxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiZGF0ZXBpY2tlci1jb250cm9scyBmbGV4IHNwYWNlLXgtMiBydGw6c3BhY2UteC1yZXZlcnNlIG10LTJcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCIlYnV0dG9uQ2xhc3MlIHRvZGF5LWJ0biB0ZXh0LXdoaXRlIGJnLWJsdWUtNzAwICFiZy1wcmltYXJ5LTcwMCBkYXJrOmJnLWJsdWUtNjAwIGRhcms6IWJnLXByaW1hcnktNjAwIGhvdmVyOmJnLWJsdWUtODAwIGhvdmVyOiFiZy1wcmltYXJ5LTgwMCBkYXJrOmhvdmVyOmJnLWJsdWUtNzAwIGRhcms6aG92ZXI6IWJnLXByaW1hcnktNzAwIGZvY3VzOnJpbmctNCBmb2N1czpyaW5nLWJsdWUtMzAwIGZvY3VzOiFyaW5nLXByaW1hcnktMzAwIGZvbnQtbWVkaXVtIHJvdW5kZWQtbGcgdGV4dC1zbSBweC01IHB5LTIgdGV4dC1jZW50ZXIgdy0xLzJcXFwiPjwvYnV0dG9uPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCIlYnV0dG9uQ2xhc3MlIGNsZWFyLWJ0biB0ZXh0LWdyYXktOTAwIGRhcms6dGV4dC13aGl0ZSBiZy13aGl0ZSBkYXJrOmJnLWdyYXktNzAwIGJvcmRlciBib3JkZXItZ3JheS0zMDAgZGFyazpib3JkZXItZ3JheS02MDAgaG92ZXI6YmctZ3JheS0xMDAgZGFyazpob3ZlcjpiZy1ncmF5LTYwMCBmb2N1czpyaW5nLTQgZm9jdXM6cmluZy1ibHVlLTMwMCBmb2N1czohcmluZy1wcmltYXJ5LTMwMCBmb250LW1lZGl1bSByb3VuZGVkLWxnIHRleHQtc20gcHgtNSBweS0yIHRleHQtY2VudGVyIHctMS8yXFxcIj48L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L2Rpdj5cIik7XG5cbnZhciBkYXlzVGVtcGxhdGUgPSBvcHRpbWl6ZVRlbXBsYXRlSFRNTChcIjxkaXYgY2xhc3M9XFxcImRheXNcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiZGF5cy1vZi13ZWVrIGdyaWQgZ3JpZC1jb2xzLTcgbWItMVxcXCI+XCIuY29uY2F0KGNyZWF0ZVRhZ1JlcGVhdCgnc3BhbicsIDcsIHtcbiAgXCJjbGFzc1wiOiAnZG93IGJsb2NrIGZsZXgtMSBsZWFkaW5nLTkgYm9yZGVyLTAgcm91bmRlZC1sZyBjdXJzb3ItZGVmYXVsdCB0ZXh0LWNlbnRlciB0ZXh0LWdyYXktOTAwIGZvbnQtc2VtaWJvbGQgdGV4dC1zbSdcbn0pLCBcIjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiZGF0ZXBpY2tlci1ncmlkIHctNjQgZ3JpZCBncmlkLWNvbHMtN1xcXCI+XCIpLmNvbmNhdChjcmVhdGVUYWdSZXBlYXQoJ3NwYW4nLCA0Miwge1xuICBcImNsYXNzXCI6ICdibG9jayBmbGV4LTEgbGVhZGluZy05IGJvcmRlci0wIHJvdW5kZWQtbGcgY3Vyc29yLWRlZmF1bHQgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTkwMCBmb250LXNlbWlib2xkIHRleHQtc20gaC02IGxlYWRpbmctNiB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS01MDAgZGFyazp0ZXh0LWdyYXktNDAwJ1xufSksIFwiPC9kaXY+XFxuPC9kaXY+XCIpKTtcblxudmFyIGNhbGVuZGFyV2Vla3NUZW1wbGF0ZSA9IG9wdGltaXplVGVtcGxhdGVIVE1MKFwiPGRpdiBjbGFzcz1cXFwiY2FsZW5kYXItd2Vla3NcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiZGF5cy1vZi13ZWVrIGZsZXhcXFwiPjxzcGFuIGNsYXNzPVxcXCJkb3cgaC02IGxlYWRpbmctNiB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS01MDAgZGFyazp0ZXh0LWdyYXktNDAwXFxcIj48L3NwYW4+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJ3ZWVrc1xcXCI+XCIuY29uY2F0KGNyZWF0ZVRhZ1JlcGVhdCgnc3BhbicsIDYsIHtcbiAgXCJjbGFzc1wiOiAnd2VlayBibG9jayBmbGV4LTEgbGVhZGluZy05IGJvcmRlci0wIHJvdW5kZWQtbGcgY3Vyc29yLWRlZmF1bHQgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTkwMCBmb250LXNlbWlib2xkIHRleHQtc20nXG59KSwgXCI8L2Rpdj5cXG48L2Rpdj5cIikpO1xuXG4vLyBCYXNlIGNsYXNzIG9mIHRoZSB2aWV3IGNsYXNzZXNcbnZhciBWaWV3ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmlldyhwaWNrZXIsIGNvbmZpZykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWV3KTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNvbmZpZywge1xuICAgICAgcGlja2VyOiBwaWNrZXIsXG4gICAgICBlbGVtZW50OiBwYXJzZUhUTUwoXCI8ZGl2IGNsYXNzPVxcXCJkYXRlcGlja2VyLXZpZXcgZmxleFxcXCI+PC9kaXY+XCIpLmZpcnN0Q2hpbGQsXG4gICAgICBzZWxlY3RlZDogW11cbiAgICB9KTtcbiAgICB0aGlzLmluaXQodGhpcy5waWNrZXIuZGF0ZXBpY2tlci5jb25maWcpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVmlldywgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLnBpY2tMZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaXNNaW5WaWV3ID0gdGhpcy5pZCA9PT0gb3B0aW9ucy5waWNrTGV2ZWw7XG4gICAgICB9XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLnVwZGF0ZUZvY3VzKCk7XG4gICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgIH1cblxuICAgIC8vIEV4ZWN1dGUgYmVmb3JlU2hvdygpIGNhbGxiYWNrIGFuZCBhcHBseSB0aGUgcmVzdWx0IHRvIHRoZSBlbGVtZW50XG4gICAgLy8gYXJnczpcbiAgICAvLyAtIGN1cnJlbnQgLSBjdXJyZW50IHZhbHVlIG9uIHRoZSBpdGVyYXRpb24gb24gdmlldyByZW5kZXJpbmdcbiAgICAvLyAtIHRpbWVWYWx1ZSAtIHRpbWUgdmFsdWUgb2YgdGhlIGRhdGUgdG8gcGFzcyB0byBiZWZvcmVTaG93KClcbiAgfSwge1xuICAgIGtleTogXCJwZXJmb3JtQmVmb3JlSG9va1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwZXJmb3JtQmVmb3JlSG9vayhlbCwgY3VycmVudCwgdGltZVZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5iZWZvcmVTaG93KG5ldyBEYXRlKHRpbWVWYWx1ZSkpO1xuICAgICAgc3dpdGNoIChfdHlwZW9mKHJlc3VsdCkpIHtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgZW5hYmxlZDogcmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICBjbGFzc2VzOiByZXN1bHRcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0LmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnKTtcbiAgICAgICAgICBwdXNoVW5pcXVlKHRoaXMuZGlzYWJsZWQsIGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuY2xhc3Nlcykge1xuICAgICAgICAgIHZhciBfZWwkY2xhc3NMaXN0O1xuICAgICAgICAgIHZhciBleHRyYUNsYXNzZXMgPSByZXN1bHQuY2xhc3Nlcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgIChfZWwkY2xhc3NMaXN0ID0gZWwuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2VsJGNsYXNzTGlzdCwgX3RvQ29uc3VtYWJsZUFycmF5KGV4dHJhQ2xhc3NlcykpO1xuICAgICAgICAgIGlmIChleHRyYUNsYXNzZXMuaW5jbHVkZXMoJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgICAgIHB1c2hVbmlxdWUodGhpcy5kaXNhYmxlZCwgY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuY29udGVudCkge1xuICAgICAgICAgIHJlcGxhY2VDaGlsZE5vZGVzKGVsLCByZXN1bHQuY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIERheXNWaWV3ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVmlldykge1xuICBmdW5jdGlvbiBEYXlzVmlldyhwaWNrZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF5c1ZpZXcpO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIERheXNWaWV3LCBbcGlja2VyLCB7XG4gICAgICBpZDogMCxcbiAgICAgIG5hbWU6ICdkYXlzJyxcbiAgICAgIGNlbGxDbGFzczogJ2RheSdcbiAgICB9XSk7XG4gIH1cbiAgX2luaGVyaXRzKERheXNWaWV3LCBfVmlldyk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRGF5c1ZpZXcsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgICB2YXIgb25Db25zdHJ1Y3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICBpZiAob25Db25zdHJ1Y3Rpb24pIHtcbiAgICAgICAgdmFyIGlubmVyID0gcGFyc2VIVE1MKGRheXNUZW1wbGF0ZSkuZmlyc3RDaGlsZDtcbiAgICAgICAgdGhpcy5kb3cgPSBpbm5lci5maXJzdENoaWxkO1xuICAgICAgICB0aGlzLmdyaWQgPSBpbm5lci5sYXN0Q2hpbGQ7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChpbm5lcik7XG4gICAgICB9XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihEYXlzVmlldy5wcm90b3R5cGUpLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgdXBkYXRlRE9XO1xuICAgICAgaWYgKGhhc1Byb3BlcnR5KG9wdGlvbnMsICdtaW5EYXRlJykpIHtcbiAgICAgICAgdGhpcy5taW5EYXRlID0gb3B0aW9ucy5taW5EYXRlO1xuICAgICAgfVxuICAgICAgaWYgKGhhc1Byb3BlcnR5KG9wdGlvbnMsICdtYXhEYXRlJykpIHtcbiAgICAgICAgdGhpcy5tYXhEYXRlID0gb3B0aW9ucy5tYXhEYXRlO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZGF0ZXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRhdGVzRGlzYWJsZWQgPSBvcHRpb25zLmRhdGVzRGlzYWJsZWQ7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5kYXlzT2ZXZWVrRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kYXlzT2ZXZWVrRGlzYWJsZWQgPSBvcHRpb25zLmRheXNPZldlZWtEaXNhYmxlZDtcbiAgICAgICAgdXBkYXRlRE9XID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmRheXNPZldlZWtIaWdobGlnaHRlZCkge1xuICAgICAgICB0aGlzLmRheXNPZldlZWtIaWdobGlnaHRlZCA9IG9wdGlvbnMuZGF5c09mV2Vla0hpZ2hsaWdodGVkO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudG9kYXlIaWdobGlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRvZGF5SGlnaGxpZ2h0ID0gb3B0aW9ucy50b2RheUhpZ2hsaWdodDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLndlZWtTdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMud2Vla1N0YXJ0ID0gb3B0aW9ucy53ZWVrU3RhcnQ7XG4gICAgICAgIHRoaXMud2Vla0VuZCA9IG9wdGlvbnMud2Vla0VuZDtcbiAgICAgICAgdXBkYXRlRE9XID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmxvY2FsZSkge1xuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5sb2NhbGUgPSBvcHRpb25zLmxvY2FsZTtcbiAgICAgICAgdGhpcy5kYXlOYW1lcyA9IGxvY2FsZS5kYXlzTWluO1xuICAgICAgICB0aGlzLnN3aXRjaExhYmVsRm9ybWF0ID0gbG9jYWxlLnRpdGxlRm9ybWF0O1xuICAgICAgICB1cGRhdGVET1cgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYmVmb3JlU2hvd0RheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYmVmb3JlU2hvdyA9IHR5cGVvZiBvcHRpb25zLmJlZm9yZVNob3dEYXkgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmJlZm9yZVNob3dEYXkgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5jYWxlbmRhcldlZWtzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2FsZW5kYXJXZWVrcyAmJiAhdGhpcy5jYWxlbmRhcldlZWtzKSB7XG4gICAgICAgICAgdmFyIHdlZWtzRWxlbSA9IHBhcnNlSFRNTChjYWxlbmRhcldlZWtzVGVtcGxhdGUpLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgdGhpcy5jYWxlbmRhcldlZWtzID0ge1xuICAgICAgICAgICAgZWxlbWVudDogd2Vla3NFbGVtLFxuICAgICAgICAgICAgZG93OiB3ZWVrc0VsZW0uZmlyc3RDaGlsZCxcbiAgICAgICAgICAgIHdlZWtzOiB3ZWVrc0VsZW0ubGFzdENoaWxkXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKHdlZWtzRWxlbSwgdGhpcy5lbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2FsZW5kYXJXZWVrcyAmJiAhb3B0aW9ucy5jYWxlbmRhcldlZWtzKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuY2FsZW5kYXJXZWVrcy5lbGVtZW50KTtcbiAgICAgICAgICB0aGlzLmNhbGVuZGFyV2Vla3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zaG93RGF5c09mV2VlayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNob3dEYXlzT2ZXZWVrKSB7XG4gICAgICAgICAgc2hvd0VsZW1lbnQodGhpcy5kb3cpO1xuICAgICAgICAgIGlmICh0aGlzLmNhbGVuZGFyV2Vla3MpIHtcbiAgICAgICAgICAgIHNob3dFbGVtZW50KHRoaXMuY2FsZW5kYXJXZWVrcy5kb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWRlRWxlbWVudCh0aGlzLmRvdyk7XG4gICAgICAgICAgaWYgKHRoaXMuY2FsZW5kYXJXZWVrcykge1xuICAgICAgICAgICAgaGlkZUVsZW1lbnQodGhpcy5jYWxlbmRhcldlZWtzLmRvdyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSBkYXlzLW9mLXdlZWsgd2hlbiBsb2NhbGUsIGRheXNPZndlZWtEaXNhYmxlZCBvciB3ZWVrU3RhcnQgaXMgY2hhbmdlZFxuICAgICAgaWYgKHVwZGF0ZURPVykge1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMuZG93LmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgZG93ID0gKF90aGlzLndlZWtTdGFydCArIGluZGV4KSAlIDc7XG4gICAgICAgICAgZWwudGV4dENvbnRlbnQgPSBfdGhpcy5kYXlOYW1lc1tkb3ddO1xuICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IF90aGlzLmRheXNPZldlZWtEaXNhYmxlZC5pbmNsdWRlcyhkb3cpID8gJ2RvdyBkaXNhYmxlZCB0ZXh0LWNlbnRlciBoLTYgbGVhZGluZy02IHRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1ncmF5LTUwMCBkYXJrOnRleHQtZ3JheS00MDAgY3Vyc29yLW5vdC1hbGxvd2VkJyA6ICdkb3cgdGV4dC1jZW50ZXIgaC02IGxlYWRpbmctNiB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS01MDAgZGFyazp0ZXh0LWdyYXktNDAwJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgdXBkYXRlIG9uIHRoZSBmb2N1c2VkIGRhdGUgdG8gdmlldydzIHNldHRpbmdzXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRm9jdXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRm9jdXMoKSB7XG4gICAgICB2YXIgdmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLnBpY2tlci52aWV3RGF0ZSk7XG4gICAgICB2YXIgdmlld1llYXIgPSB2aWV3RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgdmFyIHZpZXdNb250aCA9IHZpZXdEYXRlLmdldE1vbnRoKCk7XG4gICAgICB2YXIgZmlyc3RPZk1vbnRoID0gZGF0ZVZhbHVlKHZpZXdZZWFyLCB2aWV3TW9udGgsIDEpO1xuICAgICAgdmFyIHN0YXJ0ID0gZGF5T2ZUaGVXZWVrT2YoZmlyc3RPZk1vbnRoLCB0aGlzLndlZWtTdGFydCwgdGhpcy53ZWVrU3RhcnQpO1xuICAgICAgdGhpcy5maXJzdCA9IGZpcnN0T2ZNb250aDtcbiAgICAgIHRoaXMubGFzdCA9IGRhdGVWYWx1ZSh2aWV3WWVhciwgdmlld01vbnRoICsgMSwgMCk7XG4gICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICB0aGlzLmZvY3VzZWQgPSB0aGlzLnBpY2tlci52aWV3RGF0ZTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSB1cGRhdGUgb24gdGhlIHNlbGVjdGVkIGRhdGVzIHRvIHZpZXcncyBzZXR0aW5nc1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMkcGlja2VyJGRhdGVwaWNrID0gdGhpcy5waWNrZXIuZGF0ZXBpY2tlcixcbiAgICAgICAgZGF0ZXMgPSBfdGhpcyRwaWNrZXIkZGF0ZXBpY2suZGF0ZXMsXG4gICAgICAgIHJhbmdlcGlja2VyID0gX3RoaXMkcGlja2VyJGRhdGVwaWNrLnJhbmdlcGlja2VyO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGRhdGVzO1xuICAgICAgaWYgKHJhbmdlcGlja2VyKSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZXBpY2tlci5kYXRlcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIGVudGlyZSB2aWV3IFVJXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgLy8gdXBkYXRlIHRvZGF5IG1hcmtlciBvbiBldmVyIHJlbmRlclxuICAgICAgdGhpcy50b2RheSA9IHRoaXMudG9kYXlIaWdobGlnaHQgPyB0b2RheSgpIDogdW5kZWZpbmVkO1xuICAgICAgLy8gcmVmcmVzaCBkaXNhYmxlZCBkYXRlcyBvbiBldmVyeSByZW5kZXIgaW4gb3JkZXIgdG8gY2xlYXIgdGhlIG9uZXMgYWRkZWRcbiAgICAgIC8vIGJ5IGJlZm9yZVNob3cgaG9vayBhdCBwcmV2aW91cyByZW5kZXJcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5kYXRlc0Rpc2FibGVkKTtcbiAgICAgIHZhciBzd2l0Y2hMYWJlbCA9IGZvcm1hdERhdGUodGhpcy5mb2N1c2VkLCB0aGlzLnN3aXRjaExhYmVsRm9ybWF0LCB0aGlzLmxvY2FsZSk7XG4gICAgICB0aGlzLnBpY2tlci5zZXRWaWV3U3dpdGNoTGFiZWwoc3dpdGNoTGFiZWwpO1xuICAgICAgdGhpcy5waWNrZXIuc2V0UHJldkJ0bkRpc2FibGVkKHRoaXMuZmlyc3QgPD0gdGhpcy5taW5EYXRlKTtcbiAgICAgIHRoaXMucGlja2VyLnNldE5leHRCdG5EaXNhYmxlZCh0aGlzLmxhc3QgPj0gdGhpcy5tYXhEYXRlKTtcbiAgICAgIGlmICh0aGlzLmNhbGVuZGFyV2Vla3MpIHtcbiAgICAgICAgLy8gc3RhcnQgb2YgdGhlIFVUQyB3ZWVrIChNb25kYXkpIG9mIHRoZSAxc3Qgb2YgdGhlIG1vbnRoXG4gICAgICAgIHZhciBzdGFydE9mV2VlayA9IGRheU9mVGhlV2Vla09mKHRoaXMuZmlyc3QsIDEsIDEpO1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMuY2FsZW5kYXJXZWVrcy53ZWVrcy5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGluZGV4KSB7XG4gICAgICAgICAgZWwudGV4dENvbnRlbnQgPSBnZXRXZWVrKGFkZFdlZWtzKHN0YXJ0T2ZXZWVrLCBpbmRleCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIEFycmF5LmZyb20odGhpcy5ncmlkLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBhZGREYXlzKF90aGlzMi5zdGFydCwgaW5kZXgpO1xuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKGN1cnJlbnQpO1xuICAgICAgICB2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gXCJkYXRlcGlja2VyLWNlbGwgaG92ZXI6YmctZ3JheS0xMDAgZGFyazpob3ZlcjpiZy1ncmF5LTYwMCBibG9jayBmbGV4LTEgbGVhZGluZy05IGJvcmRlci0wIHJvdW5kZWQtbGcgY3Vyc29yLXBvaW50ZXIgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTkwMCBkYXJrOnRleHQtd2hpdGUgZm9udC1zZW1pYm9sZCB0ZXh0LXNtIFwiLmNvbmNhdChfdGhpczIuY2VsbENsYXNzKTtcbiAgICAgICAgZWwuZGF0YXNldC5kYXRlID0gY3VycmVudDtcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSBkYXRlLmdldERhdGUoKTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPCBfdGhpczIuZmlyc3QpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdwcmV2JywgJ3RleHQtZ3JheS01MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudCA+IF90aGlzMi5sYXN0KSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgnbmV4dCcsICd0ZXh0LWdyYXktNTAwJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczIudG9kYXkgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCd0b2RheScsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPCBfdGhpczIubWluRGF0ZSB8fCBjdXJyZW50ID4gX3RoaXMyLm1heERhdGUgfHwgX3RoaXMyLmRpc2FibGVkLmluY2x1ZGVzKGN1cnJlbnQpKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnLCAnY3Vyc29yLW5vdC1hbGxvd2VkJywgJ3RleHQtZ3JheS00MDAnLCAnZGFyazp0ZXh0LWdyYXktNTAwJyk7XG4gICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgnaG92ZXI6YmctZ3JheS0xMDAnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcsICd0ZXh0LWdyYXktOTAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdjdXJzb3ItcG9pbnRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczIuZGF5c09mV2Vla0Rpc2FibGVkLmluY2x1ZGVzKGRheSkpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcsICdjdXJzb3Itbm90LWFsbG93ZWQnLCAndGV4dC1ncmF5LTQwMCcsICdkYXJrOnRleHQtZ3JheS01MDAnKTtcbiAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOmhvdmVyOmJnLWdyYXktNjAwJywgJ3RleHQtZ3JheS05MDAnLCAnZGFyazp0ZXh0LXdoaXRlJywgJ2N1cnNvci1wb2ludGVyJyk7XG4gICAgICAgICAgcHVzaFVuaXF1ZShfdGhpczIuZGlzYWJsZWQsIGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczIuZGF5c09mV2Vla0hpZ2hsaWdodGVkLmluY2x1ZGVzKGRheSkpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdoaWdobGlnaHRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczIucmFuZ2UpIHtcbiAgICAgICAgICB2YXIgX3RoaXMyJHJhbmdlID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMyLnJhbmdlLCAyKSxcbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSBfdGhpczIkcmFuZ2VbMF0sXG4gICAgICAgICAgICByYW5nZUVuZCA9IF90aGlzMiRyYW5nZVsxXTtcbiAgICAgICAgICBpZiAoY3VycmVudCA+IHJhbmdlU3RhcnQgJiYgY3VycmVudCA8IHJhbmdlRW5kKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZScsICdiZy1ncmF5LTIwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XG4gICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCdyb3VuZGVkLWxnJywgJ3JvdW5kZWQtbC1sZycsICdyb3VuZGVkLXItbGcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLXN0YXJ0JywgJ2JnLWdyYXktMTAwJywgJ2Rhcms6YmctZ3JheS02MDAnLCAncm91bmRlZC1sLWxnJyk7XG4gICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCdyb3VuZGVkLWxnJywgJ3JvdW5kZWQtci1sZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gcmFuZ2VFbmQpIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLWVuZCcsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJywgJ3JvdW5kZWQtci1sZycpO1xuICAgICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgncm91bmRlZC1sZycsICdyb3VuZGVkLWwtbGcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzMi5zZWxlY3RlZC5pbmNsdWRlcyhjdXJyZW50KSkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJyFiZy1wcmltYXJ5LTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazohYmctcHJpbWFyeS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XG4gICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICd0ZXh0LWdyYXktNTAwJywgJ2hvdmVyOmJnLWdyYXktMTAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdkYXJrOmhvdmVyOmJnLWdyYXktNjAwJywgJ2Rhcms6YmctZ3JheS02MDAnLCAnYmctZ3JheS0xMDAnLCAnYmctZ3JheS0yMDAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCA9PT0gX3RoaXMyLmZvY3VzZWQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzMi5iZWZvcmVTaG93KSB7XG4gICAgICAgICAgX3RoaXMyLnBlcmZvcm1CZWZvcmVIb29rKGVsLCBjdXJyZW50LCBjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSB2aWV3IFVJIGJ5IGFwcGx5aW5nIHRoZSBjaGFuZ2VzIG9mIHNlbGVjdGVkIGFuZCBmb2N1c2VkIGl0ZW1zXG4gIH0sIHtcbiAgICBrZXk6IFwicmVmcmVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgX3JlZiA9IHRoaXMucmFuZ2UgfHwgW10sXG4gICAgICAgIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgIHJhbmdlU3RhcnQgPSBfcmVmMlswXSxcbiAgICAgICAgcmFuZ2VFbmQgPSBfcmVmMlsxXTtcbiAgICAgIHRoaXMuZ3JpZC5xdWVyeVNlbGVjdG9yQWxsKCcucmFuZ2UsIC5yYW5nZS1zdGFydCwgLnJhbmdlLWVuZCwgLnNlbGVjdGVkLCAuZm9jdXNlZCcpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3JhbmdlJywgJ3JhbmdlLXN0YXJ0JywgJ3JhbmdlLWVuZCcsICdzZWxlY3RlZCcsICdiZy1ibHVlLTcwMCcsICchYmctcHJpbWFyeS03MDAnLCAndGV4dC13aGl0ZScsICdkYXJrOmJnLWJsdWUtNjAwJywgJ2Rhcms6IWJnLXByaW1hcnktNjAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdmb2N1c2VkJyk7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ3RleHQtZ3JheS05MDAnLCAncm91bmRlZC1sZycsICdkYXJrOnRleHQtd2hpdGUnKTtcbiAgICAgIH0pO1xuICAgICAgQXJyYXkuZnJvbSh0aGlzLmdyaWQuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gTnVtYmVyKGVsLmRhdGFzZXQuZGF0ZSk7XG4gICAgICAgIHZhciBjbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3Q7XG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ2JnLWdyYXktMjAwJywgJ2Rhcms6YmctZ3JheS02MDAnLCAncm91bmRlZC1sLWxnJywgJ3JvdW5kZWQtci1sZycpO1xuICAgICAgICBpZiAoY3VycmVudCA+IHJhbmdlU3RhcnQgJiYgY3VycmVudCA8IHJhbmdlRW5kKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UnLCAnYmctZ3JheS0yMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcpO1xuICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3JvdW5kZWQtbGcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCA9PT0gcmFuZ2VTdGFydCkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLXN0YXJ0JywgJ2JnLWdyYXktMjAwJywgJ2Rhcms6YmctZ3JheS02MDAnLCAncm91bmRlZC1sLWxnJyk7XG4gICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgncm91bmRlZC1sZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZUVuZCkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLWVuZCcsICdiZy1ncmF5LTIwMCcsICdkYXJrOmJnLWdyYXktNjAwJywgJ3JvdW5kZWQtci1sZycpO1xuICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3JvdW5kZWQtbGcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMzLnNlbGVjdGVkLmluY2x1ZGVzKGN1cnJlbnQpKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAnIWJnLXByaW1hcnktNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrOiFiZy1wcmltYXJ5LTYwMCcsICdkYXJrOnRleHQtd2hpdGUnKTtcbiAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LWdyYXktOTAwJywgJ2hvdmVyOmJnLWdyYXktMTAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdkYXJrOmhvdmVyOmJnLWdyYXktNjAwJywgJ2JnLWdyYXktMTAwJywgJ2JnLWdyYXktMjAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCA9PT0gX3RoaXMzLmZvY3VzZWQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgdmlldyBVSSBieSBhcHBseWluZyB0aGUgY2hhbmdlIG9mIGZvY3VzZWQgaXRlbVxuICB9LCB7XG4gICAga2V5OiBcInJlZnJlc2hGb2N1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoRm9jdXMoKSB7XG4gICAgICB2YXIgaW5kZXggPSBNYXRoLnJvdW5kKCh0aGlzLmZvY3VzZWQgLSB0aGlzLnN0YXJ0KSAvIDg2NDAwMDAwKTtcbiAgICAgIHRoaXMuZ3JpZC5xdWVyeVNlbGVjdG9yQWxsKCcuZm9jdXNlZCcpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2ZvY3VzZWQnKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ncmlkLmNoaWxkcmVuW2luZGV4XS5jbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG4gICAgfVxuICB9XSk7XG59KFZpZXcpO1xuXG5mdW5jdGlvbiBjb21wdXRlTW9udGhSYW5nZShyYW5nZSwgdGhpc1llYXIpIHtcbiAgaWYgKCFyYW5nZSB8fCAhcmFuZ2VbMF0gfHwgIXJhbmdlWzFdKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBfcmFuZ2UgPSBfc2xpY2VkVG9BcnJheShyYW5nZSwgMiksXG4gICAgX3JhbmdlJCA9IF9zbGljZWRUb0FycmF5KF9yYW5nZVswXSwgMiksXG4gICAgc3RhcnRZID0gX3JhbmdlJFswXSxcbiAgICBzdGFydE0gPSBfcmFuZ2UkWzFdLFxuICAgIF9yYW5nZSQyID0gX3NsaWNlZFRvQXJyYXkoX3JhbmdlWzFdLCAyKSxcbiAgICBlbmRZID0gX3JhbmdlJDJbMF0sXG4gICAgZW5kTSA9IF9yYW5nZSQyWzFdO1xuICBpZiAoc3RhcnRZID4gdGhpc1llYXIgfHwgZW5kWSA8IHRoaXNZZWFyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBbc3RhcnRZID09PSB0aGlzWWVhciA/IHN0YXJ0TSA6IC0xLCBlbmRZID09PSB0aGlzWWVhciA/IGVuZE0gOiAxMl07XG59XG52YXIgTW9udGhzVmlldyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1ZpZXcpIHtcbiAgZnVuY3Rpb24gTW9udGhzVmlldyhwaWNrZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9udGhzVmlldyk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgTW9udGhzVmlldywgW3BpY2tlciwge1xuICAgICAgaWQ6IDEsXG4gICAgICBuYW1lOiAnbW9udGhzJyxcbiAgICAgIGNlbGxDbGFzczogJ21vbnRoJ1xuICAgIH1dKTtcbiAgfVxuICBfaW5oZXJpdHMoTW9udGhzVmlldywgX1ZpZXcpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKE1vbnRoc1ZpZXcsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgICB2YXIgb25Db25zdHJ1Y3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICBpZiAob25Db25zdHJ1Y3Rpb24pIHtcbiAgICAgICAgdGhpcy5ncmlkID0gdGhpcy5lbGVtZW50O1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbW9udGhzJywgJ2RhdGVwaWNrZXItZ3JpZCcsICd3LTY0JywgJ2dyaWQnLCAnZ3JpZC1jb2xzLTQnKTtcbiAgICAgICAgdGhpcy5ncmlkLmFwcGVuZENoaWxkKHBhcnNlSFRNTChjcmVhdGVUYWdSZXBlYXQoJ3NwYW4nLCAxMiwge1xuICAgICAgICAgICdkYXRhLW1vbnRoJzogZnVuY3Rpb24gZGF0YU1vbnRoKGl4KSB7XG4gICAgICAgICAgICByZXR1cm4gaXg7XG4gICAgICAgICAgfVxuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTW9udGhzVmlldy5wcm90b3R5cGUpLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLmxvY2FsZSkge1xuICAgICAgICB0aGlzLm1vbnRoTmFtZXMgPSBvcHRpb25zLmxvY2FsZS5tb250aHNTaG9ydDtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWluRGF0ZScpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm1pbkRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMubWluWWVhciA9IHRoaXMubWluTW9udGggPSB0aGlzLm1pbkRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1pbkRhdGVPYmogPSBuZXcgRGF0ZShvcHRpb25zLm1pbkRhdGUpO1xuICAgICAgICAgIHRoaXMubWluWWVhciA9IG1pbkRhdGVPYmouZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICB0aGlzLm1pbk1vbnRoID0gbWluRGF0ZU9iai5nZXRNb250aCgpO1xuICAgICAgICAgIHRoaXMubWluRGF0ZSA9IG1pbkRhdGVPYmouc2V0RGF0ZSgxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc1Byb3BlcnR5KG9wdGlvbnMsICdtYXhEYXRlJykpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubWF4RGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5tYXhZZWFyID0gdGhpcy5tYXhNb250aCA9IHRoaXMubWF4RGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWF4RGF0ZU9iaiA9IG5ldyBEYXRlKG9wdGlvbnMubWF4RGF0ZSk7XG4gICAgICAgICAgdGhpcy5tYXhZZWFyID0gbWF4RGF0ZU9iai5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgIHRoaXMubWF4TW9udGggPSBtYXhEYXRlT2JqLmdldE1vbnRoKCk7XG4gICAgICAgICAgdGhpcy5tYXhEYXRlID0gZGF0ZVZhbHVlKHRoaXMubWF4WWVhciwgdGhpcy5tYXhNb250aCArIDEsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5iZWZvcmVTaG93TW9udGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJlZm9yZVNob3cgPSB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTaG93TW9udGggPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmJlZm9yZVNob3dNb250aCA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdmlldydzIHNldHRpbmdzIHRvIHJlZmxlY3QgdGhlIHZpZXdEYXRlIHNldCBvbiB0aGUgcGlja2VyXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRm9jdXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRm9jdXMoKSB7XG4gICAgICB2YXIgdmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLnBpY2tlci52aWV3RGF0ZSk7XG4gICAgICB0aGlzLnllYXIgPSB2aWV3RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgdGhpcy5mb2N1c2VkID0gdmlld0RhdGUuZ2V0TW9udGgoKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdmlldydzIHNldHRpbmdzIHRvIHJlZmxlY3QgdGhlIHNlbGVjdGVkIGRhdGVzXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyRwaWNrZXIkZGF0ZXBpY2sgPSB0aGlzLnBpY2tlci5kYXRlcGlja2VyLFxuICAgICAgICBkYXRlcyA9IF90aGlzJHBpY2tlciRkYXRlcGljay5kYXRlcyxcbiAgICAgICAgcmFuZ2VwaWNrZXIgPSBfdGhpcyRwaWNrZXIkZGF0ZXBpY2sucmFuZ2VwaWNrZXI7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZGF0ZXMucmVkdWNlKGZ1bmN0aW9uIChzZWxlY3RlZCwgdGltZVZhbHVlKSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUodGltZVZhbHVlKTtcbiAgICAgICAgdmFyIHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIHZhciBtb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkW3llYXJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxlY3RlZFt5ZWFyXSA9IFttb250aF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaFVuaXF1ZShzZWxlY3RlZFt5ZWFyXSwgbW9udGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgIH0sIHt9KTtcbiAgICAgIGlmIChyYW5nZXBpY2tlciAmJiByYW5nZXBpY2tlci5kYXRlcykge1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VwaWNrZXIuZGF0ZXMubWFwKGZ1bmN0aW9uICh0aW1lVmFsdWUpIHtcbiAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWVWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGlzTmFOKGRhdGUpID8gdW5kZWZpbmVkIDogW2RhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBlbnRpcmUgdmlldyBVSVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgLy8gcmVmcmVzaCBkaXNhYmxlZCBtb250aHMgb24gZXZlcnkgcmVuZGVyIGluIG9yZGVyIHRvIGNsZWFyIHRoZSBvbmVzIGFkZGVkXG4gICAgICAvLyBieSBiZWZvcmVTaG93IGhvb2sgYXQgcHJldmlvdXMgcmVuZGVyXG4gICAgICB0aGlzLmRpc2FibGVkID0gW107XG4gICAgICB0aGlzLnBpY2tlci5zZXRWaWV3U3dpdGNoTGFiZWwodGhpcy55ZWFyKTtcbiAgICAgIHRoaXMucGlja2VyLnNldFByZXZCdG5EaXNhYmxlZCh0aGlzLnllYXIgPD0gdGhpcy5taW5ZZWFyKTtcbiAgICAgIHRoaXMucGlja2VyLnNldE5leHRCdG5EaXNhYmxlZCh0aGlzLnllYXIgPj0gdGhpcy5tYXhZZWFyKTtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRbdGhpcy55ZWFyXSB8fCBbXTtcbiAgICAgIHZhciB5ck91dE9mUmFuZ2UgPSB0aGlzLnllYXIgPCB0aGlzLm1pblllYXIgfHwgdGhpcy55ZWFyID4gdGhpcy5tYXhZZWFyO1xuICAgICAgdmFyIGlzTWluWWVhciA9IHRoaXMueWVhciA9PT0gdGhpcy5taW5ZZWFyO1xuICAgICAgdmFyIGlzTWF4WWVhciA9IHRoaXMueWVhciA9PT0gdGhpcy5tYXhZZWFyO1xuICAgICAgdmFyIHJhbmdlID0gY29tcHV0ZU1vbnRoUmFuZ2UodGhpcy5yYW5nZSwgdGhpcy55ZWFyKTtcbiAgICAgIEFycmF5LmZyb20odGhpcy5ncmlkLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcbiAgICAgICAgdmFyIGRhdGUgPSBkYXRlVmFsdWUoX3RoaXMueWVhciwgaW5kZXgsIDEpO1xuICAgICAgICBlbC5jbGFzc05hbWUgPSBcImRhdGVwaWNrZXItY2VsbCBob3ZlcjpiZy1ncmF5LTEwMCBkYXJrOmhvdmVyOmJnLWdyYXktNjAwIGJsb2NrIGZsZXgtMSBsZWFkaW5nLTkgYm9yZGVyLTAgcm91bmRlZC1sZyBjdXJzb3ItcG9pbnRlciB0ZXh0LWNlbnRlciB0ZXh0LWdyYXktOTAwIGRhcms6dGV4dC13aGl0ZSBmb250LXNlbWlib2xkIHRleHQtc20gXCIuY29uY2F0KF90aGlzLmNlbGxDbGFzcyk7XG4gICAgICAgIGlmIChfdGhpcy5pc01pblZpZXcpIHtcbiAgICAgICAgICBlbC5kYXRhc2V0LmRhdGUgPSBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc2V0IHRleHQgb24gZXZlcnkgcmVuZGVyIHRvIGNsZWFyIHRoZSBjdXN0b20gY29udGVudCBzZXRcbiAgICAgICAgLy8gYnkgYmVmb3JlU2hvdyBob29rIGF0IHByZXZpb3VzIHJlbmRlclxuICAgICAgICBlbC50ZXh0Q29udGVudCA9IF90aGlzLm1vbnRoTmFtZXNbaW5kZXhdO1xuICAgICAgICBpZiAoeXJPdXRPZlJhbmdlIHx8IGlzTWluWWVhciAmJiBpbmRleCA8IF90aGlzLm1pbk1vbnRoIHx8IGlzTWF4WWVhciAmJiBpbmRleCA+IF90aGlzLm1heE1vbnRoKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICB2YXIgX3JhbmdlMiA9IF9zbGljZWRUb0FycmF5KHJhbmdlLCAyKSxcbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSBfcmFuZ2UyWzBdLFxuICAgICAgICAgICAgcmFuZ2VFbmQgPSBfcmFuZ2UyWzFdO1xuICAgICAgICAgIGlmIChpbmRleCA+IHJhbmdlU3RhcnQgJiYgaW5kZXggPCByYW5nZUVuZCkge1xuICAgICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZGV4ID09PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1zdGFydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5kZXggPT09IHJhbmdlRW5kKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1lbmQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGVkLmluY2x1ZGVzKGluZGV4KSkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJyFiZy1wcmltYXJ5LTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazohYmctcHJpbWFyeS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XG4gICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA9PT0gX3RoaXMuZm9jdXNlZCkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMuYmVmb3JlU2hvdykge1xuICAgICAgICAgIF90aGlzLnBlcmZvcm1CZWZvcmVIb29rKGVsLCBpbmRleCwgZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgdmlldyBVSSBieSBhcHBseWluZyB0aGUgY2hhbmdlcyBvZiBzZWxlY3RlZCBhbmQgZm9jdXNlZCBpdGVtc1xuICB9LCB7XG4gICAga2V5OiBcInJlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIHNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZFt0aGlzLnllYXJdIHx8IFtdO1xuICAgICAgdmFyIF9yZWYgPSBjb21wdXRlTW9udGhSYW5nZSh0aGlzLnJhbmdlLCB0aGlzLnllYXIpIHx8IFtdLFxuICAgICAgICBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICByYW5nZVN0YXJ0ID0gX3JlZjJbMF0sXG4gICAgICAgIHJhbmdlRW5kID0gX3JlZjJbMV07XG4gICAgICB0aGlzLmdyaWQucXVlcnlTZWxlY3RvckFsbCgnLnJhbmdlLCAucmFuZ2Utc3RhcnQsIC5yYW5nZS1lbmQsIC5zZWxlY3RlZCwgLmZvY3VzZWQnKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdyYW5nZScsICdyYW5nZS1zdGFydCcsICdyYW5nZS1lbmQnLCAnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAnIWJnLXByaW1hcnktNzAwJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazohYmctcHJpbWFyeS03MDAnLCAnZGFyazp0ZXh0LXdoaXRlJywgJ3RleHQtd2hpdGUnLCAnZm9jdXNlZCcpO1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCd0ZXh0LWdyYXktOTAwJywgJ2hvdmVyOmJnLWdyYXktMTAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdkYXJrOmhvdmVyOmJnLWdyYXktNjAwJyk7XG4gICAgICB9KTtcbiAgICAgIEFycmF5LmZyb20odGhpcy5ncmlkLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcbiAgICAgICAgaWYgKGluZGV4ID4gcmFuZ2VTdGFydCAmJiBpbmRleCA8IHJhbmdlRW5kKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPT09IHJhbmdlU3RhcnQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1zdGFydCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA9PT0gcmFuZ2VFbmQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1lbmQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0ZWQuaW5jbHVkZXMoaW5kZXgpKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAnIWJnLXByaW1hcnktNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrOiFiZy1wcmltYXJ5LTYwMCcsICdkYXJrOnRleHQtd2hpdGUnKTtcbiAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LWdyYXktOTAwJywgJ2hvdmVyOmJnLWdyYXktMTAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdkYXJrOmhvdmVyOmJnLWdyYXktNjAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID09PSBfdGhpczIuZm9jdXNlZCkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSB2aWV3IFVJIGJ5IGFwcGx5aW5nIHRoZSBjaGFuZ2Ugb2YgZm9jdXNlZCBpdGVtXG4gIH0sIHtcbiAgICBrZXk6IFwicmVmcmVzaEZvY3VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2hGb2N1cygpIHtcbiAgICAgIHRoaXMuZ3JpZC5xdWVyeVNlbGVjdG9yQWxsKCcuZm9jdXNlZCcpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2ZvY3VzZWQnKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ncmlkLmNoaWxkcmVuW3RoaXMuZm9jdXNlZF0uY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcpO1xuICAgIH1cbiAgfV0pO1xufShWaWV3KTtcblxuZnVuY3Rpb24gdG9UaXRsZUNhc2Uod29yZCkge1xuICByZXR1cm4gX3RvQ29uc3VtYWJsZUFycmF5KHdvcmQpLnJlZHVjZShmdW5jdGlvbiAoc3RyLCBjaCwgaXgpIHtcbiAgICByZXR1cm4gc3RyICs9IGl4ID8gY2ggOiBjaC50b1VwcGVyQ2FzZSgpO1xuICB9LCAnJyk7XG59XG5cbi8vIENsYXNzIHJlcHJlc2VudGluZyB0aGUgeWVhcnMgYW5kIGRlY2FkZXMgdmlldyBlbGVtZW50c1xudmFyIFllYXJzVmlldyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1ZpZXcpIHtcbiAgZnVuY3Rpb24gWWVhcnNWaWV3KHBpY2tlciwgY29uZmlnKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFllYXJzVmlldyk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgWWVhcnNWaWV3LCBbcGlja2VyLCBjb25maWddKTtcbiAgfVxuICBfaW5oZXJpdHMoWWVhcnNWaWV3LCBfVmlldyk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoWWVhcnNWaWV3LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQob3B0aW9ucykge1xuICAgICAgdmFyIG9uQ29uc3RydWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgaWYgKG9uQ29uc3RydWN0aW9uKSB7XG4gICAgICAgIHRoaXMubmF2U3RlcCA9IHRoaXMuc3RlcCAqIDEwO1xuICAgICAgICB0aGlzLmJlZm9yZVNob3dPcHRpb24gPSBcImJlZm9yZVNob3dcIi5jb25jYXQodG9UaXRsZUNhc2UodGhpcy5jZWxsQ2xhc3MpKTtcbiAgICAgICAgdGhpcy5ncmlkID0gdGhpcy5lbGVtZW50O1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGlzLm5hbWUsICdkYXRlcGlja2VyLWdyaWQnLCAndy02NCcsICdncmlkJywgJ2dyaWQtY29scy00Jyk7XG4gICAgICAgIHRoaXMuZ3JpZC5hcHBlbmRDaGlsZChwYXJzZUhUTUwoY3JlYXRlVGFnUmVwZWF0KCdzcGFuJywgMTIpKSk7XG4gICAgICB9XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihZZWFyc1ZpZXcucHJvdG90eXBlKSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAoaGFzUHJvcGVydHkob3B0aW9ucywgJ21pbkRhdGUnKSkge1xuICAgICAgICBpZiAob3B0aW9ucy5taW5EYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm1pblllYXIgPSB0aGlzLm1pbkRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5taW5ZZWFyID0gc3RhcnRPZlllYXJQZXJpb2Qob3B0aW9ucy5taW5EYXRlLCB0aGlzLnN0ZXApO1xuICAgICAgICAgIHRoaXMubWluRGF0ZSA9IGRhdGVWYWx1ZSh0aGlzLm1pblllYXIsIDAsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzUHJvcGVydHkob3B0aW9ucywgJ21heERhdGUnKSkge1xuICAgICAgICBpZiAob3B0aW9ucy5tYXhEYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm1heFllYXIgPSB0aGlzLm1heERhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tYXhZZWFyID0gc3RhcnRPZlllYXJQZXJpb2Qob3B0aW9ucy5tYXhEYXRlLCB0aGlzLnN0ZXApO1xuICAgICAgICAgIHRoaXMubWF4RGF0ZSA9IGRhdGVWYWx1ZSh0aGlzLm1heFllYXIsIDExLCAzMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zW3RoaXMuYmVmb3JlU2hvd09wdGlvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgYmVmb3JlU2hvdyA9IG9wdGlvbnNbdGhpcy5iZWZvcmVTaG93T3B0aW9uXTtcbiAgICAgICAgdGhpcy5iZWZvcmVTaG93ID0gdHlwZW9mIGJlZm9yZVNob3cgPT09ICdmdW5jdGlvbicgPyBiZWZvcmVTaG93IDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB2aWV3J3Mgc2V0dGluZ3MgdG8gcmVmbGVjdCB0aGUgdmlld0RhdGUgc2V0IG9uIHRoZSBwaWNrZXJcbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVGb2N1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVGb2N1cygpIHtcbiAgICAgIHZhciB2aWV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMucGlja2VyLnZpZXdEYXRlKTtcbiAgICAgIHZhciBmaXJzdCA9IHN0YXJ0T2ZZZWFyUGVyaW9kKHZpZXdEYXRlLCB0aGlzLm5hdlN0ZXApO1xuICAgICAgdmFyIGxhc3QgPSBmaXJzdCArIDkgKiB0aGlzLnN0ZXA7XG4gICAgICB0aGlzLmZpcnN0ID0gZmlyc3Q7XG4gICAgICB0aGlzLmxhc3QgPSBsYXN0O1xuICAgICAgdGhpcy5zdGFydCA9IGZpcnN0IC0gdGhpcy5zdGVwO1xuICAgICAgdGhpcy5mb2N1c2VkID0gc3RhcnRPZlllYXJQZXJpb2Qodmlld0RhdGUsIHRoaXMuc3RlcCk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHZpZXcncyBzZXR0aW5ncyB0byByZWZsZWN0IHRoZSBzZWxlY3RlZCBkYXRlc1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIF90aGlzJHBpY2tlciRkYXRlcGljayA9IHRoaXMucGlja2VyLmRhdGVwaWNrZXIsXG4gICAgICAgIGRhdGVzID0gX3RoaXMkcGlja2VyJGRhdGVwaWNrLmRhdGVzLFxuICAgICAgICByYW5nZXBpY2tlciA9IF90aGlzJHBpY2tlciRkYXRlcGljay5yYW5nZXBpY2tlcjtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBkYXRlcy5yZWR1Y2UoZnVuY3Rpb24gKHllYXJzLCB0aW1lVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHB1c2hVbmlxdWUoeWVhcnMsIHN0YXJ0T2ZZZWFyUGVyaW9kKHRpbWVWYWx1ZSwgX3RoaXMuc3RlcCkpO1xuICAgICAgfSwgW10pO1xuICAgICAgaWYgKHJhbmdlcGlja2VyICYmIHJhbmdlcGlja2VyLmRhdGVzKSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZXBpY2tlci5kYXRlcy5tYXAoZnVuY3Rpb24gKHRpbWVWYWx1ZSkge1xuICAgICAgICAgIGlmICh0aW1lVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZZZWFyUGVyaW9kKHRpbWVWYWx1ZSwgX3RoaXMuc3RlcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIGVudGlyZSB2aWV3IFVJXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgLy8gcmVmcmVzaCBkaXNhYmxlZCB5ZWFycyBvbiBldmVyeSByZW5kZXIgaW4gb3JkZXIgdG8gY2xlYXIgdGhlIG9uZXMgYWRkZWRcbiAgICAgIC8vIGJ5IGJlZm9yZVNob3cgaG9vayBhdCBwcmV2aW91cyByZW5kZXJcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSBbXTtcbiAgICAgIHRoaXMucGlja2VyLnNldFZpZXdTd2l0Y2hMYWJlbChcIlwiLmNvbmNhdCh0aGlzLmZpcnN0LCBcIi1cIikuY29uY2F0KHRoaXMubGFzdCkpO1xuICAgICAgdGhpcy5waWNrZXIuc2V0UHJldkJ0bkRpc2FibGVkKHRoaXMuZmlyc3QgPD0gdGhpcy5taW5ZZWFyKTtcbiAgICAgIHRoaXMucGlja2VyLnNldE5leHRCdG5EaXNhYmxlZCh0aGlzLmxhc3QgPj0gdGhpcy5tYXhZZWFyKTtcbiAgICAgIEFycmF5LmZyb20odGhpcy5ncmlkLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBfdGhpczIuc3RhcnQgKyBpbmRleCAqIF90aGlzMi5zdGVwO1xuICAgICAgICB2YXIgZGF0ZSA9IGRhdGVWYWx1ZShjdXJyZW50LCAwLCAxKTtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gXCJkYXRlcGlja2VyLWNlbGwgaG92ZXI6YmctZ3JheS0xMDAgZGFyazpob3ZlcjpiZy1ncmF5LTYwMCBibG9jayBmbGV4LTEgbGVhZGluZy05IGJvcmRlci0wIHJvdW5kZWQtbGcgY3Vyc29yLXBvaW50ZXIgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTkwMCBkYXJrOnRleHQtd2hpdGUgZm9udC1zZW1pYm9sZCB0ZXh0LXNtIFwiLmNvbmNhdChfdGhpczIuY2VsbENsYXNzKTtcbiAgICAgICAgaWYgKF90aGlzMi5pc01pblZpZXcpIHtcbiAgICAgICAgICBlbC5kYXRhc2V0LmRhdGUgPSBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gZWwuZGF0YXNldC55ZWFyID0gY3VycmVudDtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncHJldicpO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAxMSkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ25leHQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCA8IF90aGlzMi5taW5ZZWFyIHx8IGN1cnJlbnQgPiBfdGhpczIubWF4WWVhcikge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzMi5yYW5nZSkge1xuICAgICAgICAgIHZhciBfdGhpczIkcmFuZ2UgPSBfc2xpY2VkVG9BcnJheShfdGhpczIucmFuZ2UsIDIpLFxuICAgICAgICAgICAgcmFuZ2VTdGFydCA9IF90aGlzMiRyYW5nZVswXSxcbiAgICAgICAgICAgIHJhbmdlRW5kID0gX3RoaXMyJHJhbmdlWzFdO1xuICAgICAgICAgIGlmIChjdXJyZW50ID4gcmFuZ2VTdGFydCAmJiBjdXJyZW50IDwgcmFuZ2VFbmQpIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1zdGFydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gcmFuZ2VFbmQpIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLWVuZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMyLnNlbGVjdGVkLmluY2x1ZGVzKGN1cnJlbnQpKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAnIWJnLXByaW1hcnktNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrOiFiZy1wcmltYXJ5LTYwMCcsICdkYXJrOnRleHQtd2hpdGUnKTtcbiAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LWdyYXktOTAwJywgJ2hvdmVyOmJnLWdyYXktMTAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdkYXJrOmhvdmVyOmJnLWdyYXktNjAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IF90aGlzMi5mb2N1c2VkKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczIuYmVmb3JlU2hvdykge1xuICAgICAgICAgIF90aGlzMi5wZXJmb3JtQmVmb3JlSG9vayhlbCwgY3VycmVudCwgZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgdmlldyBVSSBieSBhcHBseWluZyB0aGUgY2hhbmdlcyBvZiBzZWxlY3RlZCBhbmQgZm9jdXNlZCBpdGVtc1xuICB9LCB7XG4gICAga2V5OiBcInJlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIF9yZWYgPSB0aGlzLnJhbmdlIHx8IFtdLFxuICAgICAgICBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICByYW5nZVN0YXJ0ID0gX3JlZjJbMF0sXG4gICAgICAgIHJhbmdlRW5kID0gX3JlZjJbMV07XG4gICAgICB0aGlzLmdyaWQucXVlcnlTZWxlY3RvckFsbCgnLnJhbmdlLCAucmFuZ2Utc3RhcnQsIC5yYW5nZS1lbmQsIC5zZWxlY3RlZCwgLmZvY3VzZWQnKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdyYW5nZScsICdyYW5nZS1zdGFydCcsICdyYW5nZS1lbmQnLCAnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAnIWJnLXByaW1hcnktNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrIWJnLXByaW1hcnktNjAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdmb2N1c2VkJyk7XG4gICAgICB9KTtcbiAgICAgIEFycmF5LmZyb20odGhpcy5ncmlkLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IE51bWJlcihlbC50ZXh0Q29udGVudCk7XG4gICAgICAgIHZhciBjbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3Q7XG4gICAgICAgIGlmIChjdXJyZW50ID4gcmFuZ2VTdGFydCAmJiBjdXJyZW50IDwgcmFuZ2VFbmQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2Utc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCA9PT0gcmFuZ2VFbmQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1lbmQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMzLnNlbGVjdGVkLmluY2x1ZGVzKGN1cnJlbnQpKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAnIWJnLXByaW1hcnktNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrOiFiZy1wcmltYXJ5LTYwMCcsICdkYXJrOnRleHQtd2hpdGUnKTtcbiAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LWdyYXktOTAwJywgJ2hvdmVyOmJnLWdyYXktMTAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdkYXJrOmhvdmVyOmJnLWdyYXktNjAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IF90aGlzMy5mb2N1c2VkKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHZpZXcgVUkgYnkgYXBwbHlpbmcgdGhlIGNoYW5nZSBvZiBmb2N1c2VkIGl0ZW1cbiAgfSwge1xuICAgIGtleTogXCJyZWZyZXNoRm9jdXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaEZvY3VzKCkge1xuICAgICAgdmFyIGluZGV4ID0gTWF0aC5yb3VuZCgodGhpcy5mb2N1c2VkIC0gdGhpcy5zdGFydCkgLyB0aGlzLnN0ZXApO1xuICAgICAgdGhpcy5ncmlkLnF1ZXJ5U2VsZWN0b3JBbGwoJy5mb2N1c2VkJykuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZm9jdXNlZCcpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmdyaWQuY2hpbGRyZW5baW5kZXhdLmNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnKTtcbiAgICB9XG4gIH1dKTtcbn0oVmlldyk7XG5cbmZ1bmN0aW9uIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQoZGF0ZXBpY2tlciwgdHlwZSkge1xuICB2YXIgZGV0YWlsID0ge1xuICAgIGRhdGU6IGRhdGVwaWNrZXIuZ2V0RGF0ZSgpLFxuICAgIHZpZXdEYXRlOiBuZXcgRGF0ZShkYXRlcGlja2VyLnBpY2tlci52aWV3RGF0ZSksXG4gICAgdmlld0lkOiBkYXRlcGlja2VyLnBpY2tlci5jdXJyZW50Vmlldy5pZCxcbiAgICBkYXRlcGlja2VyOiBkYXRlcGlja2VyXG4gIH07XG4gIGRhdGVwaWNrZXIuZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCh0eXBlLCB7XG4gICAgZGV0YWlsOiBkZXRhaWxcbiAgfSkpO1xufVxuXG4vLyBkaXJlY3Rpb246IC0xICh0byBwcmV2aW91cyksIDEgKHRvIG5leHQpXG5mdW5jdGlvbiBnb1RvUHJldk9yTmV4dChkYXRlcGlja2VyLCBkaXJlY3Rpb24pIHtcbiAgdmFyIF9kYXRlcGlja2VyJGNvbmZpZyA9IGRhdGVwaWNrZXIuY29uZmlnLFxuICAgIG1pbkRhdGUgPSBfZGF0ZXBpY2tlciRjb25maWcubWluRGF0ZSxcbiAgICBtYXhEYXRlID0gX2RhdGVwaWNrZXIkY29uZmlnLm1heERhdGU7XG4gIHZhciBfZGF0ZXBpY2tlciRwaWNrZXIgPSBkYXRlcGlja2VyLnBpY2tlcixcbiAgICBjdXJyZW50VmlldyA9IF9kYXRlcGlja2VyJHBpY2tlci5jdXJyZW50VmlldyxcbiAgICB2aWV3RGF0ZSA9IF9kYXRlcGlja2VyJHBpY2tlci52aWV3RGF0ZTtcbiAgdmFyIG5ld1ZpZXdEYXRlO1xuICBzd2l0Y2ggKGN1cnJlbnRWaWV3LmlkKSB7XG4gICAgY2FzZSAwOlxuICAgICAgbmV3Vmlld0RhdGUgPSBhZGRNb250aHModmlld0RhdGUsIGRpcmVjdGlvbik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBuZXdWaWV3RGF0ZSA9IGFkZFllYXJzKHZpZXdEYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG5ld1ZpZXdEYXRlID0gYWRkWWVhcnModmlld0RhdGUsIGRpcmVjdGlvbiAqIGN1cnJlbnRWaWV3Lm5hdlN0ZXApO1xuICB9XG4gIG5ld1ZpZXdEYXRlID0gbGltaXRUb1JhbmdlKG5ld1ZpZXdEYXRlLCBtaW5EYXRlLCBtYXhEYXRlKTtcbiAgZGF0ZXBpY2tlci5waWNrZXIuY2hhbmdlRm9jdXMobmV3Vmlld0RhdGUpLnJlbmRlcigpO1xufVxuZnVuY3Rpb24gc3dpdGNoVmlldyhkYXRlcGlja2VyKSB7XG4gIHZhciB2aWV3SWQgPSBkYXRlcGlja2VyLnBpY2tlci5jdXJyZW50Vmlldy5pZDtcbiAgaWYgKHZpZXdJZCA9PT0gZGF0ZXBpY2tlci5jb25maWcubWF4Vmlldykge1xuICAgIHJldHVybjtcbiAgfVxuICBkYXRlcGlja2VyLnBpY2tlci5jaGFuZ2VWaWV3KHZpZXdJZCArIDEpLnJlbmRlcigpO1xufVxuZnVuY3Rpb24gdW5mb2N1cyhkYXRlcGlja2VyKSB7XG4gIGlmIChkYXRlcGlja2VyLmNvbmZpZy51cGRhdGVPbkJsdXIpIHtcbiAgICBkYXRlcGlja2VyLnVwZGF0ZSh7XG4gICAgICBhdXRvaGlkZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGVwaWNrZXIucmVmcmVzaCgnaW5wdXQnKTtcbiAgICBkYXRlcGlja2VyLmhpZGUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnb1RvU2VsZWN0ZWRNb250aE9yWWVhcihkYXRlcGlja2VyLCBzZWxlY3Rpb24pIHtcbiAgdmFyIHBpY2tlciA9IGRhdGVwaWNrZXIucGlja2VyO1xuICB2YXIgdmlld0RhdGUgPSBuZXcgRGF0ZShwaWNrZXIudmlld0RhdGUpO1xuICB2YXIgdmlld0lkID0gcGlja2VyLmN1cnJlbnRWaWV3LmlkO1xuICB2YXIgbmV3RGF0ZSA9IHZpZXdJZCA9PT0gMSA/IGFkZE1vbnRocyh2aWV3RGF0ZSwgc2VsZWN0aW9uIC0gdmlld0RhdGUuZ2V0TW9udGgoKSkgOiBhZGRZZWFycyh2aWV3RGF0ZSwgc2VsZWN0aW9uIC0gdmlld0RhdGUuZ2V0RnVsbFllYXIoKSk7XG4gIHBpY2tlci5jaGFuZ2VGb2N1cyhuZXdEYXRlKS5jaGFuZ2VWaWV3KHZpZXdJZCAtIDEpLnJlbmRlcigpO1xufVxuZnVuY3Rpb24gb25DbGlja1RvZGF5QnRuKGRhdGVwaWNrZXIpIHtcbiAgdmFyIHBpY2tlciA9IGRhdGVwaWNrZXIucGlja2VyO1xuICB2YXIgY3VycmVudERhdGUgPSB0b2RheSgpO1xuICBpZiAoZGF0ZXBpY2tlci5jb25maWcudG9kYXlCdG5Nb2RlID09PSAxKSB7XG4gICAgaWYgKGRhdGVwaWNrZXIuY29uZmlnLmF1dG9oaWRlKSB7XG4gICAgICBkYXRlcGlja2VyLnNldERhdGUoY3VycmVudERhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRlcGlja2VyLnNldERhdGUoY3VycmVudERhdGUsIHtcbiAgICAgIHJlbmRlcjogZmFsc2VcbiAgICB9KTtcbiAgICBwaWNrZXIudXBkYXRlKCk7XG4gIH1cbiAgaWYgKHBpY2tlci52aWV3RGF0ZSAhPT0gY3VycmVudERhdGUpIHtcbiAgICBwaWNrZXIuY2hhbmdlRm9jdXMoY3VycmVudERhdGUpO1xuICB9XG4gIHBpY2tlci5jaGFuZ2VWaWV3KDApLnJlbmRlcigpO1xufVxuZnVuY3Rpb24gb25DbGlja0NsZWFyQnRuKGRhdGVwaWNrZXIpIHtcbiAgZGF0ZXBpY2tlci5zZXREYXRlKHtcbiAgICBjbGVhcjogdHJ1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9uQ2xpY2tWaWV3U3dpdGNoKGRhdGVwaWNrZXIpIHtcbiAgc3dpdGNoVmlldyhkYXRlcGlja2VyKTtcbn1cbmZ1bmN0aW9uIG9uQ2xpY2tQcmV2QnRuKGRhdGVwaWNrZXIpIHtcbiAgZ29Ub1ByZXZPck5leHQoZGF0ZXBpY2tlciwgLTEpO1xufVxuZnVuY3Rpb24gb25DbGlja05leHRCdG4oZGF0ZXBpY2tlcikge1xuICBnb1RvUHJldk9yTmV4dChkYXRlcGlja2VyLCAxKTtcbn1cblxuLy8gRm9yIHRoZSBwaWNrZXIncyBtYWluIGJsb2NrIHRvIGRlbGVnZXRlIHRoZSBldmVudHMgZnJvbSBgZGF0ZXBpY2tlci1jZWxsYHNcbmZ1bmN0aW9uIG9uQ2xpY2tWaWV3KGRhdGVwaWNrZXIsIGV2KSB7XG4gIHZhciB0YXJnZXQgPSBmaW5kRWxlbWVudEluRXZlbnRQYXRoKGV2LCAnLmRhdGVwaWNrZXItY2VsbCcpO1xuICBpZiAoIXRhcmdldCB8fCB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBfZGF0ZXBpY2tlciRwaWNrZXIkY3UgPSBkYXRlcGlja2VyLnBpY2tlci5jdXJyZW50VmlldyxcbiAgICBpZCA9IF9kYXRlcGlja2VyJHBpY2tlciRjdS5pZCxcbiAgICBpc01pblZpZXcgPSBfZGF0ZXBpY2tlciRwaWNrZXIkY3UuaXNNaW5WaWV3O1xuICBpZiAoaXNNaW5WaWV3KSB7XG4gICAgZGF0ZXBpY2tlci5zZXREYXRlKE51bWJlcih0YXJnZXQuZGF0YXNldC5kYXRlKSk7XG4gIH0gZWxzZSBpZiAoaWQgPT09IDEpIHtcbiAgICBnb1RvU2VsZWN0ZWRNb250aE9yWWVhcihkYXRlcGlja2VyLCBOdW1iZXIodGFyZ2V0LmRhdGFzZXQubW9udGgpKTtcbiAgfSBlbHNlIHtcbiAgICBnb1RvU2VsZWN0ZWRNb250aE9yWWVhcihkYXRlcGlja2VyLCBOdW1iZXIodGFyZ2V0LmRhdGFzZXQueWVhcikpO1xuICB9XG59XG5mdW5jdGlvbiBvbkNsaWNrUGlja2VyKGRhdGVwaWNrZXIpIHtcbiAgaWYgKCFkYXRlcGlja2VyLmlubGluZSAmJiAhZGF0ZXBpY2tlci5jb25maWcuZGlzYWJsZVRvdWNoS2V5Ym9hcmQpIHtcbiAgICBkYXRlcGlja2VyLmlucHV0RmllbGQuZm9jdXMoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUGlja2VyT3B0aW9ucyhwaWNrZXIsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMudGl0bGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zLnRpdGxlKSB7XG4gICAgICBwaWNrZXIuY29udHJvbHMudGl0bGUudGV4dENvbnRlbnQgPSBvcHRpb25zLnRpdGxlO1xuICAgICAgc2hvd0VsZW1lbnQocGlja2VyLmNvbnRyb2xzLnRpdGxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGlja2VyLmNvbnRyb2xzLnRpdGxlLnRleHRDb250ZW50ID0gJyc7XG4gICAgICBoaWRlRWxlbWVudChwaWNrZXIuY29udHJvbHMudGl0bGUpO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5wcmV2QXJyb3cpIHtcbiAgICB2YXIgcHJldkJ0biA9IHBpY2tlci5jb250cm9scy5wcmV2QnRuO1xuICAgIGVtcHR5Q2hpbGROb2RlcyhwcmV2QnRuKTtcbiAgICBvcHRpb25zLnByZXZBcnJvdy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBwcmV2QnRuLmFwcGVuZENoaWxkKG5vZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9KTtcbiAgfVxuICBpZiAob3B0aW9ucy5uZXh0QXJyb3cpIHtcbiAgICB2YXIgbmV4dEJ0biA9IHBpY2tlci5jb250cm9scy5uZXh0QnRuO1xuICAgIGVtcHR5Q2hpbGROb2RlcyhuZXh0QnRuKTtcbiAgICBvcHRpb25zLm5leHRBcnJvdy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBuZXh0QnRuLmFwcGVuZENoaWxkKG5vZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9KTtcbiAgfVxuICBpZiAob3B0aW9ucy5sb2NhbGUpIHtcbiAgICBwaWNrZXIuY29udHJvbHMudG9kYXlCdG4udGV4dENvbnRlbnQgPSBvcHRpb25zLmxvY2FsZS50b2RheTtcbiAgICBwaWNrZXIuY29udHJvbHMuY2xlYXJCdG4udGV4dENvbnRlbnQgPSBvcHRpb25zLmxvY2FsZS5jbGVhcjtcbiAgfVxuICBpZiAob3B0aW9ucy50b2RheUJ0biAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG9wdGlvbnMudG9kYXlCdG4pIHtcbiAgICAgIHNob3dFbGVtZW50KHBpY2tlci5jb250cm9scy50b2RheUJ0bik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZGVFbGVtZW50KHBpY2tlci5jb250cm9scy50b2RheUJ0bik7XG4gICAgfVxuICB9XG4gIGlmIChoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWluRGF0ZScpIHx8IGhhc1Byb3BlcnR5KG9wdGlvbnMsICdtYXhEYXRlJykpIHtcbiAgICB2YXIgX3BpY2tlciRkYXRlcGlja2VyJGNvID0gcGlja2VyLmRhdGVwaWNrZXIuY29uZmlnLFxuICAgICAgbWluRGF0ZSA9IF9waWNrZXIkZGF0ZXBpY2tlciRjby5taW5EYXRlLFxuICAgICAgbWF4RGF0ZSA9IF9waWNrZXIkZGF0ZXBpY2tlciRjby5tYXhEYXRlO1xuICAgIHBpY2tlci5jb250cm9scy50b2RheUJ0bi5kaXNhYmxlZCA9ICFpc0luUmFuZ2UodG9kYXkoKSwgbWluRGF0ZSwgbWF4RGF0ZSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuY2xlYXJCdG4gIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zLmNsZWFyQnRuKSB7XG4gICAgICBzaG93RWxlbWVudChwaWNrZXIuY29udHJvbHMuY2xlYXJCdG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaWRlRWxlbWVudChwaWNrZXIuY29udHJvbHMuY2xlYXJCdG4pO1xuICAgIH1cbiAgfVxufVxuXG4vLyBDb21wdXRlIHZpZXcgZGF0ZSB0byByZXNldCwgd2hpY2ggd2lsbCBiZS4uLlxuLy8gLSB0aGUgbGFzdCBpdGVtIG9mIHRoZSBzZWxlY3RlZCBkYXRlcyBvciBkZWZhdWx0Vmlld0RhdGUgaWYgbm8gc2VsZWN0aW9uXG4vLyAtIGxpbWl0dGVkIHRvIG1pbkRhdGUgb3IgbWF4RGF0ZSBpZiBpdCBleGNlZWRzIHRoZSByYW5nZVxuZnVuY3Rpb24gY29tcHV0ZVJlc2V0Vmlld0RhdGUoZGF0ZXBpY2tlcikge1xuICB2YXIgZGF0ZXMgPSBkYXRlcGlja2VyLmRhdGVzLFxuICAgIGNvbmZpZyA9IGRhdGVwaWNrZXIuY29uZmlnO1xuICB2YXIgdmlld0RhdGUgPSBkYXRlcy5sZW5ndGggPiAwID8gbGFzdEl0ZW1PZihkYXRlcykgOiBjb25maWcuZGVmYXVsdFZpZXdEYXRlO1xuICByZXR1cm4gbGltaXRUb1JhbmdlKHZpZXdEYXRlLCBjb25maWcubWluRGF0ZSwgY29uZmlnLm1heERhdGUpO1xufVxuXG4vLyBDaGFuZ2UgY3VycmVudCB2aWV3J3MgdmlldyBkYXRlXG5mdW5jdGlvbiBzZXRWaWV3RGF0ZShwaWNrZXIsIG5ld0RhdGUpIHtcbiAgdmFyIG9sZFZpZXdEYXRlID0gbmV3IERhdGUocGlja2VyLnZpZXdEYXRlKTtcbiAgdmFyIG5ld1ZpZXdEYXRlID0gbmV3IERhdGUobmV3RGF0ZSk7XG4gIHZhciBfcGlja2VyJGN1cnJlbnRWaWV3ID0gcGlja2VyLmN1cnJlbnRWaWV3LFxuICAgIGlkID0gX3BpY2tlciRjdXJyZW50Vmlldy5pZCxcbiAgICB5ZWFyID0gX3BpY2tlciRjdXJyZW50Vmlldy55ZWFyLFxuICAgIGZpcnN0ID0gX3BpY2tlciRjdXJyZW50Vmlldy5maXJzdCxcbiAgICBsYXN0ID0gX3BpY2tlciRjdXJyZW50Vmlldy5sYXN0O1xuICB2YXIgdmlld1llYXIgPSBuZXdWaWV3RGF0ZS5nZXRGdWxsWWVhcigpO1xuICBwaWNrZXIudmlld0RhdGUgPSBuZXdEYXRlO1xuICBpZiAodmlld1llYXIgIT09IG9sZFZpZXdEYXRlLmdldEZ1bGxZZWFyKCkpIHtcbiAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KHBpY2tlci5kYXRlcGlja2VyLCAnY2hhbmdlWWVhcicpO1xuICB9XG4gIGlmIChuZXdWaWV3RGF0ZS5nZXRNb250aCgpICE9PSBvbGRWaWV3RGF0ZS5nZXRNb250aCgpKSB7XG4gICAgdHJpZ2dlckRhdGVwaWNrZXJFdmVudChwaWNrZXIuZGF0ZXBpY2tlciwgJ2NoYW5nZU1vbnRoJyk7XG4gIH1cblxuICAvLyByZXR1cm4gd2hldGhlciB0aGUgbmV3IGRhdGUgaXMgaW4gZGlmZmVyZW50IHBlcmlvZCBvbiB0aW1lIGZyb20gdGhlIG9uZVxuICAvLyBkaXNwbGF5ZWQgaW4gdGhlIGN1cnJlbnQgdmlld1xuICAvLyB3aGVuIHRydWUsIHRoZSB2aWV3IG5lZWRzIHRvIGJlIHJlLXJlbmRlcmVkIG9uIHRoZSBuZXh0IFVJIHJlZnJlc2guXG4gIHN3aXRjaCAoaWQpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gbmV3RGF0ZSA8IGZpcnN0IHx8IG5ld0RhdGUgPiBsYXN0O1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiB2aWV3WWVhciAhPT0geWVhcjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZpZXdZZWFyIDwgZmlyc3QgfHwgdmlld1llYXIgPiBsYXN0O1xuICB9XG59XG5mdW5jdGlvbiBnZXRUZXh0RGlyZWN0aW9uKGVsKSB7XG4gIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZGlyZWN0aW9uO1xufVxuXG4vLyBDbGFzcyByZXByZXNlbnRpbmcgdGhlIHBpY2tlciBVSVxudmFyIFBpY2tlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBpY2tlcihkYXRlcGlja2VyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBpY2tlcik7XG4gICAgdGhpcy5kYXRlcGlja2VyID0gZGF0ZXBpY2tlcjtcbiAgICB2YXIgdGVtcGxhdGUgPSBwaWNrZXJUZW1wbGF0ZS5yZXBsYWNlKC8lYnV0dG9uQ2xhc3MlL2csIGRhdGVwaWNrZXIuY29uZmlnLmJ1dHRvbkNsYXNzKTtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCA9IHBhcnNlSFRNTCh0ZW1wbGF0ZSkuZmlyc3RDaGlsZDtcbiAgICB2YXIgX2VsZW1lbnQkZmlyc3RDaGlsZCRjID0gX3NsaWNlZFRvQXJyYXkoZWxlbWVudC5maXJzdENoaWxkLmNoaWxkcmVuLCAzKSxcbiAgICAgIGhlYWRlciA9IF9lbGVtZW50JGZpcnN0Q2hpbGQkY1swXSxcbiAgICAgIG1haW4gPSBfZWxlbWVudCRmaXJzdENoaWxkJGNbMV0sXG4gICAgICBmb290ZXIgPSBfZWxlbWVudCRmaXJzdENoaWxkJGNbMl07XG4gICAgdmFyIHRpdGxlID0gaGVhZGVyLmZpcnN0RWxlbWVudENoaWxkO1xuICAgIHZhciBfaGVhZGVyJGxhc3RFbGVtZW50Q2ggPSBfc2xpY2VkVG9BcnJheShoZWFkZXIubGFzdEVsZW1lbnRDaGlsZC5jaGlsZHJlbiwgMyksXG4gICAgICBwcmV2QnRuID0gX2hlYWRlciRsYXN0RWxlbWVudENoWzBdLFxuICAgICAgdmlld1N3aXRjaCA9IF9oZWFkZXIkbGFzdEVsZW1lbnRDaFsxXSxcbiAgICAgIG5leHRCdG4gPSBfaGVhZGVyJGxhc3RFbGVtZW50Q2hbMl07XG4gICAgdmFyIF9mb290ZXIkZmlyc3RDaGlsZCRjaCA9IF9zbGljZWRUb0FycmF5KGZvb3Rlci5maXJzdENoaWxkLmNoaWxkcmVuLCAyKSxcbiAgICAgIHRvZGF5QnRuID0gX2Zvb3RlciRmaXJzdENoaWxkJGNoWzBdLFxuICAgICAgY2xlYXJCdG4gPSBfZm9vdGVyJGZpcnN0Q2hpbGQkY2hbMV07XG4gICAgdmFyIGNvbnRyb2xzID0ge1xuICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgcHJldkJ0bjogcHJldkJ0bixcbiAgICAgIHZpZXdTd2l0Y2g6IHZpZXdTd2l0Y2gsXG4gICAgICBuZXh0QnRuOiBuZXh0QnRuLFxuICAgICAgdG9kYXlCdG46IHRvZGF5QnRuLFxuICAgICAgY2xlYXJCdG46IGNsZWFyQnRuXG4gICAgfTtcbiAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgIHRoaXMuY29udHJvbHMgPSBjb250cm9scztcbiAgICB2YXIgZWxlbWVudENsYXNzID0gZGF0ZXBpY2tlci5pbmxpbmUgPyAnaW5saW5lJyA6ICdkcm9wZG93bic7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZGF0ZXBpY2tlci1cIi5jb25jYXQoZWxlbWVudENsYXNzKSk7XG4gICAgZWxlbWVudENsYXNzID09PSAnZHJvcGRvd24nID8gZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdkcm9wZG93bicsICdhYnNvbHV0ZScsICd0b3AtMCcsICdsZWZ0LTAnLCAnei01MCcsICdwdC0yJykgOiBudWxsO1xuICAgIHByb2Nlc3NQaWNrZXJPcHRpb25zKHRoaXMsIGRhdGVwaWNrZXIuY29uZmlnKTtcbiAgICB0aGlzLnZpZXdEYXRlID0gY29tcHV0ZVJlc2V0Vmlld0RhdGUoZGF0ZXBpY2tlcik7XG5cbiAgICAvLyBzZXQgdXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgcmVnaXN0ZXJMaXN0ZW5lcnMoZGF0ZXBpY2tlciwgW1tlbGVtZW50LCAnY2xpY2snLCBvbkNsaWNrUGlja2VyLmJpbmQobnVsbCwgZGF0ZXBpY2tlciksIHtcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9XSwgW21haW4sICdjbGljaycsIG9uQ2xpY2tWaWV3LmJpbmQobnVsbCwgZGF0ZXBpY2tlcildLCBbY29udHJvbHMudmlld1N3aXRjaCwgJ2NsaWNrJywgb25DbGlja1ZpZXdTd2l0Y2guYmluZChudWxsLCBkYXRlcGlja2VyKV0sIFtjb250cm9scy5wcmV2QnRuLCAnY2xpY2snLCBvbkNsaWNrUHJldkJ0bi5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSwgW2NvbnRyb2xzLm5leHRCdG4sICdjbGljaycsIG9uQ2xpY2tOZXh0QnRuLmJpbmQobnVsbCwgZGF0ZXBpY2tlcildLCBbY29udHJvbHMudG9kYXlCdG4sICdjbGljaycsIG9uQ2xpY2tUb2RheUJ0bi5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSwgW2NvbnRyb2xzLmNsZWFyQnRuLCAnY2xpY2snLCBvbkNsaWNrQ2xlYXJCdG4uYmluZChudWxsLCBkYXRlcGlja2VyKV1dKTtcblxuICAgIC8vIHNldCB1cCB2aWV3c1xuICAgIHRoaXMudmlld3MgPSBbbmV3IERheXNWaWV3KHRoaXMpLCBuZXcgTW9udGhzVmlldyh0aGlzKSwgbmV3IFllYXJzVmlldyh0aGlzLCB7XG4gICAgICBpZDogMixcbiAgICAgIG5hbWU6ICd5ZWFycycsXG4gICAgICBjZWxsQ2xhc3M6ICd5ZWFyJyxcbiAgICAgIHN0ZXA6IDFcbiAgICB9KSwgbmV3IFllYXJzVmlldyh0aGlzLCB7XG4gICAgICBpZDogMyxcbiAgICAgIG5hbWU6ICdkZWNhZGVzJyxcbiAgICAgIGNlbGxDbGFzczogJ2RlY2FkZScsXG4gICAgICBzdGVwOiAxMFxuICAgIH0pXTtcbiAgICB0aGlzLmN1cnJlbnRWaWV3ID0gdGhpcy52aWV3c1tkYXRlcGlja2VyLmNvbmZpZy5zdGFydFZpZXddO1xuICAgIHRoaXMuY3VycmVudFZpZXcucmVuZGVyKCk7XG4gICAgdGhpcy5tYWluLmFwcGVuZENoaWxkKHRoaXMuY3VycmVudFZpZXcuZWxlbWVudCk7XG4gICAgZGF0ZXBpY2tlci5jb25maWcuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhQaWNrZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBwcm9jZXNzUGlja2VyT3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMudmlld3MuZm9yRWFjaChmdW5jdGlvbiAodmlldykge1xuICAgICAgICB2aWV3LmluaXQob3B0aW9ucywgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmN1cnJlbnRWaWV3LnJlbmRlcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXRhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgdGhpcy5kYXRlcGlja2VyLmNvbmZpZy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnLCAnYmxvY2snKTtcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgIHZhciBkYXRlcGlja2VyID0gdGhpcy5kYXRlcGlja2VyO1xuICAgICAgaWYgKCFkYXRlcGlja2VyLmlubGluZSkge1xuICAgICAgICAvLyBlbnN1cmUgcGlja2VyJ3MgZGlyZWN0aW9uIG1hdGNoZXMgaW5wdXQnc1xuICAgICAgICB2YXIgaW5wdXREaXJlY3Rpb24gPSBnZXRUZXh0RGlyZWN0aW9uKGRhdGVwaWNrZXIuaW5wdXRGaWVsZCk7XG4gICAgICAgIGlmIChpbnB1dERpcmVjdGlvbiAhPT0gZ2V0VGV4dERpcmVjdGlvbihkYXRlcGlja2VyLmNvbmZpZy5jb250YWluZXIpKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LmRpciA9IGlucHV0RGlyZWN0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZWxlbWVudC5kaXIpIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkaXInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBsYWNlKCk7XG4gICAgICAgIGlmIChkYXRlcGlja2VyLmNvbmZpZy5kaXNhYmxlVG91Y2hLZXlib2FyZCkge1xuICAgICAgICAgIGRhdGVwaWNrZXIuaW5wdXRGaWVsZC5ibHVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQoZGF0ZXBpY2tlciwgJ3Nob3cnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmRhdGVwaWNrZXIuZXhpdEVkaXRNb2RlKCk7XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJywgJ2Jsb2NrJyk7XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJywgJ2Jsb2NrJywgJ2hpZGRlbicpO1xuICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQodGhpcy5kYXRlcGlja2VyLCAnaGlkZScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwbGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGFjZSgpIHtcbiAgICAgIHZhciBfdGhpcyRlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICBjbGFzc0xpc3QgPSBfdGhpcyRlbGVtZW50LmNsYXNzTGlzdCxcbiAgICAgICAgc3R5bGUgPSBfdGhpcyRlbGVtZW50LnN0eWxlO1xuICAgICAgdmFyIF90aGlzJGRhdGVwaWNrZXIgPSB0aGlzLmRhdGVwaWNrZXIsXG4gICAgICAgIGNvbmZpZyA9IF90aGlzJGRhdGVwaWNrZXIuY29uZmlnLFxuICAgICAgICBpbnB1dEZpZWxkID0gX3RoaXMkZGF0ZXBpY2tlci5pbnB1dEZpZWxkO1xuICAgICAgdmFyIGNvbnRhaW5lciA9IGNvbmZpZy5jb250YWluZXI7XG4gICAgICB2YXIgX3RoaXMkZWxlbWVudCRnZXRCb3VuID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBjYWxlbmRhcldpZHRoID0gX3RoaXMkZWxlbWVudCRnZXRCb3VuLndpZHRoLFxuICAgICAgICBjYWxlbmRhckhlaWdodCA9IF90aGlzJGVsZW1lbnQkZ2V0Qm91bi5oZWlnaHQ7XG4gICAgICB2YXIgX2NvbnRhaW5lciRnZXRCb3VuZGluID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBjb250YWluZXJMZWZ0ID0gX2NvbnRhaW5lciRnZXRCb3VuZGluLmxlZnQsXG4gICAgICAgIGNvbnRhaW5lclRvcCA9IF9jb250YWluZXIkZ2V0Qm91bmRpbi50b3AsXG4gICAgICAgIGNvbnRhaW5lcldpZHRoID0gX2NvbnRhaW5lciRnZXRCb3VuZGluLndpZHRoO1xuICAgICAgdmFyIF9pbnB1dEZpZWxkJGdldEJvdW5kaSA9IGlucHV0RmllbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGlucHV0TGVmdCA9IF9pbnB1dEZpZWxkJGdldEJvdW5kaS5sZWZ0LFxuICAgICAgICBpbnB1dFRvcCA9IF9pbnB1dEZpZWxkJGdldEJvdW5kaS50b3AsXG4gICAgICAgIGlucHV0V2lkdGggPSBfaW5wdXRGaWVsZCRnZXRCb3VuZGkud2lkdGgsXG4gICAgICAgIGlucHV0SGVpZ2h0ID0gX2lucHV0RmllbGQkZ2V0Qm91bmRpLmhlaWdodDtcbiAgICAgIHZhciBfY29uZmlnJG9yaWVudGF0aW9uID0gY29uZmlnLm9yaWVudGF0aW9uLFxuICAgICAgICBvcmllbnRYID0gX2NvbmZpZyRvcmllbnRhdGlvbi54LFxuICAgICAgICBvcmllbnRZID0gX2NvbmZpZyRvcmllbnRhdGlvbi55O1xuICAgICAgdmFyIHNjcm9sbFRvcDtcbiAgICAgIHZhciBsZWZ0O1xuICAgICAgdmFyIHRvcDtcbiAgICAgIGlmIChjb250YWluZXIgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgc2Nyb2xsVG9wID0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgIGxlZnQgPSBpbnB1dExlZnQgKyB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgdG9wID0gaW5wdXRUb3AgKyBzY3JvbGxUb3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY3JvbGxUb3AgPSBjb250YWluZXIuc2Nyb2xsVG9wO1xuICAgICAgICBsZWZ0ID0gaW5wdXRMZWZ0IC0gY29udGFpbmVyTGVmdDtcbiAgICAgICAgdG9wID0gaW5wdXRUb3AgLSBjb250YWluZXJUb3AgKyBzY3JvbGxUb3A7XG4gICAgICB9XG4gICAgICBpZiAob3JpZW50WCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgICAgIC8vIGFsaWduIHRvIHRoZSBsZWZ0IGFuZCBtb3ZlIGludG8gdmlzaWJsZSBhcmVhIGlmIGlucHV0J3MgbGVmdCBlZGdlIDwgd2luZG93J3NcbiAgICAgICAgICBvcmllbnRYID0gJ2xlZnQnO1xuICAgICAgICAgIGxlZnQgPSAxMDtcbiAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICsgY2FsZW5kYXJXaWR0aCA+IGNvbnRhaW5lcldpZHRoKSB7XG4gICAgICAgICAgLy8gYWxpZ24gdG8gdGhlIHJpZ2h0IGlmIGNhbmxlbmRhcidzIHJpZ2h0IGVkZ2UgPiBjb250YWluZXInc1xuICAgICAgICAgIG9yaWVudFggPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9yaWVudFggPSBnZXRUZXh0RGlyZWN0aW9uKGlucHV0RmllbGQpID09PSAncnRsJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcmllbnRYID09PSAncmlnaHQnKSB7XG4gICAgICAgIGxlZnQgLT0gY2FsZW5kYXJXaWR0aCAtIGlucHV0V2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAob3JpZW50WSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIG9yaWVudFkgPSB0b3AgLSBjYWxlbmRhckhlaWdodCA8IHNjcm9sbFRvcCA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgICB9XG4gICAgICBpZiAob3JpZW50WSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgdG9wIC09IGNhbGVuZGFySGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9wICs9IGlucHV0SGVpZ2h0O1xuICAgICAgfVxuICAgICAgY2xhc3NMaXN0LnJlbW92ZSgnZGF0ZXBpY2tlci1vcmllbnQtdG9wJywgJ2RhdGVwaWNrZXItb3JpZW50LWJvdHRvbScsICdkYXRlcGlja2VyLW9yaWVudC1yaWdodCcsICdkYXRlcGlja2VyLW9yaWVudC1sZWZ0Jyk7XG4gICAgICBjbGFzc0xpc3QuYWRkKFwiZGF0ZXBpY2tlci1vcmllbnQtXCIuY29uY2F0KG9yaWVudFkpLCBcImRhdGVwaWNrZXItb3JpZW50LVwiLmNvbmNhdChvcmllbnRYKSk7XG4gICAgICBzdHlsZS50b3AgPSB0b3AgPyBcIlwiLmNvbmNhdCh0b3AsIFwicHhcIikgOiB0b3A7XG4gICAgICBzdHlsZS5sZWZ0ID0gbGVmdCA/IFwiXCIuY29uY2F0KGxlZnQsIFwicHhcIikgOiBsZWZ0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRWaWV3U3dpdGNoTGFiZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Vmlld1N3aXRjaExhYmVsKGxhYmVsVGV4dCkge1xuICAgICAgdGhpcy5jb250cm9scy52aWV3U3dpdGNoLnRleHRDb250ZW50ID0gbGFiZWxUZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQcmV2QnRuRGlzYWJsZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJldkJ0bkRpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgICB0aGlzLmNvbnRyb2xzLnByZXZCdG4uZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TmV4dEJ0bkRpc2FibGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE5leHRCdG5EaXNhYmxlZChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5jb250cm9scy5uZXh0QnRuLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoYW5nZVZpZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hhbmdlVmlldyh2aWV3SWQpIHtcbiAgICAgIHZhciBvbGRWaWV3ID0gdGhpcy5jdXJyZW50VmlldztcbiAgICAgIHZhciBuZXdWaWV3ID0gdGhpcy52aWV3c1t2aWV3SWRdO1xuICAgICAgaWYgKG5ld1ZpZXcuaWQgIT09IG9sZFZpZXcuaWQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VmlldyA9IG5ld1ZpZXc7XG4gICAgICAgIHRoaXMuX3JlbmRlck1ldGhvZCA9ICdyZW5kZXInO1xuICAgICAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KHRoaXMuZGF0ZXBpY2tlciwgJ2NoYW5nZVZpZXcnKTtcbiAgICAgICAgdGhpcy5tYWluLnJlcGxhY2VDaGlsZChuZXdWaWV3LmVsZW1lbnQsIG9sZFZpZXcuZWxlbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBDaGFuZ2UgdGhlIGZvY3VzZWQgZGF0ZSAodmlldyBkYXRlKVxuICB9LCB7XG4gICAga2V5OiBcImNoYW5nZUZvY3VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoYW5nZUZvY3VzKG5ld1ZpZXdEYXRlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJNZXRob2QgPSBzZXRWaWV3RGF0ZSh0aGlzLCBuZXdWaWV3RGF0ZSkgPyAncmVuZGVyJyA6ICdyZWZyZXNoRm9jdXMnO1xuICAgICAgdGhpcy52aWV3cy5mb3JFYWNoKGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgIHZpZXcudXBkYXRlRm9jdXMoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgdGhlIGNoYW5nZSBvZiB0aGUgc2VsZWN0ZWQgZGF0ZXNcbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIG5ld1ZpZXdEYXRlID0gY29tcHV0ZVJlc2V0Vmlld0RhdGUodGhpcy5kYXRlcGlja2VyKTtcbiAgICAgIHRoaXMuX3JlbmRlck1ldGhvZCA9IHNldFZpZXdEYXRlKHRoaXMsIG5ld1ZpZXdEYXRlKSA/ICdyZW5kZXInIDogJ3JlZnJlc2gnO1xuICAgICAgdGhpcy52aWV3cy5mb3JFYWNoKGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgIHZpZXcudXBkYXRlRm9jdXMoKTtcbiAgICAgICAgdmlldy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gUmVmcmVzaCB0aGUgcGlja2VyIFVJXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBxdWlja1JlbmRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgIHZhciByZW5kZXJNZXRob2QgPSBxdWlja1JlbmRlciAmJiB0aGlzLl9yZW5kZXJNZXRob2QgfHwgJ3JlbmRlcic7XG4gICAgICBkZWxldGUgdGhpcy5fcmVuZGVyTWV0aG9kO1xuICAgICAgdGhpcy5jdXJyZW50Vmlld1tyZW5kZXJNZXRob2RdKCk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbi8vIEZpbmQgdGhlIGNsb3Nlc3QgZGF0ZSB0aGF0IGRvZXNuJ3QgbWVldCB0aGUgY29uZGl0aW9uIGZvciB1bmF2YWlsYWJsZSBkYXRlXG4vLyBSZXR1cm5zIHVuZGVmaW5lZCBpZiBubyBhdmFpbGFibGUgZGF0ZSBpcyBmb3VuZFxuLy8gYWRkRm46IGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSB0aGUgbmV4dCBkYXRlXG4vLyAgIC0gYXJnczogdGltZSB2YWx1ZSwgYW1vdW50XG4vLyBpbmNyZWFzZTogYW1vdW50IHRvIHBhc3MgdG8gYWRkRm5cbi8vIHRlc3RGbjogZnVuY3Rpb24gdG8gdGVzdCB0aGUgdW5hdmFpbGFibGl0eSBvZiB0aGUgZGF0ZVxuLy8gICAtIGFyZ3M6IHRpbWUgdmFsdWU7IHJldHVuOiB0cnVlIGlmIHVuYXZhaWxhYmxlXG5mdW5jdGlvbiBmaW5kTmV4dEF2YWlsYWJsZU9uZShkYXRlLCBhZGRGbiwgaW5jcmVhc2UsIHRlc3RGbiwgbWluLCBtYXgpIHtcbiAgaWYgKCFpc0luUmFuZ2UoZGF0ZSwgbWluLCBtYXgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0ZXN0Rm4oZGF0ZSkpIHtcbiAgICB2YXIgbmV3RGF0ZSA9IGFkZEZuKGRhdGUsIGluY3JlYXNlKTtcbiAgICByZXR1cm4gZmluZE5leHRBdmFpbGFibGVPbmUobmV3RGF0ZSwgYWRkRm4sIGluY3JlYXNlLCB0ZXN0Rm4sIG1pbiwgbWF4KTtcbiAgfVxuICByZXR1cm4gZGF0ZTtcbn1cblxuLy8gZGlyZWN0aW9uOiAtMSAobGVmdC91cCksIDEgKHJpZ2h0L2Rvd24pXG4vLyB2ZXJ0aWNhbDogdHJ1ZSBmb3IgdXAvZG93biwgZmFsc2UgZm9yIGxlZnQvcmlnaHRcbmZ1bmN0aW9uIG1vdmVCeUFycm93S2V5KGRhdGVwaWNrZXIsIGV2LCBkaXJlY3Rpb24sIHZlcnRpY2FsKSB7XG4gIHZhciBwaWNrZXIgPSBkYXRlcGlja2VyLnBpY2tlcjtcbiAgdmFyIGN1cnJlbnRWaWV3ID0gcGlja2VyLmN1cnJlbnRWaWV3O1xuICB2YXIgc3RlcCA9IGN1cnJlbnRWaWV3LnN0ZXAgfHwgMTtcbiAgdmFyIHZpZXdEYXRlID0gcGlja2VyLnZpZXdEYXRlO1xuICB2YXIgYWRkRm47XG4gIHZhciB0ZXN0Rm47XG4gIHN3aXRjaCAoY3VycmVudFZpZXcuaWQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgdmlld0RhdGUgPSBhZGREYXlzKHZpZXdEYXRlLCBkaXJlY3Rpb24gKiA3KTtcbiAgICAgIH0gZWxzZSBpZiAoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSB7XG4gICAgICAgIHZpZXdEYXRlID0gYWRkWWVhcnModmlld0RhdGUsIGRpcmVjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aWV3RGF0ZSA9IGFkZERheXModmlld0RhdGUsIGRpcmVjdGlvbik7XG4gICAgICB9XG4gICAgICBhZGRGbiA9IGFkZERheXM7XG4gICAgICB0ZXN0Rm4gPSBmdW5jdGlvbiB0ZXN0Rm4oZGF0ZSkge1xuICAgICAgICByZXR1cm4gY3VycmVudFZpZXcuZGlzYWJsZWQuaW5jbHVkZXMoZGF0ZSk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgdmlld0RhdGUgPSBhZGRNb250aHModmlld0RhdGUsIHZlcnRpY2FsID8gZGlyZWN0aW9uICogNCA6IGRpcmVjdGlvbik7XG4gICAgICBhZGRGbiA9IGFkZE1vbnRocztcbiAgICAgIHRlc3RGbiA9IGZ1bmN0aW9uIHRlc3RGbihkYXRlKSB7XG4gICAgICAgIHZhciBkdCA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICB2YXIgeWVhciA9IGN1cnJlbnRWaWV3LnllYXIsXG4gICAgICAgICAgZGlzYWJsZWQgPSBjdXJyZW50Vmlldy5kaXNhYmxlZDtcbiAgICAgICAgcmV0dXJuIGR0LmdldEZ1bGxZZWFyKCkgPT09IHllYXIgJiYgZGlzYWJsZWQuaW5jbHVkZXMoZHQuZ2V0TW9udGgoKSk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZpZXdEYXRlID0gYWRkWWVhcnModmlld0RhdGUsIGRpcmVjdGlvbiAqICh2ZXJ0aWNhbCA/IDQgOiAxKSAqIHN0ZXApO1xuICAgICAgYWRkRm4gPSBhZGRZZWFycztcbiAgICAgIHRlc3RGbiA9IGZ1bmN0aW9uIHRlc3RGbihkYXRlKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50Vmlldy5kaXNhYmxlZC5pbmNsdWRlcyhzdGFydE9mWWVhclBlcmlvZChkYXRlLCBzdGVwKSk7XG4gICAgICB9O1xuICB9XG4gIHZpZXdEYXRlID0gZmluZE5leHRBdmFpbGFibGVPbmUodmlld0RhdGUsIGFkZEZuLCBkaXJlY3Rpb24gPCAwID8gLXN0ZXAgOiBzdGVwLCB0ZXN0Rm4sIGN1cnJlbnRWaWV3Lm1pbkRhdGUsIGN1cnJlbnRWaWV3Lm1heERhdGUpO1xuICBpZiAodmlld0RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHBpY2tlci5jaGFuZ2VGb2N1cyh2aWV3RGF0ZSkucmVuZGVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uS2V5ZG93bihkYXRlcGlja2VyLCBldikge1xuICBpZiAoZXYua2V5ID09PSAnVGFiJykge1xuICAgIHVuZm9jdXMoZGF0ZXBpY2tlcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwaWNrZXIgPSBkYXRlcGlja2VyLnBpY2tlcjtcbiAgdmFyIF9waWNrZXIkY3VycmVudFZpZXcgPSBwaWNrZXIuY3VycmVudFZpZXcsXG4gICAgaWQgPSBfcGlja2VyJGN1cnJlbnRWaWV3LmlkLFxuICAgIGlzTWluVmlldyA9IF9waWNrZXIkY3VycmVudFZpZXcuaXNNaW5WaWV3O1xuICBpZiAoIXBpY2tlci5hY3RpdmUpIHtcbiAgICBzd2l0Y2ggKGV2LmtleSkge1xuICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICAgIHBpY2tlci5zaG93KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICBkYXRlcGlja2VyLnVwZGF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGF0ZXBpY2tlci5lZGl0TW9kZSkge1xuICAgIHN3aXRjaCAoZXYua2V5KSB7XG4gICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICBwaWNrZXIuaGlkZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgZGF0ZXBpY2tlci5leGl0RWRpdE1vZGUoe1xuICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgICBhdXRvaGlkZTogZGF0ZXBpY2tlci5jb25maWcuYXV0b2hpZGVcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKGV2LmtleSkge1xuICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgcGlja2VyLmhpZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICBpZiAoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSB7XG4gICAgICAgICAgZ29Ub1ByZXZPck5leHQoZGF0ZXBpY2tlciwgLTEpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgZGF0ZXBpY2tlci5lbnRlckVkaXRNb2RlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vdmVCeUFycm93S2V5KGRhdGVwaWNrZXIsIGV2LCAtMSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICAgIGlmIChldi5jdHJsS2V5IHx8IGV2Lm1ldGFLZXkpIHtcbiAgICAgICAgICBnb1RvUHJldk9yTmV4dChkYXRlcGlja2VyLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChldi5zaGlmdEtleSkge1xuICAgICAgICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb3ZlQnlBcnJvd0tleShkYXRlcGlja2VyLCBldiwgMSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgIGlmIChldi5jdHJsS2V5IHx8IGV2Lm1ldGFLZXkpIHtcbiAgICAgICAgICBzd2l0Y2hWaWV3KGRhdGVwaWNrZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgZGF0ZXBpY2tlci5lbnRlckVkaXRNb2RlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vdmVCeUFycm93S2V5KGRhdGVwaWNrZXIsIGV2LCAtMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICBpZiAoZXYuc2hpZnRLZXkgJiYgIWV2LmN0cmxLZXkgJiYgIWV2Lm1ldGFLZXkpIHtcbiAgICAgICAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbW92ZUJ5QXJyb3dLZXkoZGF0ZXBpY2tlciwgZXYsIDEsIHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgaWYgKGlzTWluVmlldykge1xuICAgICAgICAgIGRhdGVwaWNrZXIuc2V0RGF0ZShwaWNrZXIudmlld0RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBpY2tlci5jaGFuZ2VWaWV3KGlkIC0gMSkucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdCYWNrc3BhY2UnOlxuICAgICAgY2FzZSAnRGVsZXRlJzpcbiAgICAgICAgZGF0ZXBpY2tlci5lbnRlckVkaXRNb2RlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChldi5rZXkubGVuZ3RoID09PSAxICYmICFldi5jdHJsS2V5ICYmICFldi5tZXRhS2V5KSB7XG4gICAgICAgICAgZGF0ZXBpY2tlci5lbnRlckVkaXRNb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbn1cbmZ1bmN0aW9uIG9uRm9jdXMoZGF0ZXBpY2tlcikge1xuICBpZiAoZGF0ZXBpY2tlci5jb25maWcuc2hvd09uRm9jdXMgJiYgIWRhdGVwaWNrZXIuX3Nob3dpbmcpIHtcbiAgICBkYXRlcGlja2VyLnNob3coKTtcbiAgfVxufVxuXG4vLyBmb3IgdGhlIHByZXZlbnRpb24gZm9yIGVudGVyaW5nIGVkaXQgbW9kZSB3aGlsZSBnZXR0aW5nIGZvY3VzIG9uIGNsaWNrXG5mdW5jdGlvbiBvbk1vdXNlZG93bihkYXRlcGlja2VyLCBldikge1xuICB2YXIgZWwgPSBldi50YXJnZXQ7XG4gIGlmIChkYXRlcGlja2VyLnBpY2tlci5hY3RpdmUgfHwgZGF0ZXBpY2tlci5jb25maWcuc2hvd09uQ2xpY2spIHtcbiAgICBlbC5fYWN0aXZlID0gZWwgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgZWwuX2NsaWNraW5nID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWxldGUgZWwuX2FjdGl2ZTtcbiAgICAgIGRlbGV0ZSBlbC5fY2xpY2tpbmc7XG4gICAgfSwgMjAwMCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uQ2xpY2tJbnB1dChkYXRlcGlja2VyLCBldikge1xuICB2YXIgZWwgPSBldi50YXJnZXQ7XG4gIGlmICghZWwuX2NsaWNraW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNsZWFyVGltZW91dChlbC5fY2xpY2tpbmcpO1xuICBkZWxldGUgZWwuX2NsaWNraW5nO1xuICBpZiAoZWwuX2FjdGl2ZSkge1xuICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xuICB9XG4gIGRlbGV0ZSBlbC5fYWN0aXZlO1xuICBpZiAoZGF0ZXBpY2tlci5jb25maWcuc2hvd09uQ2xpY2spIHtcbiAgICBkYXRlcGlja2VyLnNob3coKTtcbiAgfVxufVxuZnVuY3Rpb24gb25QYXN0ZShkYXRlcGlja2VyLCBldikge1xuICBpZiAoZXYuY2xpcGJvYXJkRGF0YS50eXBlcy5pbmNsdWRlcygndGV4dC9wbGFpbicpKSB7XG4gICAgZGF0ZXBpY2tlci5lbnRlckVkaXRNb2RlKCk7XG4gIH1cbn1cblxuLy8gZm9yIHRoZSBgZG9jdW1lbnRgIHRvIGRlbGVnYXRlIHRoZSBldmVudHMgZnJvbSBvdXRzaWRlIHRoZSBwaWNrZXIvaW5wdXQgZmllbGRcbmZ1bmN0aW9uIG9uQ2xpY2tPdXRzaWRlKGRhdGVwaWNrZXIsIGV2KSB7XG4gIHZhciBlbGVtZW50ID0gZGF0ZXBpY2tlci5lbGVtZW50O1xuICBpZiAoZWxlbWVudCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcGlja2VyRWxlbSA9IGRhdGVwaWNrZXIucGlja2VyLmVsZW1lbnQ7XG4gIGlmIChmaW5kRWxlbWVudEluRXZlbnRQYXRoKGV2LCBmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwgPT09IGVsZW1lbnQgfHwgZWwgPT09IHBpY2tlckVsZW07XG4gIH0pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHVuZm9jdXMoZGF0ZXBpY2tlcik7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeURhdGVzKGRhdGVzLCBjb25maWcpIHtcbiAgcmV0dXJuIGRhdGVzLm1hcChmdW5jdGlvbiAoZHQpIHtcbiAgICByZXR1cm4gZm9ybWF0RGF0ZShkdCwgY29uZmlnLmZvcm1hdCwgY29uZmlnLmxvY2FsZSk7XG4gIH0pLmpvaW4oY29uZmlnLmRhdGVEZWxpbWl0ZXIpO1xufVxuXG4vLyBwYXJzZSBpbnB1dCBkYXRlcyBhbmQgY3JlYXRlIGFuIGFycmF5IG9mIHRpbWUgdmFsdWVzIGZvciBzZWxlY3Rpb25cbi8vIHJldHVybnMgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBubyB2YWxpZCBkYXRlcyBpbiBpbnB1dERhdGVzXG4vLyB3aGVuIG9yaWdEYXRlcyAoY3VycmVudCBzZWxlY3Rpb24pIGlzIHBhc3NlZCwgdGhlIGZ1bmN0aW9uIHdvcmtzIHRvIG1peFxuLy8gdGhlIGlucHV0IGRhdGVzIGludG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5mdW5jdGlvbiBwcm9jZXNzSW5wdXREYXRlcyhkYXRlcGlja2VyLCBpbnB1dERhdGVzKSB7XG4gIHZhciBjbGVhciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIHZhciBjb25maWcgPSBkYXRlcGlja2VyLmNvbmZpZyxcbiAgICBvcmlnRGF0ZXMgPSBkYXRlcGlja2VyLmRhdGVzLFxuICAgIHJhbmdlcGlja2VyID0gZGF0ZXBpY2tlci5yYW5nZXBpY2tlcjtcbiAgaWYgKGlucHV0RGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gZW1wdHkgaW5wdXQgaXMgY29uc2lkZXJlZCB2YWxpZCB1bmxlc3Mgb3JpZ2lEYXRlcyBpcyBwYXNzZWRcbiAgICByZXR1cm4gY2xlYXIgPyBbXSA6IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgcmFuZ2VFbmQgPSByYW5nZXBpY2tlciAmJiBkYXRlcGlja2VyID09PSByYW5nZXBpY2tlci5kYXRlcGlja2Vyc1sxXTtcbiAgdmFyIG5ld0RhdGVzID0gaW5wdXREYXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGRhdGVzLCBkdCkge1xuICAgIHZhciBkYXRlID0gcGFyc2VEYXRlKGR0LCBjb25maWcuZm9ybWF0LCBjb25maWcubG9jYWxlKTtcbiAgICBpZiAoZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZGF0ZXM7XG4gICAgfVxuICAgIGlmIChjb25maWcucGlja0xldmVsID4gMCkge1xuICAgICAgLy8gYWRqdXN0IHRvIDFzdCBvZiB0aGUgbW9udGgvSmFuIDFzdCBvZiB0aGUgeWVhclxuICAgICAgLy8gb3IgdG8gdGhlIGxhc3QgZGF5IG9mIHRoZSBtb25oL0RlYyAzMXN0IG9mIHRoZSB5ZWFyIGlmIHRoZSBkYXRlcGlja2VyXG4gICAgICAvLyBpcyB0aGUgcmFuZ2UtZW5kIHBpY2tlciBvZiBhIHJhbmdlcGlja2VyXG4gICAgICB2YXIgX2R0ID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICBpZiAoY29uZmlnLnBpY2tMZXZlbCA9PT0gMSkge1xuICAgICAgICBkYXRlID0gcmFuZ2VFbmQgPyBfZHQuc2V0TW9udGgoX2R0LmdldE1vbnRoKCkgKyAxLCAwKSA6IF9kdC5zZXREYXRlKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0ZSA9IHJhbmdlRW5kID8gX2R0LnNldEZ1bGxZZWFyKF9kdC5nZXRGdWxsWWVhcigpICsgMSwgMCwgMCkgOiBfZHQuc2V0TW9udGgoMCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0luUmFuZ2UoZGF0ZSwgY29uZmlnLm1pbkRhdGUsIGNvbmZpZy5tYXhEYXRlKSAmJiAhZGF0ZXMuaW5jbHVkZXMoZGF0ZSkgJiYgIWNvbmZpZy5kYXRlc0Rpc2FibGVkLmluY2x1ZGVzKGRhdGUpICYmICFjb25maWcuZGF5c09mV2Vla0Rpc2FibGVkLmluY2x1ZGVzKG5ldyBEYXRlKGRhdGUpLmdldERheSgpKSkge1xuICAgICAgZGF0ZXMucHVzaChkYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVzO1xuICB9LCBbXSk7XG4gIGlmIChuZXdEYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGNvbmZpZy5tdWx0aWRhdGUgJiYgIWNsZWFyKSB7XG4gICAgLy8gZ2V0IHRoZSBzeW5tZXRyaWMgZGlmZmVyZW5jZSBiZXR3ZWVuIG9yaWdEYXRlcyBhbmQgbmV3RGF0ZXNcbiAgICBuZXdEYXRlcyA9IG5ld0RhdGVzLnJlZHVjZShmdW5jdGlvbiAoZGF0ZXMsIGRhdGUpIHtcbiAgICAgIGlmICghb3JpZ0RhdGVzLmluY2x1ZGVzKGRhdGUpKSB7XG4gICAgICAgIGRhdGVzLnB1c2goZGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0ZXM7XG4gICAgfSwgb3JpZ0RhdGVzLmZpbHRlcihmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuICFuZXdEYXRlcy5pbmNsdWRlcyhkYXRlKTtcbiAgICB9KSk7XG4gIH1cbiAgLy8gZG8gbGVuZ3RoIGNoZWNrIGFsd2F5cyBiZWNhdXNlIHVzZXIgY2FuIGlucHV0IG11bHRpcGxlIGRhdGVzIHJlZ2FyZGxlc3Mgb2YgdGhlIG1vZGVcbiAgcmV0dXJuIGNvbmZpZy5tYXhOdW1iZXJPZkRhdGVzICYmIG5ld0RhdGVzLmxlbmd0aCA+IGNvbmZpZy5tYXhOdW1iZXJPZkRhdGVzID8gbmV3RGF0ZXMuc2xpY2UoY29uZmlnLm1heE51bWJlck9mRGF0ZXMgKiAtMSkgOiBuZXdEYXRlcztcbn1cblxuLy8gcmVmcmVzaCB0aGUgVUkgZWxlbWVudHNcbi8vIG1vZGVzOiAxOiBpbnB1dCBvbmx5LCAyLCBwaWNrZXIgb25seSwgMyBib3RoXG5mdW5jdGlvbiByZWZyZXNoVUkoZGF0ZXBpY2tlcikge1xuICB2YXIgbW9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMztcbiAgdmFyIHF1aWNrUmVuZGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICB2YXIgY29uZmlnID0gZGF0ZXBpY2tlci5jb25maWcsXG4gICAgcGlja2VyID0gZGF0ZXBpY2tlci5waWNrZXIsXG4gICAgaW5wdXRGaWVsZCA9IGRhdGVwaWNrZXIuaW5wdXRGaWVsZDtcbiAgaWYgKG1vZGUgJiAyKSB7XG4gICAgdmFyIG5ld1ZpZXcgPSBwaWNrZXIuYWN0aXZlID8gY29uZmlnLnBpY2tMZXZlbCA6IGNvbmZpZy5zdGFydFZpZXc7XG4gICAgcGlja2VyLnVwZGF0ZSgpLmNoYW5nZVZpZXcobmV3VmlldykucmVuZGVyKHF1aWNrUmVuZGVyKTtcbiAgfVxuICBpZiAobW9kZSAmIDEgJiYgaW5wdXRGaWVsZCkge1xuICAgIGlucHV0RmllbGQudmFsdWUgPSBzdHJpbmdpZnlEYXRlcyhkYXRlcGlja2VyLmRhdGVzLCBjb25maWcpO1xuICB9XG59XG5mdW5jdGlvbiBfc2V0RGF0ZShkYXRlcGlja2VyLCBpbnB1dERhdGVzLCBvcHRpb25zKSB7XG4gIHZhciBjbGVhciA9IG9wdGlvbnMuY2xlYXIsXG4gICAgcmVuZGVyID0gb3B0aW9ucy5yZW5kZXIsXG4gICAgYXV0b2hpZGUgPSBvcHRpb25zLmF1dG9oaWRlO1xuICBpZiAocmVuZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZW5kZXIgPSB0cnVlO1xuICB9XG4gIGlmICghcmVuZGVyKSB7XG4gICAgYXV0b2hpZGUgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChhdXRvaGlkZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXV0b2hpZGUgPSBkYXRlcGlja2VyLmNvbmZpZy5hdXRvaGlkZTtcbiAgfVxuICB2YXIgbmV3RGF0ZXMgPSBwcm9jZXNzSW5wdXREYXRlcyhkYXRlcGlja2VyLCBpbnB1dERhdGVzLCBjbGVhcik7XG4gIGlmICghbmV3RGF0ZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG5ld0RhdGVzLnRvU3RyaW5nKCkgIT09IGRhdGVwaWNrZXIuZGF0ZXMudG9TdHJpbmcoKSkge1xuICAgIGRhdGVwaWNrZXIuZGF0ZXMgPSBuZXdEYXRlcztcbiAgICByZWZyZXNoVUkoZGF0ZXBpY2tlciwgcmVuZGVyID8gMyA6IDEpO1xuICAgIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQoZGF0ZXBpY2tlciwgJ2NoYW5nZURhdGUnKTtcbiAgfSBlbHNlIHtcbiAgICByZWZyZXNoVUkoZGF0ZXBpY2tlciwgMSk7XG4gIH1cbiAgaWYgKGF1dG9oaWRlKSB7XG4gICAgZGF0ZXBpY2tlci5oaWRlKCk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGRhdGUgcGlja2VyXHJcbiAqL1xudmFyIERhdGVwaWNrZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBDcmVhdGUgYSBkYXRlIHBpY2tlclxyXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGJpbmQgYSBkYXRlIHBpY2tlclxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIC0gY29uZmlnIG9wdGlvbnNcclxuICAgKiBAcGFyYW0gIHtEYXRlUmFuZ2VQaWNrZXJ9IFtyYW5nZXBpY2tlcl0gLSBEYXRlUmFuZ2VQaWNrZXIgaW5zdGFuY2UgdGhlXHJcbiAgICogZGF0ZSBwaWNrZXIgYmVsb25ncyB0by4gVXNlIHRoaXMgb25seSB3aGVuIGNyZWF0aW5nIGRhdGUgcGlja2VyIGFzIGEgcGFydFxyXG4gICAqIG9mIGRhdGUgcmFuZ2UgcGlja2VyXHJcbiAgICovXG4gIGZ1bmN0aW9uIERhdGVwaWNrZXIoZWxlbWVudCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgcmFuZ2VwaWNrZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0ZXBpY2tlcik7XG4gICAgZWxlbWVudC5kYXRlcGlja2VyID0gdGhpcztcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgLy8gc2V0IHVwIGNvbmZpZ1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgYnV0dG9uQ2xhc3M6IG9wdGlvbnMuYnV0dG9uQ2xhc3MgJiYgU3RyaW5nKG9wdGlvbnMuYnV0dG9uQ2xhc3MpIHx8ICdidXR0b24nLFxuICAgICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAgZGVmYXVsdFZpZXdEYXRlOiB0b2RheSgpLFxuICAgICAgbWF4RGF0ZTogdW5kZWZpbmVkLFxuICAgICAgbWluRGF0ZTogdW5kZWZpbmVkXG4gICAgfSwgcHJvY2Vzc09wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIHRoaXMpKTtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgcHJvY2Vzc09wdGlvbnMob3B0aW9ucywgdGhpcykpO1xuXG4gICAgLy8gY29uZmlndXJlIGJ5IHR5cGVcbiAgICB2YXIgaW5saW5lID0gdGhpcy5pbmxpbmUgPSBlbGVtZW50LnRhZ05hbWUgIT09ICdJTlBVVCc7XG4gICAgdmFyIGlucHV0RmllbGQ7XG4gICAgdmFyIGluaXRpYWxEYXRlcztcbiAgICBpZiAoaW5saW5lKSB7XG4gICAgICBjb25maWcuY29udGFpbmVyID0gZWxlbWVudDtcbiAgICAgIGluaXRpYWxEYXRlcyA9IHN0cmluZ1RvQXJyYXkoZWxlbWVudC5kYXRhc2V0LmRhdGUsIGNvbmZpZy5kYXRlRGVsaW1pdGVyKTtcbiAgICAgIGRlbGV0ZSBlbGVtZW50LmRhdGFzZXQuZGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihvcHRpb25zLmNvbnRhaW5lcikgOiBudWxsO1xuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICBjb25maWcuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgfVxuICAgICAgaW5wdXRGaWVsZCA9IHRoaXMuaW5wdXRGaWVsZCA9IGVsZW1lbnQ7XG4gICAgICBpbnB1dEZpZWxkLmNsYXNzTGlzdC5hZGQoJ2RhdGVwaWNrZXItaW5wdXQnKTtcbiAgICAgIGluaXRpYWxEYXRlcyA9IHN0cmluZ1RvQXJyYXkoaW5wdXRGaWVsZC52YWx1ZSwgY29uZmlnLmRhdGVEZWxpbWl0ZXIpO1xuICAgIH1cbiAgICBpZiAocmFuZ2VwaWNrZXIpIHtcbiAgICAgIC8vIGNoZWNrIHZhbGlkaXJ5XG4gICAgICB2YXIgaW5kZXggPSByYW5nZXBpY2tlci5pbnB1dHMuaW5kZXhPZihpbnB1dEZpZWxkKTtcbiAgICAgIHZhciBkYXRlcGlja2VycyA9IHJhbmdlcGlja2VyLmRhdGVwaWNrZXJzO1xuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IDEgfHwgIUFycmF5LmlzQXJyYXkoZGF0ZXBpY2tlcnMpKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHJhbmdlcGlja2VyIG9iamVjdC4nKTtcbiAgICAgIH1cbiAgICAgIC8vIGF0dGFjaCBpdGFlbGYgdG8gdGhlIHJhbmdlcGlja2VyIGhlcmUgc28gdGhhdCBwcm9jZXNzSW5wdXREYXRlcygpIGNhblxuICAgICAgLy8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgdGhlIHJhbmdlLWVuZCBwaWNrZXIgb2YgdGhlIHJhbmdlcGlja2VyIHdoaWxlXG4gICAgICAvLyBzZXR0aW5nIGluaXRhbCB2YWx1ZXMgd2hlbiBwaWNrTGV2ZWwgPiAwXG4gICAgICBkYXRlcGlja2Vyc1tpbmRleF0gPSB0aGlzO1xuICAgICAgLy8gYWRkIGdldHRlciBmb3IgcmFuZ2VwaWNrZXJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmFuZ2VwaWNrZXInLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiByYW5nZXBpY2tlcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGluaXRpYWwgZGF0ZXNcbiAgICB0aGlzLmRhdGVzID0gW107XG4gICAgLy8gcHJvY2VzcyBpbml0aWFsIHZhbHVlXG4gICAgdmFyIGlucHV0RGF0ZVZhbHVlcyA9IHByb2Nlc3NJbnB1dERhdGVzKHRoaXMsIGluaXRpYWxEYXRlcyk7XG4gICAgaWYgKGlucHV0RGF0ZVZhbHVlcyAmJiBpbnB1dERhdGVWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5kYXRlcyA9IGlucHV0RGF0ZVZhbHVlcztcbiAgICB9XG4gICAgaWYgKGlucHV0RmllbGQpIHtcbiAgICAgIGlucHV0RmllbGQudmFsdWUgPSBzdHJpbmdpZnlEYXRlcyh0aGlzLmRhdGVzLCBjb25maWcpO1xuICAgIH1cbiAgICB2YXIgcGlja2VyID0gdGhpcy5waWNrZXIgPSBuZXcgUGlja2VyKHRoaXMpO1xuICAgIGlmIChpbmxpbmUpIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzZXQgdXAgZXZlbnQgbGlzdGVuZXJzIGluIG90aGVyIG1vZGVzXG4gICAgICB2YXIgb25Nb3VzZWRvd25Eb2N1bWVudCA9IG9uQ2xpY2tPdXRzaWRlLmJpbmQobnVsbCwgdGhpcyk7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gW1tpbnB1dEZpZWxkLCAna2V5ZG93bicsIG9uS2V5ZG93bi5iaW5kKG51bGwsIHRoaXMpXSwgW2lucHV0RmllbGQsICdmb2N1cycsIG9uRm9jdXMuYmluZChudWxsLCB0aGlzKV0sIFtpbnB1dEZpZWxkLCAnbW91c2Vkb3duJywgb25Nb3VzZWRvd24uYmluZChudWxsLCB0aGlzKV0sIFtpbnB1dEZpZWxkLCAnY2xpY2snLCBvbkNsaWNrSW5wdXQuYmluZChudWxsLCB0aGlzKV0sIFtpbnB1dEZpZWxkLCAncGFzdGUnLCBvblBhc3RlLmJpbmQobnVsbCwgdGhpcyldLCBbZG9jdW1lbnQsICdtb3VzZWRvd24nLCBvbk1vdXNlZG93bkRvY3VtZW50XSwgW2RvY3VtZW50LCAndG91Y2hzdGFydCcsIG9uTW91c2Vkb3duRG9jdW1lbnRdLCBbd2luZG93LCAncmVzaXplJywgcGlja2VyLnBsYWNlLmJpbmQocGlja2VyKV1dO1xuICAgICAgcmVnaXN0ZXJMaXN0ZW5lcnModGhpcywgbGlzdGVuZXJzKTtcbiAgICB9XG4gIH1cblxuICAvKipcclxuICAgKiBGb3JtYXQgRGF0ZSBvYmplY3Qgb3IgdGltZSB2YWx1ZSBpbiBnaXZlbiBmb3JtYXQgYW5kIGxhbmd1YWdlXHJcbiAgICogQHBhcmFtICB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSBkYXRlIG9yIHRpbWUgdmFsdWUgdG8gZm9ybWF0XHJcbiAgICogQHBhcmFtICB7U3RyaW5nfE9iamVjdH0gZm9ybWF0IC0gZm9ybWF0IHN0cmluZyBvciBvYmplY3QgdGhhdCBjb250YWluc1xyXG4gICAqIHRvRGlzcGxheSgpIGN1c3RvbSBmb3JtYXR0ZXIsIHdob3NlIHNpZ25hdHVyZSBpc1xyXG4gICAqIC0gYXJnczpcclxuICAgKiAgIC0gZGF0ZToge0RhdGV9IC0gRGF0ZSBpbnN0YW5jZSBvZiB0aGUgZGF0ZSBwYXNzZWQgdG8gdGhlIG1ldGhvZFxyXG4gICAqICAgLSBmb3JtYXQ6IHtPYmplY3R9IC0gdGhlIGZvcm1hdCBvYmplY3QgcGFzc2VkIHRvIHRoZSBtZXRob2RcclxuICAgKiAgIC0gbG9jYWxlOiB7T2JqZWN0fSAtIGxvY2FsZSBmb3IgdGhlIGxhbmd1YWdlIHNwZWNpZmllZCBieSBgbGFuZ2BcclxuICAgKiAtIHJldHVybjpcclxuICAgKiAgICAge1N0cmluZ30gZm9ybWF0dGVkIGRhdGVcclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtsYW5nPWVuXSAtIGxhbmd1YWdlIGNvZGUgZm9yIHRoZSBsb2NhbGUgdG8gdXNlXHJcbiAgICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWQgZGF0ZVxyXG4gICAqL1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKERhdGVwaWNrZXIsIFt7XG4gICAga2V5OiBcImFjdGl2ZVwiLFxuICAgIGdldDpcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtCb29sZWFufSAtIFdoZXRoZXIgdGhlIHBpY2tlciBlbGVtZW50IGlzIHNob3duLiBgdHJ1ZWAgd2huZSBzaG93blxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICEhKHRoaXMucGlja2VyICYmIHRoaXMucGlja2VyLmFjdGl2ZSk7XG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9IC0gRE9NIG9iamVjdCBvZiBwaWNrZXIgZWxlbWVudFxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicGlja2VyRWxlbWVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGlja2VyID8gdGhpcy5waWNrZXIuZWxlbWVudCA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAqIFNldCBuZXcgdmFsdWVzIHRvIHRoZSBjb25maWcgb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWcgb3B0aW9ucyB0byB1cGRhdGVcclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgcGlja2VyID0gdGhpcy5waWNrZXI7XG4gICAgICB2YXIgbmV3T3B0aW9ucyA9IHByb2Nlc3NPcHRpb25zKG9wdGlvbnMsIHRoaXMpO1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb25maWcsIG5ld09wdGlvbnMpO1xuICAgICAgcGlja2VyLnNldE9wdGlvbnMobmV3T3B0aW9ucyk7XG4gICAgICByZWZyZXNoVUkodGhpcywgMyk7XG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IHRoZSBwaWNrZXIgZWxlbWVudFxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgaWYgKHRoaXMuaW5wdXRGaWVsZCkge1xuICAgICAgICBpZiAodGhpcy5pbnB1dEZpZWxkLmRpc2FibGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlucHV0RmllbGQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLl9zaG93aW5nID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmlucHV0RmllbGQuZm9jdXMoKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fc2hvd2luZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5waWNrZXIuc2hvdygpO1xuICAgIH1cblxuICAgIC8qKlxyXG4gICAgICogSGlkZSB0aGUgcGlja2VyIGVsZW1lbnRcclxuICAgICAqIE5vdCBhdmFpbGFibGUgb24gaW5saW5lIHBpY2tlclxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgaWYgKHRoaXMuaW5saW5lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGlja2VyLmhpZGUoKTtcbiAgICAgIHRoaXMucGlja2VyLnVwZGF0ZSgpLmNoYW5nZVZpZXcodGhpcy5jb25maWcuc3RhcnRWaWV3KS5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kgdGhlIERhdGVwaWNrZXIgaW5zdGFuY2VcclxuICAgICAqIEByZXR1cm4ge0RldGVwaWNrZXJ9IC0gdGhlIGluc3RhbmNlIGRlc3Ryb3llZFxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB1bnJlZ2lzdGVyTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgdGhpcy5waWNrZXIuZGV0YWNoKCk7XG4gICAgICBpZiAoIXRoaXMuaW5saW5lKSB7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5jbGFzc0xpc3QucmVtb3ZlKCdkYXRlcGlja2VyLWlucHV0Jyk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5lbGVtZW50LmRhdGVwaWNrZXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc2VsZWN0ZWQgZGF0ZShzKVxyXG4gICAgICpcclxuICAgICAqIFRoZSBtZXRob2QgcmV0dXJucyBhIERhdGUgb2JqZWN0IG9mIHNlbGVjdGVkIGRhdGUgYnkgZGVmYXVsdCwgYW5kIHJldHVybnNcclxuICAgICAqIGFuIGFycmF5IG9mIHNlbGVjdGVkIGRhdGVzIGluIG11bHRpZGF0ZSBtb2RlLiBJZiBmb3JtYXQgc3RyaW5nIGlzIHBhc3NlZCxcclxuICAgICAqIGl0IHJldHVybnMgZGF0ZSBzdHJpbmcocykgZm9ybWF0dGVkIGluIGdpdmVuIGZvcm1hdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtmb3JtYXRdIC0gRm9ybWF0IHN0cmluZyB0byBzdHJpbmdpZnkgdGhlIGRhdGUocylcclxuICAgICAqIEByZXR1cm4ge0RhdGV8U3RyaW5nfERhdGVbXXxTdHJpbmdbXX0gLSBzZWxlY3RlZCBkYXRlKHMpLCBvciBpZiBub25lIGlzXHJcbiAgICAgKiBzZWxlY3RlZCwgZW1wdHkgYXJyYXkgaW4gbXVsdGlkYXRlIG1vZGUgYW5kIHVudGl0bGVkIGluIHNpZ2xlZGF0ZSBtb2RlXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXREYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERhdGUoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGZvcm1hdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGNhbGxiYWNrID0gZm9ybWF0ID8gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCBfdGhpcy5jb25maWcubG9jYWxlKTtcbiAgICAgIH0gOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY29uZmlnLm11bHRpZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlcy5tYXAoY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5kYXRlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgc2VsZWN0ZWQgZGF0ZShzKVxyXG4gICAgICpcclxuICAgICAqIEluIG11bHRpZGF0ZSBtb2RlLCB5b3UgY2FuIHBhc3MgbXVsdGlwbGUgZGF0ZXMgYXMgYSBzZXJpZXMgb2YgYXJndW1lbnRzXHJcbiAgICAgKiBvciBhbiBhcnJheS4gKFNpbmNlIGVhY2ggZGF0ZSBpcyBwYXJzZWQgaW5kaXZpZHVhbGx5LCB0aGUgdHlwZSBvZiB0aGVcclxuICAgICAqIGRhdGVzIGRvZXNuJ3QgaGF2ZSB0byBiZSB0aGUgc2FtZS4pXHJcbiAgICAgKiBUaGUgZ2l2ZW4gZGF0ZXMgYXJlIHVzZWQgdG8gdG9nZ2xlIHRoZSBzZWxlY3Qgc3RhdHVzIG9mIGVhY2ggZGF0ZS4gVGhlXHJcbiAgICAgKiBudW1iZXIgb2Ygc2VsZWN0ZWQgZGF0ZXMgaXMga2VwdCBmcm9tIGV4Y2VlZGluZyB0aGUgbGVuZ3RoIHNldCB0b1xyXG4gICAgICogbWF4TnVtYmVyT2ZEYXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBXaXRoIGNsZWFyOiB0cnVlIG9wdGlvbiwgdGhlIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBjbGVhciB0aGUgc2VsZWN0aW9uXHJcbiAgICAgKiBhbmQgdG8gcmVwbGFjZSB0aGUgc2VsZWN0aW9uIGluc3RlYWQgb2YgdG9nZ2xpbmcgaW4gbXVsdGlkYXRlIG1vZGUuXHJcbiAgICAgKiBJZiB0aGUgb3B0aW9uIGlzIHBhc3NlZCB3aXRoIG5vIGRhdGUgYXJndW1lbnRzIG9yIGFuIGVtcHR5IGRhdGVzIGFycmF5LFxyXG4gICAgICogaXQgd29ya3MgYXMgXCJjbGVhclwiIChjbGVhciB0aGUgc2VsZWN0aW9uIHRoZW4gc2V0IG5vdGhpbmcpLCBhbmQgaWYgdGhlXHJcbiAgICAgKiBvcHRpb24gaXMgcGFzc2VkIHdpdGggbmV3IGRhdGVzIHRvIHNlbGVjdCwgaXQgd29ya3MgYXMgXCJyZXBsYWNlXCIgKGNsZWFyXHJcbiAgICAgKiB0aGUgc2VsZWN0aW9uIHRoZW4gc2V0IHRoZSBnaXZlbiBkYXRlcylcclxuICAgICAqXHJcbiAgICAgKiBXaGVuIHJlbmRlcjogZmFsc2Ugb3B0aW9uIGlzIHVzZWQsIHRoZSBtZXRob2Qgb21pdHMgcmUtcmVuZGVyaW5nIHRoZVxyXG4gICAgICogcGlja2VyIGVsZW1lbnQuIEluIHRoaXMgY2FzZSwgeW91IG5lZWQgdG8gY2FsbCByZWZyZXNoKCkgbWV0aG9kIGxhdGVyIGluXHJcbiAgICAgKiBvcmRlciBmb3IgdGhlIHBpY2tlciBlbGVtZW50IHRvIHJlZmxlY3QgdGhlIGNoYW5nZXMuIFRoZSBpbnB1dCBmaWVsZCBpc1xyXG4gICAgICogcmVmcmVzaGVkIGFsd2F5cyByZWdhcmRsZXNzIG9mIHRoaXMgb3B0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFdoZW4gaW52YWxpZCAodW5wYXJzYWJsZSwgcmVwZWF0ZWQsIGRpc2FibGVkIG9yIG91dC1vZi1yYW5nZSkgZGF0ZXMgYXJlXHJcbiAgICAgKiBwYXNzZWQsIHRoZSBtZXRob2QgaWdub3JlcyB0aGVtIGFuZCBhcHBsaWVzIG9ubHkgdmFsaWQgb25lcy4gSW4gdGhlIGNhc2VcclxuICAgICAqIHRoYXQgYWxsIHRoZSBnaXZlbiBkYXRlcyBhcmUgaW52YWxpZCwgd2hpY2ggaXMgZGlzdGluZ3Vpc2hlZCBmcm9tIHBhc3NpbmdcclxuICAgICAqIG5vIGRhdGVzLCB0aGUgbWV0aG9kIGNvbnNpZGVycyBpdCBhcyBhbiBlcnJvciBhbmQgbGVhdmVzIHRoZSBzZWxlY3Rpb25cclxuICAgICAqIHVudG91Y2hlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gey4uLihEYXRlfE51bWJlcnxTdHJpbmcpfEFycmF5fSBbZGF0ZXNdIC0gRGF0ZSBzdHJpbmdzLCBEYXRlXHJcbiAgICAgKiBvYmplY3RzLCB0aW1lIHZhbHVlcyBvciBtaXggb2YgdGhvc2UgZm9yIG5ldyBzZWxlY3Rpb25cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBmdW5jdGlvbiBvcHRpb25zXHJcbiAgICAgKiAtIGNsZWFyOiB7Ym9vbGVhbn0gLSBXaGV0aGVyIHRvIGNsZWFyIHRoZSBleGlzdGluZyBzZWxlY3Rpb25cclxuICAgICAqICAgICBkZWZ1YWx0OiBmYWxzZVxyXG4gICAgICogLSByZW5kZXI6IHtib29sZWFufSAtIFdoZXRoZXIgdG8gcmUtcmVuZGVyIHRoZSBwaWNrZXIgZWxlbWVudFxyXG4gICAgICogICAgIGRlZmF1bHQ6IHRydWVcclxuICAgICAqIC0gYXV0b2hpZGU6IHtib29sZWFufSAtIFdoZXRoZXIgdG8gaGlkZSB0aGUgcGlja2VyIGVsZW1lbnQgYWZ0ZXIgcmUtcmVuZGVyXHJcbiAgICAgKiAgICAgSWdub3JlZCB3aGVuIHVzZWQgd2l0aCByZW5kZXI6IGZhbHNlXHJcbiAgICAgKiAgICAgZGVmYXVsdDogY29uZmlnLmF1dG9oaWRlXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXREYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGUoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRlcyA9IFtdLmNvbmNhdChhcmdzKTtcbiAgICAgIHZhciBvcHRzID0ge307XG4gICAgICB2YXIgbGFzdEFyZyA9IGxhc3RJdGVtT2YoYXJncyk7XG4gICAgICBpZiAoX3R5cGVvZihsYXN0QXJnKSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkobGFzdEFyZykgJiYgIShsYXN0QXJnIGluc3RhbmNlb2YgRGF0ZSkgJiYgbGFzdEFyZykge1xuICAgICAgICBPYmplY3QuYXNzaWduKG9wdHMsIGRhdGVzLnBvcCgpKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbnB1dERhdGVzID0gQXJyYXkuaXNBcnJheShkYXRlc1swXSkgPyBkYXRlc1swXSA6IGRhdGVzO1xuICAgICAgX3NldERhdGUodGhpcywgaW5wdXREYXRlcywgb3B0cyk7XG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIHNlbGVjdGVkIGRhdGUocykgd2l0aCBpbnB1dCBmaWVsZCdzIHZhbHVlXHJcbiAgICAgKiBOb3QgYXZhaWxhYmxlIG9uIGlubGluZSBwaWNrZXJcclxuICAgICAqXHJcbiAgICAgKiBUaGUgaW5wdXQgZmllbGQgd2lsbCBiZSByZWZyZXNoZWQgd2l0aCBwcm9wZXJseSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gLSBmdW5jdGlvbiBvcHRpb25zXHJcbiAgICAgKiAtIGF1dG9oaWRlOiB7Ym9vbGVhbn0gLSB3aGV0aGVyIHRvIGhpZGUgdGhlIHBpY2tlciBlbGVtZW50IGFmdGVyIHJlZnJlc2hcclxuICAgICAqICAgICBkZWZhdWx0OiBmYWxzZVxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIGNsZWFyOiB0cnVlLFxuICAgICAgICBhdXRvaGlkZTogISEob3B0aW9ucyAmJiBvcHRpb25zLmF1dG9oaWRlKVxuICAgICAgfTtcbiAgICAgIHZhciBpbnB1dERhdGVzID0gc3RyaW5nVG9BcnJheSh0aGlzLmlucHV0RmllbGQudmFsdWUsIHRoaXMuY29uZmlnLmRhdGVEZWxpbWl0ZXIpO1xuICAgICAgX3NldERhdGUodGhpcywgaW5wdXREYXRlcywgb3B0cyk7XG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoIHRoZSBwaWNrZXIgZWxlbWVudCBhbmQgdGhlIGFzc29jaWF0ZWQgaW5wdXQgZmllbGRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbdGFyZ2V0XSAtIHRhcmdldCBpdGVtIHdoZW4gcmVmcmVzaGluZyBvbmUgaXRlbSBvbmx5XHJcbiAgICAgKiAncGlja2VyJyBvciAnaW5wdXQnXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZVJlbmRlcl0gLSB3aGV0aGVyIHRvIHJlLXJlbmRlciB0aGUgcGlja2VyIGVsZW1lbnRcclxuICAgICAqIHJlZ2FyZGxlc3Mgb2YgaXRzIHN0YXRlIGluc3RlYWQgb2Ygb3B0aW1pemVkIHJlZnJlc2hcclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBmb3JjZVJlbmRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICBpZiAodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyID0gdGFyZ2V0O1xuICAgICAgICB0YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgbW9kZTtcbiAgICAgIGlmICh0YXJnZXQgPT09ICdwaWNrZXInKSB7XG4gICAgICAgIG1vZGUgPSAyO1xuICAgICAgfSBlbHNlIGlmICh0YXJnZXQgPT09ICdpbnB1dCcpIHtcbiAgICAgICAgbW9kZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlID0gMztcbiAgICAgIH1cbiAgICAgIHJlZnJlc2hVSSh0aGlzLCBtb2RlLCAhZm9yY2VSZW5kZXIpO1xuICAgIH1cblxuICAgIC8qKlxyXG4gICAgICogRW50ZXIgZWRpdCBtb2RlXHJcbiAgICAgKiBOb3QgYXZhaWxhYmxlIG9uIGlubGluZSBwaWNrZXIgb3Igd2hlbiB0aGUgcGlja2VyIGVsZW1lbnQgaXMgaGlkZGVuXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJlbnRlckVkaXRNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVudGVyRWRpdE1vZGUoKSB7XG4gICAgICBpZiAodGhpcy5pbmxpbmUgfHwgIXRoaXMucGlja2VyLmFjdGl2ZSB8fCB0aGlzLmVkaXRNb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xuICAgICAgdGhpcy5pbnB1dEZpZWxkLmNsYXNzTGlzdC5hZGQoJ2luLWVkaXQnLCAnYm9yZGVyLWJsdWUtNzAwJywgJyFib3JkZXItcHJpbWFyeS03MDAnKTtcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAqIEV4aXQgZnJvbSBlZGl0IG1vZGVcclxuICAgICAqIE5vdCBhdmFpbGFibGUgb24gaW5saW5lIHBpY2tlclxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gLSBmdW5jdGlvbiBvcHRpb25zXHJcbiAgICAgKiAtIHVwZGF0ZToge2Jvb2xlYW59IC0gd2hldGhlciB0byBjYWxsIHVwZGF0ZSgpIGFmdGVyIGV4aXRpbmdcclxuICAgICAqICAgICBJZiBmYWxzZSwgaW5wdXQgZmllbGQgaXMgcmV2ZXJ0IHRvIHRoZSBleGlzdGluZyBzZWxlY3Rpb25cclxuICAgICAqICAgICBkZWZhdWx0OiBmYWxzZVxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZXhpdEVkaXRNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4aXRFZGl0TW9kZSgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodGhpcy5pbmxpbmUgfHwgIXRoaXMuZWRpdE1vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgdXBkYXRlOiBmYWxzZVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICBkZWxldGUgdGhpcy5lZGl0TW9kZTtcbiAgICAgIHRoaXMuaW5wdXRGaWVsZC5jbGFzc0xpc3QucmVtb3ZlKCdpbi1lZGl0JywgJ2JvcmRlci1ibHVlLTcwMCcsICchYm9yZGVyLXByaW1hcnktNzAwJyk7XG4gICAgICBpZiAob3B0cy51cGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUob3B0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZm9ybWF0RGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXREYXRlJDEoZGF0ZSwgZm9ybWF0LCBsYW5nKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIGxhbmcgJiYgbG9jYWxlc1tsYW5nXSB8fCBsb2NhbGVzLmVuKTtcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAqIFBhcnNlIGRhdGUgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8RGF0ZXxOdW1iZXJ9IGRhdGVTdHIgLSBkYXRlIHN0cmluZywgRGF0ZSBvYmplY3Qgb3IgdGltZVxyXG4gICAgICogdmFsdWUgdG8gcGFyc2VcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ3xPYmplY3R9IGZvcm1hdCAtIGZvcm1hdCBzdHJpbmcgb3Igb2JqZWN0IHRoYXQgY29udGFpbnNcclxuICAgICAqIHRvVmFsdWUoKSBjdXN0b20gcGFyc2VyLCB3aG9zZSBzaWduYXR1cmUgaXNcclxuICAgICAqIC0gYXJnczpcclxuICAgICAqICAgLSBkYXRlU3RyOiB7U3RyaW5nfERhdGV8TnVtYmVyfSAtIHRoZSBkYXRlU3RyIHBhc3NlZCB0byB0aGUgbWV0aG9kXHJcbiAgICAgKiAgIC0gZm9ybWF0OiB7T2JqZWN0fSAtIHRoZSBmb3JtYXQgb2JqZWN0IHBhc3NlZCB0byB0aGUgbWV0aG9kXHJcbiAgICAgKiAgIC0gbG9jYWxlOiB7T2JqZWN0fSAtIGxvY2FsZSBmb3IgdGhlIGxhbmd1YWdlIHNwZWNpZmllZCBieSBgbGFuZ2BcclxuICAgICAqIC0gcmV0dXJuOlxyXG4gICAgICogICAgIHtEYXRlfE51bWJlcn0gcGFyc2VkIGRhdGUgb3IgaXRzIHRpbWUgdmFsdWVcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW2xhbmc9ZW5dIC0gbGFuZ3VhZ2UgY29kZSBmb3IgdGhlIGxvY2FsZSB0byB1c2VcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gdGltZSB2YWx1ZSBvZiBwYXJzZWQgZGF0ZVxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VEYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlRGF0ZSQxKGRhdGVTdHIsIGZvcm1hdCwgbGFuZykge1xuICAgICAgcmV0dXJuIHBhcnNlRGF0ZShkYXRlU3RyLCBmb3JtYXQsIGxhbmcgJiYgbG9jYWxlc1tsYW5nXSB8fCBsb2NhbGVzLmVuKTtcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtPYmplY3R9IC0gSW5zdGFsbGVkIGxvY2FsZXMgaW4gYFtsYW5ndWFnZUNvZGVdOiBsb2NhbGVPYmplY3RgIGZvcm1hdFxyXG4gICAgICogZW5gOl9FbmdsaXNoIChVUylfIGlzIHByZS1pbnN0YWxsZWQuXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJsb2NhbGVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gbG9jYWxlcztcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxuLy8gZmlsdGVyIG91dCB0aGUgY29uZmlnIG9wdGlvbnMgaW5hcHByb3ByaXRlIHRvIHBhc3MgdG8gRGF0ZXBpY2tlclxuZnVuY3Rpb24gZmlsdGVyT3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBuZXdPcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gIGRlbGV0ZSBuZXdPcHRzLmlucHV0cztcbiAgZGVsZXRlIG5ld09wdHMuYWxsb3dPbmVTaWRlZFJhbmdlO1xuICBkZWxldGUgbmV3T3B0cy5tYXhOdW1iZXJPZkRhdGVzOyAvLyB0byBlbnN1cmUgZWFjaCBkYXRlcGlja2VyIGhhbmRsZXMgYSBzaW5nbGUgZGF0ZVxuXG4gIHJldHVybiBuZXdPcHRzO1xufVxuZnVuY3Rpb24gc2V0dXBEYXRlcGlja2VyKHJhbmdlcGlja2VyLCBjaGFuZ2VEYXRlTGlzdGVuZXIsIGVsLCBvcHRpb25zKSB7XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKHJhbmdlcGlja2VyLCBbW2VsLCAnY2hhbmdlRGF0ZScsIGNoYW5nZURhdGVMaXN0ZW5lcl1dKTtcbiAgbmV3IERhdGVwaWNrZXIoZWwsIG9wdGlvbnMsIHJhbmdlcGlja2VyKTtcbn1cbmZ1bmN0aW9uIG9uQ2hhbmdlRGF0ZShyYW5nZXBpY2tlciwgZXYpIHtcbiAgLy8gdG8gcHJldmVudCBib3RoIGRhdGVwaWNrZXJzIHRyaWdnZXIgdGhlIG90aGVyIHNpZGUncyB1cGRhdGUgZWFjaCBvdGhlclxuICBpZiAocmFuZ2VwaWNrZXIuX3VwZGF0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJhbmdlcGlja2VyLl91cGRhdGluZyA9IHRydWU7XG4gIHZhciB0YXJnZXQgPSBldi50YXJnZXQ7XG4gIGlmICh0YXJnZXQuZGF0ZXBpY2tlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBkYXRlcGlja2VycyA9IHJhbmdlcGlja2VyLmRhdGVwaWNrZXJzO1xuICB2YXIgc2V0RGF0ZU9wdGlvbnMgPSB7XG4gICAgcmVuZGVyOiBmYWxzZVxuICB9O1xuICB2YXIgY2hhbmdlZFNpZGUgPSByYW5nZXBpY2tlci5pbnB1dHMuaW5kZXhPZih0YXJnZXQpO1xuICB2YXIgb3RoZXJTaWRlID0gY2hhbmdlZFNpZGUgPT09IDAgPyAxIDogMDtcbiAgdmFyIGNoYW5nZWREYXRlID0gZGF0ZXBpY2tlcnNbY2hhbmdlZFNpZGVdLmRhdGVzWzBdO1xuICB2YXIgb3RoZXJEYXRlID0gZGF0ZXBpY2tlcnNbb3RoZXJTaWRlXS5kYXRlc1swXTtcbiAgaWYgKGNoYW5nZWREYXRlICE9PSB1bmRlZmluZWQgJiYgb3RoZXJEYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBpZiB0aGUgc3RhcnQgb2YgdGhlIHJhbmdlID4gdGhlIGVuZCwgc3dhcCB0aGVtXG4gICAgaWYgKGNoYW5nZWRTaWRlID09PSAwICYmIGNoYW5nZWREYXRlID4gb3RoZXJEYXRlKSB7XG4gICAgICBkYXRlcGlja2Vyc1swXS5zZXREYXRlKG90aGVyRGF0ZSwgc2V0RGF0ZU9wdGlvbnMpO1xuICAgICAgZGF0ZXBpY2tlcnNbMV0uc2V0RGF0ZShjaGFuZ2VkRGF0ZSwgc2V0RGF0ZU9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlZFNpZGUgPT09IDEgJiYgY2hhbmdlZERhdGUgPCBvdGhlckRhdGUpIHtcbiAgICAgIGRhdGVwaWNrZXJzWzBdLnNldERhdGUoY2hhbmdlZERhdGUsIHNldERhdGVPcHRpb25zKTtcbiAgICAgIGRhdGVwaWNrZXJzWzFdLnNldERhdGUob3RoZXJEYXRlLCBzZXREYXRlT3B0aW9ucyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFyYW5nZXBpY2tlci5hbGxvd09uZVNpZGVkUmFuZ2UpIHtcbiAgICAvLyB0byBwcmV2ZW50IHRoZSByYW5nZSBmcm9tIGJlY29taW5nIG9uZS1zaWRlZCwgY29weSBjaGFuZ2VkIHNpZGUnc1xuICAgIC8vIHNlbGVjdGlvbiAobm8gbWF0dGVyIGlmIGl0J3MgZW1wdHkpIHRvIHRoZSBvdGhlciBzaWRlXG4gICAgaWYgKGNoYW5nZWREYXRlICE9PSB1bmRlZmluZWQgfHwgb3RoZXJEYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNldERhdGVPcHRpb25zLmNsZWFyID0gdHJ1ZTtcbiAgICAgIGRhdGVwaWNrZXJzW290aGVyU2lkZV0uc2V0RGF0ZShkYXRlcGlja2Vyc1tjaGFuZ2VkU2lkZV0uZGF0ZXMsIHNldERhdGVPcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgZGF0ZXBpY2tlcnNbMF0ucGlja2VyLnVwZGF0ZSgpLnJlbmRlcigpO1xuICBkYXRlcGlja2Vyc1sxXS5waWNrZXIudXBkYXRlKCkucmVuZGVyKCk7XG4gIGRlbGV0ZSByYW5nZXBpY2tlci5fdXBkYXRpbmc7XG59XG5cbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBkYXRlIHJhbmdlIHBpY2tlclxyXG4gKi9cbnZhciBEYXRlUmFuZ2VQaWNrZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBDcmVhdGUgYSBkYXRlIHJhbmdlIHBpY2tlclxyXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGJpbmQgYSBkYXRlIHJhbmdlIHBpY2tlclxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIC0gY29uZmlnIG9wdGlvbnNcclxuICAgKi9cbiAgZnVuY3Rpb24gRGF0ZVJhbmdlUGlja2VyKGVsZW1lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGVSYW5nZVBpY2tlcik7XG4gICAgdmFyIGlucHV0cyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5pbnB1dHMpID8gb3B0aW9ucy5pbnB1dHMgOiBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKSk7XG4gICAgaWYgKGlucHV0cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZW1lbnQucmFuZ2VwaWNrZXIgPSB0aGlzO1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5pbnB1dHMgPSBpbnB1dHMuc2xpY2UoMCwgMik7XG4gICAgdGhpcy5hbGxvd09uZVNpZGVkUmFuZ2UgPSAhIW9wdGlvbnMuYWxsb3dPbmVTaWRlZFJhbmdlO1xuICAgIHZhciBjaGFuZ2VEYXRlTGlzdGVuZXIgPSBvbkNoYW5nZURhdGUuYmluZChudWxsLCB0aGlzKTtcbiAgICB2YXIgY2xlYW5PcHRpb25zID0gZmlsdGVyT3B0aW9ucyhvcHRpb25zKTtcbiAgICAvLyBpbiBvcmRlciBmb3IgaW5pdGlhbCBkYXRlIHNldHVwIHRvIHdvcmsgcmlnaHQgd2hlbiBwY2ljTHZlbCA+IDAsXG4gICAgLy8gbGV0IERhdGVwaWNrZXIgY29uc3RydWN0b3IgYWRkIHRoZSBpbnN0YW5jZSB0byB0aGUgcmFuZ2VwaWNrZXJcbiAgICB2YXIgZGF0ZXBpY2tlcnMgPSBbXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2RhdGVwaWNrZXJzJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBkYXRlcGlja2VycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZXR1cERhdGVwaWNrZXIodGhpcywgY2hhbmdlRGF0ZUxpc3RlbmVyLCB0aGlzLmlucHV0c1swXSwgY2xlYW5PcHRpb25zKTtcbiAgICBzZXR1cERhdGVwaWNrZXIodGhpcywgY2hhbmdlRGF0ZUxpc3RlbmVyLCB0aGlzLmlucHV0c1sxXSwgY2xlYW5PcHRpb25zKTtcbiAgICBPYmplY3QuZnJlZXplKGRhdGVwaWNrZXJzKTtcbiAgICAvLyBub3JtYWxpemUgdGhlIHJhbmdlIGlmIGluaXRhbCBkYXRlcyBhcmUgZ2l2ZW5cbiAgICBpZiAoZGF0ZXBpY2tlcnNbMF0uZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgb25DaGFuZ2VEYXRlKHRoaXMsIHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmlucHV0c1swXVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChkYXRlcGlja2Vyc1sxXS5kYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBvbkNoYW5nZURhdGUodGhpcywge1xuICAgICAgICB0YXJnZXQ6IHRoaXMuaW5wdXRzWzFdXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcclxuICAgKiBAdHlwZSB7QXJyYXl9IC0gc2VsZWN0ZWQgZGF0ZSBvZiB0aGUgbGlua2VkIGRhdGUgcGlja2Vyc1xyXG4gICAqL1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKERhdGVSYW5nZVBpY2tlciwgW3tcbiAgICBrZXk6IFwiZGF0ZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGVwaWNrZXJzLmxlbmd0aCA9PT0gMiA/IFt0aGlzLmRhdGVwaWNrZXJzWzBdLmRhdGVzWzBdLCB0aGlzLmRhdGVwaWNrZXJzWzFdLmRhdGVzWzBdXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAqIFNldCBuZXcgdmFsdWVzIHRvIHRoZSBjb25maWcgb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWcgb3B0aW9ucyB0byB1cGRhdGVcclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLmFsbG93T25lU2lkZWRSYW5nZSA9ICEhb3B0aW9ucy5hbGxvd09uZVNpZGVkUmFuZ2U7XG4gICAgICB2YXIgY2xlYW5PcHRpb25zID0gZmlsdGVyT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHRoaXMuZGF0ZXBpY2tlcnNbMF0uc2V0T3B0aW9ucyhjbGVhbk9wdGlvbnMpO1xuICAgICAgdGhpcy5kYXRlcGlja2Vyc1sxXS5zZXRPcHRpb25zKGNsZWFuT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95IHRoZSBEYXRlUmFuZ2VQaWNrZXIgaW5zdGFuY2VcclxuICAgICAqIEByZXR1cm4ge0RhdGVSYW5nZVBpY2tlcn0gLSB0aGUgaW5zdGFuY2UgZGVzdHJveWVkXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmRhdGVwaWNrZXJzWzBdLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZGF0ZXBpY2tlcnNbMV0uZGVzdHJveSgpO1xuICAgICAgdW5yZWdpc3Rlckxpc3RlbmVycyh0aGlzKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmVsZW1lbnQucmFuZ2VwaWNrZXI7XG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgb2YgdGhlIGRhdGUgcmFuZ2VcclxuICAgICAqXHJcbiAgICAgKiBUaGUgbWV0aG9kIHJldHVybnMgRGF0ZSBvYmplY3RzIGJ5IGRlZmF1bHQuIElmIGZvcm1hdCBzdHJpbmcgaXMgcGFzc2VkLFxyXG4gICAgICogaXQgcmV0dXJucyBkYXRlIHN0cmluZ3MgZm9ybWF0dGVkIGluIGdpdmVuIGZvcm1hdC5cclxuICAgICAqIFRoZSByZXN1bHQgYXJyYXkgYWx3YXlzIGNvbnRhaW5zIDIgaXRlbXMgKHN0YXJ0IGRhdGUvZW5kIGRhdGUpIGFuZFxyXG4gICAgICogdW5kZWZpbmVkIGlzIHVzZWQgZm9yIHVuc2VsZWN0ZWQgc2lkZS4gKGUuZy4gSWYgbm9uZSBpcyBzZWxlY3RlZCxcclxuICAgICAqIHRoZSByZXN1bHQgd2lsbCBiZSBbdW5kZWZpbmVkLCB1bmRlZmluZWRdLiBJZiBvbmx5IHRoZSBlbmQgZGF0ZSBpcyBzZXRcclxuICAgICAqIHdoZW4gYWxsb3dPbmVTaWRlZFJhbmdlIGNvbmZpZyBvcHRpb24gaXMgdHJ1ZSwgW3VuZGVmaW5lZCwgZW5kRGF0ZV0gd2lsbFxyXG4gICAgICogYmUgcmV0dXJuZWQuKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW2Zvcm1hdF0gLSBGb3JtYXQgc3RyaW5nIHRvIHN0cmluZ2lmeSB0aGUgZGF0ZXNcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSAtIFN0YXJ0IGFuZCBlbmQgZGF0ZXNcclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldERhdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERhdGVzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBmb3JtYXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBjYWxsYmFjayA9IGZvcm1hdCA/IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXREYXRlKGRhdGUsIGZvcm1hdCwgX3RoaXMuZGF0ZXBpY2tlcnNbMF0uY29uZmlnLmxvY2FsZSk7XG4gICAgICB9IDogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGVzLm1hcChmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZSA9PT0gdW5kZWZpbmVkID8gZGF0ZSA6IGNhbGxiYWNrKGRhdGUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgb2YgdGhlIGRhdGUgcmFuZ2VcclxuICAgICAqXHJcbiAgICAgKiBUaGUgbWV0aG9kIGNhbGxzIGRhdGVwaWNrZXIuc2V0RGF0ZSgpIGludGVybmFsbHkgdXNpbmcgZWFjaCBvZiB0aGVcclxuICAgICAqIGFyZ3VtZW50cyBpbiBzdGFydFx1MjE5MmVuZCBvcmRlci5cclxuICAgICAqXHJcbiAgICAgKiBXaGVuIGEgY2xlYXI6IHRydWUgb3B0aW9uIG9iamVjdCBpcyBwYXNzZWQgaW5zdGVhZCBvZiBhIGRhdGUsIHRoZSBtZXRob2RcclxuICAgICAqIGNsZWFycyB0aGUgZGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBJZiBhbiBpbnZhbGlkIGRhdGUsIHRoZSBzYW1lIGRhdGUgYXMgdGhlIGN1cnJlbnQgb25lIG9yIGFuIG9wdGlvbiBvYmplY3RcclxuICAgICAqIHdpdGhvdXQgY2xlYXI6IHRydWUgaXMgcGFzc2VkLCB0aGUgbWV0aG9kIGNvbnNpZGVycyB0aGF0IGFyZ3VtZW50IGFzIGFuXHJcbiAgICAgKiBcImluZWZmZWN0aXZlXCIgYXJndW1lbnQgYmVjYXVzZSBjYWxsaW5nIGRhdGVwaWNrZXIuc2V0RGF0ZSgpIHdpdGggdGhvc2VcclxuICAgICAqIHZhbHVlcyBtYWtlcyBubyBjaGFuZ2VzIHRvIHRoZSBkYXRlIHNlbGVjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBXaGVuIHRoZSBhbGxvd09uZVNpZGVkUmFuZ2UgY29uZmlnIG9wdGlvbiBpcyBmYWxzZSwgcGFzc2luZyB7Y2xlYXI6IHRydWV9XHJcbiAgICAgKiB0byBjbGVhciB0aGUgcmFuZ2Ugd29ya3Mgb25seSB3aGVuIGl0IGlzIGRvbmUgdG8gdGhlIGxhc3QgZWZmZWN0aXZlXHJcbiAgICAgKiBhcmd1bWVudCAoaW4gb3RoZXIgd29yZHMsIHBhc3NlZCB0byByYW5nZUVuZCBvciB0byByYW5nZVN0YXJ0IGFsb25nIHdpdGhcclxuICAgICAqIGluZWZmZWN0aXZlIHJhbmdlRW5kKS4gVGhpcyBpcyBiZWNhdXNlIHdoZW4gdGhlIGRhdGUgcmFuZ2UgaXMgY2hhbmdlZCxcclxuICAgICAqIGl0IGdldHMgbm9ybWFsaXplZCBiYXNlZCBvbiB0aGUgbGFzdCBjaGFuZ2UgYXQgdGhlIGVuZCBvZiB0aGUgY2hhbmdpbmdcclxuICAgICAqIHByb2Nlc3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtEYXRlfE51bWJlcnxTdHJpbmd8T2JqZWN0fSByYW5nZVN0YXJ0IC0gU3RhcnQgZGF0ZSBvZiB0aGUgcmFuZ2VcclxuICAgICAqIG9yIHtjbGVhcjogdHJ1ZX0gdG8gY2xlYXIgdGhlIGRhdGVcclxuICAgICAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ8U3RyaW5nfE9iamVjdH0gcmFuZ2VFbmQgLSBFbmQgZGF0ZSBvZiB0aGUgcmFuZ2VcclxuICAgICAqIG9yIHtjbGVhcjogdHJ1ZX0gdG8gY2xlYXIgdGhlIGRhdGVcclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldERhdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGVzKHJhbmdlU3RhcnQsIHJhbmdlRW5kKSB7XG4gICAgICB2YXIgX3RoaXMkZGF0ZXBpY2tlcnMgPSBfc2xpY2VkVG9BcnJheSh0aGlzLmRhdGVwaWNrZXJzLCAyKSxcbiAgICAgICAgZGF0ZXBpY2tlcjAgPSBfdGhpcyRkYXRlcGlja2Vyc1swXSxcbiAgICAgICAgZGF0ZXBpY2tlcjEgPSBfdGhpcyRkYXRlcGlja2Vyc1sxXTtcbiAgICAgIHZhciBvcmlnRGF0ZXMgPSB0aGlzLmRhdGVzO1xuXG4gICAgICAvLyBJZiByYW5nZSBub3JtYWxpemF0aW9uIHJ1bnMgb24gZXZlcnkgY2hhbmdlLCB3ZSBjYW4ndCBzZXQgYSBuZXcgcmFuZ2VcbiAgICAgIC8vIHRoYXQgc3RhcnRzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgcmFuZ2UgY29ycmVjdGx5IGJlY2F1c2UgdGhlXG4gICAgICAvLyBub3JtYWxpemF0aW9uIHByb2Nlc3Mgc3dhcHMgc3RhcnRcdTIxOTRcdUZFMEVlbmQgcmlnaHQgYWZ0ZXIgc2V0dGluZyB0aGUgbmV3IHN0YXJ0XG4gICAgICAvLyBkYXRlLiBUbyBwcmV2ZW50IHRoaXMsIHRoZSBub3JtYWxpemF0aW9uIHByb2Nlc3MgbmVlZHMgdG8gcnVuIG9uY2UgYWZ0ZXJcbiAgICAgIC8vIGJvdGggb2YgdGhlIG5ldyBkYXRlcyBhcmUgc2V0LlxuICAgICAgdGhpcy5fdXBkYXRpbmcgPSB0cnVlO1xuICAgICAgZGF0ZXBpY2tlcjAuc2V0RGF0ZShyYW5nZVN0YXJ0KTtcbiAgICAgIGRhdGVwaWNrZXIxLnNldERhdGUocmFuZ2VFbmQpO1xuICAgICAgZGVsZXRlIHRoaXMuX3VwZGF0aW5nO1xuICAgICAgaWYgKGRhdGVwaWNrZXIxLmRhdGVzWzBdICE9PSBvcmlnRGF0ZXNbMV0pIHtcbiAgICAgICAgb25DaGFuZ2VEYXRlKHRoaXMsIHtcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMuaW5wdXRzWzFdXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChkYXRlcGlja2VyMC5kYXRlc1swXSAhPT0gb3JpZ0RhdGVzWzBdKSB7XG4gICAgICAgIG9uQ2hhbmdlRGF0ZSh0aGlzLCB7XG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLmlucHV0c1swXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbn0oKTtcblxuZXhwb3J0IHsgRGF0ZVJhbmdlUGlja2VyLCBEYXRlcGlja2VyIH07XG4iLCBudWxsLCBudWxsLCBudWxsXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQU1B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LE1BQU07QUFBQSxJQUNYLEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxFQUNKO0FBQ0EsTUFBTSxVQUFVO0FBQUEsSUFDZixRQUFRO0FBQUEsSUFDUixhQUFhO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixXQUFXO0FBQUEsSUFDWCxNQUFNO0FBQUEsSUFDTixPQUFPO0FBQUEsSUFDUCxRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxjQUFjO0FBQUEsSUFDZCxJQUFJO0FBQUEsSUFDSixTQUFTO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixXQUFXO0FBQUEsSUFDWCxRQUFRO0FBQUEsSUFDUixVQUFVO0FBQUEsSUFDVixTQUFTO0FBQUEsSUFDVCxLQUFLO0FBQUEsSUFDTCxhQUFhO0FBQUEsSUFDYixTQUFTO0FBQUEsSUFDVCxTQUFTO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixLQUFLO0FBQUEsSUFDTCxPQUFPO0FBQUEsSUFDUCxTQUFTO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsSUFDTixRQUFRO0FBQUEsSUFDUixTQUFTO0FBQUEsSUFDVCxVQUFVO0FBQUEsSUFDVixRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxLQUFLO0FBQUEsSUFDTCxRQUFRO0FBQUEsSUFDUixRQUFRO0FBQUEsSUFDUixNQUFNO0FBQUEsSUFDTixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxLQUFLO0FBQUEsSUFDTCxRQUFRO0FBQUEsSUFDUixRQUFRO0FBQUEsSUFDUixVQUFVO0FBQUEsSUFDVixRQUFRO0FBQUEsSUFDUixRQUFRO0FBQUEsSUFDUixVQUFVO0FBQUEsSUFDVixVQUFVO0FBQUEsSUFDVixVQUFVO0FBQUEsSUFDVixVQUFVO0FBQUEsSUFDVixRQUFRO0FBQUEsSUFDUixTQUFTO0FBQUEsSUFDVCxXQUFXO0FBQUEsSUFDWCxLQUFLO0FBQUEsSUFDTCxRQUFRO0FBQUEsSUFDUixLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxPQUFPO0FBQUEsSUFDUCxLQUFLO0FBQUEsSUFDTCxTQUFTO0FBQUEsSUFDVCxRQUFRO0FBQUEsSUFDUixTQUFTO0FBQUEsSUFDVCxPQUFPO0FBQUEsSUFDUCxNQUFNO0FBQUEsSUFDTixPQUFPO0FBQUEsSUFDUCxRQUFRO0FBQUEsSUFDUixXQUFXO0FBQUEsSUFDWCxTQUFTO0FBQUEsSUFDVCxZQUFZO0FBQUEsSUFDWixLQUFLO0FBQUEsSUFDTCxNQUFNO0FBQUEsSUFDTixPQUFPO0FBQUEsSUFDUCxXQUFXO0FBQUEsSUFDWCxNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsSUFDTixRQUFRO0FBQUEsSUFDUixRQUFRO0FBQUEsSUFDUixRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxTQUFTO0FBQUEsSUFDVCxLQUFLO0FBQUEsSUFDTCxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsSUFDVCxLQUFLO0FBQUEsSUFDTCxRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxZQUFZO0FBQUEsSUFDWixLQUFLO0FBQUEsSUFDTCxPQUFPO0FBQUEsSUFDUCxRQUFRO0FBQUEsSUFDUixRQUFRO0FBQUEsSUFDUixNQUFNO0FBQUEsSUFDTixXQUFXO0FBQUEsSUFDWCxLQUFLO0FBQUEsSUFDTCxVQUFVO0FBQUEsSUFDVixZQUFZO0FBQUEsSUFDWixTQUFTO0FBQUEsSUFDVCxVQUFVO0FBQUEsSUFDVixTQUFTO0FBQUEsSUFDVCxZQUFZO0FBQUEsSUFDWixNQUFNO0FBQUEsSUFDTixRQUFRO0FBQUEsSUFDUixNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsSUFDVCxPQUFPO0FBQUEsSUFDUCxTQUFTO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixXQUFXO0FBQUEsSUFDWCxRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxZQUFZO0FBQUEsSUFDWixXQUFXO0FBQUEsSUFDWCxTQUFTO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixLQUFLO0FBQUEsSUFDTCxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsSUFDVCxPQUFPO0FBQUEsSUFDUCxhQUFhO0FBQUEsSUFDYixJQUFJO0FBQUEsSUFDSixVQUFVO0FBQUEsSUFDVixPQUFPO0FBQUEsSUFDUCxXQUFXO0FBQUEsSUFDWCxPQUFPO0FBQUEsSUFDUCxXQUFXO0FBQUEsSUFDWCxPQUFPO0FBQUEsSUFDUCxTQUFTO0FBQUEsSUFDVCxPQUFPO0FBQUEsSUFDUCxRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxLQUFLO0FBQUEsSUFDTCxNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsSUFDTixVQUFVO0FBQUEsSUFDVixRQUFRO0FBQUEsSUFDUixLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxPQUFPO0FBQUEsSUFDUCxRQUFRO0FBQUEsSUFDUixJQUFJO0FBQUEsSUFDSixPQUFPO0FBQUEsSUFDUCxLQUFLO0FBQUEsSUFDTCxNQUFNO0FBQUEsSUFDTixXQUFXO0FBQUEsSUFDWCxJQUFJO0FBQUEsSUFDSixPQUFPO0FBQUEsRUFDUjtBQUNBLFdBQVMsU0FBUztBQUNoQixVQUFNLFdBQVcsQ0FB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QUksR0FBRyxhQUFhLFdBQVcsQ0FBQztBQUFBLEVBQ3BELENBQUM7QUFHRCxTQUFPLGlCQUFpQixtQkFBbUIsT0FBSztBQUM5QyxTQUFLLFNBQVMsZUFBZSxFQUFFLE9BQU8sRUFBRTtBQUN4QyxlQUFXLE9BQU8sSUFBSSxHQUFHLGFBQWEsWUFBWSxDQUFDO0FBQUEsRUFDckQsQ0FBQztBQUdELGdCQUFBRSxRQUFPLE9BQU8sRUFBRSxXQUFXLEVBQUUsR0FBRyxPQUFPLEdBQUcsYUFBYSxvQkFBb0IsQ0FBQztBQUM1RSxTQUFPLGlCQUFpQiwwQkFBMEIsV0FBUyxjQUFBQSxRQUFPLEtBQUssR0FBRyxDQUFDO0FBQzNFLFNBQU8saUJBQWlCLHlCQUF5QixXQUFTLGNBQUFBLFFBQU8sS0FBSyxDQUFDO0FBR3ZFLGFBQVcsUUFBUTtBQU1uQixTQUFPLGFBQWE7IiwKICAibmFtZXMiOiBbIndpbmRvdyIsICJkb2N1bWVudCIsICJjYWxsYmFjayIsICJyZXBhaW50IiwgInRvcGJhciIsICJ0byIsICJDdXN0b21FdmVudCIsICJ0byIsICJjbG9zdXJlIiwgImNhbGxiYWNrIiwgImNhbGxiYWNrIiwgIm9mZnNldCIsICJsaXZlU29ja2V0IiwgImNsb3N1cmUiLCAiZWwiLCAiY2FsbGJhY2siLCAibG9jYWxTdG9yYWdlIiwgInRvIiwgImhhc2giLCAiZSIsICJpc0VtcHR5IiwgImRlYm91bmNlIiwgInRocm90dGxlIiwgImZpbGUiLCAibGFzdENoaWxkIiwgImQiLCAibW9ycGhBdHRycyIsICJtb3JwaGRvbSIsICJjaGlsZHJlbk9ubHkiLCAidGFyZ2V0Q29udGFpbmVyIiwgImZyb20iLCAiY2xvbmUiLCAidmlldyIsICJvbGRJbmRleCIsICJldmVudHMiLCAic2tpcCIsICJkZWZhdWx0cyIsICJuYW1lcyIsICJyZXNvbHZlIiwgImlzQXJyYXkiLCAiZWxlbWVudHMiLCAicm9vdEVsIiwgImxvY2siLCAibG9hZGluZyIsICJlbnRyeSIsICJpbnB1dCIsICJjbG9zdXJlIiwgImNhbGxiYWNrIiwgImVsIiwgInJvb3RFbCIsICJ0byIsICJlbGVtZW50cyIsICJldmVudHMiLCAiZCIsICJtYXgiLCAicmFuZ2UiLCAibWluIiwgIm0iLCAiY2xvbmUiLCAiY29sb3IiLCAibm9vcCIsICJ1aWQiLCAiaWQiLCAiaXNOdWxsT3JVbmRlZiIsICJ2YWx1ZSIsICJ1bmRlZmluZWQiLCAiaXNBcnJheSIsICJBcnJheSIsICJ0eXBlIiwgIk9iamVjdCIsICJwcm90b3R5cGUiLCAidG9TdHJpbmciLCAiY2FsbCIsICJzbGljZSIsICJpc09iamVjdCIsICJpc051bWJlckZpbml0ZSIsICJOdW1iZXIiLCAiaXNGaW5pdGUiLCAiZmluaXRlT3JEZWZhdWx0IiwgImRlZmF1bHRWYWx1ZSIsICJ2YWx1ZU9yRGVmYXVsdCIsICJ0b1BlcmNlbnRhZ2UiLCAiZGltZW5zaW9uIiwgImVuZHNXaXRoIiwgInBhcnNlRmxvYXQiLCAidG9EaW1lbnNpb24iLCAiY2FsbGJhY2siLCAiZm4iLCAiYXJncyIsICJ0aGlzQXJnIiwgImFwcGx5IiwgImVhY2giLCAibG9vcGFibGUiLCAicmV2ZXJzZSIsICJpIiwgImxlbiIsICJrZXlzIiwgImxlbmd0aCIsICJfZWxlbWVudHNFcXVhbCIsICJhMCIsICJhMSIsICJpbGVuIiwgInYwIiwgInYxIiwgImRhdGFzZXRJbmRleCIsICJpbmRleCIsICJjbG9uZSIsICJzb3VyY2UiLCAibWFwIiwgInRhcmdldCIsICJjcmVhdGUiLCAia2xlbiIsICJrIiwgImlzVmFsaWRLZXkiLCAia2V5IiwgImluZGV4T2YiLCAiX21lcmdlciIsICJvcHRpb25zIiwgInR2YWwiLCAic3ZhbCIsICJtZXJnZSIsICJzb3VyY2VzIiwgIm1lcmdlciIsICJjdXJyZW50IiwgIm1lcmdlSWYiLCAiX21lcmdlcklmIiwgImhhc093blByb3BlcnR5IiwgImtleVJlc29sdmVycyIsICJ2IiwgIngiLCAibyIsICJ5IiwgIl9zcGxpdEtleSIsICJrZXkiLCAicGFydHMiLCAic3BsaXQiLCAia2V5cyIsICJ0bXAiLCAicGFydCIsICJlbmRzV2l0aCIsICJzbGljZSIsICJwdXNoIiwgIl9nZXRLZXlSZXNvbHZlciIsICJvYmoiLCAiayIsICJyZXNvbHZlT2JqZWN0S2V5IiwgInJlc29sdmVyIiwgIl9jYXBpdGFsaXplIiwgInN0ciIsICJjaGFyQXQiLCAidG9VcHBlckNhc2UiLCAiZGVmaW5lZCIsICJ2YWx1ZSIsICJpc0Z1bmN0aW9uIiwgInNldHNFcXVhbCIsICJhIiwgImIiLCAic2l6ZSIsICJpdGVtIiwgImhhcyIsICJfaXNDbGlja0V2ZW50IiwgImUiLCAidHlwZSIsICJQSSIsICJNYXRoIiwgIlRBVSIsICJQSVRBVSIsICJJTkZJTklUWSIsICJOdW1iZXIiLCAiUE9TSVRJVkVfSU5GSU5JVFkiLCAiUkFEX1BFUl9ERUciLCAiSEFMRl9QSSIsICJRVUFSVEVSX1BJIiwgIlRXT19USElSRFNfUEkiLCAibG9nMTAiLCAic2lnbiIsICJhbG1vc3RFcXVhbHMiLCAiZXBzaWxvbiIsICJhYnMiLCAibmljZU51bSIsICJyYW5nZSIsICJyb3VuZGVkUmFuZ2UiLCAicm91bmQiLCAibmljZVJhbmdlIiwgInBvdyIsICJmbG9vciIsICJmcmFjdGlvbiIsICJuaWNlRnJhY3Rpb24iLCAiX2ZhY3Rvcml6ZSIsICJyZXN1bHQiLCAic3FydCIsICJpIiwgInNvcnQiLCAicG9wIiwgImlzTm9uUHJpbWl0aXZlIiwgIm4iLCAiU3ltYm9sIiwgInRvUHJpbWl0aXZlIiwgImlzTnVtYmVyIiwgImlzTmFOIiwgInBhcnNlRmxvYXQiLCAiaXNGaW5pdGUiLCAiYWxtb3N0V2hvbGUiLCAicm91bmRlZCIsICJfc2V0TWluQW5kTWF4QnlLZXkiLCAiYXJyYXkiLCAidGFyZ2V0IiwgInByb3BlcnR5IiwgImlsZW4iLCAibGVuZ3RoIiwgIm1pbiIsICJtYXgiLCAidG9SYWRpYW5zIiwgImRlZ3JlZXMiLCAidG9EZWdyZWVzIiwgInJhZGlhbnMiLCAiX2RlY2ltYWxQbGFjZXMiLCAiaXNGaW5pdGVOdW1iZXIiLCAicCIsICJnZXRBbmdsZUZyb21Qb2ludCIsICJjZW50cmVQb2ludCIsICJhbmdsZVBvaW50IiwgImRpc3RhbmNlRnJvbVhDZW50ZXIiLCAiZGlzdGFuY2VGcm9tWUNlbnRlciIsICJyYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIiLCAiYW5nbGUiLCAiYXRhbjIiLCAiZGlzdGFuY2UiLCAiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwgInB0MSIsICJwdDIiLCAiX2FuZ2xlRGlmZiIsICJfbm9ybWFsaXplQW5nbGUiLCAiX2FuZ2xlQmV0d2VlbiIsICJzdGFydCIsICJlbmQiLCAic2FtZUFuZ2xlSXNGdWxsQ2lyY2xlIiwgInMiLCAiYW5nbGVUb1N0YXJ0IiwgImFuZ2xlVG9FbmQiLCAic3RhcnRUb0FuZ2xlIiwgImVuZFRvQW5nbGUiLCAiX2xpbWl0VmFsdWUiLCAiX2ludDE2UmFuZ2UiLCAiX2lzQmV0d2VlbiIsICJfbG9va3VwIiwgInRhYmxlIiwgImNtcCIsICJpbmRleCIsICJoaSIsICJsbyIsICJtaWQiLCAiX2xvb2t1cEJ5S2V5IiwgImxhc3QiLCAidGkiLCAiX3Jsb29rdXBCeUtleSIsICJfZmlsdGVyQmV0d2VlbiIsICJ2YWx1ZXMiLCAiYXJyYXlFdmVudHMiLCAibGlzdGVuQXJyYXlFdmVudHMiLCAibGlzdGVuZXIiLCAiX2NoYXJ0anMiLCAibGlzdGVuZXJzIiwgIk9iamVjdCIsICJkZWZpbmVQcm9wZXJ0eSIsICJjb25maWd1cmFibGUiLCAiZW51bWVyYWJsZSIsICJmb3JFYWNoIiwgIm1ldGhvZCIsICJiYXNlIiwgImFyZ3MiLCAicmVzIiwgImFwcGx5IiwgIm9iamVjdCIsICJ1bmxpc3RlbkFycmF5RXZlbnRzIiwgInN0dWIiLCAiaW5kZXhPZiIsICJzcGxpY2UiLCAiX2FycmF5VW5pcXVlIiwgIml0ZW1zIiwgInNldCIsICJTZXQiLCAiQXJyYXkiLCAiZnJvbSIsICJyZXF1ZXN0QW5pbUZyYW1lIiwgIndpbmRvdyIsICJjYWxsYmFjayIsICJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCAidGhyb3R0bGVkIiwgImZuIiwgInRoaXNBcmciLCAiYXJnc1RvVXNlIiwgInRpY2tpbmciLCAiYXJncyIsICJjYWxsIiwgImFwcGx5IiwgImRlYm91bmNlIiwgImRlbGF5IiwgInRpbWVvdXQiLCAiY2xlYXJUaW1lb3V0IiwgInNldFRpbWVvdXQiLCAiX3RvTGVmdFJpZ2h0Q2VudGVyIiwgImFsaWduIiwgIl9hbGlnblN0YXJ0RW5kIiwgInN0YXJ0IiwgImVuZCIsICJfdGV4dFgiLCAibGVmdCIsICJyaWdodCIsICJydGwiLCAiY2hlY2siLCAiX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMiLCAibWV0YSIsICJwb2ludHMiLCAiYW5pbWF0aW9uc0Rpc2FibGVkIiwgInBvaW50Q291bnQiLCAibGVuZ3RoIiwgImNvdW50IiwgIl9zb3J0ZWQiLCAiaVNjYWxlIiwgInZTY2FsZSIsICJfcGFyc2VkIiwgInNwYW5HYXBzIiwgImRhdGFzZXQiLCAib3B0aW9ucyIsICJheGlzIiwgIm1pbiIsICJtYXgiLCAibWluRGVmaW5lZCIsICJtYXhEZWZpbmVkIiwgImdldFVzZXJCb3VuZHMiLCAiTWF0aCIsICJfbG9va3VwQnlLZXkiLCAibG8iLCAiZ2V0UGl4ZWxGb3JWYWx1ZSIsICJkaXN0YW5jZVRvRGVmaW5lZExvIiwgInNsaWNlIiwgInJldmVyc2UiLCAiZmluZEluZGV4IiwgInBvaW50IiwgImlzTnVsbE9yVW5kZWYiLCAiX2xpbWl0VmFsdWUiLCAiaGkiLCAiZGlzdGFuY2VUb0RlZmluZWRIaSIsICJfc2NhbGVSYW5nZXNDaGFuZ2VkIiwgInhTY2FsZSIsICJ5U2NhbGUiLCAiX3NjYWxlUmFuZ2VzIiwgIm5ld1JhbmdlcyIsICJ4bWluIiwgInhtYXgiLCAieW1pbiIsICJ5bWF4IiwgImNoYW5nZWQiLCAiT2JqZWN0IiwgImFzc2lnbiIsICJhdEVkZ2UiLCAidCIsICJlbGFzdGljSW4iLCAicyIsICJwIiwgInBvdyIsICJzaW4iLCAiVEFVIiwgImVsYXN0aWNPdXQiLCAiZWZmZWN0cyIsICJsaW5lYXIiLCAiZWFzZUluUXVhZCIsICJlYXNlT3V0UXVhZCIsICJlYXNlSW5PdXRRdWFkIiwgImVhc2VJbkN1YmljIiwgImVhc2VPdXRDdWJpYyIsICJlYXNlSW5PdXRDdWJpYyIsICJlYXNlSW5RdWFydCIsICJlYXNlT3V0UXVhcnQiLCAiZWFzZUluT3V0UXVhcnQiLCAiZWFzZUluUXVpbnQiLCAiZWFzZU91dFF1aW50IiwgImVhc2VJbk91dFF1aW50IiwgImVhc2VJblNpbmUiLCAiY29zIiwgIkhBTEZfUEkiLCAiZWFzZU91dFNpbmUiLCAiZWFzZUluT3V0U2luZSIsICJQSSIsICJlYXNlSW5FeHBvIiwgImVhc2VPdXRFeHBvIiwgImVhc2VJbk91dEV4cG8iLCAiZWFzZUluQ2lyYyIsICJzcXJ0IiwgImVhc2VPdXRDaXJjIiwgImVhc2VJbk91dENpcmMiLCAiZWFzZUluRWxhc3RpYyIsICJlYXNlT3V0RWxhc3RpYyIsICJlYXNlSW5PdXRFbGFzdGljIiwgImVhc2VJbkJhY2siLCAiZWFzZU91dEJhY2siLCAiZWFzZUluT3V0QmFjayIsICJlYXNlSW5Cb3VuY2UiLCAiZWFzZU91dEJvdW5jZSIsICJtIiwgImQiLCAiZWFzZUluT3V0Qm91bmNlIiwgImlzUGF0dGVybk9yR3JhZGllbnQiLCAidmFsdWUiLCAidHlwZSIsICJ0b1N0cmluZyIsICJjb2xvciIsICJDb2xvciIsICJnZXRIb3ZlckNvbG9yIiwgInNhdHVyYXRlIiwgImRhcmtlbiIsICJoZXhTdHJpbmciLCAibnVtYmVycyIsICJjb2xvcnMiLCAiYXBwbHlBbmltYXRpb25zRGVmYXVsdHMiLCAiZGVmYXVsdHMiLCAic2V0IiwgInVuZGVmaW5lZCIsICJkdXJhdGlvbiIsICJlYXNpbmciLCAiZnJvbSIsICJsb29wIiwgInRvIiwgImRlc2NyaWJlIiwgIl9mYWxsYmFjayIsICJfaW5kZXhhYmxlIiwgIl9zY3JpcHRhYmxlIiwgIm5hbWUiLCAicHJvcGVydGllcyIsICJhY3RpdmUiLCAiYW5pbWF0aW9uIiwgInJlc2l6ZSIsICJzaG93IiwgImFuaW1hdGlvbnMiLCAidmlzaWJsZSIsICJoaWRlIiwgInYiLCAiYXBwbHlMYXlvdXRzRGVmYXVsdHMiLCAiYXV0b1BhZGRpbmciLCAicGFkZGluZyIsICJ0b3AiLCAiYm90dG9tIiwgImludGxDYWNoZSIsICJNYXAiLCAiZ2V0TnVtYmVyRm9ybWF0IiwgImxvY2FsZSIsICJjYWNoZUtleSIsICJKU09OIiwgInN0cmluZ2lmeSIsICJmb3JtYXR0ZXIiLCAiZ2V0IiwgIkludGwiLCAiTnVtYmVyRm9ybWF0IiwgImZvcm1hdE51bWJlciIsICJudW0iLCAiZm9ybWF0IiwgImZvcm1hdHRlcnMiLCAidmFsdWVzIiwgImlzQXJyYXkiLCAibnVtZXJpYyIsICJ0aWNrVmFsdWUiLCAiaW5kZXgiLCAidGlja3MiLCAiY2hhcnQiLCAibm90YXRpb24iLCAiZGVsdGEiLCAibWF4VGljayIsICJhYnMiLCAiY2FsY3VsYXRlRGVsdGEiLCAibG9nRGVsdGEiLCAibG9nMTAiLCAibnVtRGVjaW1hbCIsICJpc05hTiIsICJmbG9vciIsICJtaW5pbXVtRnJhY3Rpb25EaWdpdHMiLCAibWF4aW11bUZyYWN0aW9uRGlnaXRzIiwgImxvZ2FyaXRobWljIiwgInJlbWFpbiIsICJzaWduaWZpY2FuZCIsICJpbmNsdWRlcyIsICJhcHBseVNjYWxlRGVmYXVsdHMiLCAiZGlzcGxheSIsICJvZmZzZXQiLCAiYmVnaW5BdFplcm8iLCAiYm91bmRzIiwgImNsaXAiLCAiZ3JhY2UiLCAiZ3JpZCIsICJsaW5lV2lkdGgiLCAiZHJhd09uQ2hhcnRBcmVhIiwgImRyYXdUaWNrcyIsICJ0aWNrTGVuZ3RoIiwgInRpY2tXaWR0aCIsICJfY3R4IiwgInRpY2tDb2xvciIsICJib3JkZXIiLCAiZGFzaCIsICJkYXNoT2Zmc2V0IiwgIndpZHRoIiwgInRpdGxlIiwgInRleHQiLCAibWluUm90YXRpb24iLCAibWF4Um90YXRpb24iLCAibWlycm9yIiwgInRleHRTdHJva2VXaWR0aCIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAiYXV0b1NraXAiLCAiYXV0b1NraXBQYWRkaW5nIiwgImxhYmVsT2Zmc2V0IiwgIlRpY2tzIiwgIm1pbm9yIiwgIm1ham9yIiwgImNyb3NzQWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3BDb2xvciIsICJiYWNrZHJvcFBhZGRpbmciLCAicm91dGUiLCAic3RhcnRzV2l0aCIsICJvdmVycmlkZXMiLCAiY3JlYXRlIiwgImRlc2NyaXB0b3JzIiwgImdldFNjb3BlIiwgIm5vZGUiLCAia2V5IiwgImtleXMiLCAic3BsaXQiLCAiaSIsICJuIiwgImsiLCAicm9vdCIsICJzY29wZSIsICJtZXJnZSIsICJEZWZhdWx0cyIsICJjb25zdHJ1Y3RvciIsICJfZGVzY3JpcHRvcnMiLCAiX2FwcGxpZXJzIiwgImJhY2tncm91bmRDb2xvciIsICJib3JkZXJDb2xvciIsICJkYXRhc2V0cyIsICJkZXZpY2VQaXhlbFJhdGlvIiwgImNvbnRleHQiLCAicGxhdGZvcm0iLCAiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsICJlbGVtZW50cyIsICJldmVudHMiLCAiZm9udCIsICJmYW1pbHkiLCAic2l6ZSIsICJzdHlsZSIsICJsaW5lSGVpZ2h0IiwgIndlaWdodCIsICJob3ZlciIsICJob3ZlckJhY2tncm91bmRDb2xvciIsICJjdHgiLCAiaG92ZXJCb3JkZXJDb2xvciIsICJob3ZlckNvbG9yIiwgImluZGV4QXhpcyIsICJpbnRlcmFjdGlvbiIsICJtb2RlIiwgImludGVyc2VjdCIsICJpbmNsdWRlSW52aXNpYmxlIiwgIm1haW50YWluQXNwZWN0UmF0aW8iLCAib25Ib3ZlciIsICJvbkNsaWNrIiwgInBhcnNpbmciLCAicGx1Z2lucyIsICJyZXNwb25zaXZlIiwgInNjYWxlIiwgInNjYWxlcyIsICJzaG93TGluZSIsICJkcmF3QWN0aXZlRWxlbWVudHNPblRvcCIsICJvdmVycmlkZSIsICJ0YXJnZXRTY29wZSIsICJ0YXJnZXROYW1lIiwgInNjb3BlT2JqZWN0IiwgInRhcmdldFNjb3BlT2JqZWN0IiwgInByaXZhdGVOYW1lIiwgImRlZmluZVByb3BlcnRpZXMiLCAid3JpdGFibGUiLCAiZW51bWVyYWJsZSIsICJsb2NhbCIsICJ0YXJnZXQiLCAiaXNPYmplY3QiLCAidmFsdWVPckRlZmF1bHQiLCAiYXBwbGllcnMiLCAiZm9yRWFjaCIsICJ0b0ZvbnRTdHJpbmciLCAiX21lYXN1cmVUZXh0IiwgImRhdGEiLCAiZ2MiLCAibG9uZ2VzdCIsICJzdHJpbmciLCAidGV4dFdpZHRoIiwgIm1lYXN1cmVUZXh0IiwgInB1c2giLCAiX2xvbmdlc3RUZXh0IiwgImFycmF5T2ZUaGluZ3MiLCAiY2FjaGUiLCAiZ2FyYmFnZUNvbGxlY3QiLCAic2F2ZSIsICJpbGVuIiwgImoiLCAiamxlbiIsICJ0aGluZyIsICJuZXN0ZWRUaGluZyIsICJyZXN0b3JlIiwgImdjTGVuIiwgInNwbGljZSIsICJfYWxpZ25QaXhlbCIsICJwaXhlbCIsICJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsICJoYWxmV2lkdGgiLCAicm91bmQiLCAiY2xlYXJDYW52YXMiLCAiY2FudmFzIiwgImdldENvbnRleHQiLCAicmVzZXRUcmFuc2Zvcm0iLCAiY2xlYXJSZWN0IiwgImhlaWdodCIsICJkcmF3UG9pbnQiLCAieCIsICJ5IiwgImRyYXdQb2ludExlZ2VuZCIsICJ3IiwgInhPZmZzZXQiLCAieU9mZnNldCIsICJjb3JuZXJSYWRpdXMiLCAieE9mZnNldFciLCAieU9mZnNldFciLCAicG9pbnRTdHlsZSIsICJyb3RhdGlvbiIsICJyYWRpdXMiLCAicmFkIiwgIlJBRF9QRVJfREVHIiwgInRyYW5zbGF0ZSIsICJyb3RhdGUiLCAiZHJhd0ltYWdlIiwgImJlZ2luUGF0aCIsICJlbGxpcHNlIiwgImFyYyIsICJjbG9zZVBhdGgiLCAibW92ZVRvIiwgIlRXT19USElSRFNfUEkiLCAibGluZVRvIiwgIlFVQVJURVJfUEkiLCAiU1FSVDFfMiIsICJyZWN0IiwgImZpbGwiLCAiYm9yZGVyV2lkdGgiLCAic3Ryb2tlIiwgIl9pc1BvaW50SW5BcmVhIiwgImFyZWEiLCAibWFyZ2luIiwgImNsaXBBcmVhIiwgInVuY2xpcEFyZWEiLCAiX3N0ZXBwZWRMaW5lVG8iLCAicHJldmlvdXMiLCAiZmxpcCIsICJtaWRwb2ludCIsICJfYmV6aWVyQ3VydmVUbyIsICJiZXppZXJDdXJ2ZVRvIiwgImNwMXgiLCAiY3AyeCIsICJjcDF5IiwgImNwMnkiLCAic2V0UmVuZGVyT3B0cyIsICJvcHRzIiwgInRyYW5zbGF0aW9uIiwgImZpbGxTdHlsZSIsICJ0ZXh0QWxpZ24iLCAidGV4dEJhc2VsaW5lIiwgImRlY29yYXRlVGV4dCIsICJsaW5lIiwgInN0cmlrZXRocm91Z2giLCAidW5kZXJsaW5lIiwgIm1ldHJpY3MiLCAiYWN0dWFsQm91bmRpbmdCb3hMZWZ0IiwgImFjdHVhbEJvdW5kaW5nQm94UmlnaHQiLCAiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCAiYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50IiwgInlEZWNvcmF0aW9uIiwgInN0cm9rZVN0eWxlIiwgImRlY29yYXRpb25XaWR0aCIsICJkcmF3QmFja2Ryb3AiLCAib2xkQ29sb3IiLCAiZmlsbFJlY3QiLCAicmVuZGVyVGV4dCIsICJsaW5lcyIsICJzdHJva2VXaWR0aCIsICJzdHJva2VDb2xvciIsICJiYWNrZHJvcCIsICJzdHJva2VUZXh0IiwgIm1heFdpZHRoIiwgImZpbGxUZXh0IiwgIk51bWJlciIsICJhZGRSb3VuZGVkUmVjdFBhdGgiLCAiaCIsICJ0b3BMZWZ0IiwgImJvdHRvbUxlZnQiLCAiYm90dG9tUmlnaHQiLCAidG9wUmlnaHQiLCAiTElORV9IRUlHSFQiLCAiRk9OVF9TVFlMRSIsICJ0b0xpbmVIZWlnaHQiLCAibWF0Y2hlcyIsICJtYXRjaCIsICJudW1iZXJPclplcm8iLCAiX3JlYWRWYWx1ZVRvUHJvcHMiLCAicHJvcHMiLCAicmV0IiwgIm9ialByb3BzIiwgInJlYWQiLCAicHJvcCIsICJ0b1RSQkwiLCAidG9UUkJMQ29ybmVycyIsICJ0b1BhZGRpbmciLCAib2JqIiwgInRvRm9udCIsICJmYWxsYmFjayIsICJwYXJzZUludCIsICJjb25zb2xlIiwgIndhcm4iLCAicmVzb2x2ZSIsICJpbnB1dHMiLCAiaW5mbyIsICJjYWNoZWFibGUiLCAiX2FkZEdyYWNlIiwgIm1pbm1heCIsICJjaGFuZ2UiLCAidG9EaW1lbnNpb24iLCAia2VlcFplcm8iLCAiYWRkIiwgImNyZWF0ZUNvbnRleHQiLCAicGFyZW50Q29udGV4dCIsICJfY3JlYXRlUmVzb2x2ZXIiLCAic2NvcGVzIiwgInByZWZpeGVzIiwgInJvb3RTY29wZXMiLCAiZ2V0VGFyZ2V0IiwgImZpbmFsUm9vdFNjb3BlcyIsICJfcmVzb2x2ZSIsICJTeW1ib2wiLCAidG9TdHJpbmdUYWciLCAiX2NhY2hlYWJsZSIsICJfc2NvcGVzIiwgIl9yb290U2NvcGVzIiwgIl9nZXRUYXJnZXQiLCAiUHJveHkiLCAiZGVsZXRlUHJvcGVydHkiLCAiX2tleXMiLCAiX2NhY2hlZCIsICJfcmVzb2x2ZVdpdGhQcmVmaXhlcyIsICJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCAiUmVmbGVjdCIsICJnZXRQcm90b3R5cGVPZiIsICJoYXMiLCAiZ2V0S2V5c0Zyb21BbGxTY29wZXMiLCAib3duS2V5cyIsICJzdG9yYWdlIiwgIl9zdG9yYWdlIiwgIl9hdHRhY2hDb250ZXh0IiwgInByb3h5IiwgInN1YlByb3h5IiwgImRlc2NyaXB0b3JEZWZhdWx0cyIsICJfcHJveHkiLCAiX2NvbnRleHQiLCAiX3N1YlByb3h5IiwgIl9zdGFjayIsICJTZXQiLCAic2V0Q29udGV4dCIsICJyZWNlaXZlciIsICJfcmVzb2x2ZVdpdGhDb250ZXh0IiwgImFsbEtleXMiLCAiY29uZmlndXJhYmxlIiwgInNjcmlwdGFibGUiLCAiaW5kZXhhYmxlIiwgIl9hbGxLZXlzIiwgImlzU2NyaXB0YWJsZSIsICJpc0Z1bmN0aW9uIiwgImlzSW5kZXhhYmxlIiwgInJlYWRLZXkiLCAicHJlZml4IiwgIl9jYXBpdGFsaXplIiwgIm5lZWRzU3ViUmVzb2x2ZXIiLCAicHJvdG90eXBlIiwgImhhc093blByb3BlcnR5IiwgIl9yZXNvbHZlU2NyaXB0YWJsZSIsICJfcmVzb2x2ZUFycmF5IiwgImdldFZhbHVlIiwgIkVycm9yIiwgIkFycmF5IiwgImpvaW4iLCAiZGVsZXRlIiwgImNyZWF0ZVN1YlJlc29sdmVyIiwgImFyciIsICJmaWx0ZXIiLCAiaXRlbSIsICJyZXNvbHZlciIsICJyZXNvbHZlRmFsbGJhY2siLCAicGFyZW50IiwgInJlc29sdmVPYmplY3RLZXkiLCAiYWRkU2NvcGVzIiwgInBhcmVudFNjb3BlcyIsICJwYXJlbnRGYWxsYmFjayIsICJhbGxTY29wZXMiLCAiYWRkU2NvcGVzRnJvbUtleSIsICJzdWJHZXRUYXJnZXQiLCAicmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzIiwgIl9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSIsICJfcGFyc2luZyIsICJwYXJzZWQiLCAiciIsICJwYXJzZSIsICJFUFNJTE9OIiwgImdldFBvaW50IiwgInNraXAiLCAiZ2V0VmFsdWVBeGlzIiwgInNwbGluZUN1cnZlIiwgImZpcnN0UG9pbnQiLCAibWlkZGxlUG9pbnQiLCAiYWZ0ZXJQb2ludCIsICJjdXJyZW50IiwgIm5leHQiLCAiZDAxIiwgImRpc3RhbmNlQmV0d2VlblBvaW50cyIsICJkMTIiLCAiczAxIiwgInMxMiIsICJmYSIsICJmYiIsICJtb25vdG9uZUFkanVzdCIsICJkZWx0YUsiLCAibUsiLCAicG9pbnRzTGVuIiwgImFscGhhSyIsICJiZXRhSyIsICJ0YXVLIiwgInNxdWFyZWRNYWduaXR1ZGUiLCAicG9pbnRDdXJyZW50IiwgInBvaW50QWZ0ZXIiLCAiYWxtb3N0RXF1YWxzIiwgIm1vbm90b25lQ29tcHV0ZSIsICJ2YWx1ZUF4aXMiLCAicG9pbnRCZWZvcmUiLCAiaVBpeGVsIiwgInZQaXhlbCIsICJzcGxpbmVDdXJ2ZU1vbm90b25lIiwgInNsb3BlRGVsdGEiLCAic2lnbiIsICJjYXBDb250cm9sUG9pbnQiLCAicHQiLCAiY2FwQmV6aWVyUG9pbnRzIiwgImluQXJlYSIsICJpbkFyZWFQcmV2IiwgImluQXJlYU5leHQiLCAiX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMiLCAiY29udHJvbFBvaW50cyIsICJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwgInByZXYiLCAidGVuc2lvbiIsICJfaXNEb21TdXBwb3J0ZWQiLCAiZG9jdW1lbnQiLCAiX2dldFBhcmVudE5vZGUiLCAiZG9tTm9kZSIsICJwYXJlbnROb2RlIiwgImhvc3QiLCAicGFyc2VNYXhTdHlsZSIsICJzdHlsZVZhbHVlIiwgInBhcmVudFByb3BlcnR5IiwgInZhbHVlSW5QaXhlbHMiLCAiaW5kZXhPZiIsICJnZXRDb21wdXRlZFN0eWxlIiwgImVsZW1lbnQiLCAib3duZXJEb2N1bWVudCIsICJkZWZhdWx0VmlldyIsICJnZXRTdHlsZSIsICJlbCIsICJwcm9wZXJ0eSIsICJnZXRQcm9wZXJ0eVZhbHVlIiwgInBvc2l0aW9ucyIsICJnZXRQb3NpdGlvbmVkU3R5bGUiLCAic3R5bGVzIiwgInN1ZmZpeCIsICJyZXN1bHQiLCAicG9zIiwgInBhcnNlRmxvYXQiLCAidXNlT2Zmc2V0UG9zIiwgInNoYWRvd1Jvb3QiLCAiZ2V0Q2FudmFzUG9zaXRpb24iLCAiZSIsICJ0b3VjaGVzIiwgInNvdXJjZSIsICJvZmZzZXRYIiwgIm9mZnNldFkiLCAiYm94IiwgImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsICJjbGllbnRYIiwgImNsaWVudFkiLCAiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsICJldmVudCIsICJib3JkZXJCb3giLCAiYm94U2l6aW5nIiwgInBhZGRpbmdzIiwgImJvcmRlcnMiLCAiZ2V0Q29udGFpbmVyU2l6ZSIsICJtYXhIZWlnaHQiLCAiY29udGFpbmVyIiwgImNsaWVudFdpZHRoIiwgImNsaWVudEhlaWdodCIsICJjb250YWluZXJTdHlsZSIsICJjb250YWluZXJCb3JkZXIiLCAiY29udGFpbmVyUGFkZGluZyIsICJJTkZJTklUWSIsICJyb3VuZDEiLCAiZ2V0TWF4aW11bVNpemUiLCAiYmJXaWR0aCIsICJiYkhlaWdodCIsICJhc3BlY3RSYXRpbyIsICJtYXJnaW5zIiwgImNvbnRhaW5lclNpemUiLCAibWFpbnRhaW5IZWlnaHQiLCAicmV0aW5hU2NhbGUiLCAiZm9yY2VSYXRpbyIsICJmb3JjZVN0eWxlIiwgInBpeGVsUmF0aW8iLCAiZGV2aWNlSGVpZ2h0IiwgImRldmljZVdpZHRoIiwgInNldFRyYW5zZm9ybSIsICJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwgInBhc3NpdmVTdXBwb3J0ZWQiLCAicGFzc2l2ZSIsICJhZGRFdmVudExpc3RlbmVyIiwgInJlbW92ZUV2ZW50TGlzdGVuZXIiLCAicmVhZFVzZWRTaXplIiwgIl9wb2ludEluTGluZSIsICJwMSIsICJwMiIsICJfc3RlcHBlZEludGVycG9sYXRpb24iLCAiX2JlemllckludGVycG9sYXRpb24iLCAiY3AxIiwgImNwMiIsICJhIiwgImIiLCAiYyIsICJnZXRSaWdodFRvTGVmdEFkYXB0ZXIiLCAicmVjdFgiLCAic2V0V2lkdGgiLCAieFBsdXMiLCAibGVmdEZvckx0ciIsICJpdGVtV2lkdGgiLCAiZ2V0TGVmdFRvUmlnaHRBZGFwdGVyIiwgIl9pdGVtV2lkdGgiLCAiZ2V0UnRsQWRhcHRlciIsICJvdmVycmlkZVRleHREaXJlY3Rpb24iLCAiZGlyZWN0aW9uIiwgIm9yaWdpbmFsIiwgImdldFByb3BlcnR5UHJpb3JpdHkiLCAic2V0UHJvcGVydHkiLCAicHJldlRleHREaXJlY3Rpb24iLCAicmVzdG9yZVRleHREaXJlY3Rpb24iLCAicHJvcGVydHlGbiIsICJiZXR3ZWVuIiwgIl9hbmdsZUJldHdlZW4iLCAiY29tcGFyZSIsICJfYW5nbGVEaWZmIiwgIm5vcm1hbGl6ZSIsICJfbm9ybWFsaXplQW5nbGUiLCAiX2lzQmV0d2VlbiIsICJub3JtYWxpemVTZWdtZW50IiwgImdldFNlZ21lbnQiLCAic2VnbWVudCIsICJzdGFydEJvdW5kIiwgImVuZEJvdW5kIiwgIl9ib3VuZFNlZ21lbnQiLCAiaW5zaWRlIiwgInN1YlN0YXJ0IiwgInByZXZWYWx1ZSIsICJzdGFydElzQmVmb3JlIiwgImVuZElzQmVmb3JlIiwgInNob3VsZFN0YXJ0IiwgInNob3VsZFN0b3AiLCAiX2JvdW5kU2VnbWVudHMiLCAic2VnbWVudHMiLCAic3ViIiwgImZpbmRTdGFydEFuZEVuZCIsICJzb2xpZFNlZ21lbnRzIiwgImxhc3QiLCAiY3VyIiwgInN0b3AiLCAiX2NvbXB1dGVTZWdtZW50cyIsICJzZWdtZW50T3B0aW9ucyIsICJfbG9vcCIsICJzcGxpdEJ5U3R5bGVzIiwgImNvbXBsZXRlTG9vcCIsICJfZnVsbExvb3AiLCAiZG9TcGxpdEJ5U3R5bGVzIiwgImNoYXJ0Q29udGV4dCIsICJfY2hhcnQiLCAiYmFzZVN0eWxlIiwgInJlYWRTdHlsZSIsICJfZGF0YXNldEluZGV4IiwgImRhdGFzZXRJbmRleCIsICJwcmV2U3R5bGUiLCAiYWRkU3R5bGUiLCAibCIsICJzdCIsICJkaXIiLCAicDAiLCAicDBEYXRhSW5kZXgiLCAicDFEYXRhSW5kZXgiLCAic3R5bGVDaGFuZ2VkIiwgImJvcmRlckNhcFN0eWxlIiwgImJvcmRlckRhc2giLCAiYm9yZGVyRGFzaE9mZnNldCIsICJib3JkZXJKb2luU3R5bGUiLCAicmVwbGFjZXIiLCAiZ2V0U2l6ZUZvckFyZWEiLCAiY2hhcnRBcmVhIiwgImZpZWxkIiwgImdldERhdGFzZXRBcmVhIiwgImdldERhdGFzZXRDbGlwQXJlYSIsICJfY2xpcCIsICJkaXNhYmxlZCIsICJBbmltYXRvciIsICJjb25zdHJ1Y3RvciIsICJfcmVxdWVzdCIsICJfY2hhcnRzIiwgIk1hcCIsICJfcnVubmluZyIsICJfbGFzdERhdGUiLCAidW5kZWZpbmVkIiwgIl9ub3RpZnkiLCAiY2hhcnQiLCAiYW5pbXMiLCAiZGF0ZSIsICJ0eXBlIiwgImNhbGxiYWNrcyIsICJsaXN0ZW5lcnMiLCAibnVtU3RlcHMiLCAiZHVyYXRpb24iLCAiZm9yRWFjaCIsICJmbiIsICJpbml0aWFsIiwgImN1cnJlbnRTdGVwIiwgIk1hdGgiLCAibWluIiwgInN0YXJ0IiwgIl9yZWZyZXNoIiwgInJlcXVlc3RBbmltRnJhbWUiLCAiY2FsbCIsICJ3aW5kb3ciLCAiX3VwZGF0ZSIsICJEYXRlIiwgIm5vdyIsICJyZW1haW5pbmciLCAicnVubmluZyIsICJpdGVtcyIsICJsZW5ndGgiLCAiaSIsICJkcmF3IiwgIml0ZW0iLCAiX2FjdGl2ZSIsICJfdG90YWwiLCAidGljayIsICJwb3AiLCAiX2dldEFuaW1zIiwgImNoYXJ0cyIsICJnZXQiLCAiY29tcGxldGUiLCAicHJvZ3Jlc3MiLCAic2V0IiwgImxpc3RlbiIsICJldmVudCIsICJjYiIsICJwdXNoIiwgImFkZCIsICJoYXMiLCAicmVkdWNlIiwgImFjYyIsICJjdXIiLCAibWF4IiwgIl9kdXJhdGlvbiIsICJzdG9wIiwgImNhbmNlbCIsICJyZW1vdmUiLCAiZGVsZXRlIiwgInRyYW5zcGFyZW50IiwgImludGVycG9sYXRvcnMiLCAiYm9vbGVhbiIsICJmcm9tIiwgInRvIiwgImZhY3RvciIsICJjb2xvciIsICJjMCIsICJoZWxwZXJzQ29sb3IiLCAiYzEiLCAidmFsaWQiLCAibWl4IiwgImhleFN0cmluZyIsICJudW1iZXIiLCAiQW5pbWF0aW9uIiwgImNmZyIsICJ0YXJnZXQiLCAicHJvcCIsICJjdXJyZW50VmFsdWUiLCAicmVzb2x2ZSIsICJfZm4iLCAiX2Vhc2luZyIsICJlZmZlY3RzIiwgImVhc2luZyIsICJsaW5lYXIiLCAiX3N0YXJ0IiwgImZsb29yIiwgImRlbGF5IiwgIl9sb29wIiwgImxvb3AiLCAiX3RhcmdldCIsICJfcHJvcCIsICJfZnJvbSIsICJfdG8iLCAiX3Byb21pc2VzIiwgImFjdGl2ZSIsICJ1cGRhdGUiLCAiZWxhcHNlZCIsICJyZW1haW4iLCAid2FpdCIsICJwcm9taXNlcyIsICJQcm9taXNlIiwgInJlcyIsICJyZWoiLCAicmVzb2x2ZWQiLCAibWV0aG9kIiwgIkFuaW1hdGlvbnMiLCAiY29uZmlnIiwgIl9jaGFydCIsICJfcHJvcGVydGllcyIsICJjb25maWd1cmUiLCAiaXNPYmplY3QiLCAiYW5pbWF0aW9uT3B0aW9ucyIsICJPYmplY3QiLCAia2V5cyIsICJkZWZhdWx0cyIsICJhbmltYXRpb24iLCAiYW5pbWF0ZWRQcm9wcyIsICJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwgImtleSIsICJvcHRpb24iLCAiaXNBcnJheSIsICJwcm9wZXJ0aWVzIiwgIl9hbmltYXRlT3B0aW9ucyIsICJ2YWx1ZXMiLCAibmV3T3B0aW9ucyIsICJvcHRpb25zIiwgInJlc29sdmVUYXJnZXRPcHRpb25zIiwgImFuaW1hdGlvbnMiLCAiX2NyZWF0ZUFuaW1hdGlvbnMiLCAiJHNoYXJlZCIsICJhd2FpdEFsbCIsICIkYW5pbWF0aW9ucyIsICJ0aGVuIiwgInByb3BzIiwgImNoYXJBdCIsICJ2YWx1ZSIsICJzaXplIiwgImFzc2lnbiIsICJhbmltYXRvciIsICJhbmltIiwgImFsbCIsICJzY2FsZUNsaXAiLCAic2NhbGUiLCAiYWxsb3dlZE92ZXJmbG93IiwgIm9wdHMiLCAicmV2ZXJzZSIsICJlbmQiLCAiZGVmYXVsdENsaXAiLCAieFNjYWxlIiwgInlTY2FsZSIsICJ4IiwgInkiLCAidG9wIiwgInJpZ2h0IiwgImJvdHRvbSIsICJsZWZ0IiwgInRvQ2xpcCIsICJ0IiwgInIiLCAiYiIsICJsIiwgImRpc2FibGVkIiwgImdldFNvcnRlZERhdGFzZXRJbmRpY2VzIiwgImZpbHRlclZpc2libGUiLCAibWV0YXNldHMiLCAiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsICJpbGVuIiwgImluZGV4IiwgImFwcGx5U3RhY2siLCAic3RhY2siLCAiZHNJbmRleCIsICJzaW5nbGVNb2RlIiwgIm1vZGUiLCAiZGF0YXNldEluZGV4IiwgIm90aGVyVmFsdWUiLCAiZm91bmQiLCAiaXNGaW5pdGUiLCAic2lnbiIsICJjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkiLCAiZGF0YSIsICJtZXRhIiwgImlTY2FsZSIsICJ2U2NhbGUiLCAiaUF4aXNLZXkiLCAiYXhpcyIsICJ2QXhpc0tleSIsICJhZGF0YSIsICJBcnJheSIsICJpc1N0YWNrZWQiLCAic3RhY2tlZCIsICJnZXRTdGFja0tleSIsICJpbmRleFNjYWxlIiwgInZhbHVlU2NhbGUiLCAiaWQiLCAiZ2V0VXNlckJvdW5kcyIsICJtaW5EZWZpbmVkIiwgIm1heERlZmluZWQiLCAiTnVtYmVyIiwgIk5FR0FUSVZFX0lORklOSVRZIiwgIlBPU0lUSVZFX0lORklOSVRZIiwgImdldE9yQ3JlYXRlU3RhY2siLCAic3RhY2tzIiwgInN0YWNrS2V5IiwgImluZGV4VmFsdWUiLCAic3ViU3RhY2siLCAiZ2V0TGFzdEluZGV4SW5TdGFjayIsICJwb3NpdGl2ZSIsICJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsICJ1cGRhdGVTdGFja3MiLCAiY29udHJvbGxlciIsICJwYXJzZWQiLCAiX2NhY2hlZE1ldGEiLCAiX3N0YWNrcyIsICJpQXhpcyIsICJ2QXhpcyIsICJpdGVtU3RhY2tzIiwgIl90b3AiLCAiX2JvdHRvbSIsICJ2aXN1YWxWYWx1ZXMiLCAiX3Zpc3VhbFZhbHVlcyIsICJnZXRGaXJzdFNjYWxlSWQiLCAic2NhbGVzIiwgImZpbHRlciIsICJzaGlmdCIsICJjcmVhdGVEYXRhc2V0Q29udGV4dCIsICJwYXJlbnQiLCAiY3JlYXRlQ29udGV4dCIsICJkYXRhc2V0IiwgImNyZWF0ZURhdGFDb250ZXh0IiwgImVsZW1lbnQiLCAiZGF0YUluZGV4IiwgInJhdyIsICJjbGVhclN0YWNrcyIsICJfcGFyc2VkIiwgImlzRGlyZWN0VXBkYXRlTW9kZSIsICJjbG9uZUlmTm90U2hhcmVkIiwgImNhY2hlZCIsICJzaGFyZWQiLCAiY3JlYXRlU3RhY2siLCAiY2FuU3RhY2siLCAiaGlkZGVuIiwgIl9zdGFja2VkIiwgIkRhdGFzZXRDb250cm9sbGVyIiwgIl9jdHgiLCAiY3R4IiwgIl9jYWNoZWREYXRhT3B0cyIsICJnZXRNZXRhIiwgIl90eXBlIiwgIl9wYXJzaW5nIiwgIl9kYXRhIiwgIl9vYmplY3REYXRhIiwgIl9zaGFyZWRPcHRpb25zIiwgIl9kcmF3U3RhcnQiLCAiX2RyYXdDb3VudCIsICJlbmFibGVPcHRpb25TaGFyaW5nIiwgInN1cHBvcnRzRGVjaW1hdGlvbiIsICIkY29udGV4dCIsICJfc3luY0xpc3QiLCAiZGF0YXNldEVsZW1lbnRUeXBlIiwgImRhdGFFbGVtZW50VHlwZSIsICJpbml0aWFsaXplIiwgImxpbmtTY2FsZXMiLCAiYWRkRWxlbWVudHMiLCAiZmlsbCIsICJpc1BsdWdpbkVuYWJsZWQiLCAiY29uc29sZSIsICJ3YXJuIiwgInVwZGF0ZUluZGV4IiwgImdldERhdGFzZXQiLCAiY2hvb3NlSWQiLCAieGlkIiwgInhBeGlzSUQiLCAidmFsdWVPckRlZmF1bHQiLCAieWlkIiwgInlBeGlzSUQiLCAicmlkIiwgInJBeGlzSUQiLCAiaW5kZXhBeGlzIiwgImlpZCIsICJpQXhpc0lEIiwgInZpZCIsICJ2QXhpc0lEIiwgImdldFNjYWxlRm9ySWQiLCAiclNjYWxlIiwgImRhdGFzZXRzIiwgImdldERhdGFzZXRNZXRhIiwgInNjYWxlSUQiLCAiX2dldE90aGVyU2NhbGUiLCAicmVzZXQiLCAiX2Rlc3Ryb3kiLCAidW5saXN0ZW5BcnJheUV2ZW50cyIsICJfZGF0YUNoZWNrIiwgImlzRXh0ZW5zaWJsZSIsICJsaXN0ZW5BcnJheUV2ZW50cyIsICJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCAicmVzZXROZXdFbGVtZW50cyIsICJzdGFja0NoYW5nZWQiLCAib2xkU3RhY2tlZCIsICJfcmVzeW5jRWxlbWVudHMiLCAic2NvcGVLZXlzIiwgImRhdGFzZXRTY29wZUtleXMiLCAic2NvcGVzIiwgImdldE9wdGlvblNjb3BlcyIsICJjcmVhdGVSZXNvbHZlciIsICJnZXRDb250ZXh0IiwgInBhcnNpbmciLCAicGFyc2UiLCAiY291bnQiLCAic29ydGVkIiwgIl9zb3J0ZWQiLCAicHJldiIsICJwYXJzZUFycmF5RGF0YSIsICJwYXJzZU9iamVjdERhdGEiLCAicGFyc2VQcmltaXRpdmVEYXRhIiwgImlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2IiwgImxhYmVscyIsICJnZXRMYWJlbHMiLCAic2luZ2xlU2NhbGUiLCAieEF4aXNLZXkiLCAieUF4aXNLZXkiLCAicmVzb2x2ZU9iamVjdEtleSIsICJnZXRQYXJzZWQiLCAiZ2V0RGF0YUVsZW1lbnQiLCAidXBkYXRlUmFuZ2VGcm9tUGFyc2VkIiwgInJhbmdlIiwgInBhcnNlZFZhbHVlIiwgIk5hTiIsICJnZXRNaW5NYXgiLCAib3RoZXJTY2FsZSIsICJvdGhlck1pbiIsICJvdGhlck1heCIsICJfc2tpcCIsICJnZXRBbGxQYXJzZWRWYWx1ZXMiLCAiZ2V0TWF4T3ZlcmZsb3ciLCAiZ2V0TGFiZWxBbmRWYWx1ZSIsICJsYWJlbCIsICJnZXRMYWJlbEZvclZhbHVlIiwgIl9jbGlwIiwgImNsaXAiLCAiZWxlbWVudHMiLCAiYXJlYSIsICJjaGFydEFyZWEiLCAiZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AiLCAiZ2V0U3R5bGUiLCAicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyIsICJyZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zIiwgImNvbnRleHQiLCAiX3Jlc29sdmVFbGVtZW50T3B0aW9ucyIsICJlbGVtZW50VHlwZSIsICJjYWNoZSIsICJjYWNoZUtleSIsICJzaGFyaW5nIiwgImRlZmluZWQiLCAiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCAicHJlZml4ZXMiLCAibmFtZXMiLCAicmVzb2x2ZU5hbWVkT3B0aW9ucyIsICJmcmVlemUiLCAiX3Jlc29sdmVBbmltYXRpb25zIiwgInRyYW5zaXRpb24iLCAiZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyIsICJfY2FjaGVhYmxlIiwgImdldFNoYXJlZE9wdGlvbnMiLCAiaW5jbHVkZU9wdGlvbnMiLCAic2hhcmVkT3B0aW9ucyIsICJfYW5pbWF0aW9uc0Rpc2FibGVkIiwgIl9nZXRTaGFyZWRPcHRpb25zIiwgImZpcnN0T3B0cyIsICJwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyIsICJ1cGRhdGVTaGFyZWRPcHRpb25zIiwgInVwZGF0ZUVsZW1lbnQiLCAiX3NldFN0eWxlIiwgInJlbW92ZUhvdmVyU3R5bGUiLCAic2V0SG92ZXJTdHlsZSIsICJfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUiLCAiX3NldERhdGFzZXRIb3ZlclN0eWxlIiwgImFyZzEiLCAiYXJnMiIsICJudW1NZXRhIiwgIm51bURhdGEiLCAiX2luc2VydEVsZW1lbnRzIiwgIl9yZW1vdmVFbGVtZW50cyIsICJtb3ZlIiwgImFyciIsICJ1cGRhdGVFbGVtZW50cyIsICJyZW1vdmVkIiwgInNwbGljZSIsICJfc3luYyIsICJhcmdzIiwgIl9kYXRhQ2hhbmdlcyIsICJfb25EYXRhUHVzaCIsICJhcmd1bWVudHMiLCAiX29uRGF0YVBvcCIsICJfb25EYXRhU2hpZnQiLCAiX29uRGF0YVNwbGljZSIsICJuZXdDb3VudCIsICJfb25EYXRhVW5zaGlmdCIsICJnZXRBbGxTY2FsZVZhbHVlcyIsICJfY2FjaGUiLCAiJGJhciIsICJ2aXNpYmxlTWV0YXMiLCAiY29uY2F0IiwgIl9hcnJheVVuaXF1ZSIsICJzb3J0IiwgImEiLCAiY29tcHV0ZU1pblNhbXBsZVNpemUiLCAiX2xlbmd0aCIsICJjdXJyIiwgInVwZGF0ZU1pbkFuZFByZXYiLCAiYWJzIiwgImdldFBpeGVsRm9yVmFsdWUiLCAidGlja3MiLCAiZ2V0UGl4ZWxGb3JUaWNrIiwgImNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyIsICJydWxlciIsICJzdGFja0NvdW50IiwgInRoaWNrbmVzcyIsICJiYXJUaGlja25lc3MiLCAicmF0aW8iLCAiaXNOdWxsT3JVbmRlZiIsICJjYXRlZ29yeVBlcmNlbnRhZ2UiLCAiYmFyUGVyY2VudGFnZSIsICJjaHVuayIsICJwaXhlbHMiLCAiY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyIsICJuZXh0IiwgInBlcmNlbnQiLCAicGFyc2VGbG9hdEJhciIsICJlbnRyeSIsICJzdGFydFZhbHVlIiwgImVuZFZhbHVlIiwgImJhclN0YXJ0IiwgImJhckVuZCIsICJfY3VzdG9tIiwgInBhcnNlVmFsdWUiLCAicGFyc2VBcnJheU9yUHJpbWl0aXZlIiwgImlzRmxvYXRCYXIiLCAiY3VzdG9tIiwgImJhclNpZ24iLCAiYWN0dWFsQmFzZSIsICJpc0hvcml6b250YWwiLCAiYm9yZGVyUHJvcHMiLCAiaG9yaXpvbnRhbCIsICJiYXNlIiwgInNldEJvcmRlclNraXBwZWQiLCAiZWRnZSIsICJib3JkZXJTa2lwcGVkIiwgImVuYWJsZUJvcmRlclJhZGl1cyIsICJwYXJzZUVkZ2UiLCAic3dhcCIsICJzdGFydEVuZCIsICJvcmlnIiwgInYxIiwgInYyIiwgInYiLCAic2V0SW5mbGF0ZUFtb3VudCIsICJpbmZsYXRlQW1vdW50IiwgIkJhckNvbnRyb2xsZXIiLCAib2JqIiwgImJhcnMiLCAiZ2V0QmFzZVBpeGVsIiwgIl9nZXRSdWxlciIsICJ2cGl4ZWxzIiwgImhlYWQiLCAiX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwgImlwaXhlbHMiLCAiX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwgImNlbnRlciIsICJoZWlnaHQiLCAid2lkdGgiLCAiX2dldFN0YWNrcyIsICJsYXN0IiwgImdyb3VwZWQiLCAiY3VycmVudFBhcnNlZCIsICJpU2NhbGVWYWx1ZSIsICJza2lwTnVsbCIsICJmaW5kIiwgInZhbCIsICJpc05hTiIsICJpbmRleE9mIiwgIl9nZXRTdGFja0NvdW50IiwgIl9nZXRTdGFja0luZGV4IiwgIm5hbWUiLCAiX3N0YXJ0UGl4ZWwiLCAiX2VuZFBpeGVsIiwgImJhc2VWYWx1ZSIsICJtaW5CYXJMZW5ndGgiLCAiZmxvYXRpbmciLCAiZ2V0RGF0YVZpc2liaWxpdHkiLCAic3RhcnRQaXhlbCIsICJnZXRQaXhlbEZvckRlY2ltYWwiLCAiZW5kUGl4ZWwiLCAiZ2V0VmFsdWVGb3JQaXhlbCIsICJoYWxmR3JpZCIsICJnZXRMaW5lV2lkdGhGb3JWYWx1ZSIsICJtYXhCYXJUaGlja25lc3MiLCAiSW5maW5pdHkiLCAic3RhY2tJbmRleCIsICJyZWN0cyIsICJudW1iZXJzIiwgIm92ZXJyaWRlcyIsICJfaW5kZXhfIiwgIm9mZnNldCIsICJncmlkIiwgIl92YWx1ZV8iLCAiYmVnaW5BdFplcm8iLCAiQnViYmxlQ29udHJvbGxlciIsICJyYWRpdXMiLCAicG9pbnRzIiwgInBvaW50IiwgImlQaXhlbCIsICJ2UGl4ZWwiLCAic2tpcCIsICJnZXRSYXRpb0FuZE9mZnNldCIsICJyb3RhdGlvbiIsICJjaXJjdW1mZXJlbmNlIiwgImN1dG91dCIsICJyYXRpb1giLCAicmF0aW9ZIiwgIm9mZnNldFgiLCAib2Zmc2V0WSIsICJUQVUiLCAic3RhcnRBbmdsZSIsICJlbmRBbmdsZSIsICJzdGFydFgiLCAiY29zIiwgInN0YXJ0WSIsICJzaW4iLCAiZW5kWCIsICJlbmRZIiwgImNhbGNNYXgiLCAiYW5nbGUiLCAiX2FuZ2xlQmV0d2VlbiIsICJjYWxjTWluIiwgIm1heFgiLCAibWF4WSIsICJIQUxGX1BJIiwgIm1pblgiLCAiUEkiLCAibWluWSIsICJEb3VnaG51dENvbnRyb2xsZXIiLCAiaW5uZXJSYWRpdXMiLCAib3V0ZXJSYWRpdXMiLCAiZ2V0dGVyIiwgIl9nZXRSb3RhdGlvbiIsICJ0b1JhZGlhbnMiLCAiX2dldENpcmN1bWZlcmVuY2UiLCAiX2dldFJvdGF0aW9uRXh0ZW50cyIsICJpc0RhdGFzZXRWaXNpYmxlIiwgImFyY3MiLCAic3BhY2luZyIsICJnZXRNYXhCb3JkZXJXaWR0aCIsICJnZXRNYXhPZmZzZXQiLCAibWF4U2l6ZSIsICJ0b1BlcmNlbnRhZ2UiLCAiY2hhcnRXZWlnaHQiLCAiX2dldFJpbmdXZWlnaHQiLCAibWF4V2lkdGgiLCAibWF4SGVpZ2h0IiwgIm1heFJhZGl1cyIsICJ0b0RpbWVuc2lvbiIsICJyYWRpdXNMZW5ndGgiLCAiX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwiLCAidG90YWwiLCAiY2FsY3VsYXRlVG90YWwiLCAiX2dldFJpbmdXZWlnaHRPZmZzZXQiLCAiX2NpcmN1bWZlcmVuY2UiLCAiYW5pbWF0ZVJvdGF0ZSIsICJjYWxjdWxhdGVDaXJjdW1mZXJlbmNlIiwgImFuaW1hdGlvbk9wdHMiLCAiY2VudGVyWCIsICJjZW50ZXJZIiwgImFuaW1hdGVTY2FsZSIsICJhcmMiLCAibWV0YURhdGEiLCAiZm9ybWF0TnVtYmVyIiwgImxvY2FsZSIsICJib3JkZXJBbGlnbiIsICJib3JkZXJXaWR0aCIsICJob3ZlckJvcmRlcldpZHRoIiwgImhvdmVyT2Zmc2V0IiwgInJpbmdXZWlnaHRPZmZzZXQiLCAid2VpZ2h0IiwgImRlc2NyaXB0b3JzIiwgIl9zY3JpcHRhYmxlIiwgIl9pbmRleGFibGUiLCAic3RhcnRzV2l0aCIsICJhc3BlY3RSYXRpbyIsICJwbHVnaW5zIiwgImxlZ2VuZCIsICJnZW5lcmF0ZUxhYmVscyIsICJwb2ludFN0eWxlIiwgIm1hcCIsICJzdHlsZSIsICJ0ZXh0IiwgImZpbGxTdHlsZSIsICJiYWNrZ3JvdW5kQ29sb3IiLCAic3Ryb2tlU3R5bGUiLCAiYm9yZGVyQ29sb3IiLCAiZm9udENvbG9yIiwgImxpbmVXaWR0aCIsICJvbkNsaWNrIiwgImUiLCAibGVnZW5kSXRlbSIsICJ0b2dnbGVEYXRhVmlzaWJpbGl0eSIsICJMaW5lQ29udHJvbGxlciIsICJsaW5lIiwgIl9kYXRhc2V0IiwgImFuaW1hdGlvbnNEaXNhYmxlZCIsICJfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyIsICJfc2NhbGVSYW5nZXNDaGFuZ2VkIiwgIl9kYXRhc2V0SW5kZXgiLCAiX2RlY2ltYXRlZCIsICJzaG93TGluZSIsICJzZWdtZW50IiwgImFuaW1hdGVkIiwgInNwYW5HYXBzIiwgIm1heEdhcExlbmd0aCIsICJpc051bWJlciIsICJkaXJlY3RVcGRhdGUiLCAicG9pbnRzQ291bnQiLCAicHJldlBhcnNlZCIsICJudWxsRGF0YSIsICJib3JkZXIiLCAiZmlyc3RQb2ludCIsICJsYXN0UG9pbnQiLCAidXBkYXRlQ29udHJvbFBvaW50cyIsICJQb2xhckFyZWFDb250cm9sbGVyIiwgIl9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSIsICJiaW5kIiwgIl91cGRhdGVSYWRpdXMiLCAibWluU2l6ZSIsICJjdXRvdXRQZXJjZW50YWdlIiwgImdldFZpc2libGVEYXRhc2V0Q291bnQiLCAieENlbnRlciIsICJ5Q2VudGVyIiwgImRhdGFzZXRTdGFydEFuZ2xlIiwgImdldEluZGV4QW5nbGUiLCAiZGVmYXVsdEFuZ2xlIiwgImNvdW50VmlzaWJsZUVsZW1lbnRzIiwgIl9jb21wdXRlQW5nbGUiLCAiZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUiLCAiYW5nbGVMaW5lcyIsICJkaXNwbGF5IiwgImNpcmN1bGFyIiwgInBvaW50TGFiZWxzIiwgIlBpZUNvbnRyb2xsZXIiLCAiUmFkYXJDb250cm9sbGVyIiwgIl9mdWxsTG9vcCIsICJwb2ludFBvc2l0aW9uIiwgImdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSIsICJTY2F0dGVyQ29udHJvbGxlciIsICJyZWdpc3RyeSIsICJnZXRFbGVtZW50IiwgImludGVyYWN0aW9uIiwgImFic3RyYWN0IiwgIkVycm9yIiwgIkRhdGVBZGFwdGVyQmFzZSIsICJvdmVycmlkZSIsICJtZW1iZXJzIiwgInByb3RvdHlwZSIsICJpbml0IiwgImZvcm1hdHMiLCAiZm9ybWF0IiwgImRpZmYiLCAic3RhcnRPZiIsICJlbmRPZiIsICJfZGF0ZSIsICJiaW5hcnlTZWFyY2giLCAibWV0YXNldCIsICJpbnRlcnNlY3QiLCAibG9va3VwTWV0aG9kIiwgIl9yZXZlcnNlUGl4ZWxzIiwgIl9ybG9va3VwQnlLZXkiLCAiX2xvb2t1cEJ5S2V5IiwgInJlc3VsdCIsICJkaXN0YW5jZVRvRGVmaW5lZExvIiwgInNsaWNlIiwgImxvIiwgImZpbmRJbmRleCIsICJkaXN0YW5jZVRvRGVmaW5lZEhpIiwgImhpIiwgImVsIiwgImdldFJhbmdlIiwgImV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyIsICJwb3NpdGlvbiIsICJoYW5kbGVyIiwgImdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMiLCAiaiIsICJnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMiLCAidXNlWCIsICJ1c2VZIiwgInB0MSIsICJwdDIiLCAiZGVsdGFYIiwgImRlbHRhWSIsICJzcXJ0IiwgInBvdyIsICJnZXRJbnRlcnNlY3RJdGVtcyIsICJ1c2VGaW5hbFBvc2l0aW9uIiwgImluY2x1ZGVJbnZpc2libGUiLCAiaXNQb2ludEluQXJlYSIsICJldmFsdWF0aW9uRnVuYyIsICJfaXNQb2ludEluQXJlYSIsICJpblJhbmdlIiwgImdldE5lYXJlc3RSYWRpYWxJdGVtcyIsICJnZXRQcm9wcyIsICJnZXRBbmdsZUZyb21Qb2ludCIsICJnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMiLCAiZGlzdGFuY2VNZXRyaWMiLCAibWluRGlzdGFuY2UiLCAiZ2V0Q2VudGVyUG9pbnQiLCAicG9pbnRJbkFyZWEiLCAiZGlzdGFuY2UiLCAiZ2V0TmVhcmVzdEl0ZW1zIiwgImdldEF4aXNJdGVtcyIsICJyYW5nZU1ldGhvZCIsICJpbnRlcnNlY3RzSXRlbSIsICJtb2RlcyIsICJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwgIm5lYXJlc3QiLCAiU1RBVElDX1BPU0lUSU9OUyIsICJmaWx0ZXJCeVBvc2l0aW9uIiwgImFycmF5IiwgInBvcyIsICJmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMiLCAiYm94IiwgInNvcnRCeVdlaWdodCIsICJ2MCIsICJ3cmFwQm94ZXMiLCAiYm94ZXMiLCAibGF5b3V0Qm94ZXMiLCAic3RhY2tXZWlnaHQiLCAiYnVpbGRTdGFja3MiLCAibGF5b3V0cyIsICJ3cmFwIiwgImluY2x1ZGVzIiwgIl9zdGFjayIsICJwbGFjZWQiLCAic2V0TGF5b3V0RGltcyIsICJwYXJhbXMiLCAidkJveE1heFdpZHRoIiwgImhCb3hNYXhIZWlnaHQiLCAibGF5b3V0IiwgImZ1bGxTaXplIiwgImF2YWlsYWJsZVdpZHRoIiwgImF2YWlsYWJsZUhlaWdodCIsICJidWlsZExheW91dEJveGVzIiwgImNlbnRlckhvcml6b250YWwiLCAiY2VudGVyVmVydGljYWwiLCAibGVmdEFuZFRvcCIsICJyaWdodEFuZEJvdHRvbSIsICJ2ZXJ0aWNhbCIsICJnZXRDb21iaW5lZE1heCIsICJtYXhQYWRkaW5nIiwgInVwZGF0ZU1heFBhZGRpbmciLCAiYm94UGFkZGluZyIsICJ1cGRhdGVEaW1zIiwgImdldFBhZGRpbmciLCAibmV3V2lkdGgiLCAib3V0ZXJXaWR0aCIsICJuZXdIZWlnaHQiLCAib3V0ZXJIZWlnaHQiLCAid2lkdGhDaGFuZ2VkIiwgInciLCAiaGVpZ2h0Q2hhbmdlZCIsICJoIiwgInNhbWUiLCAib3RoZXIiLCAiaGFuZGxlTWF4UGFkZGluZyIsICJ1cGRhdGVQb3MiLCAiY2hhbmdlIiwgImdldE1hcmdpbnMiLCAibWFyZ2luRm9yUG9zaXRpb25zIiwgInBvc2l0aW9ucyIsICJtYXJnaW4iLCAiZml0Qm94ZXMiLCAicmVmaXRCb3hlcyIsICJyZWZpdCIsICJjaGFuZ2VkIiwgInNldEJveERpbXMiLCAicGxhY2VCb3hlcyIsICJ1c2VyUGFkZGluZyIsICJwYWRkaW5nIiwgImFkZEJveCIsICJfbGF5ZXJzIiwgInoiLCAicmVtb3ZlQm94IiwgImxheW91dEl0ZW0iLCAibWluUGFkZGluZyIsICJ0b1BhZGRpbmciLCAidmVydGljYWxCb3hlcyIsICJob3Jpem9udGFsQm94ZXMiLCAiZWFjaCIsICJiZWZvcmVMYXlvdXQiLCAidmlzaWJsZVZlcnRpY2FsQm94Q291bnQiLCAiQmFzZVBsYXRmb3JtIiwgImFjcXVpcmVDb250ZXh0IiwgImNhbnZhcyIsICJyZWxlYXNlQ29udGV4dCIsICJhZGRFdmVudExpc3RlbmVyIiwgImxpc3RlbmVyIiwgInJlbW92ZUV2ZW50TGlzdGVuZXIiLCAiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsICJnZXRNYXhpbXVtU2l6ZSIsICJpc0F0dGFjaGVkIiwgInVwZGF0ZUNvbmZpZyIsICJCYXNpY1BsYXRmb3JtIiwgIkVYUEFORE9fS0VZIiwgIkVWRU5UX1RZUEVTIiwgInRvdWNoc3RhcnQiLCAidG91Y2htb3ZlIiwgInRvdWNoZW5kIiwgInBvaW50ZXJlbnRlciIsICJwb2ludGVyZG93biIsICJwb2ludGVybW92ZSIsICJwb2ludGVydXAiLCAicG9pbnRlcmxlYXZlIiwgInBvaW50ZXJvdXQiLCAiaXNOdWxsT3JFbXB0eSIsICJpbml0Q2FudmFzIiwgInJlbmRlckhlaWdodCIsICJnZXRBdHRyaWJ1dGUiLCAicmVuZGVyV2lkdGgiLCAiYm94U2l6aW5nIiwgImRpc3BsYXlXaWR0aCIsICJyZWFkVXNlZFNpemUiLCAiZGlzcGxheUhlaWdodCIsICJldmVudExpc3RlbmVyT3B0aW9ucyIsICJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwgInBhc3NpdmUiLCAiYWRkTGlzdGVuZXIiLCAibm9kZSIsICJyZW1vdmVMaXN0ZW5lciIsICJmcm9tTmF0aXZlRXZlbnQiLCAibmF0aXZlIiwgIm5vZGVMaXN0Q29udGFpbnMiLCAibm9kZUxpc3QiLCAiY29udGFpbnMiLCAiY3JlYXRlQXR0YWNoT2JzZXJ2ZXIiLCAib2JzZXJ2ZXIiLCAiTXV0YXRpb25PYnNlcnZlciIsICJlbnRyaWVzIiwgInRyaWdnZXIiLCAiYWRkZWROb2RlcyIsICJyZW1vdmVkTm9kZXMiLCAib2JzZXJ2ZSIsICJkb2N1bWVudCIsICJjaGlsZExpc3QiLCAic3VidHJlZSIsICJjcmVhdGVEZXRhY2hPYnNlcnZlciIsICJkcnBMaXN0ZW5pbmdDaGFydHMiLCAib2xkRGV2aWNlUGl4ZWxSYXRpbyIsICJvbldpbmRvd1Jlc2l6ZSIsICJkcHIiLCAiZGV2aWNlUGl4ZWxSYXRpbyIsICJyZXNpemUiLCAiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCAibGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMiLCAidW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsICJjcmVhdGVSZXNpemVPYnNlcnZlciIsICJjb250YWluZXIiLCAiX2dldFBhcmVudE5vZGUiLCAidGhyb3R0bGVkIiwgImNsaWVudFdpZHRoIiwgIlJlc2l6ZU9ic2VydmVyIiwgImNvbnRlbnRSZWN0IiwgInJlbGVhc2VPYnNlcnZlciIsICJkaXNjb25uZWN0IiwgImNyZWF0ZVByb3h5QW5kTGlzdGVuIiwgInByb3h5IiwgIkRvbVBsYXRmb3JtIiwgInJlbW92ZUF0dHJpYnV0ZSIsICJzZXRBdHRyaWJ1dGUiLCAicHJveGllcyIsICIkcHJveGllcyIsICJoYW5kbGVycyIsICJhdHRhY2giLCAiZGV0YWNoIiwgImlzQ29ubmVjdGVkIiwgIl9kZXRlY3RQbGF0Zm9ybSIsICJfaXNEb21TdXBwb3J0ZWQiLCAiT2Zmc2NyZWVuQ2FudmFzIiwgIkVsZW1lbnQiLCAidG9vbHRpcFBvc2l0aW9uIiwgImhhc1ZhbHVlIiwgImZpbmFsIiwgInJldCIsICJkZWZhdWx0Um91dGVzIiwgImF1dG9Ta2lwIiwgInRpY2tPcHRzIiwgImRldGVybWluZWRNYXhUaWNrcyIsICJkZXRlcm1pbmVNYXhUaWNrcyIsICJ0aWNrc0xpbWl0IiwgIm1heFRpY2tzTGltaXQiLCAibWFqb3JJbmRpY2VzIiwgIm1ham9yIiwgImVuYWJsZWQiLCAiZ2V0TWFqb3JJbmRpY2VzIiwgIm51bU1ham9ySW5kaWNlcyIsICJmaXJzdCIsICJuZXdUaWNrcyIsICJza2lwTWFqb3JzIiwgImNhbGN1bGF0ZVNwYWNpbmciLCAiYXZnTWFqb3JTcGFjaW5nIiwgInJvdW5kIiwgInRpY2tMZW5ndGgiLCAiX3RpY2tTaXplIiwgIm1heFNjYWxlIiwgIm1heENoYXJ0IiwgIl9tYXhMZW5ndGgiLCAiZXZlbk1ham9yU3BhY2luZyIsICJnZXRFdmVuU3BhY2luZyIsICJmYWN0b3JzIiwgIl9mYWN0b3JpemUiLCAiY2VpbCIsICJtYWpvclN0YXJ0IiwgIm1ham9yRW5kIiwgImxlbiIsICJyZXZlcnNlQWxpZ24iLCAiYWxpZ24iLCAib2Zmc2V0RnJvbUVkZ2UiLCAiZ2V0VGlja3NMaW1pdCIsICJ0aWNrc0xlbmd0aCIsICJzYW1wbGUiLCAibnVtSXRlbXMiLCAiaW5jcmVtZW50IiwgImdldFBpeGVsRm9yR3JpZExpbmUiLCAib2Zmc2V0R3JpZExpbmVzIiwgInZhbGlkSW5kZXgiLCAiZXBzaWxvbiIsICJsaW5lVmFsdWUiLCAiZ2FyYmFnZUNvbGxlY3QiLCAiY2FjaGVzIiwgImdjIiwgImdjTGVuIiwgImdldFRpY2tNYXJrTGVuZ3RoIiwgImRyYXdUaWNrcyIsICJnZXRUaXRsZUhlaWdodCIsICJmYWxsYmFjayIsICJmb250IiwgInRvRm9udCIsICJsaW5lcyIsICJsaW5lSGVpZ2h0IiwgImNyZWF0ZVNjYWxlQ29udGV4dCIsICJjcmVhdGVUaWNrQ29udGV4dCIsICJ0aXRsZUFsaWduIiwgIl90b0xlZnRSaWdodENlbnRlciIsICJ0aXRsZUFyZ3MiLCAidGl0bGVYIiwgInRpdGxlWSIsICJfYWxpZ25TdGFydEVuZCIsICJwb3NpdGlvbkF4aXNJRCIsICJTY2FsZSIsICJfbWFyZ2lucyIsICJwYWRkaW5nVG9wIiwgInBhZGRpbmdCb3R0b20iLCAicGFkZGluZ0xlZnQiLCAicGFkZGluZ1JpZ2h0IiwgImxhYmVsUm90YXRpb24iLCAiX3JhbmdlIiwgIl9ncmlkTGluZUl0ZW1zIiwgIl9sYWJlbEl0ZW1zIiwgIl9sYWJlbFNpemVzIiwgIl9sb25nZXN0VGV4dENhY2hlIiwgIl91c2VyTWF4IiwgIl91c2VyTWluIiwgIl9zdWdnZXN0ZWRNYXgiLCAiX3N1Z2dlc3RlZE1pbiIsICJfdGlja3NMZW5ndGgiLCAiX2JvcmRlclZhbHVlIiwgIl9kYXRhTGltaXRzQ2FjaGVkIiwgInNldENvbnRleHQiLCAic3VnZ2VzdGVkTWluIiwgInN1Z2dlc3RlZE1heCIsICJmaW5pdGVPckRlZmF1bHQiLCAibWV0YXMiLCAiZ2V0VGlja3MiLCAieExhYmVscyIsICJ5TGFiZWxzIiwgImdldExhYmVsSXRlbXMiLCAiX2NvbXB1dGVMYWJlbEl0ZW1zIiwgImJlZm9yZVVwZGF0ZSIsICJtYXJnaW5zIiwgImdyYWNlIiwgInNhbXBsZVNpemUiLCAiYmVmb3JlU2V0RGltZW5zaW9ucyIsICJzZXREaW1lbnNpb25zIiwgImFmdGVyU2V0RGltZW5zaW9ucyIsICJiZWZvcmVEYXRhTGltaXRzIiwgImRldGVybWluZURhdGFMaW1pdHMiLCAiYWZ0ZXJEYXRhTGltaXRzIiwgIl9hZGRHcmFjZSIsICJiZWZvcmVCdWlsZFRpY2tzIiwgImJ1aWxkVGlja3MiLCAiYWZ0ZXJCdWlsZFRpY2tzIiwgInNhbXBsaW5nRW5hYmxlZCIsICJfY29udmVydFRpY2tzVG9MYWJlbHMiLCAiYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJjYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwgImFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJzb3VyY2UiLCAiYWZ0ZXJBdXRvU2tpcCIsICJiZWZvcmVGaXQiLCAiZml0IiwgImFmdGVyRml0IiwgImFmdGVyVXBkYXRlIiwgInJldmVyc2VQaXhlbHMiLCAiX2FsaWduVG9QaXhlbHMiLCAiYWxpZ25Ub1BpeGVscyIsICJfY2FsbEhvb2tzIiwgIm5vdGlmeVBsdWdpbnMiLCAiYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uIiwgImdlbmVyYXRlVGlja0xhYmVscyIsICJjYWxsYmFjayIsICJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsICJudW1UaWNrcyIsICJtaW5Sb3RhdGlvbiIsICJtYXhSb3RhdGlvbiIsICJ0aWNrV2lkdGgiLCAibWF4TGFiZWxEaWFnb25hbCIsICJfaXNWaXNpYmxlIiwgImxhYmVsU2l6ZXMiLCAiX2dldExhYmVsU2l6ZXMiLCAibWF4TGFiZWxXaWR0aCIsICJ3aWRlc3QiLCAibWF4TGFiZWxIZWlnaHQiLCAiaGlnaGVzdCIsICJfbGltaXRWYWx1ZSIsICJ0aXRsZSIsICJ0b0RlZ3JlZXMiLCAiYXNpbiIsICJ0aXRsZU9wdHMiLCAiZ3JpZE9wdHMiLCAidGl0bGVIZWlnaHQiLCAidGlja1BhZGRpbmciLCAiYW5nbGVSYWRpYW5zIiwgImxhYmVsSGVpZ2h0IiwgIm1pcnJvciIsICJsYWJlbFdpZHRoIiwgIl9jYWxjdWxhdGVQYWRkaW5nIiwgIl9oYW5kbGVNYXJnaW5zIiwgImlzUm90YXRlZCIsICJsYWJlbHNCZWxvd1RpY2tzIiwgIm9mZnNldExlZnQiLCAib2Zmc2V0UmlnaHQiLCAiaXNGdWxsU2l6ZSIsICJfY29tcHV0ZUxhYmVsU2l6ZXMiLCAid2lkdGhzIiwgImhlaWdodHMiLCAid2lkZXN0TGFiZWxTaXplIiwgImhpZ2hlc3RMYWJlbFNpemUiLCAiamxlbiIsICJ0aWNrRm9udCIsICJmb250U3RyaW5nIiwgIm5lc3RlZExhYmVsIiwgIl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zIiwgInN0cmluZyIsICJfbWVhc3VyZVRleHQiLCAidmFsdWVBdCIsICJpZHgiLCAicGl4ZWwiLCAiZGVjaW1hbCIsICJfaW50MTZSYW5nZSIsICJfYWxpZ25QaXhlbCIsICJnZXREZWNpbWFsRm9yUGl4ZWwiLCAiZ2V0QmFzZVZhbHVlIiwgIm9wdGlvblRpY2tzIiwgInJvdCIsICJhdXRvU2tpcFBhZGRpbmciLCAiX2NvbXB1dGVHcmlkTGluZUl0ZW1zIiwgInRsIiwgImJvcmRlck9wdHMiLCAiYXhpc1dpZHRoIiwgImF4aXNIYWxmV2lkdGgiLCAiYWxpZ25Cb3JkZXJWYWx1ZSIsICJib3JkZXJWYWx1ZSIsICJhbGlnbmVkTGluZVZhbHVlIiwgInR4MSIsICJ0eTEiLCAidHgyIiwgInR5MiIsICJ4MSIsICJ5MSIsICJ4MiIsICJ5MiIsICJsaW1pdCIsICJzdGVwIiwgIm9wdHNBdEluZGV4IiwgIm9wdHNBdEluZGV4Qm9yZGVyIiwgImxpbmVDb2xvciIsICJib3JkZXJEYXNoIiwgImRhc2giLCAiYm9yZGVyRGFzaE9mZnNldCIsICJkYXNoT2Zmc2V0IiwgInRpY2tDb2xvciIsICJ0aWNrQm9yZGVyRGFzaCIsICJ0aWNrQm9yZGVyRGFzaE9mZnNldCIsICJjcm9zc0FsaWduIiwgInRpY2tBbmRQYWRkaW5nIiwgImhUaWNrQW5kUGFkZGluZyIsICJ0ZXh0QWxpZ24iLCAibGluZUNvdW50IiwgInRleHRPZmZzZXQiLCAidGV4dEJhc2VsaW5lIiwgIl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50IiwgIl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50IiwgImxhYmVsT2Zmc2V0IiwgImhhbGZDb3VudCIsICJzdHJva2VDb2xvciIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAic3Ryb2tlV2lkdGgiLCAidGV4dFN0cm9rZVdpZHRoIiwgInRpY2tUZXh0QWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3AiLCAibGFiZWxQYWRkaW5nIiwgImJhY2tkcm9wUGFkZGluZyIsICJiYWNrZHJvcENvbG9yIiwgInRyYW5zbGF0aW9uIiwgIl9jb21wdXRlTGFiZWxBcmVhIiwgImRyYXdCYWNrZ3JvdW5kIiwgInNhdmUiLCAiZmlsbFJlY3QiLCAicmVzdG9yZSIsICJkcmF3R3JpZCIsICJkcmF3TGluZSIsICJwMSIsICJwMiIsICJzZXRMaW5lRGFzaCIsICJsaW5lRGFzaE9mZnNldCIsICJiZWdpblBhdGgiLCAibW92ZVRvIiwgImxpbmVUbyIsICJzdHJva2UiLCAiZHJhd09uQ2hhcnRBcmVhIiwgImRyYXdCb3JkZXIiLCAibGFzdExpbmVXaWR0aCIsICJkcmF3TGFiZWxzIiwgImNsaXBBcmVhIiwgInJlbmRlclRleHRPcHRpb25zIiwgInJlbmRlclRleHQiLCAidW5jbGlwQXJlYSIsICJkcmF3VGl0bGUiLCAidHoiLCAiZ3oiLCAiYnoiLCAiYXhpc0lEIiwgIl9tYXhEaWdpdHMiLCAiZm9udFNpemUiLCAiVHlwZWRSZWdpc3RyeSIsICJzY29wZSIsICJjcmVhdGUiLCAiaXNGb3JUeXBlIiwgImlzUHJvdG90eXBlT2YiLCAicmVnaXN0ZXIiLCAicHJvdG8iLCAiZ2V0UHJvdG90eXBlT2YiLCAicGFyZW50U2NvcGUiLCAiaXNJQ2hhcnRDb21wb25lbnQiLCAicmVnaXN0ZXJEZWZhdWx0cyIsICJ1bnJlZ2lzdGVyIiwgIml0ZW1EZWZhdWx0cyIsICJtZXJnZSIsICJyb3V0ZURlZmF1bHRzIiwgImRlc2NyaWJlIiwgInJvdXRlcyIsICJwcm9wZXJ0eSIsICJwcm9wZXJ0eVBhcnRzIiwgInNwbGl0IiwgInNvdXJjZU5hbWUiLCAic291cmNlU2NvcGUiLCAiam9pbiIsICJwYXJ0cyIsICJ0YXJnZXROYW1lIiwgInRhcmdldFNjb3BlIiwgInJvdXRlIiwgIlJlZ2lzdHJ5IiwgImNvbnRyb2xsZXJzIiwgIl90eXBlZFJlZ2lzdHJpZXMiLCAiX2VhY2giLCAiYWRkQ29udHJvbGxlcnMiLCAiYWRkUGx1Z2lucyIsICJhZGRTY2FsZXMiLCAiZ2V0Q29udHJvbGxlciIsICJfZ2V0IiwgImdldFBsdWdpbiIsICJnZXRTY2FsZSIsICJyZW1vdmVDb250cm9sbGVycyIsICJyZW1vdmVFbGVtZW50cyIsICJyZW1vdmVQbHVnaW5zIiwgInJlbW92ZVNjYWxlcyIsICJ0eXBlZFJlZ2lzdHJ5IiwgImFyZyIsICJyZWciLCAiX2dldFJlZ2lzdHJ5Rm9yVHlwZSIsICJfZXhlYyIsICJpdGVtUmVnIiwgImNvbXBvbmVudCIsICJjYW1lbE1ldGhvZCIsICJfY2FwaXRhbGl6ZSIsICJQbHVnaW5TZXJ2aWNlIiwgIl9pbml0IiwgIm5vdGlmeSIsICJob29rIiwgIl9jcmVhdGVEZXNjcmlwdG9ycyIsICJfZGVzY3JpcHRvcnMiLCAiZGVzY3JpcHRvciIsICJwbHVnaW4iLCAiY2FsbENhbGxiYWNrIiwgImNhbmNlbGFibGUiLCAiaW52YWxpZGF0ZSIsICJfb2xkQ2FjaGUiLCAiX25vdGlmeVN0YXRlQ2hhbmdlcyIsICJhbGxQbHVnaW5zIiwgImNyZWF0ZURlc2NyaXB0b3JzIiwgInByZXZpb3VzRGVzY3JpcHRvcnMiLCAic29tZSIsICJsb2NhbElkcyIsICJsb2NhbCIsICJnZXRPcHRzIiwgInBsdWdpbk9wdHMiLCAicGx1Z2luU2NvcGVLZXlzIiwgInNjcmlwdGFibGUiLCAiaW5kZXhhYmxlIiwgImFsbEtleXMiLCAiZ2V0SW5kZXhBeGlzIiwgImRhdGFzZXREZWZhdWx0cyIsICJkYXRhc2V0T3B0aW9ucyIsICJnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEIiwgImdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMiLCAiaWRNYXRjaGVzQXhpcyIsICJheGlzRnJvbVBvc2l0aW9uIiwgImRldGVybWluZUF4aXMiLCAic2NhbGVPcHRpb25zIiwgInRvTG93ZXJDYXNlIiwgImdldEF4aXNGcm9tRGF0YXNldCIsICJyZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMiLCAiYm91bmREcyIsICJkIiwgIm1lcmdlU2NhbGVDb25maWciLCAiY2hhcnREZWZhdWx0cyIsICJjb25maWdTY2FsZXMiLCAiY2hhcnRJbmRleEF4aXMiLCAic2NhbGVDb25mIiwgImVycm9yIiwgIl9wcm94eSIsICJkZWZhdWx0SWQiLCAiZGVmYXVsdFNjYWxlT3B0aW9ucyIsICJtZXJnZUlmIiwgImRlZmF1bHRJRCIsICJpbml0T3B0aW9ucyIsICJpbml0RGF0YSIsICJpbml0Q29uZmlnIiwgImtleUNhY2hlIiwgImtleXNDYWNoZWQiLCAiU2V0IiwgImNhY2hlZEtleXMiLCAiZ2VuZXJhdGUiLCAiYWRkSWZGb3VuZCIsICJDb25maWciLCAiX2NvbmZpZyIsICJfc2NvcGVDYWNoZSIsICJfcmVzb2x2ZXJDYWNoZSIsICJwbGF0Zm9ybSIsICJjbGVhckNhY2hlIiwgImNsZWFyIiwgImRhdGFzZXRUeXBlIiwgImFkZGl0aW9uYWxPcHRpb25TY29wZXMiLCAiX2NhY2hlZFNjb3BlcyIsICJtYWluU2NvcGUiLCAicmVzZXRDYWNoZSIsICJrZXlMaXN0cyIsICJjaGFydE9wdGlvblNjb3BlcyIsICJyZXNvbHZlciIsICJzdWJQcmVmaXhlcyIsICJnZXRSZXNvbHZlciIsICJuZWVkQ29udGV4dCIsICJpc0Z1bmN0aW9uIiwgInN1YlJlc29sdmVyIiwgIl9hdHRhY2hDb250ZXh0IiwgImRlc2NyaXB0b3JEZWZhdWx0cyIsICJyZXNvbHZlckNhY2hlIiwgIl9jcmVhdGVSZXNvbHZlciIsICJwIiwgImhhc0Z1bmN0aW9uIiwgImlzU2NyaXB0YWJsZSIsICJpc0luZGV4YWJsZSIsICJLTk9XTl9QT1NJVElPTlMiLCAicG9zaXRpb25Jc0hvcml6b250YWwiLCAiY29tcGFyZTJMZXZlbCIsICJsMSIsICJsMiIsICJvbkFuaW1hdGlvbnNDb21wbGV0ZSIsICJvbkNvbXBsZXRlIiwgIm9uQW5pbWF0aW9uUHJvZ3Jlc3MiLCAib25Qcm9ncmVzcyIsICJnZXRDYW52YXMiLCAiZ2V0RWxlbWVudEJ5SWQiLCAiaW5zdGFuY2VzIiwgImdldENoYXJ0IiwgImMiLCAibW92ZU51bWVyaWNLZXlzIiwgImludEtleSIsICJkZXRlcm1pbmVMYXN0RXZlbnQiLCAibGFzdEV2ZW50IiwgImluQ2hhcnRBcmVhIiwgImlzQ2xpY2siLCAiQ2hhcnQiLCAiaW52YWxpZGF0ZVBsdWdpbnMiLCAidXNlckNvbmZpZyIsICJpbml0aWFsQ2FudmFzIiwgImV4aXN0aW5nQ2hhcnQiLCAidWlkIiwgIl9vcHRpb25zIiwgIl9hc3BlY3RSYXRpbyIsICJfbWV0YXNldHMiLCAiX2xhc3RFdmVudCIsICJfbGlzdGVuZXJzIiwgIl9yZXNwb25zaXZlTGlzdGVuZXJzIiwgIl9zb3J0ZWRNZXRhc2V0cyIsICJfcGx1Z2lucyIsICJfaGlkZGVuSW5kaWNlcyIsICJhdHRhY2hlZCIsICJfZG9SZXNpemUiLCAiZGVib3VuY2UiLCAicmVzaXplRGVsYXkiLCAiX2luaXRpYWxpemUiLCAibWFpbnRhaW5Bc3BlY3RSYXRpbyIsICJyZXNwb25zaXZlIiwgInJldGluYVNjYWxlIiwgImJpbmRFdmVudHMiLCAiY2xlYXJDYW52YXMiLCAiX3Jlc2l6ZSIsICJfcmVzaXplQmVmb3JlRHJhdyIsICJuZXdTaXplIiwgIm5ld1JhdGlvIiwgIm9uUmVzaXplIiwgInJlbmRlciIsICJlbnN1cmVTY2FsZXNIYXZlSURzIiwgInNjYWxlc09wdGlvbnMiLCAiYXhpc09wdGlvbnMiLCAiYnVpbGRPclVwZGF0ZVNjYWxlcyIsICJzY2FsZU9wdHMiLCAidXBkYXRlZCIsICJpc1JhZGlhbCIsICJkcG9zaXRpb24iLCAiZHR5cGUiLCAic2NhbGVUeXBlIiwgInNjYWxlQ2xhc3MiLCAiaGFzVXBkYXRlZCIsICJfdXBkYXRlTWV0YXNldHMiLCAiX2Rlc3Ryb3lEYXRhc2V0TWV0YSIsICJfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMiLCAiYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzIiwgIm5ld0NvbnRyb2xsZXJzIiwgIm9yZGVyIiwgInZpc2libGUiLCAiQ29udHJvbGxlckNsYXNzIiwgIl9yZXNldEVsZW1lbnRzIiwgImFuaW1zRGlzYWJsZWQiLCAiX3VwZGF0ZVNjYWxlcyIsICJfY2hlY2tFdmVudEJpbmRpbmdzIiwgIl91cGRhdGVIaWRkZW5JbmRpY2VzIiwgIl9taW5QYWRkaW5nIiwgImF1dG9QYWRkaW5nIiwgIl91cGRhdGVMYXlvdXQiLCAiX3VwZGF0ZURhdGFzZXRzIiwgIl9ldmVudEhhbmRsZXIiLCAiX3VwZGF0ZUhvdmVyU3R5bGVzIiwgImV4aXN0aW5nRXZlbnRzIiwgIm5ld0V2ZW50cyIsICJldmVudHMiLCAic2V0c0VxdWFsIiwgInVuYmluZEV2ZW50cyIsICJjaGFuZ2VzIiwgIl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMiLCAiZGF0YXNldENvdW50IiwgIm1ha2VTZXQiLCAiY2hhbmdlU2V0IiwgIm5vQXJlYSIsICJfaWR4IiwgIl91cGRhdGVEYXRhc2V0IiwgImxheWVycyIsICJfZHJhd0RhdGFzZXRzIiwgIl9kcmF3RGF0YXNldCIsICJnZXREYXRhc2V0Q2xpcEFyZWEiLCAiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsICJJbnRlcmFjdGlvbiIsICJzZXREYXRhc2V0VmlzaWJpbGl0eSIsICJfdXBkYXRlVmlzaWJpbGl0eSIsICJoaWRlIiwgInNob3ciLCAiX3N0b3AiLCAiZGVzdHJveSIsICJ0b0Jhc2U2NEltYWdlIiwgInRvRGF0YVVSTCIsICJiaW5kVXNlckV2ZW50cyIsICJiaW5kUmVzcG9uc2l2ZUV2ZW50cyIsICJfYWRkIiwgIl9yZW1vdmUiLCAiZGV0YWNoZWQiLCAidXBkYXRlSG92ZXJTdHlsZSIsICJwcmVmaXgiLCAiZ2V0QWN0aXZlRWxlbWVudHMiLCAic2V0QWN0aXZlRWxlbWVudHMiLCAiYWN0aXZlRWxlbWVudHMiLCAibGFzdEFjdGl2ZSIsICJfZWxlbWVudHNFcXVhbCIsICJwbHVnaW5JZCIsICJyZXBsYXkiLCAiaG92ZXJPcHRpb25zIiwgImhvdmVyIiwgImRlYWN0aXZhdGVkIiwgImFjdGl2YXRlZCIsICJldmVudEZpbHRlciIsICJfaGFuZGxlRXZlbnQiLCAiX2dldEFjdGl2ZUVsZW1lbnRzIiwgIl9pc0NsaWNrRXZlbnQiLCAib25Ib3ZlciIsICJ2ZXJzaW9uIiwgImNsaXBBcmMiLCAicGl4ZWxNYXJnaW4iLCAiYW5nbGVNYXJnaW4iLCAiY2xvc2VQYXRoIiwgInRvUmFkaXVzQ29ybmVycyIsICJfcmVhZFZhbHVlVG9Qcm9wcyIsICJwYXJzZUJvcmRlclJhZGl1cyIsICJhbmdsZURlbHRhIiwgIm8iLCAiYm9yZGVyUmFkaXVzIiwgImhhbGZUaGlja25lc3MiLCAiaW5uZXJMaW1pdCIsICJjb21wdXRlT3V0ZXJMaW1pdCIsICJvdXRlckFyY0xpbWl0IiwgIm91dGVyU3RhcnQiLCAib3V0ZXJFbmQiLCAiaW5uZXJTdGFydCIsICJpbm5lckVuZCIsICJyVGhldGFUb1hZIiwgInRoZXRhIiwgInBhdGhBcmMiLCAiaW5uZXJSIiwgInNwYWNpbmdPZmZzZXQiLCAiYWxwaGEiLCAibm9TcGFjaW5nSW5uZXJSYWRpdXMiLCAibm9TcGFjaW5nT3V0ZXJSYWRpdXMiLCAiYXZOb2dTcGFjaW5nUmFkaXVzIiwgImFkanVzdGVkQW5nbGUiLCAiYmV0YSIsICJhbmdsZU9mZnNldCIsICJvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMiLCAib3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyIsICJvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSIsICJvdXRlckVuZEFkanVzdGVkQW5nbGUiLCAiaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzIiwgImlubmVyRW5kQWRqdXN0ZWRSYWRpdXMiLCAiaW5uZXJTdGFydEFkanVzdGVkQW5nbGUiLCAiaW5uZXJFbmRBZGp1c3RlZEFuZ2xlIiwgIm91dGVyTWlkQWRqdXN0ZWRBbmdsZSIsICJwQ2VudGVyIiwgInA0IiwgImlubmVyTWlkQWRqdXN0ZWRBbmdsZSIsICJwOCIsICJvdXRlclN0YXJ0WCIsICJvdXRlclN0YXJ0WSIsICJvdXRlckVuZFgiLCAib3V0ZXJFbmRZIiwgImRyYXdBcmMiLCAiZnVsbENpcmNsZXMiLCAiYm9yZGVySm9pblN0eWxlIiwgImlubmVyIiwgImxpbmVKb2luIiwgIkFyY0VsZW1lbnQiLCAiY2hhcnRYIiwgImNoYXJ0WSIsICJyQWRqdXN0IiwgIm5vblplcm9CZXR3ZWVuIiwgImJldHdlZW5BbmdsZXMiLCAid2l0aGluUmFkaXVzIiwgIl9pc0JldHdlZW4iLCAiaGFsZkFuZ2xlIiwgImhhbGZSYWRpdXMiLCAidHJhbnNsYXRlIiwgImZpeCIsICJyYWRpdXNPZmZzZXQiLCAic2V0U3R5bGUiLCAibGluZUNhcCIsICJib3JkZXJDYXBTdHlsZSIsICJwcmV2aW91cyIsICJnZXRMaW5lTWV0aG9kIiwgInN0ZXBwZWQiLCAiX3N0ZXBwZWRMaW5lVG8iLCAidGVuc2lvbiIsICJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwgIl9iZXppZXJDdXJ2ZVRvIiwgInBhdGhWYXJzIiwgInBhcmFtc1N0YXJ0IiwgInBhcmFtc0VuZCIsICJzZWdtZW50U3RhcnQiLCAic2VnbWVudEVuZCIsICJvdXRzaWRlIiwgInBhdGhTZWdtZW50IiwgImxpbmVNZXRob2QiLCAiZmFzdFBhdGhTZWdtZW50IiwgImF2Z1giLCAiY291bnRYIiwgInByZXZYIiwgImxhc3RZIiwgInBvaW50SW5kZXgiLCAiZHJhd1giLCAidHJ1bmNYIiwgIl9nZXRTZWdtZW50TWV0aG9kIiwgInVzZUZhc3RQYXRoIiwgIl9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kIiwgIl9zdGVwcGVkSW50ZXJwb2xhdGlvbiIsICJfYmV6aWVySW50ZXJwb2xhdGlvbiIsICJfcG9pbnRJbkxpbmUiLCAic3Ryb2tlUGF0aFdpdGhDYWNoZSIsICJwYXRoIiwgIl9wYXRoIiwgIlBhdGgyRCIsICJzdHJva2VQYXRoRGlyZWN0IiwgInNlZ21lbnRzIiwgInNlZ21lbnRNZXRob2QiLCAidXNlUGF0aDJEIiwgIkxpbmVFbGVtZW50IiwgIl9wb2ludHMiLCAiX3NlZ21lbnRzIiwgIl9wb2ludHNVcGRhdGVkIiwgIl91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzIiwgIl9jb21wdXRlU2VnbWVudHMiLCAiaW50ZXJwb2xhdGUiLCAiX2JvdW5kU2VnbWVudHMiLCAiX2ludGVycG9sYXRlIiwgImludGVycG9sYXRlZCIsICJjYXBCZXppZXJQb2ludHMiLCAiaGl0UmFkaXVzIiwgIlBvaW50RWxlbWVudCIsICJtb3VzZVgiLCAibW91c2VZIiwgImluWFJhbmdlIiwgImluWVJhbmdlIiwgImhvdmVyUmFkaXVzIiwgImRyYXdQb2ludCIsICJnZXRCYXJCb3VuZHMiLCAiYmFyIiwgImhhbGYiLCAic2tpcE9yTGltaXQiLCAicGFyc2VCb3JkZXJXaWR0aCIsICJtYXhXIiwgIm1heEgiLCAidG9UUkJMIiwgInRvVFJCTENvcm5lcnMiLCAibWF4UiIsICJlbmFibGVCb3JkZXIiLCAidG9wTGVmdCIsICJ0b3BSaWdodCIsICJib3R0b21MZWZ0IiwgImJvdHRvbVJpZ2h0IiwgImJvdW5kaW5nUmVjdHMiLCAiYm91bmRzIiwgIm91dGVyIiwgInNraXBYIiwgInNraXBZIiwgInNraXBCb3RoIiwgImhhc1JhZGl1cyIsICJhZGROb3JtYWxSZWN0UGF0aCIsICJyZWN0IiwgImluZmxhdGVSZWN0IiwgImFtb3VudCIsICJyZWZSZWN0IiwgIkJhckVsZW1lbnQiLCAiYWRkUmVjdFBhdGgiLCAiYWRkUm91bmRlZFJlY3RQYXRoIiwgIkJPUkRFUl9DT0xPUlMiLCAiQkFDS0dST1VORF9DT0xPUlMiLCAicmVwbGFjZSIsICJnZXRCb3JkZXJDb2xvciIsICJnZXRCYWNrZ3JvdW5kQ29sb3IiLCAiY29sb3JpemVEZWZhdWx0RGF0YXNldCIsICJjb2xvcml6ZURvdWdobnV0RGF0YXNldCIsICJjb2xvcml6ZVBvbGFyQXJlYURhdGFzZXQiLCAiZ2V0Q29sb3JpemVyIiwgImNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbnMiLCAiayIsICJjb250YWluc0NvbG9yc0RlZmluaXRpb24iLCAiY29udGFpbnNEZWZhdWx0Q29sb3JzRGVmZW5pdGlvbnMiLCAiZm9yY2VPdmVycmlkZSIsICJfYXJncyIsICJjaGFydE9wdGlvbnMiLCAiY29udGFpbnNDb2xvckRlZmVuaXRpb24iLCAiY29sb3JpemVyIiwgImx0dGJEZWNpbWF0aW9uIiwgInNhbXBsZXMiLCAiZGVjaW1hdGVkIiwgImJ1Y2tldFdpZHRoIiwgInNhbXBsZWRJbmRleCIsICJlbmRJbmRleCIsICJtYXhBcmVhUG9pbnQiLCAibWF4QXJlYSIsICJuZXh0QSIsICJhdmdZIiwgImF2Z1JhbmdlU3RhcnQiLCAiYXZnUmFuZ2VFbmQiLCAiYXZnUmFuZ2VMZW5ndGgiLCAicmFuZ2VPZmZzIiwgInJhbmdlVG8iLCAicG9pbnRBeCIsICJwb2ludEF5IiwgIm1pbk1heERlY2ltYXRpb24iLCAibWluSW5kZXgiLCAibWF4SW5kZXgiLCAic3RhcnRJbmRleCIsICJ4TWluIiwgInhNYXgiLCAiZHgiLCAibGFzdEluZGV4IiwgImludGVybWVkaWF0ZUluZGV4MSIsICJpbnRlcm1lZGlhdGVJbmRleDIiLCAiY2xlYW5EZWNpbWF0ZWREYXRhc2V0IiwgImRlZmluZVByb3BlcnR5IiwgImNvbmZpZ3VyYWJsZSIsICJlbnVtZXJhYmxlIiwgIndyaXRhYmxlIiwgImNsZWFuRGVjaW1hdGVkRGF0YSIsICJnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZCIsICJwb2ludENvdW50IiwgImFsZ29yaXRobSIsICJiZWZvcmVFbGVtZW50c1VwZGF0ZSIsICJ4QXhpcyIsICJ0aHJlc2hvbGQiLCAidHBvaW50cyIsICJfZmluZFNlZ21lbnRFbmQiLCAiX2dldEJvdW5kcyIsICJ0YXJnZXRTZWdtZW50cyIsICJ0Z3QiLCAic3ViQm91bmRzIiwgImZpbGxTb3VyY2VzIiwgIl9ib3VuZFNlZ21lbnQiLCAiZmlsbFNvdXJjZSIsICJfZ2V0RWRnZSIsICJfbm9ybWFsaXplQW5nbGUiLCAiX3BvaW50c0Zyb21TZWdtZW50cyIsICJib3VuZGFyeSIsICJsaW5lUG9pbnRzIiwgIl9jcmVhdGVCb3VuZGFyeUxpbmUiLCAiX3Nob3VsZEFwcGx5RmlsbCIsICJfcmVzb2x2ZVRhcmdldCIsICJzb3VyY2VzIiwgInByb3BhZ2F0ZSIsICJ2aXNpdGVkIiwgIl9kZWNvZGVGaWxsIiwgInBhcnNlRmlsbE9wdGlvbiIsICJwYXJzZUZsb2F0IiwgImRlY29kZVRhcmdldEluZGV4IiwgImZpcnN0Q2giLCAiX2dldFRhcmdldFBpeGVsIiwgIl9nZXRUYXJnZXRWYWx1ZSIsICJmaWxsT3B0aW9uIiwgIl9idWlsZFN0YWNrTGluZSIsICJzb3VyY2VQb2ludHMiLCAibGluZXNCZWxvdyIsICJnZXRMaW5lc0JlbG93IiwgImFkZFBvaW50c0JlbG93IiwgImJlbG93IiwgInVuc2hpZnQiLCAic291cmNlUG9pbnQiLCAicG9zdHBvbmVkIiwgImZpbmRQb2ludCIsICJwb2ludFZhbHVlIiwgImZpcnN0VmFsdWUiLCAibGFzdFZhbHVlIiwgInNpbXBsZUFyYyIsICJfZ2V0VGFyZ2V0IiwgImdldExpbmVCeUluZGV4IiwgImNvbXB1dGVCb3VuZGFyeSIsICJjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeSIsICJjb21wdXRlTGluZWFyQm91bmRhcnkiLCAiX2RyYXdmaWxsIiwgImxpbmVPcHRzIiwgImFib3ZlIiwgImRvRmlsbCIsICJjbGlwVmVydGljYWwiLCAiY2xpcFkiLCAibGluZUxvb3AiLCAic3JjIiwgIm5vdFNoYXBlIiwgImNsaXBCb3VuZHMiLCAiaW50ZXJwb2xhdGVkTGluZVRvIiwgInRhcmdldExvb3AiLCAiaW50ZXJwb2xhdGVkUG9pbnQiLCAiYWZ0ZXJEYXRhc2V0c1VwZGF0ZSIsICIkZmlsbGVyIiwgImJlZm9yZURyYXciLCAiZHJhd1RpbWUiLCAiYmVmb3JlRGF0YXNldHNEcmF3IiwgImJlZm9yZURhdGFzZXREcmF3IiwgImdldEJveFNpemUiLCAibGFiZWxPcHRzIiwgImJveEhlaWdodCIsICJib3hXaWR0aCIsICJ1c2VQb2ludFN0eWxlIiwgInBvaW50U3R5bGVXaWR0aCIsICJpdGVtSGVpZ2h0IiwgIml0ZW1zRXF1YWwiLCAiTGVnZW5kIiwgIl9hZGRlZCIsICJsZWdlbmRIaXRCb3hlcyIsICJfaG92ZXJlZEl0ZW0iLCAiZG91Z2hudXRNb2RlIiwgImxlZ2VuZEl0ZW1zIiwgImNvbHVtblNpemVzIiwgImxpbmVXaWR0aHMiLCAiYnVpbGRMYWJlbHMiLCAibGFiZWxGb250IiwgIl9jb21wdXRlVGl0bGVIZWlnaHQiLCAiX2ZpdFJvd3MiLCAiX2ZpdENvbHMiLCAiaGl0Ym94ZXMiLCAidG90YWxIZWlnaHQiLCAicm93IiwgIml0ZW1XaWR0aCIsICJtZWFzdXJlVGV4dCIsICJfaXRlbUhlaWdodCIsICJoZWlnaHRMaW1pdCIsICJ0b3RhbFdpZHRoIiwgImN1cnJlbnRDb2xXaWR0aCIsICJjdXJyZW50Q29sSGVpZ2h0IiwgImNvbCIsICJjYWxjdWxhdGVJdGVtU2l6ZSIsICJhZGp1c3RIaXRCb3hlcyIsICJydGwiLCAicnRsSGVscGVyIiwgImdldFJ0bEFkYXB0ZXIiLCAiaGl0Ym94IiwgImxlZnRGb3JMdHIiLCAiX2RyYXciLCAiZGVmYXVsdENvbG9yIiwgImhhbGZGb250U2l6ZSIsICJjdXJzb3IiLCAiZHJhd0xlZ2VuZEJveCIsICJsaW5lRGFzaCIsICJkcmF3T3B0aW9ucyIsICJTUVJUMiIsICJ4UGx1cyIsICJkcmF3UG9pbnRMZWdlbmQiLCAieUJveFRvcCIsICJ4Qm94TGVmdCIsICJmaWxsVGV4dCIsICJzdHJpa2V0aHJvdWdoIiwgIm92ZXJyaWRlVGV4dERpcmVjdGlvbiIsICJ0ZXh0RGlyZWN0aW9uIiwgInRleHRXaWR0aCIsICJzZXRXaWR0aCIsICJyZWFsWCIsICJfdGV4dFgiLCAiZm9udExpbmVIZWlnaHQiLCAiY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodCIsICJyZXN0b3JlVGV4dERpcmVjdGlvbiIsICJ0aXRsZUZvbnQiLCAidGl0bGVQYWRkaW5nIiwgInRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplIiwgIl9nZXRMZWdlbmRJdGVtQXQiLCAiaGl0Qm94IiwgImxoIiwgImhhbmRsZUV2ZW50IiwgImlzTGlzdGVuZWQiLCAiaG92ZXJlZEl0ZW0iLCAic2FtZUl0ZW0iLCAib25MZWF2ZSIsICJjYWxjdWxhdGVJdGVtV2lkdGgiLCAiY2FsY3VsYXRlSXRlbUhlaWdodCIsICJsZWdlbmRJdGVtVGV4dCIsICJfZWxlbWVudCIsICJhZnRlckV2ZW50IiwgImNpIiwgInVzZUJvcmRlclJhZGl1cyIsICJUaXRsZSIsICJfcGFkZGluZyIsICJ0ZXh0U2l6ZSIsICJfZHJhd0FyZ3MiLCAiZm9udE9wdHMiLCAiY3JlYXRlVGl0bGUiLCAidGl0bGVCbG9jayIsICJXZWFrTWFwIiwgInBvc2l0aW9uZXJzIiwgImF2ZXJhZ2UiLCAieFNldCIsICJ4QXZlcmFnZSIsICJldmVudFBvc2l0aW9uIiwgIm5lYXJlc3RFbGVtZW50IiwgImRpc3RhbmNlQmV0d2VlblBvaW50cyIsICJ0cCIsICJwdXNoT3JDb25jYXQiLCAidG9QdXNoIiwgImFwcGx5IiwgInNwbGl0TmV3bGluZXMiLCAic3RyIiwgIlN0cmluZyIsICJjcmVhdGVUb29sdGlwSXRlbSIsICJmb3JtYXR0ZWRWYWx1ZSIsICJnZXRUb29sdGlwU2l6ZSIsICJ0b29sdGlwIiwgImJvZHkiLCAiZm9vdGVyIiwgImJvZHlGb250IiwgImZvb3RlckZvbnQiLCAidGl0bGVMaW5lQ291bnQiLCAiZm9vdGVyTGluZUNvdW50IiwgImJvZHlMaW5lSXRlbUNvdW50IiwgImNvbWJpbmVkQm9keUxlbmd0aCIsICJib2R5SXRlbSIsICJiZWZvcmUiLCAiYWZ0ZXIiLCAiYmVmb3JlQm9keSIsICJhZnRlckJvZHkiLCAidGl0bGVTcGFjaW5nIiwgInRpdGxlTWFyZ2luQm90dG9tIiwgImJvZHlMaW5lSGVpZ2h0IiwgImRpc3BsYXlDb2xvcnMiLCAiYm9keVNwYWNpbmciLCAiZm9vdGVyTWFyZ2luVG9wIiwgImZvb3RlclNwYWNpbmciLCAid2lkdGhQYWRkaW5nIiwgIm1heExpbmVXaWR0aCIsICJkZXRlcm1pbmVZQWxpZ24iLCAiZG9lc05vdEZpdFdpdGhBbGlnbiIsICJ4QWxpZ24iLCAiY2FyZXQiLCAiY2FyZXRTaXplIiwgImNhcmV0UGFkZGluZyIsICJkZXRlcm1pbmVYQWxpZ24iLCAieUFsaWduIiwgImNoYXJ0V2lkdGgiLCAiZGV0ZXJtaW5lQWxpZ25tZW50IiwgImFsaWduWCIsICJhbGlnblkiLCAicGFkZGluZ0FuZFNpemUiLCAiZ2V0QmFja2dyb3VuZFBvaW50IiwgImFsaWdubWVudCIsICJjb3JuZXJSYWRpdXMiLCAiZ2V0QWxpZ25lZFgiLCAiZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMiLCAiY3JlYXRlVG9vbHRpcENvbnRleHQiLCAidG9vbHRpcEl0ZW1zIiwgIm92ZXJyaWRlQ2FsbGJhY2tzIiwgImRlZmF1bHRDYWxsYmFja3MiLCAiYmVmb3JlVGl0bGUiLCAibm9vcCIsICJsYWJlbENvdW50IiwgImFmdGVyVGl0bGUiLCAiYmVmb3JlTGFiZWwiLCAidG9vbHRpcEl0ZW0iLCAibGFiZWxDb2xvciIsICJsYWJlbFRleHRDb2xvciIsICJib2R5Q29sb3IiLCAibGFiZWxQb2ludFN0eWxlIiwgImFmdGVyTGFiZWwiLCAiYmVmb3JlRm9vdGVyIiwgImFmdGVyRm9vdGVyIiwgImludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrIiwgIlRvb2x0aXAiLCAib3BhY2l0eSIsICJfZXZlbnRQb3NpdGlvbiIsICJfc2l6ZSIsICJfY2FjaGVkQW5pbWF0aW9ucyIsICJfdG9vbHRpcEl0ZW1zIiwgImRhdGFQb2ludHMiLCAiY2FyZXRYIiwgImNhcmV0WSIsICJsYWJlbENvbG9ycyIsICJsYWJlbFBvaW50U3R5bGVzIiwgImxhYmVsVGV4dENvbG9ycyIsICJnZXRUaXRsZSIsICJnZXRCZWZvcmVCb2R5IiwgImdldEJvZHkiLCAiYm9keUl0ZW1zIiwgInNjb3BlZCIsICJnZXRBZnRlckJvZHkiLCAiZ2V0Rm9vdGVyIiwgIl9jcmVhdGVJdGVtcyIsICJpdGVtU29ydCIsICJwb3NpdGlvbkFuZFNpemUiLCAiYmFja2dyb3VuZFBvaW50IiwgImV4dGVybmFsIiwgImRyYXdDYXJldCIsICJ0b29sdGlwUG9pbnQiLCAiY2FyZXRQb3NpdGlvbiIsICJnZXRDYXJldFBvc2l0aW9uIiwgIngzIiwgInkzIiwgInB0WCIsICJwdFkiLCAicHQiLCAidGl0bGVDb2xvciIsICJfZHJhd0NvbG9yQm94IiwgImNvbG9yWCIsICJydGxDb2xvclgiLCAieU9mZlNldCIsICJjb2xvclkiLCAibXVsdGlLZXlCYWNrZ3JvdW5kIiwgIm91dGVyWCIsICJpbm5lclgiLCAic3Ryb2tlUmVjdCIsICJkcmF3Qm9keSIsICJib2R5QWxpZ24iLCAieExpbmVQYWRkaW5nIiwgImZpbGxMaW5lT2ZUZXh0IiwgImJvZHlBbGlnbkZvckNhbGN1bGF0aW9uIiwgInRleHRDb2xvciIsICJkcmF3Rm9vdGVyIiwgImZvb3RlckFsaWduIiwgImZvb3RlckNvbG9yIiwgInRvb2x0aXBTaXplIiwgInF1YWRyYXRpY0N1cnZlVG8iLCAiX3VwZGF0ZUFuaW1hdGlvblRhcmdldCIsICJhbmltWCIsICJhbmltWSIsICJfd2lsbFJlbmRlciIsICJoYXNUb29sdGlwQ29udGVudCIsICJnbG9iYWxBbHBoYSIsICJwb3NpdGlvbkNoYW5nZWQiLCAiX3Bvc2l0aW9uQ2hhbmdlZCIsICJfaWdub3JlUmVwbGF5RXZlbnRzIiwgImFmdGVySW5pdCIsICJhZnRlckRyYXciLCAiX2ZhbGxiYWNrIiwgImFkZElmU3RyaW5nIiwgImFkZGVkTGFiZWxzIiwgImZpbmRPckFkZExhYmVsIiwgImxhc3RJbmRleE9mIiwgIl9nZXRMYWJlbEZvclZhbHVlIiwgIkNhdGVnb3J5U2NhbGUiLCAiX3N0YXJ0VmFsdWUiLCAiX3ZhbHVlUmFuZ2UiLCAiX2FkZGVkTGFiZWxzIiwgImFkZGVkIiwgImdlbmVyYXRlVGlja3MiLCAiZ2VuZXJhdGlvbk9wdGlvbnMiLCAiZGF0YVJhbmdlIiwgIk1JTl9TUEFDSU5HIiwgInByZWNpc2lvbiIsICJtYXhUaWNrcyIsICJtYXhEaWdpdHMiLCAiaW5jbHVkZUJvdW5kcyIsICJ1bml0IiwgIm1heFNwYWNlcyIsICJybWluIiwgInJtYXgiLCAiY291bnREZWZpbmVkIiwgIm1pblNwYWNpbmciLCAibmljZU51bSIsICJuaWNlTWluIiwgIm5pY2VNYXgiLCAibnVtU3BhY2VzIiwgImFsbW9zdFdob2xlIiwgImFsbW9zdEVxdWFscyIsICJkZWNpbWFsUGxhY2VzIiwgIl9kZWNpbWFsUGxhY2VzIiwgInJlbGF0aXZlTGFiZWxTaXplIiwgInRpY2tWYWx1ZSIsICJyYWQiLCAiTGluZWFyU2NhbGVCYXNlIiwgIl9lbmRWYWx1ZSIsICJoYW5kbGVUaWNrUmFuZ2VPcHRpb25zIiwgInNldE1pbiIsICJzZXRNYXgiLCAibWluU2lnbiIsICJtYXhTaWduIiwgImdldFRpY2tMaW1pdCIsICJzdGVwU2l6ZSIsICJjb21wdXRlVGlja0xpbWl0IiwgIm51bWVyaWNHZW5lcmF0b3JPcHRpb25zIiwgIl9zZXRNaW5BbmRNYXhCeUtleSIsICJMaW5lYXJTY2FsZSIsICJUaWNrcyIsICJmb3JtYXR0ZXJzIiwgIm51bWVyaWMiLCAibG9nMTBGbG9vciIsICJsb2cxMCIsICJjaGFuZ2VFeHBvbmVudCIsICJtIiwgImlzTWFqb3IiLCAidGlja1ZhbCIsICJzdGVwcyIsICJyYW5nZUV4cCIsICJyYW5nZVN0ZXAiLCAic3RhcnRFeHAiLCAibWluRXhwIiwgImV4cCIsICJzaWduaWZpY2FuZCIsICJsYXN0VGljayIsICJMb2dhcml0aG1pY1NjYWxlIiwgIl96ZXJvIiwgImxvZ2FyaXRobWljIiwgImdldFRpY2tCYWNrZHJvcEhlaWdodCIsICJtZWFzdXJlTGFiZWxTaXplIiwgIl9sb25nZXN0VGV4dCIsICJkZXRlcm1pbmVMaW1pdHMiLCAiZml0V2l0aFBvaW50TGFiZWxzIiwgImxpbWl0cyIsICJ2YWx1ZUNvdW50IiwgIl9wb2ludExhYmVscyIsICJwb2ludExhYmVsT3B0cyIsICJhZGRpdGlvbmFsQW5nbGUiLCAiY2VudGVyUG9pbnRMYWJlbHMiLCAiZ2V0UG9pbnRMYWJlbENvbnRleHQiLCAiZ2V0UG9pbnRQb3NpdGlvbiIsICJkcmF3aW5nQXJlYSIsICJwbEZvbnQiLCAiaExpbWl0cyIsICJ2TGltaXRzIiwgInVwZGF0ZUxpbWl0cyIsICJzZXRDZW50ZXJQb2ludCIsICJfcG9pbnRMYWJlbEl0ZW1zIiwgImJ1aWxkUG9pbnRMYWJlbEl0ZW1zIiwgImNyZWF0ZVBvaW50TGFiZWxJdGVtIiwgIml0ZW1PcHRzIiwgIm91dGVyRGlzdGFuY2UiLCAiZXh0cmEiLCAicG9pbnRMYWJlbFBvc2l0aW9uIiwgInlGb3JBbmdsZSIsICJnZXRUZXh0QWxpZ25Gb3JBbmdsZSIsICJsZWZ0Rm9yVGV4dEFsaWduIiwgImlzTm90T3ZlcmxhcHBlZCIsICJhcGV4ZXNJbkFyZWEiLCAiZHJhd1BvaW50TGFiZWxCb3giLCAiYmFja2Ryb3BMZWZ0IiwgImJhY2tkcm9wVG9wIiwgImJhY2tkcm9wV2lkdGgiLCAiYmFja2Ryb3BIZWlnaHQiLCAiZHJhd1BvaW50TGFiZWxzIiwgInBhdGhSYWRpdXNMaW5lIiwgImRyYXdSYWRpdXNMaW5lIiwgImdyaWRMaW5lT3B0cyIsICJjcmVhdGVQb2ludExhYmVsQ29udGV4dCIsICJSYWRpYWxMaW5lYXJTY2FsZSIsICJsZWZ0TW92ZW1lbnQiLCAicmlnaHRNb3ZlbWVudCIsICJ0b3BNb3ZlbWVudCIsICJib3R0b21Nb3ZlbWVudCIsICJhbmdsZU11bHRpcGxpZXIiLCAic2NhbGluZ0ZhY3RvciIsICJnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlciIsICJzY2FsZWREaXN0YW5jZSIsICJwb2ludExhYmVsIiwgImRpc3RhbmNlRnJvbUNlbnRlciIsICJnZXRCYXNlUG9zaXRpb24iLCAiZ2V0UG9pbnRMYWJlbFBvc2l0aW9uIiwgInJvdGF0ZSIsICJhbmltYXRlIiwgIklOVEVSVkFMUyIsICJtaWxsaXNlY29uZCIsICJjb21tb24iLCAic2Vjb25kIiwgIm1pbnV0ZSIsICJob3VyIiwgImRheSIsICJ3ZWVrIiwgIm1vbnRoIiwgInF1YXJ0ZXIiLCAieWVhciIsICJVTklUUyIsICJzb3J0ZXIiLCAiaW5wdXQiLCAiYWRhcHRlciIsICJfYWRhcHRlciIsICJwYXJzZXIiLCAiaXNvV2Vla2RheSIsICJfcGFyc2VPcHRzIiwgImRldGVybWluZVVuaXRGb3JBdXRvVGlja3MiLCAibWluVW5pdCIsICJjYXBhY2l0eSIsICJpbnRlcnZhbCIsICJNQVhfU0FGRV9JTlRFR0VSIiwgImRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIiwgImRldGVybWluZU1ham9yVW5pdCIsICJhZGRUaWNrIiwgInRpbWUiLCAidGltZXN0YW1wcyIsICJfbG9va3VwIiwgInRpbWVzdGFtcCIsICJzZXRNYWpvclRpY2tzIiwgIm1ham9yVW5pdCIsICJ0aWNrc0Zyb21UaW1lc3RhbXBzIiwgIlRpbWVTY2FsZSIsICJfdW5pdCIsICJfbWFqb3JVbml0IiwgIl9vZmZzZXRzIiwgIl9ub3JtYWxpemVkIiwgImFkYXB0ZXJzIiwgImRpc3BsYXlGb3JtYXRzIiwgIm5vcm1hbGl6ZWQiLCAiX2FwcGx5Qm91bmRzIiwgIl9nZXRMYWJlbEJvdW5kcyIsICJnZXRMYWJlbFRpbWVzdGFtcHMiLCAidGltZU9wdHMiLCAiX2dlbmVyYXRlIiwgIl9maWx0ZXJCZXR3ZWVuIiwgIl9nZXRMYWJlbENhcGFjaXR5IiwgImluaXRPZmZzZXRzIiwgIm9mZnNldEFmdGVyQXV0b3NraXAiLCAiZ2V0RGVjaW1hbEZvclZhbHVlIiwgIm1pbm9yIiwgIndlZWtkYXkiLCAiaGFzV2Vla2RheSIsICJnZXREYXRhVGltZXN0YW1wcyIsICJ0b29sdGlwRm9ybWF0IiwgImRhdGV0aW1lIiwgImZtdCIsICJfdGlja0Zvcm1hdEZ1bmN0aW9uIiwgImZvcm1hdHRlciIsICJtaW5vckZvcm1hdCIsICJtYWpvckZvcm1hdCIsICJvZmZzZXRzIiwgIl9nZXRMYWJlbFNpemUiLCAidGlja3NPcHRzIiwgInRpY2tMYWJlbFdpZHRoIiwgImNvc1JvdGF0aW9uIiwgInNpblJvdGF0aW9uIiwgInRpY2tGb250U2l6ZSIsICJleGFtcGxlVGltZSIsICJleGFtcGxlTGFiZWwiLCAibm9ybWFsaXplIiwgInRhYmxlIiwgInByZXZTb3VyY2UiLCAibmV4dFNvdXJjZSIsICJwcmV2VGFyZ2V0IiwgIm5leHRUYXJnZXQiLCAic3BhbiIsICJUaW1lU2VyaWVzU2NhbGUiLCAiX3RhYmxlIiwgIl9taW5Qb3MiLCAiX3RhYmxlUmFuZ2UiLCAiX2dldFRpbWVzdGFtcHNGb3JUYWJsZSIsICJidWlsZExvb2t1cFRhYmxlIiwgInJlZ2lzdGVyYWJsZXMiLCAib2JqIiwgInZlcnNpb24iLCAiZWwiLCAiZm4iLCAidG9wIiwgImxlZnQiLCAiYm90dG9tIiwgInJpZ2h0IiwgImluZGV4IiwgImNhbGxiYWNrIiwgInkiLCAiY2xvbmUiLCAiZ2hvc3RFbCIsICJjYWxsYmFjayIsICJwbHVnaW5zIiwgImRlZmF1bHRzIiwgIm9wdGlvbiIsICJlbCIsICJyb290RWwiLCAiY2xvbmVFbCIsICJvbGRJbmRleCIsICJuZXdJbmRleCIsICJvbGREcmFnZ2FibGVJbmRleCIsICJuZXdEcmFnZ2FibGVJbmRleCIsICJwdXRTb3J0YWJsZSIsICJwbHVnaW5FdmVudCIsICJfZGV0ZWN0RGlyZWN0aW9uIiwgIl9kcmFnRWxJblJvd0NvbHVtbiIsICJfZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUiLCAieSIsICJfcHJlcGFyZUdyb3VwIiwgInRvIiwgImZyb20iLCAiZHJhZ0VsIiwgIl9oaWRlR2hvc3RGb3JUYXJnZXQiLCAiX3VuaGlkZUdob3N0Rm9yVGFyZ2V0IiwgIm5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50IiwgIl9jaGVja091dHNpZGVUYXJnZXRFbCIsICJmbiIsICJpbmRleCIsICJkcmFnU3RhcnRGbiIsICJjbG9uZSIsICJ0YXJnZXQiLCAiYWZ0ZXIiLCAib3JkZXIiLCAidmVyc2lvbiIsICJkcm9wIiwgImF1dG9TY3JvbGwiLCAidG9wIiwgImJvdHRvbSIsICJsZWZ0IiwgInJpZ2h0IiwgIm9uU3BpbGwiLCAiZWwiLCAiRXZlbnRzIiwgIkluc3RhbmNlcyIsICJpbnN0YW5jZXMiLCAiQWNjb3JkaW9uIiwgIl9hIiwgIl9iIiwgImNhbGxiYWNrIiwgIkRlZmF1bHQiLCAiRGVmYXVsdEluc3RhbmNlT3B0aW9ucyIsICJDb2xsYXBzZSIsICJfX2Fzc2lnbiIsICJjYWxsYmFjayIsICJEZWZhdWx0IiwgIkRlZmF1bHRJbnN0YW5jZU9wdGlvbnMiLCAiQ2Fyb3VzZWwiLCAiX19hc3NpZ24iLCAiX2EiLCAiX2IiLCAiY2FsbGJhY2siLCAiRGVmYXVsdCIsICJEZWZhdWx0SW5zdGFuY2VPcHRpb25zIiwgIkRpc21pc3MiLCAiX19hc3NpZ24iLCAiY2FsbGJhY2siLCAidG9wIiwgImJvdHRvbSIsICJuYW1lIiwgInN0eWxlIiwgInJvdW5kIiwgInJvdW5kIiwgInkiLCAiZ2V0Q29tcHV0ZWRTdHlsZSIsICJnZXRDb21wdXRlZFN0eWxlIiwgImNzcyIsICJ3aW5kb3ciLCAibWluIiwgIm1heCIsICJ0b1BhZGRpbmdPYmplY3QiLCAicG9wcGVyT2Zmc2V0cyIsICJ0b3AiLCAiYm90dG9tIiwgIm1pbiIsICJtYXgiLCAib2Zmc2V0IiwgImVmZmVjdCIsICJ5IiwgInJvdW5kIiwgInBvcHBlciIsICJ0b3AiLCAiZ2V0Q29tcHV0ZWRTdHlsZSIsICJib3R0b20iLCAiZWZmZWN0IiwgIndpbmRvdyIsICJoYXNoIiwgInNjcm9sbFRvcCIsICJ5IiwgInkiLCAiZ2V0Q29tcHV0ZWRTdHlsZSIsICJnZXRDb21wdXRlZFN0eWxlIiwgImNsaXBwaW5nUGFyZW50cyIsICJnZXRDb21wdXRlZFN0eWxlIiwgInJlZmVyZW5jZSIsICJ0b3AiLCAiYm90dG9tIiwgInBvcHBlck9mZnNldHMiLCAib2Zmc2V0IiwgImJvdHRvbSIsICJ0b3AiLCAicGxhY2VtZW50cyIsICJwbGFjZW1lbnQiLCAicGxhY2VtZW50cyIsICJwbGFjZW1lbnQiLCAidG9wIiwgImJvdHRvbSIsICJfbG9vcCIsICJfaSIsICJjaGVja3MiLCAidG9wIiwgImJvdHRvbSIsICJvZmZzZXQiLCAidG9wIiwgInkiLCAicG9wcGVyT2Zmc2V0cyIsICJ0b3AiLCAiYm90dG9tIiwgIm9mZnNldCIsICJtaW4iLCAibWF4IiwgInJvdW5kIiwgIm1hcCIsICJzb3J0IiwgImRlYm91bmNlIiwgImZuIiwgInJlc29sdmUiLCAibWVyZ2VkIiwgImRlZmF1bHRNb2RpZmllcnMiLCAiZGVmYXVsdE9wdGlvbnMiLCAiY3JlYXRlUG9wcGVyIiwgInJlZmVyZW5jZSIsICJwb3BwZXIiLCAib3B0aW9ucyIsICJtIiwgImluZGV4IiwgImZuIiwgImRlYm91bmNlIiwgInJlc29sdmUiLCAiZGVzdHJveSIsICJzdGF0ZSIsICJlZmZlY3QiLCAibm9vcEZuIiwgIkRlZmF1bHQiLCAiRGVmYXVsdEluc3RhbmNlT3B0aW9ucyIsICJEcm9wZG93biIsICJfX2Fzc2lnbiIsICJlbCIsICJjYWxsYmFjayIsICJEZWZhdWx0IiwgIkRlZmF1bHRJbnN0YW5jZU9wdGlvbnMiLCAiTW9kYWwiLCAiX19hc3NpZ24iLCAiY2FsbGJhY2siLCAiRGVmYXVsdCIsICJEZWZhdWx0SW5zdGFuY2VPcHRpb25zIiwgIkRyYXdlciIsICJfX2Fzc2lnbiIsICJjYWxsYmFjayIsICJEZWZhdWx0IiwgIkRlZmF1bHRJbnN0YW5jZU9wdGlvbnMiLCAiVGFicyIsICJfX2Fzc2lnbiIsICJfYSIsICJfYiIsICJjYWxsYmFjayIsICJEZWZhdWx0IiwgIkRlZmF1bHRJbnN0YW5jZU9wdGlvbnMiLCAiVG9vbHRpcCIsICJfX2Fzc2lnbiIsICJfX3NwcmVhZEFycmF5IiwgImNhbGxiYWNrIiwgIkRlZmF1bHQiLCAiRGVmYXVsdEluc3RhbmNlT3B0aW9ucyIsICJQb3BvdmVyIiwgIl9fYXNzaWduIiwgIl9fc3ByZWFkQXJyYXkiLCAiY2FsbGJhY2siLCAib2Zmc2V0IiwgIkRlZmF1bHQiLCAiRGVmYXVsdEluc3RhbmNlT3B0aW9ucyIsICJEaWFsIiwgInBhcmVudEVsIiwgIl9fYXNzaWduIiwgImNhbGxiYWNrIiwgIkRlZmF1bHQiLCAiRGVmYXVsdEluc3RhbmNlT3B0aW9ucyIsICJJbnB1dENvdW50ZXIiLCAiX19hc3NpZ24iLCAiY2FsbGJhY2siLCAiRGVmYXVsdCIsICJEZWZhdWx0SW5zdGFuY2VPcHRpb25zIiwgIkNvcHlDbGlwYm9hcmQiLCAiX19hc3NpZ24iLCAiY2FsbGJhY2siLCAidCIsICJyIiwgImUiLCAiX3R5cGVvZiIsICJvIiwgIm1pbiIsICJtYXgiLCAiaW5kZXgiLCAiZnJvbSIsICJjb21wYXJlTmFtZXMiLCAiZCIsICJtIiwgInkiLCAiZm4iLCAiZ2V0Q29tcG9zZWRQYXRoIiwgImVsIiwgInJhbmdlIiwgImxvY2FsZXMiLCAiVmlldyIsICJfVmlldyIsICJEYXlzVmlldyIsICJzdGFydCIsICJNb250aHNWaWV3IiwgIlllYXJzVmlldyIsICJQaWNrZXIiLCAibWFpbiIsICJoaWRlIiwgInNjcm9sbFRvcCIsICJsZWZ0IiwgInRvcCIsICJ0ZXN0Rm4iLCAiRGF0ZXBpY2tlciIsICJkZXN0cm95IiwgImNhbGxiYWNrIiwgIkRhdGVSYW5nZVBpY2tlciIsICJEZWZhdWx0IiwgIkRlZmF1bHRJbnN0YW5jZU9wdGlvbnMiLCAiRGF0ZXBpY2tlciIsICJfX2Fzc2lnbiIsICJjYWxsYmFjayIsICJIb29rcyIsICJjb2xvciIsICJ0b3BiYXIiXQp9Cg==
